diff --git a/.classpath b/.classpath
new file mode 100644
index 0000000..7a7b94d
--- /dev/null
+++ b/.classpath
@@ -0,0 +1,9 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<classpath>
+	<classpathentry kind="src" output="target/classes" path="src/main/java"/>
+	<classpathentry excluding="**" kind="src" output="target/classes" path="src/main/resources"/>
+	<classpathentry kind="src" output="target/test-classes" path="src/test/java"/>
+	<classpathentry kind="con" path="org.eclipse.jdt.launching.JRE_CONTAINER/org.eclipse.jdt.internal.debug.ui.launcher.StandardVMType/J2SE-1.5"/>
+	<classpathentry kind="con" path="org.eclipse.m2e.MAVEN2_CLASSPATH_CONTAINER"/>
+	<classpathentry kind="output" path="target/classes"/>
+</classpath>
diff --git a/.gitignore b/.gitignore
index a6f89c2..fdeceb2 100644
--- a/.gitignore
+++ b/.gitignore
@@ -1 +1,3 @@
-/target/
\ No newline at end of file
+/target/
+/.settings/
+/plugins/
diff --git a/.project b/.project
new file mode 100644
index 0000000..aa315e5
--- /dev/null
+++ b/.project
@@ -0,0 +1,23 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<projectDescription>
+	<name>CommandHelper</name>
+	<comment></comment>
+	<projects>
+	</projects>
+	<buildSpec>
+		<buildCommand>
+			<name>org.eclipse.jdt.core.javabuilder</name>
+			<arguments>
+			</arguments>
+		</buildCommand>
+		<buildCommand>
+			<name>org.eclipse.m2e.core.maven2Builder</name>
+			<arguments>
+			</arguments>
+		</buildCommand>
+	</buildSpec>
+	<natures>
+		<nature>org.eclipse.jdt.core.javanature</nature>
+		<nature>org.eclipse.m2e.core.maven2Nature</nature>
+	</natures>
+</projectDescription>
diff --git a/.settings/org.eclipse.core.resources.prefs b/.settings/org.eclipse.core.resources.prefs
new file mode 100644
index 0000000..e4a3497
--- /dev/null
+++ b/.settings/org.eclipse.core.resources.prefs
@@ -0,0 +1,6 @@
+#Thu Oct 13 09:02:05 CDT 2011
+eclipse.preferences.version=1
+encoding//src/main/java=UTF-8
+encoding//src/main/resources=UTF-8
+encoding//src/test/java=UTF-8
+encoding/<project>=UTF-8
diff --git a/.settings/org.eclipse.jdt.core.prefs b/.settings/org.eclipse.jdt.core.prefs
new file mode 100644
index 0000000..477dd78
--- /dev/null
+++ b/.settings/org.eclipse.jdt.core.prefs
@@ -0,0 +1,6 @@
+#Thu Oct 13 09:02:05 CDT 2011
+eclipse.preferences.version=1
+org.eclipse.jdt.core.compiler.codegen.targetPlatform=1.5
+org.eclipse.jdt.core.compiler.compliance=1.5
+org.eclipse.jdt.core.compiler.problem.forbiddenReference=warning
+org.eclipse.jdt.core.compiler.source=1.5
diff --git a/.settings/org.eclipse.m2e.core.prefs b/.settings/org.eclipse.m2e.core.prefs
new file mode 100644
index 0000000..9688630
--- /dev/null
+++ b/.settings/org.eclipse.m2e.core.prefs
@@ -0,0 +1,5 @@
+#Thu Oct 13 09:02:02 CDT 2011
+activeProfiles=
+eclipse.preferences.version=1
+resolveWorkspaceProjects=true
+version=1
diff --git a/CommandHelper/preferences.txt b/CommandHelper/preferences.txt
index 5001d9e..d836cb0 100644
--- a/CommandHelper/preferences.txt
+++ b/CommandHelper/preferences.txt
@@ -1,27 +1,45 @@
-#This file is generated automatically. Changes made to the values of this file
-#will persist, but changes to comments will not.
-
-#Makes command matching be case sensitive. If set to false, if your config defines /cmd, but the user runs /CMD, it will trigger the command anyways.
-case-sensitive=true
-
-#Whether or not to display warnings in the console, while compiling
-show-warnings=true
-
-#Makes CommandHelper play dirty and break all sorts of programming rules, so that other plugins can't interfere with the operations that you defined. Note that doing this essentially makes CommandHelper have absolute say over commands. Use this setting only if you can't get another plugin to cooperate with CH, because it is a global setting.
-play-dirty=false
-
-#Whether or not to display the original command in the console when it is run
-console-log-commands=true
-
-#The base directory that scripts can read and write to. If left blank, then the default of the Bukkit directory will be used. This setting affects functions like include and read.
-base-dir=
-
-#Whether or not to enable the /interpreter command. Note that even with this enabled, a player must still have the commandhelper.interpreter permission, but setting it to false prevents all players from accessing the interpreter regardless of their permissions.
-enable-interpreter=false
-
-#Whether or not to display debug information in the console
-debug-mode=false
-
-#The path to the config file, relative to the CommandHelper plugin folder
-script-name=config.txt
-
+#This file is generated automatically. Changes made to the values of this file
+#will persist, but changes to comments will not.
+
+#Makes command matching be case sensitive. If set to false, if your config defines /cmd, but the user runs /CMD, it will trigger the command anyways.
+case-sensitive=true
+
+#Whether or not to display the original command in the console when it is run
+console-log-commands=true
+
+#Makes CommandHelper play dirty and break all sorts of programming rules, so that other plugins can't interfere with the operations that you defined. Note that doing this essentially makes CommandHelper have absolute say over commands. Use this setting only if you can't get another plugin to cooperate with CH, because it is a global setting.
+play-dirty=false
+
+#If set to false, the Debug class of functions will do nothing.
+allow-debug-logging=false
+
+#Whether or not to display debug information in the console
+debug-mode=false
+
+#The path the standard log files that the log() function writes to. Six variables are available, %Y, %M, and %D, %h, %m, %s, which are replaced with the current year, month, day, hour, minute and second respectively. It is highly recommended that you use at least year, month, and day if you are actively logging things, otherwise the file size would get excessively large. The path is relative to the CommandHelper directory and is not bound by the base-dir restriction.
+standard-log-file=logs/%Y-%M-%D-commandhelper.log
+
+#The path to the main file, relative to the CommandHelper folder
+main-file=main.ms
+
+#If set to false, the Profiling class of functions will do nothing.
+allow-profiling=false
+
+#The path to the profiling logs. These logs are perf4j formatted logs. Consult the documentation for more information.
+profiling-file=logs/profiling/%Y-%M-%D-profiling.log
+
+#Whether or not to display warnings in the console, while compiling
+show-warnings=true
+
+#The path to the debug output log file. Six variables are available, %Y, %M, and %D, %h, %m, %s, which are replaced with the current year, month, day, hour, minute and second respectively. It is highly recommended that you use at least year, month, and day if you are for whatever reason leaving logging on, otherwise the file size would get excessively large. The path is relative to the CommandHelper directory and is not bound by the base-dir restriction.
+debug-log-file=logs/debug/%Y-%M-%D-debug.log
+
+#Whether or not to enable the /interpreter command. Note that even with this enabled, a player must still have the commandhelper.interpreter permission, but setting it to false prevents all players from accessing the interpreter regardless of their permissions.
+enable-interpreter=false
+
+#The base directory that scripts can read and write to. If left blank, then the default of the server directory will be used. This setting affects functions like include and read.
+base-dir=
+
+#The path to the config file, relative to the CommandHelper plugin folder
+script-name=config.txt
+
diff --git a/README.md b/README.md
index 25262ce..ef6a9d6 100644
--- a/README.md
+++ b/README.md
@@ -22,5 +22,8 @@ CommandHelper on GitHub, add your changes, and then submit a pull request.
 We'll look at it, make comments, and merge it into CommandHelper if
 everything works out.
 
-By submitting code, you agree to place to license your code under the 
-irrevocable GNU General Public License v3.
\ No newline at end of file
+By submitting code, you agree to dual license your code under the 
+irrevocable GNU General Public License v3, and the MIT License.
+
+Portions of CommandHelper are copyright: wraithguard01, sk89q, Deaygo, 
+t3hk0d3, zml2008, and albatrossen
\ No newline at end of file
diff --git a/nbactions-provisional-build.xml b/nbactions-provisional-build.xml
index d5e8535..43f35d4 100644
--- a/nbactions-provisional-build.xml
+++ b/nbactions-provisional-build.xml
@@ -7,4 +7,41 @@
                 <goal>compile</goal>
             </goals>
         </action>
+        <action>
+            <actionName>run</actionName>
+            <goals>
+                <goal>process-classes</goal>
+                <goal>org.codehaus.mojo:exec-maven-plugin:1.2:exec</goal>
+            </goals>
+            <properties>
+                <exec.classpathScope>runtime</exec.classpathScope>
+                <exec.args>-classpath %classpath ${packageClassName} --docs wiki</exec.args>
+                <exec.executable>java</exec.executable>
+            </properties>
+        </action>
+        <action>
+            <actionName>debug</actionName>
+            <goals>
+                <goal>process-classes</goal>
+                <goal>org.codehaus.mojo:exec-maven-plugin:1.2:exec</goal>
+            </goals>
+            <properties>
+                <exec.classpathScope>runtime</exec.classpathScope>
+                <exec.args>-Xdebug -Xrunjdwp:transport=dt_socket,server=n,address=${jpda.address} -classpath %classpath ${packageClassName} --docs wiki</exec.args>
+                <jpda.listen>true</jpda.listen>
+                <exec.executable>java</exec.executable>
+            </properties>
+        </action>
+        <action>
+            <actionName>profile</actionName>
+            <goals>
+                <goal>process-classes</goal>
+                <goal>org.codehaus.mojo:exec-maven-plugin:1.1.1:exec</goal>
+            </goals>
+            <properties>
+                <exec.args>${profiler.args} -classpath %classpath ${packageClassName} --docs wiki</exec.args>
+                <profiler.action>profile</profiler.action>
+                <exec.executable>${profiler.java}</exec.executable>
+            </properties>
+        </action>
     </actions>
diff --git a/nbactions.xml b/nbactions.xml
index cd663a9..7a986f3 100644
--- a/nbactions.xml
+++ b/nbactions.xml
@@ -1,40 +1,76 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<actions>
-        <action>
-            <actionName>run</actionName>
-            <goals>
-                <goal>process-classes</goal>
-                <goal>org.codehaus.mojo:exec-maven-plugin:1.2:exec</goal>
-            </goals>
-            <properties>
-                <exec.classpathScope>runtime</exec.classpathScope>
-                <exec.args>-classpath %classpath com.laytonsmith.aliasengine.Main --docs wiki</exec.args>
-                <exec.executable>java</exec.executable>
-            </properties>
-        </action>
-        <action>
-            <actionName>debug</actionName>
-            <goals>
-                <goal>process-classes</goal>
-                <goal>org.codehaus.mojo:exec-maven-plugin:1.2:exec</goal>
-            </goals>
-            <properties>
-                <exec.classpathScope>runtime</exec.classpathScope>
-                <exec.args>-Xdebug -Xrunjdwp:transport=dt_socket,server=n,address=${jpda.address} -classpath %classpath com.laytonsmith.aliasengine.Main --docs wiki</exec.args>
-                <jpda.listen>true</jpda.listen>
-                <exec.executable>java</exec.executable>
-            </properties>
-        </action>
-        <action>
-            <actionName>profile</actionName>
-            <goals>
-                <goal>process-classes</goal>
-                <goal>org.codehaus.mojo:exec-maven-plugin:1.1.1:exec</goal>
-            </goals>
-            <properties>
-                <exec.args>${profiler.args} -classpath %classpath com.laytonsmith.aliasengine.Main --docs wiki</exec.args>
-                <profiler.action>profile</profiler.action>
-                <exec.executable>${profiler.java}</exec.executable>
-            </properties>
-        </action>
-    </actions>
+<?xml version="1.0" encoding="UTF-8"?>
+<actions>
+        <action>
+            <actionName>run</actionName>
+            <goals>
+                <goal>process-classes</goal>
+                <goal>org.codehaus.mojo:exec-maven-plugin:1.2:exec</goal>
+            </goals>
+            <properties>
+                <exec.classpathScope>runtime</exec.classpathScope>
+                <exec.args>-classpath %classpath com.laytonsmith.aliasengine.Main --docs wiki</exec.args>
+                <exec.executable>java</exec.executable>
+            </properties>
+        </action>
+        <action>
+            <actionName>debug</actionName>
+            <goals>
+                <goal>process-classes</goal>
+                <goal>org.codehaus.mojo:exec-maven-plugin:1.2:exec</goal>
+            </goals>
+            <properties>
+                <exec.classpathScope>runtime</exec.classpathScope>
+                <exec.args>-Xdebug -Xrunjdwp:transport=dt_socket,server=n,address=${jpda.address} -classpath %classpath com.laytonsmith.aliasengine.Main --docs wiki</exec.args>
+                <jpda.listen>true</jpda.listen>
+                <exec.executable>java</exec.executable>
+            </properties>
+        </action>
+        <action>
+            <actionName>profile</actionName>
+            <goals>
+                <goal>process-classes</goal>
+                <goal>org.codehaus.mojo:exec-maven-plugin:1.1.1:exec</goal>
+            </goals>
+            <properties>
+                <exec.args>${profiler.args} -classpath %classpath com.laytonsmith.aliasengine.Main --docs wiki</exec.args>
+                <profiler.action>profile</profiler.action>
+                <exec.executable>${profiler.java}</exec.executable>
+            </properties>
+        </action>
+        <action>
+            <actionName>run</actionName>
+            <goals>
+                <goal>process-classes</goal>
+                <goal>org.codehaus.mojo:exec-maven-plugin:1.2:exec</goal>
+            </goals>
+            <properties>
+                <exec.classpathScope>runtime</exec.classpathScope>
+                <exec.args>-classpath %classpath com.laytonsmith.aliasengine.Main</exec.args>
+                <exec.executable>java</exec.executable>
+            </properties>
+        </action>
+        <action>
+            <actionName>run</actionName>
+            <goals>
+                <goal>process-classes</goal>
+                <goal>org.codehaus.mojo:exec-maven-plugin:1.2:exec</goal>
+            </goals>
+            <properties>
+                <exec.classpathScope>runtime</exec.classpathScope>
+                <exec.args>-classpath %classpath com.laytonsmith.aliasengine.Main</exec.args>
+                <exec.executable>java</exec.executable>
+            </properties>
+        </action>
+        <action>
+            <actionName>run</actionName>
+            <goals>
+                <goal>process-classes</goal>
+                <goal>org.codehaus.mojo:exec-maven-plugin:1.2:exec</goal>
+            </goals>
+            <properties>
+                <exec.classpathScope>runtime</exec.classpathScope>
+                <exec.args>-classpath %classpath com.laytonsmith.core.Main</exec.args>
+                <exec.executable>java</exec.executable>
+            </properties>
+        </action>
+    </actions>
diff --git a/plugins/CommandHelper/persistance.ser b/plugins/CommandHelper/persistance.ser
new file mode 100644
index 0000000..04b19f1
Binary files /dev/null and b/plugins/CommandHelper/persistance.ser differ
diff --git a/pom.xml b/pom.xml
index 38bb4c9..cc1d20a 100644
--- a/pom.xml
+++ b/pom.xml
@@ -3,9 +3,24 @@
     <modelVersion>4.0.0</modelVersion>
     <groupId>com.sk89q</groupId>
     <artifactId>commandhelper</artifactId>
-    <version>3.2.0</version>
+    <version>3.3.0-SNAPSHOT</version>
     <name>CommandHelper</name>
     <description>CommandHelper adds powerful command related utility functions</description>
+    <issueManagement>
+        <system>BukkitDev</system>
+        <url>http://dev.bukkit.org/server-mods/commandhelper/create-ticket/</url>
+    </issueManagement>
+    <ciManagement>
+        <system>Jenkins</system>
+        <url>http://build.sk89q.com/job/CommandHelper/</url>
+    </ciManagement>
+    <licenses>
+        <license>
+            <name>GNU Lesser General Public License, Version 3</name>
+            <url>http://www.gnu.org/licenses/lgpl.html</url>
+            <distribution>repo</distribution>
+        </license>
+    </licenses>
   
     <scm>
         <connection>scm:git:git://github.com/sk89q/commandhelper.git</connection>
@@ -23,14 +38,14 @@
         
         <repository>
             <id>bukkit-repo</id>
-            <url>http://repo.bukkit.org/artifactory/repo</url>
+            <url>http://repo.bukkit.org/content/groups/public/</url>
         </repository>
         
         <repository>
             <id>bukkit-maven</id>
             <url>http://ci.bukkit.org/plugin/repository/project/dev-Bukkit/LastSuccessful/repository/</url>
             <snapshots>
-                <enabled>true</enabled>
+                <enabled>false</enabled>
             </snapshots>
         </repository>
         <repository>
@@ -44,14 +59,14 @@
         <dependency>
             <groupId>com.sk89q</groupId>
             <artifactId>worldedit</artifactId>
-            <version>4.6</version>
+            <version>5.1</version>
         </dependency>
     
-    <!-- Bukkit -->
+        <!-- Bukkit -->
         <dependency>
             <groupId>org.bukkit</groupId>
             <artifactId>bukkit</artifactId>
-            <version>0.0.1-SNAPSHOT</version>
+            <version>1.0.0-R1-SNAPSHOT</version>
         </dependency>
         
         <!-- CraftBukkit Dependency for experimental features -->
@@ -77,7 +92,59 @@
             <scope>compile</scope>
         </dependency>
         
-        <!-- Pulls in mockito, for testing purposes -->
+        
+        <!-- Used for economy stuff -->
+        <dependency>
+            <groupId>com.nijikokun</groupId>
+            <artifactId>register</artifactId>
+            <version>1.5</version>
+        </dependency>
+        
+        <!-- Used for storing and retreiving Constructs in a storage transparent medium: JSONs -->
+        <dependency>
+            <groupId>com.googlecode.json-simple</groupId>
+            <artifactId>json-simple</artifactId>
+            <version>1.1</version>
+        </dependency>
+        
+        <!-- Used for potion effects -->
+        <dependency>
+            <groupId>org.bukkit</groupId>
+            <artifactId>minecraft-server</artifactId>
+            <version>1.8.1</version>
+            <type>jar</type>
+        </dependency>
+        
+        <!-- Used for IRC hooks -->
+        <dependency>
+            <groupId>org.jibble</groupId>
+            <artifactId>pircbot</artifactId>
+            <version>1.5.0</version>
+            <scope>compile</scope>
+        </dependency>
+        
+        <!-- Profiling library -->
+        <dependency>
+            <groupId>org.perf4j</groupId>
+            <artifactId>perf4j</artifactId>
+            <version>0.9.16</version>
+            <scope>compile</scope>
+            <type>jar</type>
+        </dependency>
+        <dependency>
+            <groupId>log4j</groupId>
+            <artifactId>log4j</artifactId>
+            <version>1.2.16</version>
+            <scope>compile</scope>
+        </dependency>
+        
+        <!-- Test libraries -->
+        <dependency>
+            <groupId>junit</groupId>
+            <artifactId>junit</artifactId>
+            <version>4.8.1</version>
+            <scope>test</scope>
+        </dependency>
         <dependency>
             <groupId>org.mockito</groupId>
             <artifactId>mockito-core</artifactId>  
@@ -90,19 +157,17 @@
             <version>2.7.3</version>
             <scope>test</scope>
         </dependency>
-        
-        <!-- Used for economy stuff -->
         <dependency>
-            <groupId>com.nijikokun</groupId>
-            <artifactId>register</artifactId>
-            <version>1.0</version>
+          <groupId>org.powermock</groupId>
+            <artifactId>powermock-module-junit4</artifactId>
+            <version>1.4.10</version>
+            <scope>test</scope>
         </dependency>
-        
-        <!-- Used for storing and retreiving Constructs in a storage transparent medium: JSONs -->
         <dependency>
-            <groupId>com.googlecode.json-simple</groupId>
-            <artifactId>json-simple</artifactId>
-            <version>1.1</version>
+            <groupId>org.powermock</groupId>
+            <artifactId>powermock-api-mockito</artifactId>
+            <version>1.4.10</version>
+            <scope>test</scope>
         </dependency>
     </dependencies>
     <properties>
@@ -119,7 +184,7 @@
                 <filtering>true</filtering>
                 <directory>${basedir}/src/main/resources/</directory>
                 <includes>
-                    <include>*</include>
+                    <include>**</include>
                 </includes>
             </resource>
         </resources>
@@ -145,7 +210,8 @@
                         <manifest>
                             <addDefaultSpecificationEntries>true</addDefaultSpecificationEntries>
                             <addDefaultImplementationEntries>true</addDefaultImplementationEntries>
-                            <mainClass>com.laytonsmith.aliasengine.Main</mainClass>
+                            <mainClass>com.laytonsmith.core.Main</mainClass>
+                            <!--<mainClass>com.laytonsmith.core.MainSandbox</mainClass>-->
                         </manifest>
                         <manifestEntries>
                             <Class-Path>WorldEdit.jar CommandHelper/WorldEdit.jar lib/WorldEdit.jar ../lib/WorldEdit.jar ../WorldEdit.jar ../craftbukkit-0.0.1-SNAPSHOT.jar ../bukkit.jar CommandHelper/bukkit.jar</Class-Path>
@@ -193,25 +259,49 @@
                                 <includes>
                                     <include>com.sk89q:worldedit:jar:*</include>
                                     <include>com.nijikokun:register:jar:*</include>
+                                    <include>org.perf4j:perf4j:jar:*</include>
+                                    <include>log4j:log4j:jar:*</include>
                                 </includes>
                             </artifactSet>
                             <filters>
                                 <filter>
                                     <artifact>com.sk89q:worldedit:jar:*</artifact>
                                     <includes>
-                                        <include>com/sk89q/bukkit/migration/**</include>                                        
+                                        <!-- Permissions Items -->
+                                        <include>com/sk89q/bukkit/migration/**</include> 
+                                        <include>com/sk89q/wepif/**</include> 
+                                        <include>com/sk89q/util/**</include>
+                                        <include>com/sk89q/worldedit/Vector.*</include>
+                                        <!-- Expression Parser -->
+                                        <include>com/sk89q/worldedit/expression/**</include>
                                     </includes>
                                     <excludes>
                                         <exclude>com/sk89q/jchronic/**</exclude>
                                         <exclude>com/google/**</exclude>
                                     </excludes>
                                 </filter>
+                                <!-- Profiler -->
                                 <filter>
-                                    <artifact>com.nijikokun:register:jar:*</artifact>
+                                    <artifact>org.perf4j:perf4j:jar:*</artifact>
+                                    <includes>
+                                        <include>**</include>
+                                    </includes>
+                                </filter>
+                                <filter>
+                                    <artifact>log4j:log4j:jar:*</artifact>
                                     <includes>
                                         <include>**</include>
                                     </includes>
                                 </filter>
+                                
+                                <!-- Register -->
+                                <filter>
+                                    <artifact>com.nijikokun:register:jar:*</artifact>
+                                    <includes>
+                                        <include>**</include>
+                                    </includes>
+                                </filter>                                
+                                
                             </filters>
                         </configuration>
                     </execution>
diff --git a/src/main/java/com/laytonsmith/PureUtilities/ClassDiscovery.java b/src/main/java/com/laytonsmith/PureUtilities/ClassDiscovery.java
new file mode 100644
index 0000000..f39cd1d
--- /dev/null
+++ b/src/main/java/com/laytonsmith/PureUtilities/ClassDiscovery.java
@@ -0,0 +1,381 @@
+/*
+ * To change this template, choose Tools | Templates
+ * and open the template in the editor.
+ */
+package com.laytonsmith.PureUtilities;
+
+import java.io.File;
+import java.io.IOException;
+import java.net.URL;
+import java.security.CodeSource;
+import java.util.ArrayList;
+import java.util.List;
+import java.util.logging.Level;
+import java.util.logging.Logger;
+import java.util.regex.Pattern;
+import java.util.zip.ZipEntry;
+import java.util.zip.ZipInputStream;
+
+public class ClassDiscovery {
+
+    public static Class[] GetClassesWithinPackageHierarchy(){
+        String url = ClassDiscovery.class.getResource(ClassDiscovery.class.getSimpleName() + ".class").toString();
+        List<String> classNameList = new ArrayList<String>();
+        if(url.startsWith("file:")){
+            //We are running from the file system
+            //First, get the "root" of the class structure. We assume it's
+            //the root of this class
+            String fileName = Pattern.quote(ClassDiscovery.class.getCanonicalName().replace(".", File.separator));
+            fileName = fileName.replaceAll("\\\\Q", "").replaceAll("\\\\E", "") + ".class";
+            String root = url.replaceAll("file:", "").replaceAll(fileName, "");
+            System.out.println(root);
+            //Ok, now we have the "root" of the known class structure. Let's recursively
+            //go through everything and pull out the files
+            List<File> fileList = new ArrayList<File>();
+            descend(new File(root), fileList);
+            //Now, we have all the class files in the package. But, it's the absolute path
+            //to all of them. We have to first remove the "front" part
+            for(File f : fileList){
+                classNameList.add(f.getAbsolutePath().replaceFirst(Pattern.quote(root), ""));
+            }
+            
+        } else if(url.startsWith("jar:")) {
+            //We are running from a jar
+            CodeSource src = ClassDiscovery.class.getProtectionDomain().getCodeSource();
+            if (src != null) {
+              ZipInputStream zip = null;
+                try {
+                    URL jar = src.getLocation();
+                    zip = new ZipInputStream(jar.openStream());
+                    ZipEntry ze;
+                    while((ze = zip.getNextEntry()) != null){
+                        classNameList.add(ze.getName());
+                    }
+                } catch (IOException ex) {
+                    Logger.getLogger(ClassDiscovery.class.getName()).log(Level.SEVERE, null, ex);
+                } finally {
+                    try {
+                        zip.close();
+                    } catch (IOException ex) {
+                        Logger.getLogger(ClassDiscovery.class.getName()).log(Level.SEVERE, null, ex);
+                    }
+                }
+
+              
+            } 
+        }
+        //Ok, now we need to go through the list, and throw out entries
+        //that are anonymously named (they end in $\d.class) because they
+        //are inaccessible anyways
+        List<Class> files = new ArrayList<Class>();
+        for(String s : classNameList){
+            if(!s.matches(".*\\$(?:\\d)*\\.class") && s.endsWith(".class")){
+                //Now, replace any \ with / and replace / with ., and remove the .class,
+                //and forName it.
+                String className = s.replaceAll("\\.class", "").replaceAll("\\\\", "/").replaceAll("[/]", ".");
+                try {
+                    //Don't initialize it, so we don't have to deal with ExceptionInInitializer errors
+                    Class c = Class.forName(className, false, ClassDiscovery.class.getClassLoader());
+                    files.add(c);
+                } catch (ClassNotFoundException ex) {
+                    //It can't be loaded? O.o Oh well.
+                } catch (NoClassDefFoundError ex){
+                    //Must have been an external library
+                }
+            }
+        }
+        return files.toArray(new Class[files.size()]);
+    }
+    
+    public static Class[] GetClassesWithAnnotation(Class annotation){
+        List<Class> classes = new ArrayList<Class>();
+        for(Class c : GetClassesWithinPackageHierarchy()){
+            if(c.getAnnotation(annotation) != null){
+                classes.add(c);
+            }
+        }
+        return classes.toArray(new Class[classes.size()]);
+    }
+    
+    private static void descend(File start, List<File> fileList){
+        if(start.isFile()){
+            if(start.getName().endsWith(".class")){       
+                fileList.add(start);
+                return;
+            }
+        } else {
+            for(File child : start.listFiles()){
+                descend(child, fileList);
+            }
+        }
+    }
+//    static private String GetClassName_afterPackageAsPath(
+//            final String pFileName,
+//            final String pPkgAsPath) {
+//        final String CName = pFileName.substring(0, pFileName.length() - 6).replace('/', '.').replace('\\', '.');
+//        final String CName_AfterPackageAsPath = CName.substring(pPkgAsPath.length());
+//        return CName_AfterPackageAsPath;
+//    }
+//
+//    static private String GetClassName_ofPackageAsPath(
+//            final String pFileName,
+//            final String pPkgAsPath) {
+//
+//        final boolean aIsClass = pFileName.endsWith(".class");
+//        if (!aIsClass) {
+//            return null;
+//        }
+//
+//        final boolean aIsBelongToPackage = pFileName.startsWith(pPkgAsPath);
+//        if (!aIsBelongToPackage) {
+//            return null;
+//        }
+//
+//        final String aClassName = ClassDiscovery.GetClassName_afterPackageAsPath(pFileName, pPkgAsPath);
+//        return aClassName;
+//    }
+//
+//    static private File GetPackageFile(
+//            final String pPkgName,
+//            final File pPkgPath) {
+//
+//        final String aPkgFileName = pPkgPath.getAbsoluteFile().toString() + '/' + pPkgName.replace('.', '/');
+//        final File aPkgFile = new File(aPkgFileName);
+//
+//        final boolean aIsExist = aPkgFile.exists();
+//        final boolean aIsDirectory = aPkgFile.isDirectory();
+//        final boolean aIsExist_asDirectory = aIsExist && aIsDirectory;
+//        if (!aIsExist_asDirectory) {
+//            return null;
+//        }
+//
+//        return aPkgFile;
+//    }
+//
+//    static private boolean Check_isJarFile(final File pFile) {
+//        final boolean aIsJarFile = pFile.toString().endsWith(".jar");
+//        return aIsJarFile;
+//    }
+//
+//    static private ArrayList<String> DiscoverClassNames_fromJarFile(final PkgInfo pPkgInfo) {
+//
+//        final ArrayList<String> aClassNames = new ArrayList<String>();
+//        try {
+//            final JarFile JF = new JarFile(pPkgInfo.PkgPath);
+//            final Enumeration<JarEntry> JEs = JF.entries();
+//
+//            while (JEs.hasMoreElements()) {
+//                final JarEntry aJE = JEs.nextElement();
+//                final String aJEName = aJE.getName();
+//
+//                final String aSimpleName = GetClassName_ofPackageAsPath(aJEName, pPkgInfo.PkgAsPath);
+//                if (aSimpleName == null) {
+//                    continue;
+//                }
+//
+//                final String aClassName = pPkgInfo.PkgName + '.' + aSimpleName;
+//                aClassNames.add(aClassName);
+//            }
+//
+//            JF.close();
+//        } catch (IOException e) {
+//        }
+//
+//        return aClassNames;
+//    }
+//
+//    static private void DiscoverClassNames_fromDirectory(
+//            final String pAbsolutePackagePath,
+//            final String pPackageName,
+//            final File pPackageFolder,
+//            final ArrayList<String> pClassNames) {
+//        final File[] aFiles = pPackageFolder.listFiles();
+//        for (File aFile : aFiles) {
+//            if (aFile.isDirectory()) {
+//                DiscoverClassNames_fromDirectory(pAbsolutePackagePath, pPackageName, aFile, pClassNames);
+//                continue;
+//            }
+//
+//            final String aFileName = aFile.getAbsolutePath().substring(pAbsolutePackagePath.length() + 1);
+//            final boolean aIsClassFile = aFileName.endsWith(".class");
+//            if (!aIsClassFile) {
+//                continue;
+//            }
+//
+//            final String aSimpleName = aFileName.substring(0, aFileName.length() - 6).replace('/', '.').replace('\\', '.');
+//            final String aClassName = pPackageName + '.' + aSimpleName;
+//            pClassNames.add(aClassName);
+//        }
+//    }
+//
+//    static private ArrayList<String> DiscoverClassNames_fromDirectory(PkgInfo pPkgInfo) {
+//
+//        final ArrayList<String> aClassNames = new ArrayList<String>();
+//        final File aPkgFile = ClassDiscovery.GetPackageFile(pPkgInfo.PkgName, pPkgInfo.PkgPath);
+//        if (aPkgFile == null) {
+//            return aClassNames;
+//        }
+//
+//        DiscoverClassNames_fromDirectory(aPkgFile.getAbsolutePath(), pPkgInfo.PkgName, aPkgFile, aClassNames);
+//        return aClassNames;
+//    }
+//
+//    static public class PkgInfo {
+//
+//        PkgInfo(
+//                final File pPkgPath,
+//                final String pPkgName,
+//                final String pPkgAsPath) {
+//
+//            this.PkgPath = pPkgPath;
+//            this.PkgName = pPkgName;
+//            this.PkgAsPath = pPkgAsPath;
+//        }
+//        final File PkgPath;
+//        final String PkgName;
+//        final String PkgAsPath;
+//    }
+//
+//    static public PkgInfo GetPackageInfoOf(Class<?> pClass) {
+//        File aPkgPath = null;
+//        String aPkgName = null;
+//        String aPkgAsPath = null;
+//
+//        try {
+//            aPkgPath = new File(pClass.getProtectionDomain().getCodeSource().getLocation().toURI());
+//            aPkgName = pClass.getPackage().getName();
+//            aPkgAsPath = aPkgName.replace('.', '/') + '/';
+//        } catch (Throwable e) {
+//        }
+//
+//        if (aPkgPath == null) {
+//            return null;
+//        }
+//
+//        final PkgInfo aPkgInfo = new PkgInfo(aPkgPath, aPkgName, aPkgAsPath);
+//        return aPkgInfo;
+//    }
+//
+//    static public ArrayList<String> DiscoverClassNames_inPackage(final PkgInfo pPkgInfo) {
+//
+//        if (pPkgInfo == null) {
+//            return null;
+//        }
+//
+//        ArrayList<String> aClassNames = new ArrayList<String>();
+//        if (pPkgInfo.PkgPath.isDirectory()) {
+//
+//            aClassNames = ClassDiscovery.DiscoverClassNames_fromDirectory(pPkgInfo);
+//
+//        } else if (pPkgInfo.PkgPath.isFile()) {
+//            boolean aIsJarFile = ClassDiscovery.Check_isJarFile(pPkgInfo.PkgPath);
+//            if (!aIsJarFile) {
+//                return null;
+//            }
+//
+//            aClassNames = ClassDiscovery.DiscoverClassNames_fromJarFile(pPkgInfo);
+//        }
+//
+//        return aClassNames;
+//    }
+//
+//    /**
+//     * Returns an array of class in the same package as the the SeedClass
+//     * 
+//     * @param pFilterName     - Regular expression to match the desired classes' name (nullif no filtering needed)
+//     * @param pFilterClass   - The super class of the desired classes (null if no filtering needed)
+//     * 
+//     * @return                - The array of matched classes, null if there is a problem.
+//     * 
+//     * @author The rest       - Nawaman  http://nawaman.net
+//     * @author Package as Dir - Jon Peck http://jonpeck.com
+//     *                              (adapted from http://www.javaworld.com/javaworld/javatips/jw-javatip113.html)
+//     */
+//    @SuppressWarnings("unchecked")
+//    public static <T> Class<? extends T>[] DiscoverClasses(
+//            final Class<?> pSeedClass,
+//            final String pFilterName,
+//            final Class<T> pFilterClass) {
+//
+//        final Pattern aClsNamePattern = (pFilterName == null) ? null : Pattern.compile(pFilterName);
+//
+//        PkgInfo aPkgInfo = null;
+//
+//        try {
+//            aPkgInfo = GetPackageInfoOf(pSeedClass);
+//        } catch (Throwable e) {
+//        }
+//
+//        if (aPkgInfo == null) {
+//            return null;
+//        }
+//
+//        final ArrayList<String> aClassNames = DiscoverClassNames_inPackage(aPkgInfo);
+//
+//        if (aClassNames == null) {
+//            return null;
+//        }
+//
+//        if (aClassNames.size() == 0) {
+//            return null;
+//        }
+//
+//        final ArrayList<Class<?>> aClasses = new ArrayList<Class<?>>();
+//        for (final String aClassName : aClassNames) {
+//
+//            if ((aClsNamePattern != null) && !aClsNamePattern.matcher(aClassName).matches()) {
+//                continue;
+//            }
+//
+//            // Get the class and filter it
+//            Class<?> aClass = null;
+//            try {
+//                aClass = Class.forName(aClassName);
+//            } catch (ClassNotFoundException e) {
+//                continue;
+//            } catch (NoClassDefFoundError e) {
+//                continue;
+//            }
+//
+//            if ((pFilterClass != null) && !pFilterClass.isAssignableFrom(aClass)) {
+//                continue;
+//            }
+//
+//            if (pFilterClass != null) {
+//                if (!pFilterClass.isAssignableFrom(aClass)) {
+//                    continue;
+//                }
+//
+//                aClasses.add(aClass.asSubclass(pFilterClass));
+//            } else {
+//                aClasses.add(aClass);
+//            }
+//        }
+//
+//        Class<? extends T>[] aClassesArray = aClasses.toArray((Class<? extends T>[]) (new Class[aClasses.size()]));
+//
+//        return aClassesArray;
+//    }
+//
+//    static public void main(String... pArgs) {
+//        Class<?> aSeedClass = ClassDiscovery.class;
+//        try {
+//            aSeedClass = Class.forName(pArgs[0]);
+//        } catch (Exception E) {
+//        }
+//
+//        if (aSeedClass == null) {
+//            aSeedClass = ClassDiscovery.class;
+//        }
+//
+//        final Class<?>[] aClasses = DiscoverClasses(aSeedClass, null, null);
+//
+//        System.out.println("[");
+//        if (aClasses != null) {
+//            for (Class aClass : aClasses) {
+//                System.out.println("\t" + aClass);
+//            }
+//        }
+//        System.out.println("]");
+//    }
+}
diff --git a/src/main/java/com/laytonsmith/PureUtilities/Pair.java b/src/main/java/com/laytonsmith/PureUtilities/Pair.java
new file mode 100644
index 0000000..835f67d
--- /dev/null
+++ b/src/main/java/com/laytonsmith/PureUtilities/Pair.java
@@ -0,0 +1,25 @@
+/*
+ * To change this template, choose Tools | Templates
+ * and open the template in the editor.
+ */
+package com.laytonsmith.PureUtilities;
+
+/**
+ *
+ * @author layton
+ */
+public class Pair<A extends Object, B extends Object> {
+
+    public final A fst;
+    public final B snd;
+
+    public Pair(A a, B b) {
+        fst = a;
+        snd = b;
+    }
+
+    @Override
+    public String toString() {
+        return "<" + fst.toString() + ", " + snd.toString() + ">";
+    }
+}
diff --git a/src/main/java/com/laytonsmith/PureUtilities/Persistance.java b/src/main/java/com/laytonsmith/PureUtilities/Persistance.java
index 3677d11..820a06e 100644
--- a/src/main/java/com/laytonsmith/PureUtilities/Persistance.java
+++ b/src/main/java/com/laytonsmith/PureUtilities/Persistance.java
@@ -75,10 +75,16 @@ public interface Persistance {
      * @param partialKey The partial name of the keys you wish to return
      * @return An ArrayList of Map.Entries.
      */
-    public List<Map.Entry> getNamespaceValues(String[] partialKey);
+    public List<Map.Entry<String, Object>> getNamespaceValues(String[] partialKey);
     
     /**
      * Prints all of the stored values to the specified stream.
      */
     public void printValues(PrintStream out);
+    
+    /**
+     * Clears out all of the data from this persistance object. For the love
+     * of God, don't call this from anywhere but the data manager!
+     */
+    public void clearAllData();
 }
diff --git a/src/main/java/com/laytonsmith/PureUtilities/Preferences.java b/src/main/java/com/laytonsmith/PureUtilities/Preferences.java
index 2e4570d..9b91a4a 100644
--- a/src/main/java/com/laytonsmith/PureUtilities/Preferences.java
+++ b/src/main/java/com/laytonsmith/PureUtilities/Preferences.java
@@ -1,16 +1,8 @@
 
 package com.laytonsmith.PureUtilities;
 
-import java.io.BufferedWriter;
-import java.io.File;
-import java.io.FileInputStream;
-import java.io.FileWriter;
-import java.io.IOException;
-import java.util.ArrayList;
-import java.util.HashMap;
-import java.util.Iterator;
-import java.util.Map;
-import java.util.Properties;
+import java.io.*;
+import java.util.*;
 import java.util.logging.Level;
 import java.util.logging.Logger;
 
diff --git a/src/main/java/com/laytonsmith/PureUtilities/SerializedPersistance.java b/src/main/java/com/laytonsmith/PureUtilities/SerializedPersistance.java
index 5ccae60..40f9fa2 100644
--- a/src/main/java/com/laytonsmith/PureUtilities/SerializedPersistance.java
+++ b/src/main/java/com/laytonsmith/PureUtilities/SerializedPersistance.java
@@ -1,21 +1,9 @@
 package com.laytonsmith.PureUtilities;
 
-import java.io.File;
-import java.io.FileInputStream;
-import java.io.FileNotFoundException;
-import java.io.FileOutputStream;
-import java.io.IOException;
-import java.io.ObjectInputStream;
-import java.io.ObjectOutputStream;
-import java.io.PrintStream;
-import java.io.Serializable;
-import java.util.ArrayList;
-import java.util.HashMap;
-import java.util.Iterator;
-import java.util.Map;
+import java.io.*;
+import java.util.*;
 import java.util.logging.Level;
 import java.util.logging.Logger;
-import org.bukkit.plugin.Plugin;
 
 /**
  * This file allows for simple data storage across many different data sources. In general, the
@@ -31,26 +19,38 @@ public class SerializedPersistance implements Persistance{
     private HashMap<String, Serializable> data = new HashMap<String, Serializable>();
     private boolean isLoaded = false;
     /**
-     * The storage location of the persistance database. Note that it is package private,
-     * so it can be changed.
+     * The storage location of the persistance database. 
      */
-    File storageLocation;
-
-    Object user;
+    private File storageLocation;
     
-    public SerializedPersistance(File database, Plugin user){
-        storageLocation = database;
-        this.user = user;
-    }
-
     /**
-     * Private constructor, used for testing this class
+     * @deprecated 
      * @param database
-     * @param user
+     * @param user 
      */
-    private SerializedPersistance(File database, Object user){
+    public SerializedPersistance(File database, Object user){
         storageLocation = database;
-        this.user = user;
+    }
+    
+    public SerializedPersistance(File database){
+        storageLocation = database;
+    }
+    
+    /**
+     * Unless you're the data manager, don't use this method.
+     * @return 
+     */
+    public HashMap<String, Serializable> rawData(){
+        return data;
+    }
+    
+    /**
+     * Unless you're the data manager, and you <em>really</em> want to clear
+     * out the entire database, don't use this method. You must manually call
+     * save after this, if you wish the changes to be written out to disk.
+     */
+    public void clearAllData(){
+        data = new HashMap<String, Serializable>();
     }
 
     /**
@@ -59,37 +59,15 @@ public class SerializedPersistance implements Persistance{
      */
     public synchronized void load() throws Exception {
         try {
-            FileInputStream fis = null;
-            ObjectInputStream in = null;
-            fis = new FileInputStream(storageLocation);
-            in = new ObjectInputStream(fis);
-            HashMap<String, Serializable> tempData = (HashMap<String, Serializable>) in.readObject();
-            String[] myNamespace;
-            if(user != null){
-                myNamespace = ("plugin." + user.getClass().getCanonicalName()).split("\\.");
-            } else {
-                //We're running from the command line
-                data = tempData;
-                return;
-            }
-            Iterator i = tempData.entrySet().iterator();
-            while (i.hasNext()) {
-                String[] key = ((Map.Entry)i.next()).getKey().toString().split("\\.");
-                boolean match = true;
-                for(int j = 0; j < myNamespace.length; j++){
-                    if(key.length > myNamespace.length){
-                        if(!key[j].equals(myNamespace[j])){
-                            match = false;
-                            break;
-                        }
-                    }
-                }
-                if(match){
-                    data.put(getNamespace(key), tempData.get(getNamespace(key)));
-                }
-            }
-            in.close();
-            isLoaded = true;
+            if(!isLoaded){
+                FileInputStream fis = null;
+                ObjectInputStream in = null;
+                fis = new FileInputStream(storageLocation);
+                in = new ObjectInputStream(fis);
+                data = (HashMap<String, Serializable>) in.readObject();
+                in.close();
+                isLoaded = true;
+            }            
         } catch (FileNotFoundException ex){
             //ignore this one
         } catch (Exception ex) {
@@ -102,31 +80,7 @@ public class SerializedPersistance implements Persistance{
      * @throws IOException
      */
     public synchronized void save() throws Exception {
-        try {
-            HashMap<String, Serializable> tempData;
-            try{
-                FileInputStream fis = null;
-                ObjectInputStream in = null;
-                fis = new FileInputStream(storageLocation);
-                in = new ObjectInputStream(fis);
-                tempData = (HashMap<String, Serializable>) in.readObject();
-            } catch(FileNotFoundException ex){
-                tempData = new HashMap<String, Serializable>();
-            }
-            Iterator i = data.entrySet().iterator();
-            ArrayList<String> toRemove = new ArrayList<String>();
-            while (i.hasNext()) {
-                String key = ((Map.Entry)i.next()).getKey().toString();
-                if(data.get(key) == null){
-                    tempData.remove(key);
-                    toRemove.add(key);
-                } else{
-                    tempData.put(key, data.get(key));
-                }
-            }
-            for(String s : toRemove){
-                data.remove(s);
-            }
+        try {            
             FileOutputStream fos = null;
             ObjectOutputStream out = null;
             storageLocation.getParentFile().mkdirs();
@@ -134,9 +88,8 @@ public class SerializedPersistance implements Persistance{
                 storageLocation.createNewFile();
             fos = new FileOutputStream(storageLocation);
             out = new ObjectOutputStream(fos);
-            out.writeObject(tempData);
+            out.writeObject(data);
             out.close();
-            System.out.println("Persistance saved into " + this.hashCode());
         } catch (Exception ex) {
             throw ex;
         }
@@ -149,16 +102,23 @@ public class SerializedPersistance implements Persistance{
     private synchronized Object setValue(String key, Serializable value) {
         //defer loading until we actually try and use the data structure
         if (isLoaded == false) {
-            System.out.println("Loading values for " + user.getClass().getCanonicalName());
             try {
                 load();
             } catch (Exception ex) {
                 Logger.getLogger("Minecraft").log(Level.SEVERE, null, ex);
             }
         }
-        key = "plugin." + user.getClass().getCanonicalName() + "." + key;
         Serializable oldVal = data.get(key);
-        data.put(key, value);
+        if(value == null){
+            data.remove(key);
+        } else {
+            data.put(key, value);
+        }
+        try {
+            save();
+        } catch (Exception ex) {
+            Logger.getLogger(SerializedPersistance.class.getName()).log(Level.SEVERE, null, ex);
+        }
         return oldVal;
     }
 
@@ -166,14 +126,12 @@ public class SerializedPersistance implements Persistance{
     private synchronized Object getValue(String key) {
         //defer loading until we actually try and use the data structure
         if (isLoaded == false) {
-            System.out.println("Loading values for " + user.getClass().getCanonicalName());
             try {
                 load();
             } catch (Exception ex) {
                 Logger.getLogger(SerializedPersistance.class.getName()).log(Level.SEVERE, null, ex);
             }
         }
-        key = "plugin." + user.getClass().getCanonicalName() + "." + key;
         if(data == null){
             return null;
         }
@@ -203,7 +161,8 @@ public class SerializedPersistance implements Persistance{
     }
 
     /**
-     * Returns the value of a particular key
+     * Returns the value of a particular key, or null if the
+     * key doesn't exist
      * @param key
      * @return
      */
@@ -219,7 +178,6 @@ public class SerializedPersistance implements Persistance{
      */
     public synchronized boolean isKeySet(String[] key) {
         String k = getNamespace(key);
-        k = "plugin." + user.getClass().getCanonicalName() + "." + k;
         return data.containsKey(k);
     }
 
@@ -233,7 +191,6 @@ public class SerializedPersistance implements Persistance{
      */
     public synchronized boolean isNamespaceSet(String[] partialKey) {
         String m = getNamespace(partialKey);
-        m = "plugin." + user.getClass().getCanonicalName() + "." + m;
         partialKey = m.split("\\.");
         Iterator i = data.entrySet().iterator();
         while (i.hasNext()) {
@@ -262,11 +219,10 @@ public class SerializedPersistance implements Persistance{
      * @param partialKey The partial name of the keys you wish to return
      * @return An ArrayList of Map.Entries.
      */
-    public synchronized ArrayList<Map.Entry> getNamespaceValues(String[] partialKey){
+    public synchronized List<Map.Entry<String, Object>> getNamespaceValues(String[] partialKey){
 
-        ArrayList<Map.Entry> matches = new ArrayList<Map.Entry>();
+        List<Map.Entry<String, Object>> matches = new ArrayList<Map.Entry<String, Object>>();
         String m = getNamespace(partialKey);
-        m = "plugin." + user.getClass().getCanonicalName() + "." + m;
         partialKey = m.split("\\.");
         if(!isLoaded){
             try {
diff --git a/src/main/java/com/laytonsmith/PureUtilities/TermColors.java b/src/main/java/com/laytonsmith/PureUtilities/TermColors.java
new file mode 100644
index 0000000..22a4ee5
--- /dev/null
+++ b/src/main/java/com/laytonsmith/PureUtilities/TermColors.java
@@ -0,0 +1,151 @@
+
+package com.laytonsmith.PureUtilities;
+
+import java.awt.Color;
+
+/**
+ *
+ * @author layton
+ */
+public class TermColors {
+    public enum SYS {
+
+        WINDOWS,
+        UNIX
+    }
+    public static final SYS SYSTEM;
+
+    static {
+        String os = System.getProperty("os.name");
+        if (os.contains("Windows")) {
+            SYSTEM = SYS.WINDOWS;
+        } else {
+            SYSTEM = SYS.UNIX;
+        }
+    }
+    
+    public static void cls(){
+        if(SYSTEM.equals(SYS.WINDOWS)){
+            //Fuck you windows.
+            for(int i = 0; i < 50; i++){
+                System.out.println();
+            }
+        } else {           
+            System.out.print("\u001b[2J");
+            System.out.flush();
+        }
+    }
+    
+    /*
+     * Standard foreground colors 
+     */
+    public static final String RED = color(Color.RED).toString();
+    public static final String GREEN = color(Color.GREEN).toString();
+    public static final String BLUE = color(Color.BLUE).toString();
+    public static final String YELLOW = color(Color.YELLOW).toString();
+    public static final String CYAN = color(Color.CYAN).toString();
+    public static final String MAGENTA = color(Color.MAGENTA).toString();
+    public static final String BLACK = color(Color.BLACK).toString();
+    public static final String WHITE = color(Color.WHITE).toString();
+    
+    /*
+     * Bright foreground colors
+     */
+    public static final String BRIGHT_RED = color(Color.RED, true, true);
+    public static final String BRIGHT_GREEN = color(Color.GREEN, true, true);
+    public static final String BRIGHT_BLUE = color(Color.BLUE, true, true);
+    public static final String BRIGHT_YELLOW = color(Color.YELLOW, true, true);
+    public static final String BRIGHT_CYAN = color(Color.CYAN, true, true);
+    public static final String BRIGHT_MAGENTA = color(Color.MAGENTA, true, true);
+    public static final String BRIGHT_BLACK = color(Color.BLACK, true, true);
+    public static final String BRIGHT_WHITE = color(Color.WHITE, true, true);
+    
+    /*
+     * Standard background colors 
+     */
+    public static final String BG_RED = color(Color.RED, false, false).toString();
+    public static final String BG_GREEN = color(Color.GREEN, false, false).toString();
+    public static final String BG_BLUE = color(Color.BLUE, false, false).toString();
+    public static final String BG_YELLOW = color(Color.YELLOW, false, false).toString();
+    public static final String BG_CYAN = color(Color.CYAN, false, false).toString();
+    public static final String BG_MAGENTA = color(Color.MAGENTA, false, false).toString();
+    public static final String BG_BLACK = color(Color.BLACK, false, false).toString();
+    public static final String BG_WHITE = color(Color.WHITE, false, false).toString();
+    
+    /*
+     * Bright background colors
+     */
+    public static final String BG_BRIGHT_RED = color(Color.RED, true, false);
+    public static final String BG_BRIGHT_GREEN = color(Color.GREEN, true, false);
+    public static final String BG_BRIGHT_BLUE = color(Color.BLUE, true, false);
+    public static final String BG_BRIGHT_YELLOW = color(Color.YELLOW, true, false);
+    public static final String BG_BRIGHT_CYAN = color(Color.CYAN, true, false);
+    public static final String BG_BRIGHT_MAGENTA = color(Color.MAGENTA, true, false);
+    public static final String BG_BRIGHT_BLACK = color(Color.BLACK, true, false);
+    public static final String BG_BRIGHT_WHITE = color(Color.WHITE, true, false);
+    
+    public static final String BLINKON = special("blinkon");
+    public static final String BLINKOFF = special("blinkoff");
+    
+    private static String special(String type){
+        if(SYSTEM.equals(SYS.UNIX)){
+            if(type.equals("blinkon")){
+                return "\033[5m";
+            }
+            if(type.equals("blinkoff")){
+                return "\033[25m";
+            }
+        }
+        return "";
+    }
+    
+    public static String reset(){
+        if(SYSTEM.equals(SYS.WINDOWS)){
+            return ""; //lol, it's already reset
+        }
+        return "\033[0m";
+    }
+    /**
+     * Returns the specified color code, foreground, and dark.
+     * @param c
+     * @return 
+     */
+    public static String color(Color c){
+        return color(c, false, true);
+    }
+    /**
+     * This is not the preferred method, however, if you must, you
+     * can use this function to get the specified colors, given an awt Color.
+     * Not all colors are supported, and bad colors will just return white.
+     * @param c
+     * @return 
+     */
+    public static String color(Color c, boolean bright, boolean foreground) {
+        if (SYSTEM.equals(SYS.WINDOWS)) {
+            return "";
+        }
+
+        int color = 37;
+        if (c.equals(Color.RED)) {
+            color = 31;
+        } else if (c.equals(Color.GREEN)) {
+            color = 32;
+        } else if (c.equals(Color.BLUE)) {
+            color = 34;
+        } else if (c.equals(Color.YELLOW)) {
+            color = 33;
+        } else if (c.equals(Color.CYAN)) {
+            color = 36;
+        } else if (c.equals(Color.MAGENTA)) {
+            color = 35;
+        } else if (c.equals(Color.BLACK)) {
+            color = 30;
+        } else if (c.equals(Color.WHITE)) {
+            color = 37;
+        }
+        if(!foreground){
+            color += 10;
+        }
+        return "\033[" + (bright?"1;":"") + color + "m";
+    }
+}
diff --git a/src/main/java/com/laytonsmith/PureUtilities/fileutility/FileUtility.java b/src/main/java/com/laytonsmith/PureUtilities/fileutility/FileUtility.java
index d4c047b..de614aa 100644
--- a/src/main/java/com/laytonsmith/PureUtilities/fileutility/FileUtility.java
+++ b/src/main/java/com/laytonsmith/PureUtilities/fileutility/FileUtility.java
@@ -4,11 +4,7 @@
  */
 package com.laytonsmith.PureUtilities.fileutility;
 
-import java.io.File;
-import java.io.FileInputStream;
-import java.io.FileNotFoundException;
-import java.io.FileWriter;
-import java.io.IOException;
+import java.io.*;
 import java.util.Scanner;
 
 /**
@@ -43,7 +39,7 @@ public class FileUtility {
      * @return a string with the contents of the file
      * @throws FileNotFoundException 
      */
-    public static String read(File f) throws FileNotFoundException{
+    public static String read(File f) throws FileNotFoundException {
         StringBuilder t = new StringBuilder();
         String NL = System.getProperty("line.separator");
         Scanner scanner = new Scanner(new FileInputStream(f));
@@ -65,9 +61,9 @@ public class FileUtility {
      * @param mode Either OVERWRITE or APPEND
      * @throws IOException If the File f cannot be written to
      */
-    public static void write(String s, File f, int mode) throws IOException{
+    public static void write(String s, File f, int mode) throws IOException {
         boolean append;
-        if(mode == OVERWRITE){
+        if (mode == OVERWRITE) {
             append = false;
         } else {
             append = true;
@@ -84,7 +80,91 @@ public class FileUtility {
      * @param f The File to write to
      * @throws IOException If the File f cannot be written to
      */
-    public static void write(String s, File f) throws IOException{
+    public static void write(String s, File f) throws IOException {
         write(s, f, OVERWRITE);
     }
+
+    public static void copy(File fromFile, File toFile)
+            throws IOException {
+
+        if (!fromFile.exists()) {
+            throw new IOException("FileCopy: " + "no such source file: "
+                    + fromFile.getName());
+        }
+        if (!fromFile.isFile()) {
+            throw new IOException("FileCopy: " + "can't copy directory: "
+                    + fromFile.getName());
+        }
+        if (!fromFile.canRead()) {
+            throw new IOException("FileCopy: " + "source file is unreadable: "
+                    + fromFile.getName());
+        }
+
+        if (toFile.isDirectory()) {
+            toFile = new File(toFile, fromFile.getName());
+        }
+
+        if (toFile.exists()) {
+            if (!toFile.canWrite()) {
+                throw new IOException("FileCopy: "
+                        + "destination file is unwriteable: " + toFile.getName());
+            }
+            System.out.print("Overwrite existing file " + toFile.getName()
+                    + "? (Y/N): ");
+            System.out.flush();
+            BufferedReader in = new BufferedReader(new InputStreamReader(
+                    System.in));
+            String response = in.readLine();
+            if (!response.equals("Y") && !response.equals("y")) {
+                throw new IOException("FileCopy: "
+                        + "existing file was not overwritten.");
+            }
+        } else {
+            String parent = toFile.getParent();
+            if (parent == null) {
+                parent = System.getProperty("user.dir");
+            }
+            File dir = new File(parent);
+            if (!dir.exists()) {
+                throw new IOException("FileCopy: "
+                        + "destination directory doesn't exist: " + parent);
+            }
+            if (dir.isFile()) {
+                throw new IOException("FileCopy: "
+                        + "destination is not a directory: " + parent);
+            }
+            if (!dir.canWrite()) {
+                throw new IOException("FileCopy: "
+                        + "destination directory is unwriteable: " + parent);
+            }
+        }
+
+        FileInputStream from = null;
+        FileOutputStream to = null;
+        try {
+            from = new FileInputStream(fromFile);
+            to = new FileOutputStream(toFile);
+            byte[] buffer = new byte[4096];
+            int bytesRead;
+
+            while ((bytesRead = from.read(buffer)) != -1) {
+                to.write(buffer, 0, bytesRead); // write
+            }
+        } finally {
+            if (from != null) {
+                try {
+                    from.close();
+                } catch (IOException e) {
+                    ;
+                }
+            }
+            if (to != null) {
+                try {
+                    to.close();
+                } catch (IOException e) {
+                    ;
+                }
+            }
+        }
+    }
 }
diff --git a/src/main/java/com/laytonsmith/PureUtilities/rParser.java b/src/main/java/com/laytonsmith/PureUtilities/rParser.java
index 29d1e21..d83cf7e 100644
--- a/src/main/java/com/laytonsmith/PureUtilities/rParser.java
+++ b/src/main/java/com/laytonsmith/PureUtilities/rParser.java
@@ -1,9 +1,8 @@
 package com.laytonsmith.PureUtilities;
 
+import com.laytonsmith.abstraction.MCChatColor;
 import java.util.ArrayList;
 
-import org.bukkit.ChatColor;
-
 /**
  * This class provides a method for working around the not so pretty line breaks
  * that SMP does. The original class was written by Nossr50, with portions contributed
@@ -82,7 +81,7 @@ public class rParser {
 
                 //If the word is not too long to fit
                 len += wordLength;
-                if (len < lineLength) {
+                if (len <= lineLength) {
                     words.add(split.remove(0));
                 }
             }
@@ -91,8 +90,11 @@ public class rParser {
             if (!out.isEmpty()) {
                 lastColor = lastColor(out.get(out.size() - 1));
             }
-            out.add(lastColor
-                    + combineSplit(0, words.toArray(new String[words.size()]), " ") + " ");
+            String[] stringArray = words.toArray(new String[words.size()]);
+            //if(stringArray.length != 0){
+                out.add(lastColor
+                        + combineSplit(0, stringArray, " ") + " ");
+            //}
         }
 
         //Convert to an array and return
@@ -103,14 +105,14 @@ public class rParser {
     //Function:	msgLength
     //Input:	String str: The string to find the length of
     //Output:	int: The length on the screen of a string
-    //Use:		Finds the length on the screen of a string. Ignores ChatColor.
+    //Use:		Finds the length on the screen of a string. Ignores MCChatColor.
     //=====================================================================
     public static int msgLength(String str) {
         int length = 0;
         //Loop through all the characters, skipping any color characters
         //and their following color codes
         for (int x = 0; x < str.length(); x++) {
-            if (str.charAt(x) == '?' /*|| str.charAt(x) == ChatColor.White.charAt(0)*/) {
+            if (str.charAt(x) == '?' /*|| str.charAt(x) == MCChatColor.White.charAt(0)*/) {
                 if (x + 1 != str.length()) {
                     if (colorChange(str.charAt(x + 1)) != null) {
                         x++;
@@ -188,73 +190,73 @@ public class rParser {
     //Use:		Finds a color giving a color code
     //=====================================================================
     public static String colorChange(char colour) {
-        ChatColor color;
+        MCChatColor color;
         switch (colour) {
             case '0':
-                color = ChatColor.BLACK;
+                color = MCChatColor.BLACK;
                 break;
             case '1':
-                color = ChatColor.DARK_BLUE;
+                color = MCChatColor.DARK_BLUE;
                 break;
             case '2':
-                color = ChatColor.DARK_GREEN;
+                color = MCChatColor.DARK_GREEN;
                 break;
             case '3':
-                color = ChatColor.DARK_AQUA;
+                color = MCChatColor.DARK_AQUA;
                 break;
             case '4':
-                color = ChatColor.DARK_RED;
+                color = MCChatColor.DARK_RED;
                 break;
             case '5':
-                color = ChatColor.DARK_PURPLE;
+                color = MCChatColor.DARK_PURPLE;
                 break;
             case '6':
-                color = ChatColor.GOLD;
+                color = MCChatColor.GOLD;
                 break;
             case '7':
-                color = ChatColor.GRAY;
+                color = MCChatColor.GRAY;
                 break;
             case '8':
-                color = ChatColor.DARK_GRAY;
+                color = MCChatColor.DARK_GRAY;
                 break;
             case '9':
-                color = ChatColor.BLUE;
+                color = MCChatColor.BLUE;
                 break;
             case 'a':
-                color = ChatColor.GREEN;
+                color = MCChatColor.GREEN;
                 break;
             case 'b':
-                color = ChatColor.AQUA;
+                color = MCChatColor.AQUA;
                 break;
             case 'c':
-                color = ChatColor.RED;
+                color = MCChatColor.RED;
                 break;
             case 'd':
-                color = ChatColor.LIGHT_PURPLE;
+                color = MCChatColor.LIGHT_PURPLE;
                 break;
             case 'e':
-                color = ChatColor.YELLOW;
+                color = MCChatColor.YELLOW;
                 break;
             case 'f':
-                color = ChatColor.WHITE;
+                color = MCChatColor.WHITE;
                 break;
             case 'A':
-                color = ChatColor.GREEN;
+                color = MCChatColor.GREEN;
                 break;
             case 'B':
-                color = ChatColor.AQUA;
+                color = MCChatColor.AQUA;
                 break;
             case 'C':
-                color = ChatColor.RED;
+                color = MCChatColor.RED;
                 break;
             case 'D':
-                color = ChatColor.LIGHT_PURPLE;
+                color = MCChatColor.LIGHT_PURPLE;
                 break;
             case 'E':
-                color = ChatColor.YELLOW;
+                color = MCChatColor.YELLOW;
                 break;
             case 'F':
-                color = ChatColor.WHITE;
+                color = MCChatColor.WHITE;
                 break;
             default:
                 return null;
diff --git a/src/main/java/com/laytonsmith/abstraction/Convertor.java b/src/main/java/com/laytonsmith/abstraction/Convertor.java
new file mode 100644
index 0000000..42878d4
--- /dev/null
+++ b/src/main/java/com/laytonsmith/abstraction/Convertor.java
@@ -0,0 +1,32 @@
+/*
+ * To change this template, choose Tools | Templates
+ * and open the template in the editor.
+ */
+package com.laytonsmith.abstraction;
+
+import com.laytonsmith.commandhelper.CommandHelperPlugin;
+
+/**
+ *
+ * @author layton
+ */
+public interface Convertor {
+
+    public MCLocation GetLocation(MCWorld w, double x, double y, double z, float yaw, float pitch);
+    public Class GetServerEventMixin();
+
+    public MCEnchantment[] GetEnchantmentValues();
+
+    public MCEnchantment GetEnchantmentByName(String name);
+
+    public MCServer GetServer();
+
+    public MCItemStack GetItemStack(int type, int qty);
+
+    public void Startup(CommandHelperPlugin chp);
+    
+    public int LookupItemId(String materialName);
+
+    public String LookupMaterialName(int id);
+    
+}
diff --git a/src/main/java/com/laytonsmith/abstraction/Implementation.java b/src/main/java/com/laytonsmith/abstraction/Implementation.java
new file mode 100644
index 0000000..1597a25
--- /dev/null
+++ b/src/main/java/com/laytonsmith/abstraction/Implementation.java
@@ -0,0 +1,30 @@
+/*
+ * To change this template, choose Tools | Templates
+ * and open the template in the editor.
+ */
+package com.laytonsmith.abstraction;
+
+/**
+ * This class dynamically detects the server version being run, using various
+ * checks as needed.
+ * @author layton
+ */
+public class Implementation {
+    
+    /**
+     * These are all the supported server types
+     */
+    public static enum Type{
+        BUKKIT,
+        //GLOWSTONE,
+        //SINGLE_PLAYER
+    }
+    
+    /**
+     * Returns the server type currently running
+     * @return 
+     */
+    public static Type GetServerType(){       
+        return Type.BUKKIT;
+    }
+}
diff --git a/src/main/java/com/laytonsmith/abstraction/MCAnimalTamer.java b/src/main/java/com/laytonsmith/abstraction/MCAnimalTamer.java
new file mode 100644
index 0000000..02065c0
--- /dev/null
+++ b/src/main/java/com/laytonsmith/abstraction/MCAnimalTamer.java
@@ -0,0 +1,13 @@
+/*
+ * To change this template, choose Tools | Templates
+ * and open the template in the editor.
+ */
+package com.laytonsmith.abstraction;
+
+/**
+ *
+ * @author layton
+ */
+public interface MCAnimalTamer {
+    
+}
diff --git a/src/main/java/com/laytonsmith/abstraction/MCChatColor.java b/src/main/java/com/laytonsmith/abstraction/MCChatColor.java
new file mode 100644
index 0000000..07b923d
--- /dev/null
+++ b/src/main/java/com/laytonsmith/abstraction/MCChatColor.java
@@ -0,0 +1,126 @@
+package com.laytonsmith.abstraction;
+
+import java.util.HashMap;
+import java.util.Map;
+
+/**
+ * All supported color values for chat
+ */
+public enum MCChatColor {
+
+    /**
+     * Represents black
+     */
+    BLACK(0x0),
+    /**
+     * Represents dark blue
+     */
+    DARK_BLUE(0x1),
+    /**
+     * Represents dark green
+     */
+    DARK_GREEN(0x2),
+    /**
+     * Represents dark blue (aqua)
+     */
+    DARK_AQUA(0x3),
+    /**
+     * Represents dark red
+     */
+    DARK_RED(0x4),
+    /**
+     * Represents dark purple
+     */
+    DARK_PURPLE(0x5),
+    /**
+     * Represents gold
+     */
+    GOLD(0x6),
+    /**
+     * Represents gray
+     */
+    GRAY(0x7),
+    /**
+     * Represents dark gray
+     */
+    DARK_GRAY(0x8),
+    /**
+     * Represents blue
+     */
+    BLUE(0x9),
+    /**
+     * Represents green
+     */
+    GREEN(0xA),
+    /**
+     * Represents aqua
+     */
+    AQUA(0xB),
+    /**
+     * Represents red
+     */
+    RED(0xC),
+    /**
+     * Represents light purple
+     */
+    LIGHT_PURPLE(0xD),
+    /**
+     * Represents yellow
+     */
+    YELLOW(0xE),
+    /**
+     * Represents white
+     */
+    WHITE(0xF);
+
+    private final int code;
+    private final static Map<Integer, MCChatColor> colors = new HashMap<Integer, MCChatColor>();
+
+    private MCChatColor(final int code) {
+        this.code = code;
+    }
+
+    /**
+     * Gets the data value associated with this color
+     *
+     * @return An integer value of this color code
+     */
+    public int getCode() {
+        return code;
+    }
+
+    @Override
+    public String toString() {
+        return String.format("\u00A7%x", code);
+    }
+
+    /**
+     * Gets the color represented by the specified color code
+     *
+     * @param code Code to check
+     * @return Associative {@link com.laytonsmith.abstraction.MCChatColor} with the given code, or null if it doesn't exist
+     */
+    public static MCChatColor getByCode(final int code) {
+        return colors.get(code);
+    }
+
+    /**
+     * Strips the given message of all color codes
+     *
+     * @param input String to strip of color
+     * @return A copy of the input string, without any coloring
+     */
+    public static String stripColor(final String input) {
+        if (input == null) {
+            return null;
+        }
+
+        return input.replaceAll("(?i)\u00A7[0-9A-F]", "");
+    }
+
+    static {
+        for (MCChatColor color : MCChatColor.values()) {
+            colors.put(color.getCode(), color);
+        }
+    }
+}
diff --git a/src/main/java/com/laytonsmith/abstraction/MCCommandException.java b/src/main/java/com/laytonsmith/abstraction/MCCommandException.java
new file mode 100644
index 0000000..37e0b2b
--- /dev/null
+++ b/src/main/java/com/laytonsmith/abstraction/MCCommandException.java
@@ -0,0 +1,26 @@
+/*
+ * To change this template, choose Tools | Templates
+ * and open the template in the editor.
+ */
+package com.laytonsmith.abstraction;
+
+/**
+ *
+ * @author layton
+ */
+public class MCCommandException extends RuntimeException {
+
+    /**
+     * Creates a new instance of <code>MCCommandException</code> without detail message.
+     */
+    public MCCommandException() {
+    }
+
+    /**
+     * Constructs an instance of <code>MCCommandException</code> with the specified detail message.
+     * @param msg the detail message.
+     */
+    public MCCommandException(String msg) {
+        super(msg);
+    }
+}
diff --git a/src/main/java/com/laytonsmith/abstraction/MCCommandSender.java b/src/main/java/com/laytonsmith/abstraction/MCCommandSender.java
new file mode 100644
index 0000000..9617977
--- /dev/null
+++ b/src/main/java/com/laytonsmith/abstraction/MCCommandSender.java
@@ -0,0 +1,23 @@
+/*
+ * To change this template, choose Tools | Templates
+ * and open the template in the editor.
+ */
+package com.laytonsmith.abstraction;
+
+/**
+ *
+ * @author layton
+ */
+public interface MCCommandSender {
+    public void sendMessage(String string);
+
+    public MCServer getServer();
+
+    public String getName();
+    
+    public boolean isOp();
+
+    public boolean instanceofPlayer();
+
+    public boolean instanceofMCConsoleCommandSender();
+}
diff --git a/src/main/java/com/laytonsmith/abstraction/MCConsoleCommandSender.java b/src/main/java/com/laytonsmith/abstraction/MCConsoleCommandSender.java
new file mode 100644
index 0000000..08dfe8d
--- /dev/null
+++ b/src/main/java/com/laytonsmith/abstraction/MCConsoleCommandSender.java
@@ -0,0 +1,13 @@
+/*
+ * To change this template, choose Tools | Templates
+ * and open the template in the editor.
+ */
+package com.laytonsmith.abstraction;
+
+/**
+ *
+ * @author layton
+ */
+public interface MCConsoleCommandSender extends MCCommandSender {
+    public MCServer getServer();
+}
diff --git a/src/main/java/com/laytonsmith/abstraction/MCEffect.java b/src/main/java/com/laytonsmith/abstraction/MCEffect.java
new file mode 100644
index 0000000..1ec9c21
--- /dev/null
+++ b/src/main/java/com/laytonsmith/abstraction/MCEffect.java
@@ -0,0 +1,36 @@
+/*
+ * To change this template, choose Tools | Templates
+ * and open the template in the editor.
+ */
+package com.laytonsmith.abstraction;
+
+/**
+ *
+ * @author layton
+ */
+public enum MCEffect {
+    BOW_FIRE(1002),
+    CLICK1(1001),
+    CLICK2(1000),
+    DOOR_TOGGLE(1003),
+    EXTINGUISH(1004),
+    RECORD_PLAY(1005),
+    GHAST_SHRIEK(1007),
+    GHAST_SHOOT(1008),
+    BLAZE_SHOOT(1009),
+    SMOKE(2000),
+    STEP_SOUND(2001),
+    POTION_BREAK(2002),
+    ENDER_SIGNAL(2003),
+    MOBSPAWNER_FLAMES(2004);
+
+    private final int id;
+
+    MCEffect(int id) {
+        this.id = id;
+    }
+
+    public int getId() {
+        return this.id;
+    }
+}
diff --git a/src/main/java/com/laytonsmith/abstraction/MCEnchantment.java b/src/main/java/com/laytonsmith/abstraction/MCEnchantment.java
new file mode 100644
index 0000000..9ebfa14
--- /dev/null
+++ b/src/main/java/com/laytonsmith/abstraction/MCEnchantment.java
@@ -0,0 +1,15 @@
+/*
+ * To change this template, choose Tools | Templates
+ * and open the template in the editor.
+ */
+package com.laytonsmith.abstraction;
+
+/**
+ *
+ * @author layton
+ */
+public interface MCEnchantment {
+    public boolean canEnchantItem(MCItemStack is);
+    public int getMaxLevel();
+    public String getName();
+}
diff --git a/src/main/java/com/laytonsmith/abstraction/MCEntity.java b/src/main/java/com/laytonsmith/abstraction/MCEntity.java
new file mode 100644
index 0000000..7e860ee
--- /dev/null
+++ b/src/main/java/com/laytonsmith/abstraction/MCEntity.java
@@ -0,0 +1,17 @@
+/*
+ * To change this template, choose Tools | Templates
+ * and open the template in the editor.
+ */
+package com.laytonsmith.abstraction;
+
+/**
+ *
+ * @author layton
+ */
+public interface MCEntity {
+    public int getEntityId();
+
+    public boolean isTameable();
+
+    public MCTameable getMCTameable();
+}
diff --git a/src/main/java/com/laytonsmith/abstraction/MCGameMode.java b/src/main/java/com/laytonsmith/abstraction/MCGameMode.java
new file mode 100644
index 0000000..de5140a
--- /dev/null
+++ b/src/main/java/com/laytonsmith/abstraction/MCGameMode.java
@@ -0,0 +1,13 @@
+/*
+ * To change this template, choose Tools | Templates
+ * and open the template in the editor.
+ */
+package com.laytonsmith.abstraction;
+
+/**
+ *
+ * @author layton
+ */
+public enum MCGameMode {
+    SURVIVAL, CREATIVE
+}
diff --git a/src/main/java/com/laytonsmith/abstraction/MCInventory.java b/src/main/java/com/laytonsmith/abstraction/MCInventory.java
new file mode 100644
index 0000000..1486ce8
--- /dev/null
+++ b/src/main/java/com/laytonsmith/abstraction/MCInventory.java
@@ -0,0 +1,23 @@
+/*
+ * To change this template, choose Tools | Templates
+ * and open the template in the editor.
+ */
+package com.laytonsmith.abstraction;
+
+/**
+ *
+ * @author layton
+ */
+public interface MCInventory {
+    public MCItemStack getItem(int slot);
+    public void setItem(int slot, MCItemStack stack);
+    public void setHelmet(MCItemStack stack);
+    public void setChestplate(MCItemStack stack);
+    public void setLeggings(MCItemStack stack);
+    public void setBoots(MCItemStack stack);
+    public MCItemStack getHelmet();
+    public MCItemStack getChestplate();
+    public MCItemStack getLeggings();
+    public MCItemStack getBoots();
+    
+}
diff --git a/src/main/java/com/laytonsmith/abstraction/MCItemStack.java b/src/main/java/com/laytonsmith/abstraction/MCItemStack.java
new file mode 100644
index 0000000..edbc686
--- /dev/null
+++ b/src/main/java/com/laytonsmith/abstraction/MCItemStack.java
@@ -0,0 +1,28 @@
+/*
+ * To change this template, choose Tools | Templates
+ * and open the template in the editor.
+ */
+package com.laytonsmith.abstraction;
+
+import com.laytonsmith.abstraction.blocks.MCMaterial;
+import java.util.Map;
+
+/**
+ *
+ * @author layton
+ */
+public interface MCItemStack {
+    public MCMaterialData getData();
+    public short getDurability();
+    public int getTypeId();
+    public void setDurability(short data);
+    public void addEnchantment(MCEnchantment e, int level);
+    public Map<MCEnchantment, Integer> getEnchantments();
+    public void removeEnchantment(MCEnchantment e);
+    public MCMaterial getType();
+    public void setTypeId(int type);
+    
+    public int getAmount();
+
+    public void setData(int data);
+}
diff --git a/src/main/java/com/laytonsmith/abstraction/MCLivingEntity.java b/src/main/java/com/laytonsmith/abstraction/MCLivingEntity.java
new file mode 100644
index 0000000..6bedc07
--- /dev/null
+++ b/src/main/java/com/laytonsmith/abstraction/MCLivingEntity.java
@@ -0,0 +1,19 @@
+/*
+ * To change this template, choose Tools | Templates
+ * and open the template in the editor.
+ */
+package com.laytonsmith.abstraction;
+
+/**
+ *
+ * @author layton
+ */
+public interface MCLivingEntity extends MCEntity {
+    public int getHealth();
+
+    public void setHealth(int i);
+
+    public int getMaxHealth();
+
+    public void damage(int i);
+}
diff --git a/src/main/java/com/laytonsmith/abstraction/MCLocation.java b/src/main/java/com/laytonsmith/abstraction/MCLocation.java
new file mode 100644
index 0000000..69db107
--- /dev/null
+++ b/src/main/java/com/laytonsmith/abstraction/MCLocation.java
@@ -0,0 +1,29 @@
+/*
+ * To change this template, choose Tools | Templates
+ * and open the template in the editor.
+ */
+package com.laytonsmith.abstraction;
+
+import com.laytonsmith.abstraction.blocks.MCBlock;
+
+/**
+ *
+ * @author layton
+ */
+public interface MCLocation {    
+    public double getX();
+    public double getY();
+    public double getZ();
+    public MCWorld getWorld();
+    public float getYaw();
+    public float getPitch();
+    public int getBlockX();
+    public int getBlockY();
+    public int getBlockZ();
+    public MCBlock getBlock();
+    
+    public void setPitch(float p);
+    public void setYaw(float y);
+    
+    public MCLocation clone();
+}
diff --git a/src/main/java/com/laytonsmith/abstraction/MCMaterialData.java b/src/main/java/com/laytonsmith/abstraction/MCMaterialData.java
new file mode 100644
index 0000000..89cf51a
--- /dev/null
+++ b/src/main/java/com/laytonsmith/abstraction/MCMaterialData.java
@@ -0,0 +1,13 @@
+/*
+ * To change this template, choose Tools | Templates
+ * and open the template in the editor.
+ */
+package com.laytonsmith.abstraction;
+
+/**
+ *
+ * @author layton
+ */
+public interface MCMaterialData {
+    public byte getData();
+}
diff --git a/src/main/java/com/laytonsmith/abstraction/MCOfflinePlayer.java b/src/main/java/com/laytonsmith/abstraction/MCOfflinePlayer.java
new file mode 100644
index 0000000..410a848
--- /dev/null
+++ b/src/main/java/com/laytonsmith/abstraction/MCOfflinePlayer.java
@@ -0,0 +1,63 @@
+/*
+ * To change this template, choose Tools | Templates
+ * and open the template in the editor.
+ */
+package com.laytonsmith.abstraction;
+
+/**
+ *
+ * @author layton
+ */
+public interface MCOfflinePlayer extends MCAnimalTamer{
+    /**
+     * Checks if this player is currently online
+     *
+     * @return true if they are online
+     */
+    public boolean isOnline();
+
+    /**
+     * Returns the name of this player
+     *
+     * @return Player name
+     */
+    public String getName();
+
+    /**
+     * Checks if this player is banned or not
+     *
+     * @return true if banned, otherwise false
+     */
+    public boolean isBanned();
+
+    /**
+     * Bans or unbans this player
+     *
+     * @param banned true if banned
+     */
+    public void setBanned(boolean banned);
+
+    /**
+     * Checks if this player is whitelisted or not
+     *
+     * @return true if whitelisted
+     */
+    public boolean isWhitelisted();
+
+    /**
+     * Sets if this player is whitelisted or not
+     *
+     * @param value true if whitelisted
+     */
+    public void setWhitelisted(boolean value);
+    
+    /**
+     * Gets a {@link Player} object that this represents, if there is one
+     * <p>
+     * If the player is online, this will return that player. Otherwise,
+     * it will return null.
+     * 
+     * @return Online player
+     */
+    public MCPlayer getPlayer();
+}
diff --git a/src/main/java/com/laytonsmith/abstraction/MCPlayer.java b/src/main/java/com/laytonsmith/abstraction/MCPlayer.java
new file mode 100644
index 0000000..9c77ff2
--- /dev/null
+++ b/src/main/java/com/laytonsmith/abstraction/MCPlayer.java
@@ -0,0 +1,69 @@
+/*
+ * To change this template, choose Tools | Templates
+ * and open the template in the editor.
+ */
+package com.laytonsmith.abstraction;
+
+import com.laytonsmith.abstraction.blocks.MCBlock;
+import java.net.InetSocketAddress;
+import java.util.HashSet;
+
+/**
+ *
+ * @author layton
+ */
+public interface MCPlayer extends MCCommandSender, MCOfflinePlayer{
+    public String getDisplayName();
+    public void chat(String chat);
+    public MCItemStack getItemInHand();
+    public MCInventory getInventory();
+    public MCWorld getWorld();
+
+    public void setTempOp(Boolean value) throws Exception;
+
+    public MCLocation getLocation();
+    
+    public MCBlock getTargetBlock(HashSet<Byte> b, int i);
+    public boolean teleport(MCLocation l);
+
+    public void setHealth(int i);
+
+    public void setDisplayName(String name);
+
+    public void kickPlayer(String message);
+    public InetSocketAddress getAddress();
+    
+    public boolean isSneaking();
+    
+    public int getHealth();
+    
+    public void setExp(float i);
+    
+    public float getExp();
+    
+    public MCGameMode getGameMode();
+    public void setGameMode(MCGameMode mode);
+    
+    public void setItemInHand(MCItemStack is);
+
+    
+    public int getLevel();
+    public void setLevel(int xp);
+    public void giveExp(int xp);
+    
+    public int getTotalExperience();
+    public void setTotalExperience(int total);
+    
+    
+    public int getFoodLevel();
+    public void setFoodLevel(int f);
+
+    public MCLocation getCompassTarget();
+
+    public void setCompassTarget(MCLocation l);
+
+    public int getRemainingFireTicks();
+    public void setRemainingFireTicks(int i);  
+    
+    public void addEffect(int potionID, int strength, int seconds);
+}
diff --git a/src/main/java/com/laytonsmith/abstraction/MCPlugin.java b/src/main/java/com/laytonsmith/abstraction/MCPlugin.java
new file mode 100644
index 0000000..cfad7c3
--- /dev/null
+++ b/src/main/java/com/laytonsmith/abstraction/MCPlugin.java
@@ -0,0 +1,14 @@
+/*
+ * To change this template, choose Tools | Templates
+ * and open the template in the editor.
+ */
+package com.laytonsmith.abstraction;
+
+/**
+ *
+ * @author layton
+ */
+public interface MCPlugin {
+    public boolean isEnabled();
+    public boolean isInstanceOf(Class c);
+}
diff --git a/src/main/java/com/laytonsmith/abstraction/MCPluginManager.java b/src/main/java/com/laytonsmith/abstraction/MCPluginManager.java
new file mode 100644
index 0000000..b3167eb
--- /dev/null
+++ b/src/main/java/com/laytonsmith/abstraction/MCPluginManager.java
@@ -0,0 +1,13 @@
+/*
+ * To change this template, choose Tools | Templates
+ * and open the template in the editor.
+ */
+package com.laytonsmith.abstraction;
+
+/**
+ *
+ * @author layton
+ */
+public interface MCPluginManager {
+    public MCPlugin getPlugin(String name);
+}
diff --git a/src/main/java/com/laytonsmith/abstraction/MCServer.java b/src/main/java/com/laytonsmith/abstraction/MCServer.java
new file mode 100644
index 0000000..3aca3bd
--- /dev/null
+++ b/src/main/java/com/laytonsmith/abstraction/MCServer.java
@@ -0,0 +1,25 @@
+/*
+ * To change this template, choose Tools | Templates
+ * and open the template in the editor.
+ */
+package com.laytonsmith.abstraction;
+
+import java.util.List;
+
+
+/**
+ *
+ * @author layton
+ */
+public interface MCServer {
+    public String getName();
+    public MCPlayer[] getOnlinePlayers();
+    public boolean dispatchCommand(MCCommandSender cs, String string) throws MCCommandException;
+    public MCPluginManager getPluginManager();
+    public MCPlayer getPlayer(String name);
+    public MCWorld getWorld(String name);
+    public List<MCWorld> getWorlds();
+    public void broadcastMessage(String message);
+
+    public MCOfflinePlayer getOfflinePlayer(String player);
+}
diff --git a/src/main/java/com/laytonsmith/abstraction/MCTameable.java b/src/main/java/com/laytonsmith/abstraction/MCTameable.java
new file mode 100644
index 0000000..dca8429
--- /dev/null
+++ b/src/main/java/com/laytonsmith/abstraction/MCTameable.java
@@ -0,0 +1,19 @@
+/*
+ * To change this template, choose Tools | Templates
+ * and open the template in the editor.
+ */
+package com.laytonsmith.abstraction;
+
+/**
+ *
+ * @author layton
+ */
+public interface MCTameable extends MCEntity{
+    public boolean isTamed();
+
+    public void setTamed(boolean bln);
+
+    public MCAnimalTamer getOwner();
+
+    public void setOwner(MCAnimalTamer at);    
+}
diff --git a/src/main/java/com/laytonsmith/abstraction/MCWorld.java b/src/main/java/com/laytonsmith/abstraction/MCWorld.java
new file mode 100644
index 0000000..0ad6412
--- /dev/null
+++ b/src/main/java/com/laytonsmith/abstraction/MCWorld.java
@@ -0,0 +1,44 @@
+/*
+ * To change this template, choose Tools | Templates
+ * and open the template in the editor.
+ */
+package com.laytonsmith.abstraction;
+
+import com.laytonsmith.abstraction.blocks.MCBlock;
+import com.laytonsmith.core.constructs.Construct;
+import java.io.File;
+import java.util.List;
+
+/**
+ *
+ * @author layton
+ */
+public interface MCWorld {
+    public List<MCLivingEntity> getLivingEntities();
+    public String getName();
+    public MCBlock getBlockAt(int x, int y, int z);
+
+    public MCEntity spawn(MCLocation l, Class mobType);
+
+    public void playEffect(MCLocation l, MCEffect mCEffect, int e, int data);
+
+    public void dropItemNaturally(MCLocation l, MCItemStack is);
+
+    public void dropItem(MCLocation l, MCItemStack is);
+
+    public void strikeLightning(MCLocation GetLocation);
+
+    public void strikeLightningEffect(MCLocation GetLocation);
+
+    public void setStorm(boolean b);
+
+    public MCLocation getSpawnLocation();
+
+    public void refreshChunk(int x, int z);
+
+    public void setTime(long time);
+    
+    public long getTime();
+    
+    public Construct spawnMob(String name, String subClass, int qty, MCLocation location, int line_num, File file);
+}
diff --git a/src/main/java/com/laytonsmith/abstraction/StaticLayer.java b/src/main/java/com/laytonsmith/abstraction/StaticLayer.java
new file mode 100644
index 0000000..da91284
--- /dev/null
+++ b/src/main/java/com/laytonsmith/abstraction/StaticLayer.java
@@ -0,0 +1,106 @@
+/*
+ * To change this template, choose Tools | Templates
+ * and open the template in the editor.
+ */
+package com.laytonsmith.abstraction;
+
+import com.laytonsmith.PureUtilities.ClassDiscovery;
+import com.laytonsmith.commandhelper.CommandHelperPlugin;
+
+
+/**
+ * Unfortunately some methods just can't be overridden.
+ * @author layton
+ */
+public class StaticLayer {
+    
+    private static Convertor convertor = null;
+    static{
+        InitConvertor();
+    }
+    
+    private static void InitConvertor(){
+        Class[] classes = ClassDiscovery.GetClassesWithAnnotation(convert.class);
+        for(Class c : classes){
+            Class[] implemented = c.getInterfaces();
+            boolean doesImplement = false;
+            for(Class inter : implemented){
+                if(inter.equals(Convertor.class)){                    
+                    doesImplement = true;         
+                    break;
+                }
+            }
+            if(!doesImplement){
+                System.out.println("The Convertor " + c.getSimpleName() + " doesn't implement Convertor!");
+            }
+            convert convert = (convert)c.getAnnotation(convert.class);
+            if(convert.type() == Implementation.GetServerType()){
+                //This is what we're looking for, instatiate it.
+                try{
+                    if(convertor != null){
+                        //Uh... There are more than one implementations for this server type
+                        System.out.println("More than one Convertor for this server type was detected!");
+                    }
+                    convertor = (Convertor) c.newInstance();                    
+                    //At this point we are all set
+                } catch(Exception e){
+                    System.out.println("Tried to instantiate the Convertor, but couldn't!");
+                }
+            }
+        }
+        if(convertor == null){
+            System.out.println("Could not find a suitable convertor! You will experience serious issues with this plugin.");
+        }
+    }
+
+    public static MCLocation GetLocation(MCWorld w, double x, double y, double z, float yaw, float pitch) {
+        return convertor.GetLocation(w, x, y, z, yaw, pitch);
+    }
+    
+    public static Class GetServerEventMixin() {
+        return convertor.GetServerEventMixin();
+    }
+    
+    public static MCLocation GetLocation(MCWorld w, double x, double y, double z){
+        return GetLocation(w, x, y, z, 0, 0);
+    }
+
+    public static MCItemStack GetItemStack(int type, int qty) {
+        return convertor.GetItemStack(type, qty);
+    }
+    
+    public static MCServer GetServer(){
+        return convertor.GetServer();
+    }
+    
+    public static MCEnchantment GetEnchantmentByName(String name){
+        return convertor.GetEnchantmentByName(name);
+    }
+    
+    public static MCEnchantment[] GetEnchantmentValues(){
+        return convertor.GetEnchantmentValues();
+    }
+
+    public static void Startup(CommandHelperPlugin chp) {
+        convertor.Startup(chp);
+    }
+    
+    /**
+     * Returns the data value of the specified material name, or -1 if none was found.
+     * @param materialName
+     * @return 
+     */
+    public static int LookupItemId(String materialName){
+        return convertor.LookupItemId(materialName);
+    }
+    
+    /**
+     * Returns the name of the material, given the material's ID.
+     * @param id
+     * @return 
+     */
+    public static String LookupMaterialName(int id){
+        return convertor.LookupMaterialName(id);
+    }
+    
+}
diff --git a/src/main/java/com/laytonsmith/abstraction/blocks/MCBlock.java b/src/main/java/com/laytonsmith/abstraction/blocks/MCBlock.java
new file mode 100644
index 0000000..af405cf
--- /dev/null
+++ b/src/main/java/com/laytonsmith/abstraction/blocks/MCBlock.java
@@ -0,0 +1,37 @@
+/*
+ * To change this template, choose Tools | Templates
+ * and open the template in the editor.
+ */
+package com.laytonsmith.abstraction.blocks;
+
+import com.laytonsmith.abstraction.MCWorld;
+
+/**
+ *
+ * @author layton
+ */
+public interface MCBlock {
+    public int getTypeId();
+    public byte getData();
+
+    public void setTypeId(int idata);
+
+    public void setData(byte imeta);
+    
+    public MCBlockState getState();
+
+    public MCMaterial getType();
+
+    public MCWorld getWorld();
+    
+    public int getX();
+
+    public int getY();
+
+    public int getZ();
+
+    public MCSign getSign();
+
+    public boolean isSign();
+    public boolean isNull();
+}
diff --git a/src/main/java/com/laytonsmith/abstraction/blocks/MCBlockState.java b/src/main/java/com/laytonsmith/abstraction/blocks/MCBlockState.java
new file mode 100644
index 0000000..e664ea2
--- /dev/null
+++ b/src/main/java/com/laytonsmith/abstraction/blocks/MCBlockState.java
@@ -0,0 +1,13 @@
+/*
+ * To change this template, choose Tools | Templates
+ * and open the template in the editor.
+ */
+package com.laytonsmith.abstraction.blocks;
+
+/**
+ *
+ * @author layton
+ */
+public interface MCBlockState {
+    
+}
diff --git a/src/main/java/com/laytonsmith/abstraction/blocks/MCMaterial.java b/src/main/java/com/laytonsmith/abstraction/blocks/MCMaterial.java
new file mode 100644
index 0000000..d6ee9b6
--- /dev/null
+++ b/src/main/java/com/laytonsmith/abstraction/blocks/MCMaterial.java
@@ -0,0 +1,15 @@
+/*
+ * To change this template, choose Tools | Templates
+ * and open the template in the editor.
+ */
+package com.laytonsmith.abstraction.blocks;
+
+/**
+ *
+ * @author layton
+ */
+public interface MCMaterial {
+    short getMaxDurability();
+
+    public int getType();
+}
diff --git a/src/main/java/com/laytonsmith/abstraction/blocks/MCSign.java b/src/main/java/com/laytonsmith/abstraction/blocks/MCSign.java
new file mode 100644
index 0000000..417ca18
--- /dev/null
+++ b/src/main/java/com/laytonsmith/abstraction/blocks/MCSign.java
@@ -0,0 +1,17 @@
+/*
+ * To change this template, choose Tools | Templates
+ * and open the template in the editor.
+ */
+package com.laytonsmith.abstraction.blocks;
+
+/**
+ *
+ * @author layton
+ */
+public interface MCSign extends MCBlockState{       
+
+    public void setLine(int i, String line1);
+
+    public String getLine(int i);
+    
+}
diff --git a/src/main/java/com/laytonsmith/abstraction/bukkit/BukkitConvertor.java b/src/main/java/com/laytonsmith/abstraction/bukkit/BukkitConvertor.java
new file mode 100644
index 0000000..d23a685
--- /dev/null
+++ b/src/main/java/com/laytonsmith/abstraction/bukkit/BukkitConvertor.java
@@ -0,0 +1,182 @@
+/*
+ * To change this template, choose Tools | Templates
+ * and open the template in the editor.
+ */
+package com.laytonsmith.abstraction.bukkit;
+
+import com.laytonsmith.abstraction.bukkit.events.BukkitAbstractEventMixin;
+import com.laytonsmith.abstraction.bukkit.events.drivers.*;
+import com.laytonsmith.abstraction.*;
+import com.laytonsmith.commandhelper.CommandHelperPlugin;
+import com.laytonsmith.core.events.Driver;
+import com.laytonsmith.core.events.EventList;
+import com.laytonsmith.core.exceptions.ConfigRuntimeException;
+import java.util.Iterator;
+import java.util.SortedSet;
+import org.bukkit.Location;
+import org.bukkit.Material;
+import org.bukkit.World;
+import org.bukkit.enchantments.Enchantment;
+import org.bukkit.event.Event;
+import org.bukkit.event.Event.Category;
+import org.bukkit.event.Event.Priority;
+import org.bukkit.event.Listener;
+import org.bukkit.inventory.ItemStack;
+import org.bukkit.material.MaterialData;
+
+/**
+ *
+ * @author layton
+ */
+@convert(type=Implementation.Type.BUKKIT)
+public class BukkitConvertor implements Convertor {
+
+    public MCLocation GetLocation(MCWorld w, double x, double y, double z, float yaw, float pitch) {
+        World w2 = null;
+        if(w != null){
+            w2 = ((BukkitMCWorld)w).__World();
+        }
+        return new BukkitMCLocation(new Location(w2, x, y, z, yaw, pitch));
+    }
+
+    public Class GetServerEventMixin() {
+        return BukkitAbstractEventMixin.class;
+    }
+
+    public MCEnchantment[] GetEnchantmentValues() {
+        MCEnchantment[] ea = new MCEnchantment[Enchantment.values().length];
+        Enchantment[] oea = Enchantment.values();
+        for (int i = 0; i < ea.length; i++) {
+            ea[i] = new BukkitMCEnchantment(oea[i]);
+        }
+        return ea;
+
+    }
+
+    public MCEnchantment GetEnchantmentByName(String name) {
+        return new BukkitMCEnchantment(Enchantment.getByName(name));
+    }
+
+    public MCServer GetServer() {
+        return BukkitMCServer.Get();
+    }
+
+    public MCItemStack GetItemStack(int type, int qty) {
+        return new BukkitMCItemStack(new ItemStack(type, qty));
+    }
+    
+    public static final BukkitBlockListener BlockListener = new BukkitBlockListener();
+    public static final BukkitEntityListener EntityListener = new BukkitEntityListener();
+    public static final BukkitInventoryListener InventoryListener = new BukkitInventoryListener();
+    public static final BukkitPlayerListener PlayerListener = new BukkitPlayerListener();
+    public static final BukkitServerListener ServerListener = new BukkitServerListener();
+    public static final BukkitVehicleListener VehicleListener = new BukkitVehicleListener();
+    public static final BukkitWeatherListener WeatherListener = new BukkitWeatherListener();
+    public static final BukkitWorldListener WorldListener = new BukkitWorldListener();
+
+    public void Startup(CommandHelperPlugin chp) {
+        for(Driver type : Driver.values()){            
+            SortedSet<com.laytonsmith.core.events.Event> set = EventList.GetEvents(type);
+            if(set == null){
+                continue;
+            }
+            Iterator<com.laytonsmith.core.events.Event> i = set.iterator();
+            while(i.hasNext()){
+                com.laytonsmith.core.events.Event e = i.next();
+                Listener l = null;
+                Category c = BukkitConvertor.GetBukkitType(e.driver()).getCategory();
+                switch(c){
+                    case BLOCK:
+                        l = BlockListener;
+                        break;
+                    case ENTITY:
+                    case LIVING_ENTITY:
+                        l = EntityListener;
+                        break;
+                    case INVENTORY:
+                        l = InventoryListener;
+                        break;
+                    case PLAYER:
+                        l = PlayerListener;
+                        break;
+                    case SERVER:
+                        l = ServerListener;
+                        break;
+                    case VEHICLE:
+                        l = VehicleListener;
+                        break;
+                    case WEATHER:
+                        l = WeatherListener;
+                        break;
+                    case WORLD:
+                        l = WorldListener;
+                        break;
+                }
+                if(l == null){                    
+                    throw new ConfigRuntimeException("Unable to register listener for event, is a category"
+                            + " missing?", 
+                            0, null);
+                }
+                chp.registerEvent(BukkitConvertor.GetBukkitType(e.driver()), l, Priority.Lowest);
+            }
+        }
+    }
+    
+    public static Event.Type GetBukkitType(Driver tt){
+        Event.Type t = null;
+        switch(tt){
+            case PLAYER_INTERACT:
+                t = Event.Type.PLAYER_INTERACT;
+                break;
+            case PLAYER_JOIN:
+                t = Event.Type.PLAYER_JOIN;
+                break;
+            case PLAYER_SPAWN:
+                t = Event.Type.PLAYER_RESPAWN;
+                break;
+            case PLAYER_DEATH:
+                t = Event.Type.ENTITY_DEATH;
+                break;
+        }
+        if(t == null){
+            throw new ConfigRuntimeException("Incompatible event! Did you forget to update the"
+                    + " GetBukkitType function after adding a new event?" + t, 0, null);
+        }
+        return t;
+    }
+    
+    public static Driver GetGenericType(Event.Type tt){
+        Driver t = null;
+        switch(tt){
+            case PLAYER_INTERACT:
+                t = Driver.PLAYER_INTERACT;
+                break;
+            case PLAYER_JOIN:
+                t = Driver.PLAYER_JOIN;
+                break;
+            case PLAYER_RESPAWN:
+                t = Driver.PLAYER_SPAWN;
+                break;
+            case ENTITY_DEATH:
+                t = Driver.PLAYER_DEATH;
+                break;
+        }
+        if(t == null){
+            throw new ConfigRuntimeException("Incompatible event! Did you forget to update the"
+                    + " GetGenericType function after adding a new event?" + t, 0, null);
+        }
+        return t;
+    }
+
+    public int LookupItemId(String materialName) {
+        if(Material.matchMaterial(materialName) != null){
+            return new MaterialData(Material.matchMaterial(materialName)).getItemTypeId();
+        } else {
+            return -1;
+        }
+    }
+
+    public String LookupMaterialName(int id) {
+        return Material.getMaterial(id).toString();
+    }
+}
diff --git a/src/main/java/com/laytonsmith/abstraction/bukkit/BukkitMCAnimalTamer.java b/src/main/java/com/laytonsmith/abstraction/bukkit/BukkitMCAnimalTamer.java
new file mode 100644
index 0000000..36f9a5a
--- /dev/null
+++ b/src/main/java/com/laytonsmith/abstraction/bukkit/BukkitMCAnimalTamer.java
@@ -0,0 +1,19 @@
+/*
+ * To change this template, choose Tools | Templates
+ * and open the template in the editor.
+ */
+package com.laytonsmith.abstraction.bukkit;
+
+import com.laytonsmith.abstraction.MCAnimalTamer;
+import org.bukkit.entity.AnimalTamer;
+
+/**
+ *
+ * @author layton
+ */
+public class BukkitMCAnimalTamer implements MCAnimalTamer{
+    AnimalTamer at;
+    public BukkitMCAnimalTamer(AnimalTamer at){
+        this.at = at;
+    }
+}
diff --git a/src/main/java/com/laytonsmith/abstraction/bukkit/BukkitMCCommandSender.java b/src/main/java/com/laytonsmith/abstraction/bukkit/BukkitMCCommandSender.java
new file mode 100644
index 0000000..a9dd549
--- /dev/null
+++ b/src/main/java/com/laytonsmith/abstraction/bukkit/BukkitMCCommandSender.java
@@ -0,0 +1,54 @@
+/*
+ * To change this template, choose Tools | Templates
+ * and open the template in the editor.
+ */
+package com.laytonsmith.abstraction.bukkit;
+
+import com.laytonsmith.abstraction.MCCommandSender;
+import com.laytonsmith.abstraction.MCServer;
+import org.bukkit.command.CommandSender;
+import org.bukkit.command.ConsoleCommandSender;
+import org.bukkit.entity.Player;
+
+/**
+ *
+ * @author layton
+ */
+public class BukkitMCCommandSender implements MCCommandSender{
+
+    CommandSender c;
+    public BukkitMCCommandSender(CommandSender c){
+        this.c = c;
+    }
+    
+    public void sendMessage(String string) {
+        c.sendMessage(string);
+    }
+
+    
+    public MCServer getServer() {
+        return new BukkitMCServer();
+    }
+
+    
+    public String getName() {
+        return c.getName();
+    }
+
+    public boolean isOp() {
+        return c.isOp();
+    }
+
+    public CommandSender _CommandSender() {
+        return c;
+    }
+
+    public boolean instanceofPlayer() {
+        return c instanceof Player;
+    }
+
+    public boolean instanceofMCConsoleCommandSender() {
+        return c instanceof ConsoleCommandSender;
+    }
+    
+}
diff --git a/src/main/java/com/laytonsmith/abstraction/bukkit/BukkitMCConsoleCommandSender.java b/src/main/java/com/laytonsmith/abstraction/bukkit/BukkitMCConsoleCommandSender.java
new file mode 100644
index 0000000..b2d4433
--- /dev/null
+++ b/src/main/java/com/laytonsmith/abstraction/bukkit/BukkitMCConsoleCommandSender.java
@@ -0,0 +1,22 @@
+/*
+ * To change this template, choose Tools | Templates
+ * and open the template in the editor.
+ */
+package com.laytonsmith.abstraction.bukkit;
+
+import com.laytonsmith.abstraction.MCConsoleCommandSender;
+import org.bukkit.command.ConsoleCommandSender;
+
+/**
+ *
+ * @author layton
+ */
+public class BukkitMCConsoleCommandSender extends BukkitMCCommandSender implements MCConsoleCommandSender{
+
+    ConsoleCommandSender ccs;
+    public BukkitMCConsoleCommandSender(ConsoleCommandSender ccs){
+        super(ccs);
+        this.ccs = ccs;
+    }
+    
+}
diff --git a/src/main/java/com/laytonsmith/abstraction/bukkit/BukkitMCEnchantment.java b/src/main/java/com/laytonsmith/abstraction/bukkit/BukkitMCEnchantment.java
new file mode 100644
index 0000000..00d8cc4
--- /dev/null
+++ b/src/main/java/com/laytonsmith/abstraction/bukkit/BukkitMCEnchantment.java
@@ -0,0 +1,36 @@
+/*
+ * To change this template, choose Tools | Templates
+ * and open the template in the editor.
+ */
+package com.laytonsmith.abstraction.bukkit;
+
+import com.laytonsmith.abstraction.MCEnchantment;
+import com.laytonsmith.abstraction.MCItemStack;
+import org.bukkit.enchantments.Enchantment;
+
+/**
+ *
+ * @author layton
+ */
+public class BukkitMCEnchantment implements MCEnchantment{
+    Enchantment e;
+    public BukkitMCEnchantment(Enchantment e){
+        this.e = e;
+    }
+
+    Enchantment __Enchantment() {
+        return e;
+    }
+
+    public boolean canEnchantItem(MCItemStack is) {
+        return e.canEnchantItem(((BukkitMCItemStack)is).is);
+    }
+
+    public int getMaxLevel() {
+        return e.getMaxLevel();
+    }
+
+    public String getName() {
+        return e.getName();
+    }
+}
diff --git a/src/main/java/com/laytonsmith/abstraction/bukkit/BukkitMCEntity.java b/src/main/java/com/laytonsmith/abstraction/bukkit/BukkitMCEntity.java
new file mode 100644
index 0000000..1785429
--- /dev/null
+++ b/src/main/java/com/laytonsmith/abstraction/bukkit/BukkitMCEntity.java
@@ -0,0 +1,35 @@
+/*
+ * To change this template, choose Tools | Templates
+ * and open the template in the editor.
+ */
+package com.laytonsmith.abstraction.bukkit;
+
+import com.laytonsmith.abstraction.MCEntity;
+import com.laytonsmith.abstraction.MCTameable;
+import org.bukkit.entity.Entity;
+import org.bukkit.entity.Tameable;
+
+/**
+ *
+ * @author layton
+ */
+class BukkitMCEntity implements MCEntity {
+
+    Entity e;
+    public BukkitMCEntity(Entity e) {
+        this.e = e;
+    }
+    
+    public int getEntityId(){
+        return e.getEntityId();
+    }
+
+    public boolean isTameable() {
+        return e instanceof Tameable;
+    }
+
+    public MCTameable getMCTameable() {
+        return new BukkitMCTameable((Tameable)e);
+    }
+    
+}
diff --git a/src/main/java/com/laytonsmith/abstraction/bukkit/BukkitMCInventory.java b/src/main/java/com/laytonsmith/abstraction/bukkit/BukkitMCInventory.java
new file mode 100644
index 0000000..d27bee0
--- /dev/null
+++ b/src/main/java/com/laytonsmith/abstraction/bukkit/BukkitMCInventory.java
@@ -0,0 +1,62 @@
+/*
+ * To change this template, choose Tools | Templates
+ * and open the template in the editor.
+ */
+package com.laytonsmith.abstraction.bukkit;
+
+import com.laytonsmith.abstraction.MCInventory;
+import com.laytonsmith.abstraction.MCItemStack;
+import org.bukkit.inventory.PlayerInventory;
+
+/**
+ *
+ * @author layton
+ */
+public class BukkitMCInventory implements MCInventory {
+
+    PlayerInventory i;
+    public BukkitMCInventory(PlayerInventory inventory) {
+        this.i = inventory;
+    }
+
+    public MCItemStack getItem(int slot) {
+        return new BukkitMCItemStack(i.getItem(slot));
+    }
+
+    public void setItem(int slot, MCItemStack stack) {
+        this.i.setItem(slot, stack==null?null:((BukkitMCItemStack)stack).is);
+    }
+
+    public void setHelmet(MCItemStack stack) {
+        this.i.setHelmet(((BukkitMCItemStack)stack).is);
+    }
+
+    public void setChestplate(MCItemStack stack) {
+        this.i.setChestplate(((BukkitMCItemStack)stack).is);
+    }
+
+    public void setLeggings(MCItemStack stack) {
+        this.i.setLeggings(((BukkitMCItemStack)stack).is);
+    }
+
+    public void setBoots(MCItemStack stack) {
+        this.i.setBoots(((BukkitMCItemStack)stack).is);
+    }
+
+    public MCItemStack getHelmet() {
+        return new BukkitMCItemStack(this.i.getHelmet());
+    }
+
+    public MCItemStack getChestplate() {
+        return new BukkitMCItemStack(this.i.getChestplate());
+    }
+
+    public MCItemStack getLeggings() {
+        return new BukkitMCItemStack(this.i.getLeggings());
+    }
+
+    public MCItemStack getBoots() {
+        return new BukkitMCItemStack(this.i.getBoots());
+    }
+    
+}
diff --git a/src/main/java/com/laytonsmith/abstraction/bukkit/BukkitMCItemStack.java b/src/main/java/com/laytonsmith/abstraction/bukkit/BukkitMCItemStack.java
new file mode 100644
index 0000000..fd74614
--- /dev/null
+++ b/src/main/java/com/laytonsmith/abstraction/bukkit/BukkitMCItemStack.java
@@ -0,0 +1,90 @@
+/*
+ * To change this template, choose Tools | Templates
+ * and open the template in the editor.
+ */
+package com.laytonsmith.abstraction.bukkit;
+
+import com.laytonsmith.abstraction.MCEnchantment;
+import com.laytonsmith.abstraction.MCItemStack;
+import com.laytonsmith.abstraction.MCMaterialData;
+import com.laytonsmith.abstraction.blocks.MCMaterial;
+import java.util.HashMap;
+import java.util.Map;
+import org.bukkit.enchantments.Enchantment;
+import org.bukkit.inventory.ItemStack;
+import org.bukkit.material.MaterialData;
+
+/**
+ *
+ * @author layton
+ */
+public class BukkitMCItemStack implements MCItemStack{
+    ItemStack is;
+    public BukkitMCItemStack(ItemStack is){
+        this.is = is;
+    }
+    
+    public MCMaterialData getData(){
+        if(is == null || is.getData() == null){
+            return null;
+        }
+        return new BukkitMCMaterialData(is.getData());
+    }
+    
+    public short getDurability(){
+        if(is == null){
+            return 0;
+        }
+        return is.getDurability();
+    }
+    
+    public int getTypeId(){
+        if(is == null){
+            return 0;
+        }
+        return is.getTypeId();
+    }
+
+    public void setDurability(short data) {
+        is.setDurability(data);
+    }
+
+    public void addEnchantment(MCEnchantment e, int level) {
+        is.addEnchantment(((BukkitMCEnchantment)e).__Enchantment(), level);
+    }
+    
+    public Map<MCEnchantment, Integer> getEnchantments(){
+        if(is == null || is.getEnchantments() == null){
+            return null;
+        }
+        Map<MCEnchantment, Integer> map = new HashMap<MCEnchantment, Integer>();
+        for(Map.Entry<Enchantment, Integer> entry : is.getEnchantments().entrySet()){
+            map.put(new BukkitMCEnchantment(entry.getKey()), entry.getValue());
+        }
+        return map;
+    }
+    
+    public void removeEnchantment(MCEnchantment e){
+        is.removeEnchantment(((BukkitMCEnchantment)e).__Enchantment());
+    }
+
+    public MCMaterial getType() {
+        return new BukkitMCMaterial(is.getType());
+    }
+
+    public void setTypeId(int type) {
+        is.setTypeId(type);
+    }
+
+    public int getAmount() {
+        return is.getAmount();
+    }
+
+    public ItemStack __ItemStack() {
+        return is;
+    }
+
+    public void setData(int data) {
+        is.setData(new MaterialData(is.getTypeId(), (byte)data));
+    }
+}
diff --git a/src/main/java/com/laytonsmith/abstraction/bukkit/BukkitMCLivingEntity.java b/src/main/java/com/laytonsmith/abstraction/bukkit/BukkitMCLivingEntity.java
new file mode 100644
index 0000000..0b95b0e
--- /dev/null
+++ b/src/main/java/com/laytonsmith/abstraction/bukkit/BukkitMCLivingEntity.java
@@ -0,0 +1,37 @@
+/*
+ * To change this template, choose Tools | Templates
+ * and open the template in the editor.
+ */
+package com.laytonsmith.abstraction.bukkit;
+
+import com.laytonsmith.abstraction.MCLivingEntity;
+import org.bukkit.entity.LivingEntity;
+
+/**
+ *
+ * @author layton
+ */
+public class BukkitMCLivingEntity extends BukkitMCEntity implements MCLivingEntity{
+    
+    LivingEntity le;
+    public BukkitMCLivingEntity(LivingEntity le){
+        super(le);
+        this.le = le;
+    }
+    public int getHealth() {
+        return le.getHealth();
+    }
+
+    public void setHealth(int i) {
+        le.setHealth(i);
+    }
+
+    public int getMaxHealth() {
+        return le.getMaxHealth();
+    }
+
+    public void damage(int i) {
+        le.damage(i);
+    }
+    
+}
diff --git a/src/main/java/com/laytonsmith/abstraction/bukkit/BukkitMCLocation.java b/src/main/java/com/laytonsmith/abstraction/bukkit/BukkitMCLocation.java
new file mode 100644
index 0000000..f958a12
--- /dev/null
+++ b/src/main/java/com/laytonsmith/abstraction/bukkit/BukkitMCLocation.java
@@ -0,0 +1,85 @@
+/*
+ * To change this template, choose Tools | Templates
+ * and open the template in the editor.
+ */
+package com.laytonsmith.abstraction.bukkit;
+
+import com.laytonsmith.abstraction.MCLocation;
+import com.laytonsmith.abstraction.MCWorld;
+import com.laytonsmith.abstraction.blocks.MCBlock;
+import com.laytonsmith.abstraction.bukkit.blocks.BukkitMCBlock;
+import org.bukkit.Location;
+
+/**
+ *
+ * @author layton
+ */
+public class BukkitMCLocation implements MCLocation{
+    Location l;
+    public BukkitMCLocation(Location l){
+        this.l = l;        
+    }
+
+    public double getX() {
+        return l.getX();
+    }
+
+    public double getY() {
+        return l.getY();
+    }
+
+    public double getZ() {
+        return l.getZ();
+    }
+
+    public MCWorld getWorld() {
+        if(l.getWorld() == null){
+            return null;
+        }
+        return new BukkitMCWorld(l.getWorld());
+    }
+
+    public float getYaw() {
+        return l.getYaw();
+    }
+
+    public float getPitch() {
+        return l.getPitch();
+    }
+
+    public int getBlockX() {
+        return l.getBlockX();
+    }
+
+    public int getBlockY() {
+        return l.getBlockY();
+    }
+
+    public int getBlockZ() {
+        return l.getBlockZ();
+    }
+
+    public MCBlock getBlock() {
+        if(l.getBlock() == null){
+            return null;
+        }
+        return new BukkitMCBlock(l.getBlock());
+    }
+    
+    public Location _Location(){
+        return l;
+    }
+
+    public void setPitch(float p) {
+        l.setPitch(p);
+    }
+
+    public void setYaw(float y) {
+        l.setYaw(y);
+    }
+
+    @Override
+    public MCLocation clone() {
+        return new BukkitMCLocation(l.clone());
+    }
+}
diff --git a/src/main/java/com/laytonsmith/abstraction/bukkit/BukkitMCMaterial.java b/src/main/java/com/laytonsmith/abstraction/bukkit/BukkitMCMaterial.java
new file mode 100644
index 0000000..6babba7
--- /dev/null
+++ b/src/main/java/com/laytonsmith/abstraction/bukkit/BukkitMCMaterial.java
@@ -0,0 +1,30 @@
+/*
+ * To change this template, choose Tools | Templates
+ * and open the template in the editor.
+ */
+package com.laytonsmith.abstraction.bukkit;
+
+import com.laytonsmith.abstraction.blocks.MCMaterial;
+import org.bukkit.Material;
+
+/**
+ *
+ * @author layton
+ */
+class BukkitMCMaterial implements MCMaterial {
+    
+    Material m;
+
+    public BukkitMCMaterial(Material type) {
+        m = type;
+    }
+
+    public short getMaxDurability() {
+        return m.getMaxDurability();
+    }
+
+    public int getType() {
+        return m.getId();
+    }
+    
+}
diff --git a/src/main/java/com/laytonsmith/abstraction/bukkit/BukkitMCMaterialData.java b/src/main/java/com/laytonsmith/abstraction/bukkit/BukkitMCMaterialData.java
new file mode 100644
index 0000000..ba5b8f2
--- /dev/null
+++ b/src/main/java/com/laytonsmith/abstraction/bukkit/BukkitMCMaterialData.java
@@ -0,0 +1,25 @@
+/*
+ * To change this template, choose Tools | Templates
+ * and open the template in the editor.
+ */
+package com.laytonsmith.abstraction.bukkit;
+
+import com.laytonsmith.abstraction.MCMaterialData;
+import org.bukkit.material.MaterialData;
+
+/**
+ *
+ * @author layton
+ */
+public class BukkitMCMaterialData implements MCMaterialData{
+    MaterialData md;
+    public BukkitMCMaterialData(MaterialData md){
+        this.md = md;
+    }
+
+    public byte getData() {
+        return md.getData();
+    }
+    
+    
+}
diff --git a/src/main/java/com/laytonsmith/abstraction/bukkit/BukkitMCOfflinePlayer.java b/src/main/java/com/laytonsmith/abstraction/bukkit/BukkitMCOfflinePlayer.java
new file mode 100644
index 0000000..3e54718
--- /dev/null
+++ b/src/main/java/com/laytonsmith/abstraction/bukkit/BukkitMCOfflinePlayer.java
@@ -0,0 +1,55 @@
+/*
+ * To change this template, choose Tools | Templates
+ * and open the template in the editor.
+ */
+package com.laytonsmith.abstraction.bukkit;
+
+import com.laytonsmith.abstraction.MCOfflinePlayer;
+import com.laytonsmith.abstraction.MCPlayer;
+import org.bukkit.OfflinePlayer;
+import org.bukkit.entity.Player;
+
+/**
+ *
+ * @author layton
+ */
+public class BukkitMCOfflinePlayer extends BukkitMCAnimalTamer implements MCOfflinePlayer{
+
+    OfflinePlayer op;
+    BukkitMCOfflinePlayer(OfflinePlayer offlinePlayer) {
+        super(offlinePlayer);
+        this.op = offlinePlayer;
+    }
+
+    public boolean isOnline() {
+        return op.isOnline();
+    }
+
+    public String getName() {
+        return op.getName();
+    }
+
+    public boolean isBanned() {
+        return op.isBanned();
+    }
+
+    public void setBanned(boolean banned) {
+        op.setBanned(banned);
+    }
+
+    public boolean isWhitelisted() {
+        return op.isWhitelisted();
+    }
+
+    public void setWhitelisted(boolean value) {
+        op.setWhitelisted(value);
+    }
+
+    public MCPlayer getPlayer() {
+        if(op instanceof Player){
+            return new BukkitMCPlayer(((Player)op));
+        }
+        return null;
+    }
+    
+}
diff --git a/src/main/java/com/laytonsmith/abstraction/bukkit/BukkitMCPlayer.java b/src/main/java/com/laytonsmith/abstraction/bukkit/BukkitMCPlayer.java
new file mode 100644
index 0000000..b78b793
--- /dev/null
+++ b/src/main/java/com/laytonsmith/abstraction/bukkit/BukkitMCPlayer.java
@@ -0,0 +1,273 @@
+/*
+ * To change this template, choose Tools | Templates
+ * and open the template in the editor.
+ */
+package com.laytonsmith.abstraction.bukkit;
+
+import com.laytonsmith.abstraction.*;
+import com.laytonsmith.abstraction.blocks.MCBlock;
+import com.laytonsmith.abstraction.bukkit.blocks.BukkitMCBlock;
+import java.lang.reflect.Field;
+import java.lang.reflect.InvocationTargetException;
+import java.lang.reflect.Method;
+import java.net.InetSocketAddress;
+import java.util.HashSet;
+import java.util.Set;
+import java.util.logging.Level;
+import java.util.logging.Logger;
+import net.minecraft.server.EntityLiving;
+import net.minecraft.server.EntityPlayer;
+import net.minecraft.server.MobEffect;
+import net.minecraft.server.ServerConfigurationManager;
+import org.bukkit.Bukkit;
+import org.bukkit.GameMode;
+import org.bukkit.Server;
+import org.bukkit.craftbukkit.entity.CraftPlayer;
+import org.bukkit.entity.Player;
+
+/**
+ *
+ * @author layton
+ */
+public class BukkitMCPlayer extends BukkitMCCommandSender implements MCPlayer {
+
+    Player p;
+
+    public BukkitMCPlayer(Player p) {
+        super(p);
+        this.p = p;
+    }
+
+    @Override
+    public String getName() {
+        return p.getName();
+    }
+
+    @Override
+    public String getDisplayName() {
+        return p.getDisplayName();
+    }
+
+    @Override
+    public void chat(String chat) {
+        p.chat(chat);
+    }
+
+    public boolean isOnline() {
+        return p.isOnline();
+    }
+
+    public MCItemStack getItemInHand() {
+        if (p == null || p.getItemInHand() == null) {
+            return null;
+        }
+        return new BukkitMCItemStack(p.getItemInHand());
+    }
+
+    public MCInventory getInventory() {
+        if (p == null || p.getInventory() == null) {
+            return null;
+        }
+        return new BukkitMCInventory(p.getInventory());
+    }
+
+    public MCWorld getWorld() {
+        if (p == null || p.getWorld() == null) {
+            return null;
+        }
+        return new BukkitMCWorld(p.getWorld());
+    }
+
+    public void setTempOp(Boolean value) throws ClassNotFoundException, NoSuchFieldException, IllegalArgumentException, IllegalAccessException, NoSuchMethodException, InvocationTargetException {
+        Server server = Bukkit.getServer();
+
+        Class serverClass = Class.forName("org.bukkit.craftbukkit.CraftServer", true, server.getClass().getClassLoader());
+
+        if (!server.getClass().isAssignableFrom(serverClass)) {
+            throw new IllegalStateException("Running server isn't CraftBukkit");
+        }
+
+        Field opSetField;
+
+        try {
+            opSetField = ServerConfigurationManager.class.getDeclaredField("operators");
+        } catch (NoSuchFieldException e) {
+            opSetField = ServerConfigurationManager.class.getDeclaredField("h");
+        }
+
+        opSetField.setAccessible(true); // make field accessible for reflection 
+
+        // Reflection magic
+        Set opSet = (Set) opSetField.get((ServerConfigurationManager) serverClass.getMethod("getHandle").invoke(server));
+
+        // since all Java objects pass by reference, we don't need to set field back to object
+        if (value) {
+            opSet.add(p.getName().toLowerCase());
+        } else {
+            opSet.remove(p.getName().toLowerCase());
+        }
+        p.recalculatePermissions();
+    }
+
+    public MCLocation getLocation() {
+        if(p.getLocation() == null){
+            return null;
+        }
+        return new BukkitMCLocation(p.getLocation());
+    }
+    
+    public MCBlock getTargetBlock(HashSet<Byte> b, int i){
+        return new BukkitMCBlock(p.getTargetBlock(b, i));
+    }
+    
+    public InetSocketAddress getAddress(){
+        return p.getAddress();
+    }
+
+    public boolean teleport(MCLocation l) {
+        return p.teleport(((BukkitMCLocation)l).l);
+    }
+
+    public void setHealth(int i) {
+        p.setHealth(i);
+    }
+
+    public void setDisplayName(String name) {
+        p.setDisplayName(name);
+    }
+
+    public void kickPlayer(String message) {
+        p.kickPlayer(message);
+    }
+
+    public boolean isSneaking() {
+        return p.isSneaking();
+    }
+
+    public int getHealth() {
+        return p.getHealth();
+    }
+    
+    public Player _Player(){
+        return p;
+    }
+
+    public void setExp(float i) {
+        p.setExp(i);
+    }
+
+    public float getExp() {
+        return p.getExp();
+    }
+
+    public MCGameMode getGameMode() {
+        switch(p.getGameMode()){
+            case SURVIVAL:
+                return MCGameMode.SURVIVAL;
+            case CREATIVE:
+                return MCGameMode.CREATIVE;
+        }
+        return null;
+    }
+
+    public void setGameMode(MCGameMode mode) {
+        switch(mode){
+            case SURVIVAL:
+                p.setGameMode(GameMode.SURVIVAL);
+                break;
+            case CREATIVE:
+                p.setGameMode(GameMode.CREATIVE);
+                break;
+        }
+    }
+
+    public void setItemInHand(MCItemStack is) {
+        p.setItemInHand(((BukkitMCItemStack)is).is);
+    }
+
+    public int getLevel() {
+        return p.getLevel();
+    }
+
+    public void setLevel(int xp) {
+        p.setLevel(xp);
+    }
+
+    public void giveExp(int xp) {
+        p.giveExp(xp);
+    }
+
+    public int getTotalExperience() {
+        return p.getTotalExperience();
+    }
+
+    public void setTotalExperience(int total) {
+        p.setTotalExperience(total);
+    }
+
+    public int getFoodLevel() {
+        return p.getFoodLevel();
+    }
+
+    public void setFoodLevel(int f) {
+        p.setFoodLevel(f);
+    }
+
+    public MCLocation getCompassTarget() {
+        return new BukkitMCLocation(p.getCompassTarget());
+    }
+
+    public void setCompassTarget(MCLocation l) {
+        p.setCompassTarget(((BukkitMCLocation)l).l);
+    }
+
+    public boolean isBanned() {
+        return p.isBanned();
+    }
+
+    public void setBanned(boolean banned) {
+        p.setBanned(banned);
+    }
+
+    public boolean isWhitelisted() {
+        return p.isWhitelisted();
+    }
+
+    public void setWhitelisted(boolean value) {
+        p.setWhitelisted(value);
+    }
+
+    public MCPlayer getPlayer() {
+        return new BukkitMCPlayer(p);
+    }
+
+    public int getRemainingFireTicks() {
+        return p.getFireTicks();
+    }
+    
+    public void setRemainingFireTicks(int i){
+        p.setFireTicks(i);
+    }
+
+    public void addEffect(int potionID, int strength, int seconds) {
+        EntityPlayer ep = ((CraftPlayer) p).getHandle();
+        Class epc = EntityLiving.class;
+        MobEffect me = new MobEffect(potionID, seconds * 20, strength);
+        try {
+            Method meth = epc.getDeclaredMethod("d", net.minecraft.server.MobEffect.class);
+            //ep.d(new MobEffect(effect, seconds * 20, strength));
+            //Call it reflectively, because it's deobfuscated in newer versions of CB
+            meth.invoke(ep, me);
+        } catch (Exception e) {
+            try {
+                //Look for the addEffect version                
+                Method meth = epc.getDeclaredMethod("addEffect", MobEffect.class);
+                //ep.addEffect(me);
+                meth.invoke(ep, me);
+            } catch (Exception ex) {
+                Logger.getLogger(BukkitMCPlayer.class.getName()).log(Level.SEVERE, null, ex);
+            }
+        }
+    }
+    
+}
diff --git a/src/main/java/com/laytonsmith/abstraction/bukkit/BukkitMCPlugin.java b/src/main/java/com/laytonsmith/abstraction/bukkit/BukkitMCPlugin.java
new file mode 100644
index 0000000..2d39117
--- /dev/null
+++ b/src/main/java/com/laytonsmith/abstraction/bukkit/BukkitMCPlugin.java
@@ -0,0 +1,37 @@
+/*
+ * To change this template, choose Tools | Templates
+ * and open the template in the editor.
+ */
+package com.laytonsmith.abstraction.bukkit;
+
+import com.laytonsmith.abstraction.MCPlugin;
+import org.bukkit.plugin.Plugin;
+
+/**
+ *
+ * @author layton
+ */
+public class BukkitMCPlugin implements MCPlugin {
+
+    Plugin p;
+    public BukkitMCPlugin(Plugin plugin) {
+        this.p = plugin;
+    }
+
+    public boolean isEnabled() {
+        return p.isEnabled();
+    }
+    
+    public boolean isInstanceOf(Class c) {
+        if (c.isInstance(p)) {
+            return true;
+        }
+        
+        return false;
+    }
+    
+    public Plugin getPlugin() {
+        return p;
+    }
+    
+}
diff --git a/src/main/java/com/laytonsmith/abstraction/bukkit/BukkitMCPluginManager.java b/src/main/java/com/laytonsmith/abstraction/bukkit/BukkitMCPluginManager.java
new file mode 100644
index 0000000..0f526d1
--- /dev/null
+++ b/src/main/java/com/laytonsmith/abstraction/bukkit/BukkitMCPluginManager.java
@@ -0,0 +1,33 @@
+/*
+ * To change this template, choose Tools | Templates
+ * and open the template in the editor.
+ */
+package com.laytonsmith.abstraction.bukkit;
+
+import com.laytonsmith.abstraction.MCPlugin;
+import com.laytonsmith.abstraction.MCPluginManager;
+import org.bukkit.plugin.PluginManager;
+
+/**
+ *
+ * @author layton
+ */
+public class BukkitMCPluginManager implements MCPluginManager {
+
+    PluginManager p;
+    public BukkitMCPluginManager(PluginManager pluginManager) {
+        this.p = pluginManager;
+    }
+
+    public MCPlugin getPlugin(String name) {
+        if(p.getPlugin(name) == null){
+            return null;
+        }
+        return new BukkitMCPlugin(p.getPlugin(name));
+    }
+    
+    public PluginManager __PluginManager(){
+        return p;
+    }
+    
+}
diff --git a/src/main/java/com/laytonsmith/abstraction/bukkit/BukkitMCServer.java b/src/main/java/com/laytonsmith/abstraction/bukkit/BukkitMCServer.java
new file mode 100644
index 0000000..928c265
--- /dev/null
+++ b/src/main/java/com/laytonsmith/abstraction/bukkit/BukkitMCServer.java
@@ -0,0 +1,96 @@
+/*
+ * To change this template, choose Tools | Templates
+ * and open the template in the editor.
+ */
+package com.laytonsmith.abstraction.bukkit;
+
+import com.laytonsmith.abstraction.*;
+import java.util.ArrayList;
+import java.util.List;
+import org.bukkit.Bukkit;
+import org.bukkit.Server;
+import org.bukkit.World;
+import org.bukkit.entity.Player;
+
+/**
+ *
+ * @author layton
+ */
+public class BukkitMCServer implements MCServer{
+    
+    Server s;
+    public BukkitMCServer(){
+        this.s = Bukkit.getServer();
+    }
+    
+    public Server __Server(){
+        return s;
+    }
+
+    @Override
+    public String getName() {
+        return s.getName();
+    }
+
+    @Override
+    public MCPlayer[] getOnlinePlayers() {
+        if(s.getOnlinePlayers() == null){
+            return null;
+        }
+        Player[] pa = s.getOnlinePlayers();
+        MCPlayer[] mcpa = new MCPlayer[pa.length];
+        for(int i = 0; i < pa.length; i++){
+            mcpa[i] = new BukkitMCPlayer(pa[i]);
+        }
+        return mcpa;
+    }
+
+    public static MCServer Get() {
+        return new BukkitMCServer();
+    }
+    
+    public boolean dispatchCommand(MCCommandSender sender, String command){
+        return s.dispatchCommand(((BukkitMCCommandSender)sender).c, command);
+    }
+
+    public MCPluginManager getPluginManager() {
+        if(s.getPluginManager() == null){
+            return null;
+        }
+        return new BukkitMCPluginManager(s.getPluginManager());
+    }
+
+    public MCPlayer getPlayer(String name) {
+        if(s.getPlayer(name) == null){
+            return null;
+        }
+        return new BukkitMCPlayer(s.getPlayer(name));
+    }
+
+    public MCWorld getWorld(String name) {
+        if(s.getWorld(name) == null){
+            return null;
+        }
+        return new BukkitMCWorld(s.getWorld(name));
+    }
+    
+    public List<MCWorld> getWorlds(){
+        if(s.getWorlds() == null){
+            return null;
+        }
+        List<MCWorld> list = new ArrayList<MCWorld>();
+        for(World w : s.getWorlds()){
+            list.add(new BukkitMCWorld(w));
+        }
+        return list;
+    }
+
+    public void broadcastMessage(String message) {
+        s.broadcastMessage(message);
+    }
+
+    public MCOfflinePlayer getOfflinePlayer(String player) {
+        return new BukkitMCOfflinePlayer(s.getOfflinePlayer(player));
+    }
+
+}
diff --git a/src/main/java/com/laytonsmith/abstraction/bukkit/BukkitMCTameable.java b/src/main/java/com/laytonsmith/abstraction/bukkit/BukkitMCTameable.java
new file mode 100644
index 0000000..759911c
--- /dev/null
+++ b/src/main/java/com/laytonsmith/abstraction/bukkit/BukkitMCTameable.java
@@ -0,0 +1,59 @@
+/*
+ * To change this template, choose Tools | Templates
+ * and open the template in the editor.
+ */
+package com.laytonsmith.abstraction.bukkit;
+
+import com.laytonsmith.abstraction.MCAnimalTamer;
+import com.laytonsmith.abstraction.MCTameable;
+import org.bukkit.entity.Entity;
+import org.bukkit.entity.Tameable;
+
+/**
+ *
+ * @author layton
+ */
+public class BukkitMCTameable implements MCTameable{
+
+    Tameable t;
+    public BukkitMCTameable(Tameable t){
+        this.t = t;
+    }
+    public boolean isTamed() {
+        return t.isTamed();
+    }
+
+    public void setTamed(boolean bln) {
+        t.setTamed(bln);
+    }
+
+    public MCAnimalTamer getOwner() {
+        if(t.getOwner() == null){
+            return null;
+        }
+        return new BukkitMCAnimalTamer(t.getOwner());
+    }
+
+    public void setOwner(MCAnimalTamer at) {
+        t.setOwner(((BukkitMCAnimalTamer)at).at);
+    }
+
+    public int getEntityId() {
+        if(t instanceof Entity){
+            return ((Entity)t).getEntityId();
+        }
+        return 0;
+    }
+
+    public boolean isTameable() {
+        return true;
+    }
+
+    public MCTameable getMCTameable() {
+        return new BukkitMCTameable(t);
+    }
+    
+    
+
+    
+}
diff --git a/src/main/java/com/laytonsmith/abstraction/bukkit/BukkitMCWorld.java b/src/main/java/com/laytonsmith/abstraction/bukkit/BukkitMCWorld.java
new file mode 100644
index 0000000..9bc0f5e
--- /dev/null
+++ b/src/main/java/com/laytonsmith/abstraction/bukkit/BukkitMCWorld.java
@@ -0,0 +1,224 @@
+/*
+ * To change this template, choose Tools | Templates
+ * and open the template in the editor.
+ */
+package com.laytonsmith.abstraction.bukkit;
+
+import com.laytonsmith.abstraction.*;
+import com.laytonsmith.abstraction.blocks.MCBlock;
+import com.laytonsmith.abstraction.bukkit.blocks.BukkitMCBlock;
+import com.laytonsmith.core.constructs.CArray;
+import com.laytonsmith.core.constructs.CInt;
+import com.laytonsmith.core.constructs.CVoid;
+import com.laytonsmith.core.constructs.Construct;
+import com.laytonsmith.core.exceptions.ConfigRuntimeException;
+import com.laytonsmith.core.functions.Exceptions.ExceptionType;
+import java.io.File;
+import java.util.ArrayList;
+import java.util.List;
+import org.bukkit.DyeColor;
+import org.bukkit.Effect;
+import org.bukkit.World;
+import org.bukkit.craftbukkit.CraftWorld;
+import org.bukkit.entity.*;
+import org.bukkit.event.entity.CreatureSpawnEvent.SpawnReason;
+
+/**
+ *
+ * @author layton
+ */
+public class BukkitMCWorld implements MCWorld {
+
+    World w;
+
+    public BukkitMCWorld(World w) {
+        this.w = w;
+    }
+
+    public World __World() {
+        return w;
+    }
+
+    public List<MCLivingEntity> getLivingEntities() {
+        if (w.getLivingEntities() == null) {
+            return null;
+        }
+        List<MCLivingEntity> list = new ArrayList<MCLivingEntity>();
+        for (LivingEntity e : w.getLivingEntities()) {
+            list.add(new BukkitMCLivingEntity(e));
+        }
+        return list;
+    }
+
+    public String getName() {
+        return w.getName();
+    }
+
+    public MCBlock getBlockAt(int x, int y, int z) {
+        if (w.getBlockAt(x, y, z) == null) {
+            return null;
+        }
+        return new BukkitMCBlock(w.getBlockAt(x, y, z));
+    }
+
+    public MCEntity spawn(MCLocation l, Class mobType) {
+        return new BukkitMCEntity(w.spawn(((BukkitMCLocation) l).l, mobType));
+    }
+
+    public void playEffect(MCLocation l, MCEffect mCEffect, int e, int data) {
+        w.playEffect(((BukkitMCLocation) l).l, Effect.valueOf(mCEffect.name()), e, data);
+    }
+
+    public void dropItemNaturally(MCLocation l, MCItemStack is) {
+        w.dropItemNaturally(((BukkitMCLocation) l).l, ((BukkitMCItemStack) is).is);
+    }
+
+    public void dropItem(MCLocation l, MCItemStack is) {
+        w.dropItem(((BukkitMCLocation) l).l, ((BukkitMCItemStack) is).is);
+    }
+
+    public void strikeLightning(MCLocation GetLocation) {
+        w.strikeLightning(((BukkitMCLocation) GetLocation).l);
+    }
+
+    public void strikeLightningEffect(MCLocation GetLocation) {
+        w.strikeLightningEffect(((BukkitMCLocation) GetLocation).l);
+    }
+
+    public void setStorm(boolean b) {
+        w.setStorm(b);
+    }
+
+    public MCLocation getSpawnLocation() {
+        return new BukkitMCLocation(w.getSpawnLocation());
+    }
+
+    public void refreshChunk(int x, int z) {
+        w.refreshChunk(x, z);
+    }
+
+    public void setTime(long time) {
+        w.setTime(time);
+    }
+
+    public long getTime() {
+        return w.getTime();
+    }
+
+    private enum MOBS {
+
+        CHICKEN, COW, CREEPER, GHAST, PIG, PIGZOMBIE, SHEEP, SKELETON, SLIME,
+        SPIDER, SQUID, WOLF, ZOMBIE, CAVESPIDER, ENDERMAN, SILVERFISH, VILLAGER,
+        BLAZE, ENDERDRAGON, MAGMACUBE, MOOSHROOM, SPIDERJOCKEY, GIANT, SNOWGOLEM
+    }
+
+    public Construct spawnMob(String name, String subClass, int qty, MCLocation l, int line_num, File f) {
+        Class mobType = null;
+        CArray ids = new CArray(0, null);
+        try {
+            switch (MOBS.valueOf(name.toUpperCase().replaceAll(" ", ""))) {
+                case CHICKEN:
+                    mobType = Chicken.class;
+                    break;
+                case COW:
+                    mobType = Cow.class;
+                    break;
+                case CREEPER:
+                    mobType = Creeper.class;
+                    break;
+                case GHAST:
+                    mobType = Ghast.class;
+                    break;
+                case PIG:
+                    mobType = Pig.class;
+                    break;
+                case PIGZOMBIE:
+                    mobType = PigZombie.class;
+                    break;
+                case SHEEP:
+                    mobType = Sheep.class;
+                    break;
+                case SKELETON:
+                    mobType = Skeleton.class;
+                    break;
+                case SLIME:
+                    mobType = Slime.class;
+                    break;
+                case SPIDER:
+                    mobType = Spider.class;
+                    break;
+                case SQUID:
+                    mobType = Squid.class;
+                    break;
+                case WOLF:
+                    mobType = Wolf.class;
+                    break;
+                case ZOMBIE:
+                    mobType = Zombie.class;
+                    break;
+                case CAVESPIDER:
+                    mobType = CaveSpider.class;
+                    break;
+                case ENDERMAN:
+                    mobType = Enderman.class;
+                    break;
+                case SILVERFISH:
+                    mobType = Silverfish.class;
+                    break;
+                case BLAZE:
+                    mobType = Blaze.class;
+                    break;
+                case VILLAGER:
+                    mobType = Villager.class;
+                    break;
+                case ENDERDRAGON:
+                    mobType = EnderDragon.class;
+                    break;
+                case MAGMACUBE:
+                    mobType = MagmaCube.class;
+                    break;
+                case MOOSHROOM:
+                    mobType = MushroomCow.class;
+                    break;
+                case SPIDERJOCKEY:
+                    mobType = Spider.class;
+                    break;
+                case GIANT:
+                    double x = l.getX();
+                    double y = l.getY();
+                    double z = l.getZ();
+                    float pitch = l.getPitch();
+                    float yaw = l.getYaw();
+                    net.minecraft.server.Entity giant = new net.minecraft.server.EntityGiantZombie(((CraftWorld) l.getWorld()).getHandle());
+                    giant.setLocation(x, y, z, pitch, yaw);
+                    ((CraftWorld) ((BukkitMCLocation)l)._Location().getWorld()).getHandle().addEntity(giant, SpawnReason.CUSTOM);
+                    return new CVoid(line_num, f);
+                case SNOWGOLEM:
+                    mobType = Snowman.class;
+                    break;
+            }
+        } catch (IllegalArgumentException e) {
+            throw new ConfigRuntimeException("No mob of type " + name + " exists",
+                    ExceptionType.FormatException, line_num, f);
+        }
+        for (int i = 0; i < qty; i++) {
+            MCEntity e = l.getWorld().spawn(l, mobType);
+            if (MOBS.valueOf(name.toUpperCase()) == MOBS.SPIDERJOCKEY) {
+                Spider s = (Spider) e;
+                Skeleton sk = (Skeleton) l.getWorld().spawn(l, Skeleton.class);
+                s.setPassenger(sk);
+            }
+            if (e instanceof Sheep) {
+                Sheep s = (Sheep) e;
+                try {
+                    s.setColor(DyeColor.valueOf(subClass.toUpperCase()));
+                } catch (IllegalArgumentException ex) {
+                    throw new ConfigRuntimeException(subClass.toUpperCase() + " is not a valid color",
+                            ExceptionType.FormatException, line_num, f);
+                }
+            }
+            ids.push(new CInt(e.getEntityId(), line_num, f));
+        }
+        return ids;
+    }
+}
diff --git a/src/main/java/com/laytonsmith/abstraction/bukkit/blocks/BukkitMCBlock.java b/src/main/java/com/laytonsmith/abstraction/bukkit/blocks/BukkitMCBlock.java
new file mode 100644
index 0000000..e2b0291
--- /dev/null
+++ b/src/main/java/com/laytonsmith/abstraction/bukkit/blocks/BukkitMCBlock.java
@@ -0,0 +1,93 @@
+/*
+ * To change this template, choose Tools | Templates
+ * and open the template in the editor.
+ */
+package com.laytonsmith.abstraction.bukkit.blocks;
+
+import com.laytonsmith.abstraction.MCWorld;
+import com.laytonsmith.abstraction.blocks.MCBlock;
+import com.laytonsmith.abstraction.blocks.MCBlockState;
+import com.laytonsmith.abstraction.blocks.MCMaterial;
+import com.laytonsmith.abstraction.blocks.MCSign;
+import com.laytonsmith.abstraction.bukkit.BukkitMCWorld;
+import org.bukkit.Material;
+import org.bukkit.block.Block;
+import org.bukkit.block.Sign;
+
+/**
+ *
+ * @author layton
+ */
+public class BukkitMCBlock implements MCBlock{
+    Block b;
+    public BukkitMCBlock(Block b){
+        this.b = b;
+    }
+    
+    public int getTypeId(){
+        if(b == null){
+            return 0;
+        }
+        return b.getTypeId();
+    }
+    
+    public byte getData(){
+        return b.getData();
+    }
+
+    public void setTypeId(int idata) {
+        b.setTypeId(idata);
+    }
+
+    public void setData(byte imeta) {
+        b.setData(imeta);
+    }
+
+    public MCBlockState getState() {
+        if(b.getState() == null){
+            return null;
+        }
+        return new BukkitMCBlockState(b.getState());
+    }
+
+    public MCMaterial getType() {
+        if(b.getType() == null){
+            return null;
+        }
+        return new BukkitMCMaterial(b.getType());
+    }
+
+    public MCWorld getWorld() {
+        return new BukkitMCWorld(b.getWorld());
+    }
+
+    public int getX() {
+        return b.getX();
+    }
+
+    public int getY() {
+        return b.getY();
+    }
+
+    public int getZ() {
+        return b.getZ();
+    }
+
+    public Block __Block() {
+        return b;
+    }
+
+    public MCSign getSign() {
+        return new BukkitMCSign((Sign)b.getState());
+    }
+
+    public boolean isSign() {
+        return (b.getType() == Material.SIGN || b.getType() == Material.SIGN_POST || b.getType() == Material.WALL_SIGN);
+    }
+
+    public boolean isNull() {
+        return b == null;
+    }
+    
+    
+}
diff --git a/src/main/java/com/laytonsmith/abstraction/bukkit/blocks/BukkitMCBlockState.java b/src/main/java/com/laytonsmith/abstraction/bukkit/blocks/BukkitMCBlockState.java
new file mode 100644
index 0000000..1e81ec5
--- /dev/null
+++ b/src/main/java/com/laytonsmith/abstraction/bukkit/blocks/BukkitMCBlockState.java
@@ -0,0 +1,22 @@
+/*
+ * To change this template, choose Tools | Templates
+ * and open the template in the editor.
+ */
+package com.laytonsmith.abstraction.bukkit.blocks;
+
+import com.laytonsmith.abstraction.blocks.MCBlockState;
+import org.bukkit.block.BlockState;
+
+/**
+ *
+ * @author layton
+ */
+class BukkitMCBlockState implements MCBlockState {
+    
+    BlockState bs;
+
+    public BukkitMCBlockState(BlockState state) {
+        this.bs = state;
+    }
+    
+}
diff --git a/src/main/java/com/laytonsmith/abstraction/bukkit/blocks/BukkitMCMaterial.java b/src/main/java/com/laytonsmith/abstraction/bukkit/blocks/BukkitMCMaterial.java
new file mode 100644
index 0000000..2668ee8
--- /dev/null
+++ b/src/main/java/com/laytonsmith/abstraction/bukkit/blocks/BukkitMCMaterial.java
@@ -0,0 +1,29 @@
+/*
+ * To change this template, choose Tools | Templates
+ * and open the template in the editor.
+ */
+package com.laytonsmith.abstraction.bukkit.blocks;
+
+import com.laytonsmith.abstraction.blocks.MCMaterial;
+import org.bukkit.Material;
+
+/**
+ *
+ * @author layton
+ */
+class BukkitMCMaterial implements MCMaterial {
+    Material m;
+
+    public BukkitMCMaterial(Material type) {
+        this.m = type;
+    }
+
+    public short getMaxDurability() {
+        return this.m.getMaxDurability();
+    }
+
+    public int getType() {
+        return m.getId();
+    }
+    
+}
diff --git a/src/main/java/com/laytonsmith/abstraction/bukkit/blocks/BukkitMCSign.java b/src/main/java/com/laytonsmith/abstraction/bukkit/blocks/BukkitMCSign.java
new file mode 100644
index 0000000..04bc2ec
--- /dev/null
+++ b/src/main/java/com/laytonsmith/abstraction/bukkit/blocks/BukkitMCSign.java
@@ -0,0 +1,31 @@
+/*
+ * To change this template, choose Tools | Templates
+ * and open the template in the editor.
+ */
+package com.laytonsmith.abstraction.bukkit.blocks;
+
+import com.laytonsmith.abstraction.blocks.MCSign;
+import org.bukkit.block.Sign;
+
+/**
+ *
+ * @author layton
+ */
+class BukkitMCSign implements MCSign {
+    
+    Sign s;
+
+    public BukkitMCSign(Sign sign) {
+        this.s = sign;
+    }
+
+    public void setLine(int i, String line1) {
+        s.setLine(i, line1);
+        s.update();
+    }
+
+    public String getLine(int i) {
+        return s.getLine(i);
+    }
+    
+}
diff --git a/src/main/java/com/laytonsmith/abstraction/bukkit/events/BukkitAbstractEventMixin.java b/src/main/java/com/laytonsmith/abstraction/bukkit/events/BukkitAbstractEventMixin.java
new file mode 100644
index 0000000..5aca6b0
--- /dev/null
+++ b/src/main/java/com/laytonsmith/abstraction/bukkit/events/BukkitAbstractEventMixin.java
@@ -0,0 +1,90 @@
+/*
+ * To change this template, choose Tools | Templates
+ * and open the template in the editor.
+ */
+package com.laytonsmith.abstraction.bukkit.events;
+
+import com.laytonsmith.abstraction.bukkit.BukkitMCServer;
+import com.laytonsmith.core.Static;
+import com.laytonsmith.core.constructs.CString;
+import com.laytonsmith.core.constructs.Construct;
+import com.laytonsmith.core.events.AbstractEvent;
+import com.laytonsmith.core.events.EventMixinInterface;
+import com.laytonsmith.core.exceptions.EventException;
+import java.util.HashMap;
+import java.util.Map;
+import org.bukkit.entity.Entity;
+import org.bukkit.entity.Player;
+import org.bukkit.event.Cancellable;
+import org.bukkit.event.block.BlockEvent;
+import org.bukkit.event.entity.EntityEvent;
+import org.bukkit.event.inventory.FurnaceBurnEvent;
+import org.bukkit.event.inventory.FurnaceSmeltEvent;
+import org.bukkit.event.player.PlayerEvent;
+import org.bukkit.event.server.ServerEvent;
+import org.bukkit.event.vehicle.VehicleEvent;
+import org.bukkit.event.weather.WeatherEvent;
+import org.bukkit.event.world.WorldEvent;
+
+/**
+ *
+ * @author layton
+ */
+public class BukkitAbstractEventMixin implements EventMixinInterface{
+    
+    AbstractEvent mySuper;
+    
+    public BukkitAbstractEventMixin(AbstractEvent mySuper){
+        this.mySuper = mySuper;
+    }
+
+    public void cancel(Object e, boolean state){
+        if (e instanceof Cancellable) {
+            ((Cancellable) e).setCancelled(state);
+        }
+    }
+    
+    @Override
+    public Map<String, Construct> evaluate_helper(Object e) throws EventException{
+        Map<String, Construct> map = new HashMap<String, Construct>();
+        map.put("type", new CString(mySuper.getName(), 0, null));
+        String macro;
+        if(e instanceof BlockEvent){
+            macro = "block";
+        } else if(e instanceof EntityEvent){
+            macro = "entity";
+            if(((EntityEvent)e).getEntity() instanceof Player){
+                Entity entity = ((EntityEvent)e).getEntity();
+                map.put("player", new CString(((Player)entity).getName(), 0, null));
+            }
+        } else if(e instanceof FurnaceBurnEvent || e instanceof FurnaceSmeltEvent){
+            macro = "inventory";
+        } else if(e instanceof PlayerEvent){
+            map.put("player", new CString(((PlayerEvent)e).getPlayer().getName(), 0, null));
+            macro = "player";
+        } else if(e instanceof ServerEvent){
+            macro = "server";
+        } else if(e instanceof VehicleEvent){
+            macro = "vehicle";
+        } else if(e instanceof WeatherEvent){
+            macro = "weather";
+        } else if(e instanceof WorldEvent){
+            macro = "world";
+        } else {
+            macro = "custom";
+        }
+        map.put("macrotype", new CString(macro, 0, null));
+        return map;
+    }
+    
+    public void manualTrigger(Object e){
+        if(e instanceof org.bukkit.event.Event){
+            ((BukkitMCServer)Static.getServer()).__Server().getPluginManager().callEvent((org.bukkit.event.Event)e);
+        }
+    }
+
+    public boolean isCancellable(Object o) {
+        return (o instanceof Cancellable);
+    }
+    
+}
diff --git a/src/main/java/com/laytonsmith/abstraction/bukkit/events/BukkitPlayerEvents.java b/src/main/java/com/laytonsmith/abstraction/bukkit/events/BukkitPlayerEvents.java
new file mode 100644
index 0000000..2ee2e73
--- /dev/null
+++ b/src/main/java/com/laytonsmith/abstraction/bukkit/events/BukkitPlayerEvents.java
@@ -0,0 +1,372 @@
+/*
+ * To change this template, choose Tools | Templates
+ * and open the template in the editor.
+ */
+package com.laytonsmith.abstraction.bukkit.events;
+
+import com.laytonsmith.abstraction.Implementation;
+import com.laytonsmith.abstraction.MCPlayer;
+import com.laytonsmith.abstraction.bukkit.BukkitMCItemStack;
+import com.laytonsmith.abstraction.bukkit.BukkitMCLocation;
+import com.laytonsmith.abstraction.bukkit.BukkitMCPlayer;
+import com.laytonsmith.abstraction.bukkit.BukkitMCWorld;
+import com.laytonsmith.abstraction.bukkit.blocks.BukkitMCBlock;
+import com.laytonsmith.core.Env;
+import com.laytonsmith.core.ObjectGenerator;
+import com.laytonsmith.core.Static;
+import com.laytonsmith.core.constructs.*;
+import com.laytonsmith.core.events.Prefilters.PrefilterType;
+import com.laytonsmith.core.events.*;
+import com.laytonsmith.core.events.BoundEvent.ActiveEvent;
+import com.laytonsmith.core.exceptions.ConfigRuntimeException;
+import com.laytonsmith.core.exceptions.EventException;
+import com.laytonsmith.core.exceptions.PrefilterNonMatchException;
+import com.laytonsmith.core.functions.Exceptions;
+import java.util.ArrayList;
+import java.util.List;
+import java.util.Map;
+import org.bukkit.Location;
+import org.bukkit.block.Block;
+import org.bukkit.block.BlockFace;
+import org.bukkit.entity.Player;
+import org.bukkit.event.block.Action;
+import org.bukkit.event.entity.EntityDamageEvent.DamageCause;
+import org.bukkit.event.entity.EntityDeathEvent;
+import org.bukkit.event.entity.PlayerDeathEvent;
+import org.bukkit.event.player.PlayerInteractEvent;
+import org.bukkit.event.player.PlayerJoinEvent;
+import org.bukkit.event.player.PlayerRespawnEvent;
+import org.bukkit.inventory.ItemStack;
+
+/**
+ *
+ * @author layton
+ */
+public class BukkitPlayerEvents {
+    @abstraction(load=com.laytonsmith.core.events.drivers.PlayerEvents.player_join.class,
+            type=Implementation.Type.BUKKIT)
+    public static class player_join implements EventHandlerInterface{
+        public boolean matches(Map<String, Construct> prefilter, Object e) throws PrefilterNonMatchException {
+            if(e instanceof PlayerJoinEvent){
+                PlayerJoinEvent ple = (PlayerJoinEvent) e;
+                if(prefilter.containsKey("player")){
+                    if(!ple.getPlayer().getName().equals(prefilter.get("player_name").val())){
+                        return false;
+                    }
+                }                
+                Prefilters.match(prefilter, "join_message", ple.getJoinMessage(), PrefilterType.REGEX);
+                return true;
+            }
+            return false;
+        }
+
+        public Map<String, Construct> evaluate(Object e, EventMixinInterface mixin) throws EventException {
+            if(e instanceof PlayerJoinEvent){
+                PlayerJoinEvent ple = (PlayerJoinEvent) e;
+                Map<String, Construct> map = mixin.evaluate_helper(e);
+                //map.put("player", new CString(ple.getPlayer().getName(), 0, null));
+                map.put("join_message", new CString(ple.getJoinMessage(), 0, null));
+                return map;
+            } else{
+                throw new EventException("Cannot convert e to PlayerLoginEvent");
+            }
+        }
+        
+        public Object convert(CArray manual){
+            PlayerJoinEvent e = new PlayerJoinEvent(((BukkitMCPlayer)Static.GetPlayer(manual.get("player").val(), 0, null))._Player(), manual.get("join_message").val());
+            return e;
+        }
+
+        public boolean modifyEvent(String key, Construct value, Object event) {
+            if(event instanceof PlayerJoinEvent){
+                PlayerJoinEvent pje = (PlayerJoinEvent)event;
+                if(key.equals("join_message")){
+                    if(value instanceof CNull){
+                        pje.setJoinMessage(null);
+                        return pje.getJoinMessage() == null;
+                    } else {
+                        pje.setJoinMessage(value.val());
+                        return pje.getJoinMessage().equals(value.val());
+                    }
+                }
+            }
+            return false;
+        }
+
+        public EventMixinInterface customMixin(AbstractEvent e) {
+            return null;
+        }
+
+        public void preExecution(Env env, ActiveEvent activeEvent) {
+            throw new UnsupportedOperationException("Not supported yet.");
+        }
+
+        public void postExecution(Env env, ActiveEvent activeEvent) {
+            throw new UnsupportedOperationException("Not supported yet.");
+        }
+    }
+    
+    
+    @abstraction(load=com.laytonsmith.core.events.drivers.PlayerEvents.player_interact.class,
+            type=Implementation.Type.BUKKIT)
+    public static class player_interact implements EventHandlerInterface{
+        public boolean matches(Map<String, Construct> prefilter, Object e) throws PrefilterNonMatchException {
+            if(e instanceof PlayerInteractEvent){
+                PlayerInteractEvent pie = (PlayerInteractEvent)e;
+                if(((PlayerInteractEvent)e).getAction().equals(Action.PHYSICAL)){
+                    return false;
+                }
+                if(prefilter.containsKey("button")){
+                    if(pie.getAction().equals(Action.LEFT_CLICK_AIR) || pie.getAction().equals(Action.LEFT_CLICK_BLOCK)){
+                        if(!prefilter.get("button").val().toLowerCase().equals("left")){
+                            return false;
+                        }
+                    }
+                    if(pie.getAction().equals(Action.RIGHT_CLICK_AIR) || pie.getAction().equals(Action.RIGHT_CLICK_BLOCK)){
+                        if(!prefilter.get("button").val().toLowerCase().equals("right")){
+                            return false;
+                        }
+                    }
+                }
+                
+                Prefilters.match(prefilter, "item", Static.ParseItemNotation(new BukkitMCItemStack(pie.getItem())), PrefilterType.ITEM_MATCH);
+                Prefilters.match(prefilter, "block", Static.ParseItemNotation(new BukkitMCBlock(pie.getClickedBlock())), PrefilterType.ITEM_MATCH);
+                Prefilters.match(prefilter, "player", pie.getPlayer().getName(), PrefilterType.MACRO);
+                
+                return true;
+            }
+            return false;
+        }
+
+        public Map<String, Construct> evaluate(Object e, EventMixinInterface mixin) throws EventException {
+            if(e instanceof PlayerInteractEvent){
+                PlayerInteractEvent pie = (PlayerInteractEvent) e;
+                Map<String, Construct> map = mixin.evaluate_helper(e);
+                //map.put("player", new CString(pie.getPlayer().getName(), 0, null));
+                Action a = pie.getAction();
+                map.put("action", new CString(a.name().toLowerCase(), 0, null));
+                map.put("block", new CString(Static.ParseItemNotation(new BukkitMCBlock(pie.getClickedBlock())), 0, null));
+                if(a == Action.LEFT_CLICK_AIR || a == Action.LEFT_CLICK_BLOCK){
+                    map.put("button", new CString("left", 0, null));
+                } else {
+                    map.put("button", new CString("right", 0, null));
+                }
+                if(a == Action.LEFT_CLICK_BLOCK || a == Action.RIGHT_CLICK_BLOCK){
+                    map.put("facing", new CString(pie.getBlockFace().name().toLowerCase(), 0, null));
+                    Block b = pie.getClickedBlock();
+                    map.put("location", new CArray(0, null, new CInt(b.getX(), 0, null),
+                            new CInt(b.getY(), 0, null), new CInt(b.getZ(), 0, null), 
+                            new CString(b.getWorld().getName(), 0, null)));
+                }
+                map.put("item", new CString(Static.ParseItemNotation(new BukkitMCItemStack(pie.getItem())), 0, null));
+                return map;
+            } else {
+                throw new EventException("Cannot convert e to PlayerInteractEvent");
+            }
+        }
+        
+        @Override
+        public Object convert(CArray manual){
+            Player p = ((BukkitMCPlayer)Static.GetPlayer(manual.get("player"), 0, null))._Player();
+            Action a = Action.valueOf(manual.get("action").val().toUpperCase());
+            ItemStack is = ((BukkitMCItemStack)Static.ParseItemNotation("player_interact event", manual.get("item").val(), 1, 0, null)).__ItemStack();
+            Block b = ((BukkitMCBlock)ObjectGenerator.GetGenerator().location(manual.get("location"), null, 0, null).getBlock()).__Block();
+            BlockFace bf = BlockFace.valueOf(manual.get("facing").val());
+            PlayerInteractEvent e = new PlayerInteractEvent(p, a, is, b, bf);            
+            return e;
+        }
+
+        public boolean modifyEvent(String key, Construct value, Object event) {
+            if(event instanceof PlayerInteractEvent){
+                PlayerInteractEvent pie = (PlayerInteractEvent)event;
+                
+            }
+            return false;
+        }
+
+        public EventMixinInterface customMixin(AbstractEvent e) {
+            throw new UnsupportedOperationException("Not supported yet.");
+        }
+
+        public void preExecution(Env env, ActiveEvent activeEvent) {
+            throw new UnsupportedOperationException("Not supported yet.");
+        }
+
+        public void postExecution(Env env, ActiveEvent activeEvent) {
+            throw new UnsupportedOperationException("Not supported yet.");
+        }
+    }
+    
+    @abstraction(load = com.laytonsmith.core.events.drivers.PlayerEvents.player_spawn.class,
+    type = Implementation.Type.BUKKIT)
+    public static class player_spawn implements EventHandlerInterface {
+
+        public boolean matches(Map<String, Construct> prefilter, Object e) throws PrefilterNonMatchException {
+            if (e instanceof PlayerRespawnEvent) {
+                PlayerRespawnEvent event = (PlayerRespawnEvent) e;
+                Prefilters.match(prefilter, "player", event.getPlayer().getName(), PrefilterType.MACRO);
+                Prefilters.match(prefilter, "x", event.getRespawnLocation().getBlockX(), PrefilterType.EXPRESSION);
+                Prefilters.match(prefilter, "y", event.getRespawnLocation().getBlockY(), PrefilterType.EXPRESSION);
+                Prefilters.match(prefilter, "z", event.getRespawnLocation().getBlockZ(), PrefilterType.EXPRESSION);
+                Prefilters.match(prefilter, "world", event.getRespawnLocation().getWorld().getName(), PrefilterType.STRING_MATCH);
+                return true;
+            }
+            return false;
+        }
+        
+        public Map<String, Construct> evaluate(Object e, EventMixinInterface mixin) throws EventException {
+            if (e instanceof PlayerRespawnEvent) {
+                PlayerRespawnEvent event = (PlayerRespawnEvent) e;
+                Map<String, Construct> map = mixin.evaluate_helper(e);
+                //the helper puts the player in for us
+                CArray location = ObjectGenerator.GetGenerator().location(new BukkitMCLocation(event.getRespawnLocation()));
+                map.put("location", location);
+                return map;
+            } else {
+                throw new EventException("Cannot convert e to PlayerRespawnEvent");
+            }
+        }
+        
+        public Object convert(CArray manual) {
+            //For firing off the event manually, we have to convert the CArray into an
+            //actual object that will trigger it
+            Player p = ((BukkitMCPlayer)Static.GetPlayer(manual.get("player")))._Player();
+            Location l = ((BukkitMCLocation)ObjectGenerator.GetGenerator().location(manual.get("location"), new BukkitMCWorld(p.getWorld()), 0, null))._Location();
+            PlayerRespawnEvent e = new PlayerRespawnEvent(p, l, false);
+            return e;
+        }
+        
+        public boolean modifyEvent(String key, Construct value, Object event) {
+            if (event instanceof PlayerRespawnEvent) {
+                PlayerRespawnEvent e = (PlayerRespawnEvent) event;
+                if (key.equals("location")) {
+                    //Change this parameter in e to value
+                    e.setRespawnLocation(((BukkitMCLocation)ObjectGenerator.GetGenerator().location(value, new BukkitMCWorld(e.getPlayer().getWorld()), 0, null))._Location());                    
+                    return true;
+                }
+            }
+            return false;
+        }
+        
+        public EventMixinInterface customMixin(AbstractEvent e) {
+            return null;
+        }
+
+        public void preExecution(Env env, ActiveEvent activeEvent) {
+            if(activeEvent.getUnderlyingEvent() instanceof PlayerRespawnEvent){
+                //Static lookups of the player don't seem to work here, but
+                //the player is passed in with the event.
+                MCPlayer player = (new BukkitMCPlayer(((PlayerRespawnEvent)activeEvent.getUnderlyingEvent()).getPlayer()));
+                env.SetPlayer(player);
+                Static.InjectPlayer(player);
+            }
+        }
+
+        public void postExecution(Env env, ActiveEvent activeEvent) {
+            if(activeEvent.getUnderlyingEvent() instanceof PlayerRespawnEvent){
+                MCPlayer player = (new BukkitMCPlayer(((PlayerRespawnEvent)activeEvent.getUnderlyingEvent()).getPlayer()));
+                Static.UninjectPlayer(player);
+            }
+        }
+    }
+    
+    @abstraction(load = com.laytonsmith.core.events.drivers.PlayerEvents.player_death.class,
+    type = Implementation.Type.BUKKIT)
+    public static class player_death implements EventHandlerInterface {
+        //Check to see if this event matches the given prefilter
+
+        public boolean matches(Map<String, Construct> prefilter, Object e) throws PrefilterNonMatchException {
+            if (e instanceof EntityDeathEvent) {
+                EntityDeathEvent event = (EntityDeathEvent) e;
+                Prefilters.match(prefilter, "player", ((Player)event.getEntity()).getName(), PrefilterType.MACRO);
+                return true;
+            }
+            return false;
+        }
+
+        //We have an actual event now, change it into a Map
+        //that will end up being the @event object
+        public Map<String, Construct> evaluate(Object e, EventMixinInterface mixin) throws EventException {
+            if (e instanceof EntityDeathEvent) {
+                EntityDeathEvent event = (EntityDeathEvent) e;
+                Map<String, Construct> map = mixin.evaluate_helper(e);
+                CArray ca = new CArray(0, null);
+                for(ItemStack is : event.getDrops()){                    
+                    ca.push(ObjectGenerator.GetGenerator().item(new BukkitMCItemStack(is), 0, null));
+                }
+                Player p = (Player)event.getEntity();
+                map.put("drops", ca);
+                map.put("xp", new CInt(event.getDroppedExp(), 0, null));
+                if(event instanceof PlayerDeathEvent){
+                    map.put("death_message", new CString(((PlayerDeathEvent)event).getDeathMessage(), 0, null));
+                }
+                try{
+                    map.put("cause", new CString(event.getEntity().getLastDamageCause().getCause().name(), 0, null));
+                } catch(NullPointerException ex){
+                    map.put("cause", new CString(DamageCause.CUSTOM.name(), 0, null));
+                }
+                map.put("location", ObjectGenerator.GetGenerator().location(new BukkitMCLocation(p.getLocation())));
+                return map;
+            } else {
+                throw new EventException("Cannot convert e to EntityDeathEvent");
+            }
+        }
+        
+        public Object convert(CArray manual) {
+            //For firing off the event manually, we have to convert the CArray into an
+            //actual object that will trigger it
+            String splayer = manual.get("player").val();
+            List<ItemStack> list = new ArrayList<ItemStack>();
+            CArray clist = (CArray)manual.get("drops");
+            for(String key : clist.keySet()){
+                list.add(((BukkitMCItemStack)ObjectGenerator.GetGenerator().item(clist.get(key), clist.getLineNum(), clist.getFile())).__ItemStack());
+            }
+            EntityDeathEvent e = new EntityDeathEvent(((BukkitMCPlayer)Static.GetPlayer(splayer))._Player(), list);
+            return e;
+        }
+
+        //Given the paramters, change the underlying event
+        public boolean modifyEvent(String key, Construct value, Object event) {
+            if (event instanceof EntityDeathEvent) {
+                EntityDeathEvent e = (EntityDeathEvent) event;
+                if (key.equals("xp")) {
+                    //Change this parameter in e to value
+                    e.setDroppedExp((int)Static.getInt(value));                    
+                    return true;
+                }
+                if(key.equals("drops")){
+                    if(value instanceof CNull){
+                        value = new CArray(0, null);
+                    }
+                    if(!(value instanceof CArray)){
+                        throw new ConfigRuntimeException("drops must be an array, or null", Exceptions.ExceptionType.CastException, 0, null);
+                    }
+                    e.getDrops().clear();
+                    CArray drops = (CArray) value;
+                    for(String dropID : drops.keySet()){
+                        e.getDrops().add(((BukkitMCItemStack)ObjectGenerator.GetGenerator().item(drops.get(dropID), 0, null)).__ItemStack());
+                    }
+                    return true;
+                }
+                if(event instanceof PlayerDeathEvent && key.equals("death_message")){
+                    ((PlayerDeathEvent)event).setDeathMessage(value.val());
+                    return true;
+                }
+            }
+            return false;
+        }
+        
+        public EventMixinInterface customMixin(AbstractEvent e) {
+            return null;
+        }
+
+        public void preExecution(Env env, ActiveEvent activeEvent) {
+            throw new UnsupportedOperationException("Not supported yet.");
+        }
+
+        public void postExecution(Env env, ActiveEvent activeEvent) {
+            throw new UnsupportedOperationException("Not supported yet.");
+        }
+    }
+   
+}
diff --git a/src/main/java/com/laytonsmith/abstraction/bukkit/events/drivers/BukkitBlockListener.java b/src/main/java/com/laytonsmith/abstraction/bukkit/events/drivers/BukkitBlockListener.java
new file mode 100644
index 0000000..e7e0c4a
--- /dev/null
+++ b/src/main/java/com/laytonsmith/abstraction/bukkit/events/drivers/BukkitBlockListener.java
@@ -0,0 +1,15 @@
+/*
+ * To change this template, choose Tools | Templates
+ * and open the template in the editor.
+ */
+package com.laytonsmith.abstraction.bukkit.events.drivers;
+
+import org.bukkit.event.block.BlockListener;
+
+/**
+ *
+ * @author Layton
+ */
+public class BukkitBlockListener extends BlockListener{
+    
+}
diff --git a/src/main/java/com/laytonsmith/abstraction/bukkit/events/drivers/BukkitEntityListener.java b/src/main/java/com/laytonsmith/abstraction/bukkit/events/drivers/BukkitEntityListener.java
new file mode 100644
index 0000000..df2c10e
--- /dev/null
+++ b/src/main/java/com/laytonsmith/abstraction/bukkit/events/drivers/BukkitEntityListener.java
@@ -0,0 +1,27 @@
+/*
+ * To change this template, choose Tools | Templates
+ * and open the template in the editor.
+ */
+package com.laytonsmith.abstraction.bukkit.events.drivers;
+
+import com.laytonsmith.core.events.Driver;
+import com.laytonsmith.core.events.EventUtils;
+import org.bukkit.entity.Player;
+import org.bukkit.event.entity.EntityDeathEvent;
+import org.bukkit.event.entity.EntityListener;
+
+/**
+ *
+ * @author Layton
+ */
+public class BukkitEntityListener extends EntityListener{
+
+    @Override
+    public void onEntityDeath(EntityDeathEvent event) {
+        if(event.getEntity() instanceof Player){
+            EventUtils.TriggerListener(Driver.PLAYER_DEATH, "player_death", event);
+        }
+    }
+    
+    
+}
diff --git a/src/main/java/com/laytonsmith/abstraction/bukkit/events/drivers/BukkitInventoryListener.java b/src/main/java/com/laytonsmith/abstraction/bukkit/events/drivers/BukkitInventoryListener.java
new file mode 100644
index 0000000..d2919ac
--- /dev/null
+++ b/src/main/java/com/laytonsmith/abstraction/bukkit/events/drivers/BukkitInventoryListener.java
@@ -0,0 +1,15 @@
+/*
+ * To change this template, choose Tools | Templates
+ * and open the template in the editor.
+ */
+package com.laytonsmith.abstraction.bukkit.events.drivers;
+
+import org.bukkit.event.inventory.InventoryListener;
+
+/**
+ *
+ * @author Layton
+ */
+public class BukkitInventoryListener extends InventoryListener{
+    
+}
diff --git a/src/main/java/com/laytonsmith/abstraction/bukkit/events/drivers/BukkitPlayerListener.java b/src/main/java/com/laytonsmith/abstraction/bukkit/events/drivers/BukkitPlayerListener.java
new file mode 100644
index 0000000..6687b5b
--- /dev/null
+++ b/src/main/java/com/laytonsmith/abstraction/bukkit/events/drivers/BukkitPlayerListener.java
@@ -0,0 +1,37 @@
+/*
+ * To change this template, choose Tools | Templates
+ * and open the template in the editor.
+ */
+package com.laytonsmith.abstraction.bukkit.events.drivers;
+
+import com.laytonsmith.abstraction.bukkit.BukkitConvertor;
+import com.laytonsmith.core.events.EventUtils;
+import org.bukkit.event.Event.Type;
+import org.bukkit.event.player.PlayerInteractEvent;
+import org.bukkit.event.player.PlayerJoinEvent;
+import org.bukkit.event.player.PlayerListener;
+import org.bukkit.event.player.PlayerRespawnEvent;
+
+/**
+ *
+ * @author Layton
+ */
+public class BukkitPlayerListener extends PlayerListener{
+    
+    @Override
+    public void onPlayerJoin(PlayerJoinEvent e){
+        EventUtils.TriggerListener(BukkitConvertor.GetGenericType(Type.PLAYER_JOIN), "player_join", e);
+    }
+    
+    @Override
+    public void onPlayerInteract(PlayerInteractEvent e){
+        EventUtils.TriggerListener(BukkitConvertor.GetGenericType(Type.PLAYER_INTERACT), "player_interact", e);
+    }  
+
+    @Override
+    public void onPlayerRespawn(PlayerRespawnEvent event) {
+        EventUtils.TriggerListener(BukkitConvertor.GetGenericType(Type.PLAYER_RESPAWN), "player_spawn", event);
+    }
+    
+
+}
diff --git a/src/main/java/com/laytonsmith/abstraction/bukkit/events/drivers/BukkitServerListener.java b/src/main/java/com/laytonsmith/abstraction/bukkit/events/drivers/BukkitServerListener.java
new file mode 100644
index 0000000..f2b18b9
--- /dev/null
+++ b/src/main/java/com/laytonsmith/abstraction/bukkit/events/drivers/BukkitServerListener.java
@@ -0,0 +1,15 @@
+/*
+ * To change this template, choose Tools | Templates
+ * and open the template in the editor.
+ */
+package com.laytonsmith.abstraction.bukkit.events.drivers;
+
+import org.bukkit.event.server.ServerListener;
+
+/**
+ *
+ * @author Layton
+ */
+public class BukkitServerListener extends ServerListener{
+    
+}
diff --git a/src/main/java/com/laytonsmith/abstraction/bukkit/events/drivers/BukkitVehicleListener.java b/src/main/java/com/laytonsmith/abstraction/bukkit/events/drivers/BukkitVehicleListener.java
new file mode 100644
index 0000000..fcdf1b5
--- /dev/null
+++ b/src/main/java/com/laytonsmith/abstraction/bukkit/events/drivers/BukkitVehicleListener.java
@@ -0,0 +1,15 @@
+/*
+ * To change this template, choose Tools | Templates
+ * and open the template in the editor.
+ */
+package com.laytonsmith.abstraction.bukkit.events.drivers;
+
+import org.bukkit.event.vehicle.VehicleListener;
+
+/**
+ *
+ * @author Layton
+ */
+public class BukkitVehicleListener extends VehicleListener{
+    
+}
diff --git a/src/main/java/com/laytonsmith/abstraction/bukkit/events/drivers/BukkitWeatherListener.java b/src/main/java/com/laytonsmith/abstraction/bukkit/events/drivers/BukkitWeatherListener.java
new file mode 100644
index 0000000..389a464
--- /dev/null
+++ b/src/main/java/com/laytonsmith/abstraction/bukkit/events/drivers/BukkitWeatherListener.java
@@ -0,0 +1,15 @@
+/*
+ * To change this template, choose Tools | Templates
+ * and open the template in the editor.
+ */
+package com.laytonsmith.abstraction.bukkit.events.drivers;
+
+import org.bukkit.event.weather.WeatherListener;
+
+/**
+ *
+ * @author Layton
+ */
+public class BukkitWeatherListener extends WeatherListener{
+    
+}
diff --git a/src/main/java/com/laytonsmith/abstraction/bukkit/events/drivers/BukkitWorldListener.java b/src/main/java/com/laytonsmith/abstraction/bukkit/events/drivers/BukkitWorldListener.java
new file mode 100644
index 0000000..5d1abbe
--- /dev/null
+++ b/src/main/java/com/laytonsmith/abstraction/bukkit/events/drivers/BukkitWorldListener.java
@@ -0,0 +1,15 @@
+/*
+ * To change this template, choose Tools | Templates
+ * and open the template in the editor.
+ */
+package com.laytonsmith.abstraction.bukkit.events.drivers;
+
+import org.bukkit.event.world.WorldListener;
+
+/**
+ *
+ * @author Layton
+ */
+public class BukkitWorldListener extends WorldListener{
+    
+}
diff --git a/src/main/java/com/laytonsmith/abstraction/convert.java b/src/main/java/com/laytonsmith/abstraction/convert.java
new file mode 100644
index 0000000..dd3d300
--- /dev/null
+++ b/src/main/java/com/laytonsmith/abstraction/convert.java
@@ -0,0 +1,22 @@
+/*
+ * To change this template, choose Tools | Templates
+ * and open the template in the editor.
+ */
+package com.laytonsmith.abstraction;
+
+import java.lang.annotation.ElementType;
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
+import java.lang.annotation.Target;
+
+/**
+ * This annotation denotes that the marked class implements the noted
+ * server type's Convertor. Only one class should exist for each type,
+ * otherwise the behavior is undefined, but an error will be thrown.
+ * @author layton
+ */
+@Retention(RetentionPolicy.RUNTIME)
+@Target(ElementType.TYPE)
+public @interface convert {
+    Implementation.Type type();
+}
diff --git a/src/main/java/com/laytonsmith/aliasengine/AliasConfig.java b/src/main/java/com/laytonsmith/aliasengine/AliasConfig.java
deleted file mode 100644
index 6f727e4..0000000
--- a/src/main/java/com/laytonsmith/aliasengine/AliasConfig.java
+++ /dev/null
@@ -1,810 +0,0 @@
-
-package com.laytonsmith.aliasengine;
-
-//import com.laytonsmith.aliasengine.Constructs.*;
-//import com.laytonsmith.aliasengine.Constructs.Construct.*;
-//import com.laytonsmith.aliasengine.Constructs.Token.TType;
-//import com.laytonsmith.aliasengine.functions.Function;
-//import com.laytonsmith.aliasengine.functions.FunctionList;
-//import com.sk89q.bukkit.migration.PermissionsResolverManager;
-//import java.util.ArrayList;
-//import java.util.Arrays;
-//import java.util.HashMap;
-//import java.util.List;
-//import java.util.Stack;
-//import org.bukkit.entity.Player;
-
-/**
- *
- * @author Layton
- */
-public class AliasConfig {
-//
-//    /**
-//     * Once the config file is compiled, it gets added to this variable
-//     */
-//    Alias aliasFile = null;
-//    FunctionList func_list;
-//    PermissionsResolverManager perms;
-//    List<Script> scripts = new ArrayList<Script>();
-//
-//    /**
-//     * Constructor. Creates a compiled version of the given script.
-//     * @param config The config script to compile
-//     * @throws ConfigCompileException If there is a compiler error in the script
-//     */
-//    public AliasConfig(String config, User u, PermissionsResolverManager perms) throws ConfigCompileException{
-//        func_list = new FunctionList(u);
-//        this.perms = perms;
-//        //Convert all newlines into \n newlines
-//        config = config.replaceAll("\r\n", "\n");
-//        config = config + "\n"; //add a newline at the end so that parser will work. If it's extra,
-//        //nothing bad will happen, it'll just be ignored.
-//        ArrayList<Token> token_list = new ArrayList<Token>();
-//        //Set our state variables
-//        boolean state_in_quote = false;
-//        boolean in_comment = false;
-//        boolean in_opt_var = false;
-//        StringBuffer buf = new StringBuffer();
-//        int line_num = 1;
-//        //first we lex
-//        for(int i = 0; i < config.length(); i++){
-//            Character c = config.charAt(i);
-//            Character c2 = null;
-//            if(i < config.length() - 1){
-//                c2 = config.charAt(i + 1);
-//            }
-//            if(c == '\n'){
-//                line_num++;
-//            }
-//            if((token_list.isEmpty() || token_list.get(token_list.size() - 1).type.equals(TType.NEWLINE)) &&
-//                    c == '#'){
-//                in_comment = true;
-//            }
-//            if(in_comment && c != '\n'){
-//                continue;
-//            }
-//            if(c == '[' && !state_in_quote){
-//                if(buf.length() > 0){
-//                    token_list.add(new Token(TType.UNKNOWN, buf.toString(), line_num));
-//                    buf = new StringBuffer();
-//                }
-//                token_list.add(new Token(TType.OPT_VAR_START, "[", line_num));
-//                in_opt_var = true;
-//                continue;
-//            }
-//            if(c == '=' && !state_in_quote){
-//                if(buf.length() > 0){
-//                    token_list.add(new Token(TType.UNKNOWN, buf.toString(), line_num));
-//                    buf = new StringBuffer();
-//                }
-//                if(in_opt_var){
-//                    token_list.add(new Token(TType.OPT_VAR_ASSIGN, "=", line_num));
-//                } else{
-//                    token_list.add(new Token(TType.ALIAS_END, "=", line_num));
-//                }
-//                continue;
-//            }
-//            if(c == ']' && !state_in_quote){
-//                if(buf.length() > 0){
-//                    token_list.add(new Token(TType.UNKNOWN, buf.toString(), line_num));
-//                    buf = new StringBuffer();
-//                }
-//                token_list.add(new Token(TType.OPT_VAR_END, "]", line_num));
-//                in_opt_var = false;
-//                continue;
-//            }
-//            if(c == ':' && !state_in_quote){
-//                if(buf.length() > 0){
-//                    token_list.add(new Token(TType.UNKNOWN, buf.toString(), line_num));
-//                    buf = new StringBuffer();
-//                }
-//                token_list.add(new Token(TType.IDENT, ":", line_num));
-//                continue;
-//            }
-//            if(c == ',' && !state_in_quote){
-//                if(buf.length() > 0){
-//                    token_list.add(new Token(TType.UNKNOWN, buf.toString(), line_num));
-//                    buf = new StringBuffer();
-//                }
-//                token_list.add(new Token(TType.COMMA, ",", line_num));
-//                continue;
-//            }
-//            if(c == '(' && !state_in_quote){
-//                if(buf.length() > 0){
-//                    token_list.add(new Token(TType.FUNC_NAME, buf.toString(), line_num));
-//                    buf = new StringBuffer();
-//                }
-//                token_list.add(new Token(TType.FUNC_START, "(", line_num));
-//                continue;
-//            }
-//            if(c == ')' && !state_in_quote){
-//                if(buf.length() > 0){
-//                    token_list.add(new Token(TType.UNKNOWN, buf.toString(), line_num));
-//                    buf = new StringBuffer();
-//                }
-//                token_list.add(new Token(TType.FUNC_END, ")", line_num));
-//                continue;
-//            }
-//            if(Character.isWhitespace(c) && !state_in_quote && c != '\n'){
-//                //ignore the whitespace, but end the previous token
-//                if(buf.length() > 0){
-//                    token_list.add(new Token(TType.UNKNOWN, buf.toString(), line_num));
-//                    buf = new StringBuffer();
-//                }
-//            }
-//            else if(c == '\''){
-//                if(state_in_quote){
-//                    token_list.add(new Token(TType.STRING, buf.toString(), line_num));
-//                    buf = new StringBuffer();
-//                    state_in_quote = false;
-//                    continue;
-//                } else{
-//                    state_in_quote = true;
-//                    if(buf.length() > 0){
-//                        token_list.add(new Token(TType.UNKNOWN, buf.toString(), line_num));
-//                        buf = new StringBuffer();
-//                    }
-//                    continue;
-//                }
-//            } else if(c == '\\'){
-//                //escaped characters
-//                if(state_in_quote){
-//                    if(c2 == '\\'){
-//                        buf.append("\\");
-//                    } else if(c2 == '\''){
-//                        buf.append("'");
-//                    } else{
-//                        //Since we might expand this list later, don't let them
-//                        //use unescaped backslashes
-//                        throw new ConfigCompileException("The escape sequence \\" + c2 + " is not a recognized escape sequence", line_num);
-//                    }
-//                    
-//                    i++;
-//                    continue;
-//                } else{
-//                    //Control character backslash
-//                    token_list.add(new Token(TType.SEPERATOR, "\\", line_num));
-//                }
-//            } else if(state_in_quote){
-//                buf.append(c);
-//                continue;
-//            } else if(c == '\n'){
-//                if(buf.length() > 0){
-//                    token_list.add(new Token(TType.UNKNOWN, buf.toString(), line_num));
-//                    buf = new StringBuffer();
-//                }
-//                token_list.add(new Token(TType.NEWLINE, "\n", line_num));
-//                in_comment = false;
-//                continue;
-//            } else{ //in a literal
-//                buf.append(c);
-//                continue;
-//            }
-//        } //end lexing
-//
-//        //So, there has to be a more efficient way to do this, but I don't
-//        //really care right now. It's only read in occasionally, so it's no biggie.
-//
-//        //take out extra newlines
-//        ArrayList<Token> tokens1 = new ArrayList<Token>();
-//        for(int i = 0; i < token_list.size(); i++){
-//            try{
-//                if(token_list.get(i).type.equals(TType.NEWLINE)){
-//                    tokens1.add(new Token(TType.NEWLINE, "\n", line_num));
-//                    while(token_list.get(++i).type.equals(TType.NEWLINE)){
-//                    }
-//                }
-//                tokens1.add(token_list.get(i));
-//            } catch(IndexOutOfBoundsException e){}
-//        }
-//
-//        //Handle multiline constructs
-//        ArrayList<Token> tokens1_1 = new ArrayList<Token>();
-//        boolean inside_multiline = false;
-//        for(int i = 0; i < tokens1.size(); i++){
-//            Token prevToken = i - 1 >= tokens1.size()?tokens1.get(i - 1):new Token(TType.UNKNOWN, "", 0);
-//            Token thisToken = tokens1.get(i);
-//            Token nextToken = i + 1 < tokens1.size()?tokens1.get(i + 1):new Token(TType.UNKNOWN, "", 0);
-//            //take out newlines between the = >>> and <<< tokens (also the tokens)
-//            if(thisToken.type.equals(TType.ALIAS_END) && nextToken.val().equals(">>>")){
-//                inside_multiline = true;
-//                tokens1_1.add(thisToken);
-//                i++;
-//                continue;
-//            }
-//            if(thisToken.val().equals("<<<")){
-//                if(!inside_multiline){
-//                    throw new ConfigCompileException("Found multiline end symbol, and no multiline start found",
-//                            thisToken.line_num);
-//                }
-//                inside_multiline = false;
-//                continue;
-//            }
-//            if(thisToken.val().equals(">>>") && !prevToken.type.equals(TType.ALIAS_END)){
-//                throw new ConfigCompileException("Multiline symbol must follow the alias_end token", thisToken.line_num);
-//            }
-//
-//            //If we're not in a multiline construct, or we are in it and it's not a newline, add
-//            //it
-//            if(!inside_multiline || (inside_multiline && !thisToken.type.equals(TType.NEWLINE))){
-//                tokens1_1.add(thisToken);
-//            }
-//        }
-//
-//        //take out newlines that are behind a \
-//        ArrayList<Token> tokens2 = new ArrayList<Token>();
-//        for(int i = 0; i < tokens1_1.size(); i++){
-//            if(!tokens1_1.get(i).type.equals(TType.STRING) && tokens1_1.get(i).val().equals("\\") && tokens1_1.size() > i
-//                    && tokens1_1.get(i + 1).type.equals(TType.NEWLINE)){
-//                tokens2.add(tokens1_1.get(i));
-//                i++;
-//                continue;
-//            }
-//            tokens2.add(tokens1_1.get(i));
-//        }
-//
-//
-//
-//        //look at the tokens, and get meaning from them
-//        for(Token t : tokens2){
-//            if(t.type.equals(TType.UNKNOWN)){
-//                if(t.val().matches("/.*")){
-//                    t.type = TType.COMMAND;
-//                } else if(t.val().matches("\\\\")){
-//                    t.type = TType.SEPERATOR;
-//                } else if(t.val().matches("\\$[a-zA-Z0-9_]+")){
-//                    t.type = TType.VARIABLE;
-//                } else if(t.val().matches("\\@[a-zA-Z0-9_]+")){
-//                    t.type = TType.IVARIABLE;
-//                } else if(t.val().equals("$")){
-//                    t.type = TType.FINAL_VAR;
-//                }
-//                else {
-//                    t.type = TType.LIT;
-//                }
-//            }
-//        }
-//
-//        //split the tokens into seperate commands now
-//        ArrayList<Token> aliasBuffer = new ArrayList<Token>();
-//        ArrayList<ArrayList<Token>> commandBuffer = new ArrayList<ArrayList<Token>>();
-//        ArrayList<Token> tinyCmdBuffer = new ArrayList<Token>();
-//        boolean in_alias = true;
-//        Alias a = new Alias();
-//        for(Token t : tokens2){
-//            if(t.type.equals(TType.NEWLINE)){
-//                if(aliasBuffer.size() > 0){
-//                    if(in_alias){
-//                        throw new ConfigCompileException("Unexpected newline", t.line_num);
-//                    }
-//                    if(commandBuffer.size() > 0 || tinyCmdBuffer.size() > 0){
-//                        commandBuffer.add((ArrayList<Token>)tinyCmdBuffer.clone());
-//                        a.alias.add(new AliasString(aliasBuffer));
-//                        ArrayList<AliasString> tempBuf = new ArrayList<AliasString>();
-//                        for(int i = 0; i < commandBuffer.size(); i++){
-//                            ArrayList<Token> tlist = commandBuffer.get(i);
-//                            tempBuf.add(new AliasString(tlist));
-//                        }
-//                        a.real.add(tempBuf);
-//                        aliasBuffer.clear();
-//                        commandBuffer.clear();
-//                        tinyCmdBuffer.clear();
-//                        in_alias = true;
-//                        continue;
-//                    }
-//                }
-//            }
-//            else if(t.type.equals(TType.ALIAS_END)){
-//                in_alias = false;
-//            } else {
-//                if(in_alias){
-//                    aliasBuffer.add(t);
-//                } else{
-//                    if(t.type.equals(TType.SEPERATOR)){
-//                        commandBuffer.add((ArrayList<Token>)tinyCmdBuffer.clone());
-//                        tinyCmdBuffer.clear();
-//                    } else{
-//                        tinyCmdBuffer.add(t);
-//                    }
-//                }
-//            }
-//
-//        }
-//        //Check the syntax. Look for mismatched variables, mismatched parenthesis and square brackets,
-//        //missing commands, bad function names, strings on the left side (except directly after a
-//        //opt_var_assign), optional args on the right
-//        /**
-//         * Valid tokens on left:
-//         * command, opt_var_start, variable, final_var, opt_var_assign, opt_var_end, lit,
-//         * string (only directly after opt_var_assign)
-//         */
-//        for(int i = 0; i < a.alias.size(); i++){
-//            AliasString c = a.alias.get(i);
-//            ArrayList<AliasString> real = a.real.get(i);
-//            ArrayList<Variable> left_vars = new ArrayList<Variable>();
-//            ArrayList<Variable> right_vars = new ArrayList<Variable>();
-//            boolean inside_opt_var = false;
-//            boolean after_no_def_opt_var = false;
-//            boolean has_label = false;
-//            for(int j = 0; j < c.tokens.size(); j++){
-//               Token t = c.tokens.get(j);
-//               //Token prev_token = j - 2 >= 0?c.tokens.get(j - 2):new Token(TType.UNKNOWN, "", t.line_num);
-//               Token last_token = j - 1 >= 0?c.tokens.get(j - 1):new Token(TType.UNKNOWN, "", t.line_num);
-//               Token next_token = j + 1 < c.tokens.size()?c.tokens.get(j + 1):new Token(TType.UNKNOWN, "", t.line_num);
-//               Token after_token = j + 2 < c.tokens.size()?c.tokens.get(j + 2):new Token(TType.UNKNOWN, "", t.line_num);
-//               
-//               if(j == 0){
-//                   if(next_token.type == TType.IDENT){
-//                       a.labels.add(t.val());
-//                       has_label = true;
-//                   } else {
-//                       a.labels.add(null);
-//                   }
-//               }
-//               
-//               if(t.type == TType.IDENT){
-//                   continue;
-//               }
-//
-//               if(t.type.equals(TType.FINAL_VAR) && c.tokens.size() - j >= 5){
-//                   throw new ConfigCompileException("FINAL_VAR must be the last argument in the alias", t.line_num);
-//               }
-//               if(t.type.equals(TType.VARIABLE) || t.type.equals(TType.FINAL_VAR)){
-//                   left_vars.add(new Variable(t.val(), null, t.line_num));
-//               }
-//               if(j == 0 && !t.type.equals(TType.COMMAND)){
-//                   if(!(next_token.type == TType.IDENT && after_token.type == TType.COMMAND)){
-//                       throw new ConfigCompileException("Expected command (/command) at start of alias." +
-//                               " Instead, found " + t.type + " (" + t.val() + ")", t.line_num);
-//                   }
-//               }
-//               if(after_no_def_opt_var && !inside_opt_var){
-//                   if(t.type.equals(TType.LIT) || t.type.equals(TType.STRING) || t.type.equals(TType.OPT_VAR_ASSIGN)){
-//                       throw new ConfigCompileException("You cannot have anything other than optional arguments after your" +
-//                               " first optional argument, other that other optional arguments with no default", t.line_num);
-//                   }
-//               }
-//               if(!t.type.equals(TType.OPT_VAR_START) &&
-//                       !t.type.equals(TType.OPT_VAR_ASSIGN) &&
-//                       !t.type.equals(TType.OPT_VAR_END) &&
-//                       !t.type.equals(TType.VARIABLE) &&
-//                       !t.type.equals(TType.LIT) &&
-//                       !t.type.equals(TType.COMMAND) &&
-//                       !t.type.equals(TType.FINAL_VAR)){
-//                   if(!(t.type.equals(TType.STRING) && j - 1 > 0 && c.tokens.get(j - 1).type.equals(TType.OPT_VAR_ASSIGN)))
-//                       throw new ConfigCompileException("Unexpected " + t.type + " (" + t.val() + ")", t.line_num);
-//               }
-//               if(last_token.type.equals(TType.COMMAND)){
-//                   if(!(t.type.equals(TType.VARIABLE) || t.type.equals(TType.OPT_VAR_START) || t.type.equals(TType.FINAL_VAR) ||
-//                            t.type.equals(TType.LIT))){
-//                       throw new ConfigCompileException("Unexpected " + t.type + " (" + t.val() + ") after command", t.line_num);
-//                   }
-//               }
-//               if(last_token.type.equals(TType.OPT_VAR_START)){
-//                   inside_opt_var = true;
-//                   if(!(t.type.equals(TType.FINAL_VAR) || t.type.equals(TType.VARIABLE))){
-//                       throw new ConfigCompileException("Unexpected " + t.type.toString() + " (" + t.val() + ")", t.line_num);
-//                   }
-//               }
-//               if(inside_opt_var && t.type.equals(TType.OPT_VAR_ASSIGN)){
-//                   if(!((next_token.type.equals(TType.STRING) || next_token.type.equals(TType.LIT)) && after_token.type.equals(TType.OPT_VAR_END) ||
-//                           (next_token.type.equals(TType.OPT_VAR_END)))){
-//                       throw new ConfigCompileException("Unexpected token in optional variable", t.line_num);
-//                   } else if(next_token.type.equals(TType.STRING) || next_token.type.equals(TType.LIT)){
-//                       left_vars.get(left_vars.size() - 1).def = next_token.val();
-//                   } else {
-//                       left_vars.get(left_vars.size() - 1).def = "";
-//                   }
-//               }
-//               if(t.type.equals(TType.OPT_VAR_END)){
-//                   if(!inside_opt_var){
-//                       throw new ConfigCompileException("Unexpected " + t.type.toString(), t.line_num);
-//                   }
-//                   inside_opt_var = false;
-//                   if(last_token.type.equals(TType.VARIABLE)
-//                           || last_token.type.equals(TType.FINAL_VAR)){
-//                       after_no_def_opt_var = true;
-//                   }
-//               }
-//            }
-//            if(has_label){
-//                //remove the label from the alias
-//                a.alias.get(i).tokens.remove(0);
-//                a.alias.get(i).tokens.remove(0);
-//            }
-//            ArrayList<GenericTree<Construct>> rightTreeOne = new ArrayList<GenericTree<Construct>>();
-//
-//            //Compile the right side into a program
-//            for(int j = 0; j < real.size(); j++){
-//                AliasString r = real.get(j);
-//                int paren_stack = 0;
-//                GenericTree<Construct> root = new GenericTree<Construct>();
-//                //root.setRoot(new GenericTreeNode<Construct>(new Token(TType.ROOT, "root", 0)));
-//                GenericTreeNode<Construct> node = root.getRoot();
-//                Stack<GenericTreeNode> parents = new Stack<GenericTreeNode>();
-//                parents.push(root.getRoot());
-//                for(int k = 0; k < r.tokens.size(); k++){
-//                    Token t = r.tokens.get(k);
-//                    //Token before = k - 2 >= 0?r.tokens.get(k - 2):new Token(TType.UNKNOWN, "", t.line_num);
-//                    Token prev = k - 1 >= 0?r.tokens.get(k - 1):new Token(TType.UNKNOWN, "", t.line_num);
-//                    //Token next = k + 1 < r.tokens.size()?r.tokens.get(k + 1):new Token(TType.UNKNOWN, "", t.line_num);
-//                    //Token after = k + 2 < r.tokens.size()?r.tokens.get(k + 2):new Token(TType.UNKNOWN, "", t.line_num);
-//                    if(k == 0 && !t.type.equals(TType.COMMAND) && !t.type.equals(TType.FUNC_NAME)){
-//                        throw new ConfigCompileException("Expected command (/command) or function at start of" +
-//                                " command", t.line_num);
-//                    }
-//                    if(t.type.equals(TType.OPT_VAR_ASSIGN) || t.type.equals(TType.OPT_VAR_START)
-//                            || t.type.equals(TType.OPT_VAR_END)){
-//                        throw new ConfigCompileException("Unexpected " + t.type.toString(), t.line_num);
-//                    }
-//                    if(t.type.equals(TType.LIT)){
-//                        //See what the type of each literal is, and see if it's a double, int, boolean, null, or other keyword.
-//                        node.addChild(new GenericTreeNode<Construct>(Static.resolveConstruct(t.val(), t.line_num)));
-//                    } else if(t.type.equals(TType.STRING)){
-//                        node.addChild(new GenericTreeNode<Construct>(new CString(t.val(), t.line_num)));
-//                    } else if(t.type.equals(TType.IVARIABLE)){
-//                        node.addChild(new GenericTreeNode<Construct>(new IVariable(t.val(), line_num)));
-//                    } else if(t.type.equals(TType.VARIABLE) || t.type.equals(TType.FINAL_VAR)){
-//                        node.addChild(new GenericTreeNode<Construct>(new Variable(t.val(), null, t.line_num)));
-//                        right_vars.add(new Variable(t.val(), null, t.line_num));
-//                    } else if(t.type.equals(TType.FUNC_NAME)){
-//                        try {
-//                            GenericTreeNode<Construct> f = new GenericTreeNode<Construct>(new CFunction(t.val(), t.line_num));
-//                            node.addChild(f);
-//                            node = f;
-//                            parents.push(f);
-//                        } catch (Exception ex) {
-//                            throw new ConfigCompileException("\"" + t.val() + "\" is not a built in function", t.line_num);
-//                        }
-//                    } else if(t.type.equals(TType.FUNC_START)){
-//                        if(!prev.type.equals(TType.FUNC_NAME)){
-//                            throw new ConfigCompileException("Unexpected parenthesis", t.line_num);
-//                        }
-//                        paren_stack++;
-//                        continue;
-//                    } else if(t.type.equals(TType.FUNC_END)){
-//                        paren_stack--;
-//                        if(paren_stack < 0){
-//                            throw new ConfigCompileException("Unexpected parenthesis", t.line_num);
-//                        }
-//                        parents.pop();
-//                        node = parents.peek();
-//                    } else if(t.type.equals(TType.COMMAND)){
-//                        //For the sake of standardization, add this as a string
-//                        node.addChild(new GenericTreeNode<Construct>(new CString(t.val(), t.line_num)));
-//                    } else if(t.type.equals(TType.COMMA)){
-//                        continue;
-//                    } else{
-//                        throw new ConfigCompileException("Unexpected " + t.type + " (" + t.val() + ")", t.line_num);
-//                    }
-//                }
-//                rightTreeOne.add(root);
-//                List<GenericTreeNode<Construct>> l = root.build(GenericTreeTraversalOrderEnum.PRE_ORDER);
-//                for(GenericTreeNode<Construct> n : l){
-//                    if(n.getData() instanceof CFunction){
-//                        int args = n.getChildren().size();
-//                        Function f = func_list.getFunction((CFunction)n.getData());
-//                        List<Integer> numArgs = Arrays.asList(f.numArgs());
-//                        if(f.isRestricted()){
-//                            boolean perm;
-//                            if(u != null && perms != null){
-//                                perm = perms.hasPermission(u.player.getName(), "ch.func.compile." + f.getName())
-//                                        || perms.hasPermission(u.player.getName(), "commandhelper.func.compile." + f.getName());
-//                            } else {
-//                                perm = true;
-//                            }
-//                            if(!perm){
-//                                throw new ConfigCompileException("You do not have permission to compile the " + f.getName() + " function" +
-//                                        " into your script.");
-//                            }
-//                        }
-//                        if(!numArgs.contains(args) &&
-//                                !numArgs.contains(Integer.MAX_VALUE)){
-//                            throw new ConfigCompileException("Incorrect number of args for " +
-//                                    ((CFunction)n.getData()).toString(), n.data.line_num);
-//                        }
-//                    }
-//                }
-//                //Look to see if all the variables defined on the left are used on the right
-//                for(Variable left_var : left_vars){
-//                    boolean found = false;
-//                    for(Variable right_var : right_vars){
-//                        if(left_var.name.equals(right_var.name)){
-//                            found = true;
-//                            break;
-//                        }
-//                    }
-//                    if(!found){
-//                        //Just a warning in this case
-//                        if((Boolean)Static.getPreferences().getPreference("show-warnings")){
-//                            System.err.println("Notice: Defined variable " + left_var.name + " is unused near line " + left_var.line_num);
-//                        }
-//                    }
-//                }
-//                //Look to see if all the variables on the right are defined on the left
-//                for(Variable right_var : right_vars){
-//                    boolean found = false;
-//                    for(Variable left_var : left_vars){
-//                        if(right_var.name.equals(left_var.name)){
-//                            found = true;
-//                            right_var.def = left_var.def;
-//                            break;
-//                        }
-//                    }
-//                    if(!found){
-//                        //This is a fatal error
-//                        throw new ConfigCompileException("Undefined variable " + right_var.name, right_var.line_num);
-//                    }
-//                }
-//
-//
-//            }
-//            a.rightTrees.add(rightTreeOne);
-//        }
-//        //Compile the (now syntactically correct) left side into a ArrayList<Construct>
-//        for(int i = 0; i < a.alias.size(); i++){
-//            AliasString c = a.alias.get(i);
-//            ArrayList<Construct> ac = new ArrayList<Construct>();
-//            for(int j = 0; j < c.tokens.size(); j++){
-//                Token t = c.tokens.get(j);
-//                if(t.type.equals(TType.VARIABLE)){
-//                    ac.add(new Variable(t.val(), null, t.line_num));
-//                } else if(t.type.equals(TType.FINAL_VAR)){
-//                    Variable v = new Variable(t.val(), null, t.line_num);
-//                    v.final_var = true;
-//                    ac.add(v);
-//                }else if(t.type.equals(TType.OPT_VAR_START)){
-//                    if(j + 2 < c.tokens.size() && c.tokens.get(j + 2).type.equals(TType.OPT_VAR_ASSIGN)){
-//                        Variable v = new Variable(c.tokens.get(j + 1).val(),
-//                                c.tokens.get(j + 3).val(), t.line_num);
-//                        v.optional = true;
-//                        if(c.tokens.get(j + 1).type.equals(TType.FINAL_VAR))
-//                            v.final_var = true;
-//                        ac.add(v);
-//                        j += 4;
-//                    } else{
-//                        t = c.tokens.get(j + 1);
-//                        Variable v = new Variable(t.val(), null, t.line_num);
-//                        v.optional = true;
-//                        if(t.val().equals("$"))
-//                            v.final_var = true;
-//                        ac.add(v);
-//                        j += 2;
-//                    }
-//                } else if(t.type.equals(TType.COMMAND)){
-//                    ac.add(new Command(t.val(), t.line_num));
-//                } else{
-//                    //Don't care what it is now. Just add it.
-//                    //ac.add(t);
-//                }
-//
-//            }
-//            a.aliasConstructs.add(ac);
-//        }
-//
-//        //Check for commands with ambiguous signatures.
-//
-//        for(int i = 0; i < a.aliasConstructs.size(); i++){
-//            ArrayList<Construct> thisCommand = a.aliasConstructs.get(i);
-//            for(int j = 0; j < a.aliasConstructs.size(); j++){
-//                if(i == j){
-//                    //Of course this command is going to match it's own signature
-//                    continue;
-//                }
-//                ArrayList<Construct> thatCommand = a.aliasConstructs.get(j);
-//                boolean soFarAMatch = true;
-//                for(int k = 0; k < thisCommand.size(); k++){
-//                    try{
-//                        Construct c1 = thisCommand.get(k);
-//                        Construct c2 = thatCommand.get(k);
-//                        if(c1.ctype != c2.ctype || ((c1 instanceof Variable) && !((Variable)c1).optional)){
-//                            soFarAMatch = false;
-//                        } else {
-//                            //It's a literal, check to see if it's the same literal
-//                            if(c1.val() == null || !c1.val().equals(c2.val())){
-//                                soFarAMatch = false;
-//                            }
-//                        }
-//                    } catch(IndexOutOfBoundsException e){
-//                        /**
-//                         * The two commands:
-//                         * /cmd $var1 [$var2]
-//                         * /cmd $var1
-//                         * would cause this exception to be thrown, but the signatures
-//                         * are the same, so the fact that they've matched this far means
-//                         * they are ambiguous. However,
-//                         * /cmd $var1 $var2
-//                         * /cmd $var1
-//                         * is not ambiguous
-//                         */
-//                        //thatCommand is the short one
-//                        if(!(thisCommand.get(k) instanceof Variable) ||
-//                                (thisCommand.get(k) instanceof Variable &&
-//                                !((Variable)thisCommand.get(k)).optional)){
-//                            soFarAMatch = false;
-//                        }
-//                    }
-//                }
-//                if(thatCommand.size() > thisCommand.size()){
-//                    int k = thisCommand.size();
-//                    //thisCommand is the short one
-//                    if(!(thatCommand.get(k) instanceof Variable) ||
-//                            (thatCommand.get(k) instanceof Variable &&
-//                            !((Variable)thatCommand.get(k)).optional)){
-//                        soFarAMatch = false;
-//                    }
-//                }
-//
-//                if(soFarAMatch) {
-//                    String commandThis = "";
-//                    for (Construct c : thisCommand) {
-//                        commandThis += c.val() + " ";
-//                    }
-//                    String commandThat = "";
-//                    for (Construct c : thatCommand) {
-//                        commandThat += c.val() + " ";
-//                    }
-//                    throw new ConfigCompileException("The command " + commandThis + "is ambiguous because it "
-//                            + "matches the signature of " + commandThat, thisCommand.get(0).line_num);
-//                }
-//            }
-//        }
-//
-//        if(a.real.isEmpty()){
-//            System.out.println("No Aliases were defined.");
-//        }
-//        else{
-//            System.out.println("Config file compiled sucessfully, with " + a.alias.size() + " alias(es) defined.");
-//            aliasFile = a;
-//        }
-//    }
-//
-//    /**
-//     * This is the command that runs the magic once the config file is compiled and tucked away.
-//     * It takes a real command from the user and sees if it fits with any of the aliases. If it
-//     * does, it actually returns the commands to run. Since it's a bit more complicated than just
-//     * returning a string, it returns a "RunnableAlias" that has implementation specific functions
-//     * in it. Mostly what this function does is, selects the proper command from the command
-//     * list, fills in the variables, then returns the ArrayList.
-//     * @param command
-//     * @return
-//     */
-//    public RunnableAlias getRunnableAliases(String command, Player player){
-////        if(this.aliasFile == null){
-////            return null;
-////        }
-////        String[] cmds = command.split(" ");
-////        ArrayList<String> args = new ArrayList(Arrays.asList(cmds));
-////        for(int i = 0; i < this.aliasFile.alias.size(); i++){
-////            ArrayList<Construct> tokens = this.aliasFile.aliasConstructs.get(i);
-////            boolean isAMatch = true;
-////            StringBuilder lastVar = new StringBuilder();
-////            int lastJ = 0;
-////            try{
-////                for(int j = 0; j < tokens.size(); j++){
-////                    if(!isAMatch){                        
-////                        break;
-////                    }
-////                    lastJ = j;
-////                    Construct c = tokens.get(j);
-////                    String arg = args.get(j);
-////                    if(c.ctype == ConstructType.COMMAND || 
-////                            c.ctype == ConstructType.TOKEN ||
-////                            c.ctype == ConstructType.LITERAL){
-////                        if(!c.val().equals(arg)){
-////                            isAMatch = false;
-////                        }
-////                    }
-////                    if(j == tokens.size() - 1){
-////                        if(tokens.get(j).ctype == ConstructType.VARIABLE){
-////                            Variable lv = (Variable)tokens.get(j);
-////                            if(lv.final_var){
-////                                for(int a = j; a < args.size(); a++){
-////                                    if(lastVar.length() == 0){
-////                                        lastVar.append(args.get(a));
-////                                    }
-////                                    else {
-////                                        lastVar.append(" ").append(args.get(a));
-////                                    }
-////                                }
-////                            }
-////                        }
-////                    }
-////                }
-////            } catch(IndexOutOfBoundsException e){
-////                if(tokens.get(lastJ).ctype == ConstructType.VARIABLE &&
-////                        !((Variable)tokens.get(lastJ)).optional){
-////                    isAMatch = false;
-////                }
-////            }
-////            if(isAMatch){
-////                //Now, pull out the variables. That's all we care about in the left
-////                //side now
-////                ArrayList<Variable> vars = new ArrayList<Variable>();
-////                Variable v = null;
-////                for(int j = 0; j < tokens.size(); j++){
-////                    try{
-////                        if(tokens.get(j).ctype == ConstructType.VARIABLE){
-////                            if(((Variable)tokens.get(j)).name.equals("$")){
-////                                v = new Variable(((Variable)tokens.get(j)).name,
-////                                        lastVar.toString(), 0);
-////                            } else {
-////                                v = new Variable(((Variable)tokens.get(j)).name,
-////                                        args.get(j), 0);
-////                            }
-////                        }
-////                    } catch(IndexOutOfBoundsException e){
-////                        v = new Variable(((Variable)tokens.get(j)).name,
-////                                ((Variable)tokens.get(j)).def, 0);
-////                    }
-////                    if(v != null)
-////                        vars.add(v);
-////                }
-////
-////                ArrayList<GenericTree<Construct>> tree = aliasFile.rightTrees.get(i);
-////                for(GenericTree<Construct> t : tree){
-////                    for(GenericTreeNode g : t.build(GenericTreeTraversalOrderEnum.PRE_ORDER)){
-////                        Construct c = (Construct)g.data;
-////                        if(c instanceof Variable){
-////                            Variable var = (Variable)c;
-////                            String def = "";
-////                            for(Variable vv : vars){
-////                                if(vv.name.equals(var.name)){
-////                                    def = vv.def;
-////                                    break;
-////                                }
-////                            }
-////                            var.def = def;
-////                        }
-////                    }
-////                }
-////                return new RunnableAlias(this.aliasFile.labels.get(i), tree, player, func_list, command);
-////            }
-////        }
-//
-//        return null;
-//    }
-//
-//    public int totalAliases(){
-//        return aliasFile.alias.size();
-//    }
-//
-//
-//    public class Alias{
-//        ArrayList<AliasString> alias = new ArrayList<AliasString>();
-//        ArrayList<ArrayList<Construct>> aliasConstructs = new ArrayList<ArrayList<Construct>>();
-//        ArrayList<ArrayList<AliasString>> real = new ArrayList<ArrayList<AliasString>>();
-//        ArrayList<String> labels = new ArrayList<String>();
-//        ArrayList<ArrayList<GenericTree<Construct>>> rightTrees = new ArrayList<ArrayList<GenericTree<Construct>>>();
-//        HashMap<AliasString, ArrayList<AliasString>> map = new HashMap<AliasString, ArrayList<AliasString>>();
-//        @Override
-//        public String toString(){
-//            StringBuilder b = new StringBuilder();
-//            for(int i = 0; i < alias.size(); i++){
-//                b.append("\nAlias: ");
-//                b.append(alias.get(i));
-//                for(int j = 0; j < real.get(i).size(); j++){
-//                    b.append("\n\t").append(real.get(i).get(j));
-//                }
-//            }
-//            return b.toString();
-//        }
-//    }
-//
-//    public class AliasString{
-//        ArrayList<Token> tokens = new ArrayList<Token>();
-//        public AliasString(ArrayList<Token> a){
-//            tokens = (ArrayList<Token>) a.clone();
-//        }
-//        @Override
-//        public String toString(){
-//            StringBuilder b = new StringBuilder();
-//            for(Token t : tokens){
-//                b.append(t.toSimpleString()).append(" ");
-//            }
-//            return b.toString();
-//        }
-//    }
-
-}
diff --git a/src/main/java/com/laytonsmith/aliasengine/AliasCore.java b/src/main/java/com/laytonsmith/aliasengine/AliasCore.java
deleted file mode 100644
index dc093a1..0000000
--- a/src/main/java/com/laytonsmith/aliasengine/AliasCore.java
+++ /dev/null
@@ -1,347 +0,0 @@
-/*
- * To change this template, choose Tools | Templates
- * and open the template in the editor.
- */
-package com.laytonsmith.aliasengine;
-
-import com.laytonsmith.aliasengine.functions.exceptions.ConfigCompileException;
-import com.laytonsmith.aliasengine.functions.exceptions.ConfigRuntimeException;
-import com.laytonsmith.PureUtilities.Preferences;
-import com.laytonsmith.aliasengine.functions.IncludeCache;
-import com.sk89q.bukkit.migration.PermissionsResolverManager;
-import com.sk89q.commandhelper.CommandHelperPlugin;
-import java.io.*;
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.HashSet;
-import java.util.List;
-import java.util.Set;
-import java.util.logging.Level;
-import java.util.logging.Logger;
-import org.bukkit.ChatColor;
-import org.bukkit.command.CommandSender;
-import org.bukkit.entity.Player;
-
-/**
- * This class contains all the handling code. It only deals with built-in Java Objects,
- * so that if the Minecraft API Hook changes, porting the code will only require changing
- * the API specific portions, not this core file.
- * @author Layton
- */
-public class AliasCore {
-
-    private File aliasConfig;
-    private File prefFile;
-    //AliasConfig config;
-    List<Script> scripts;
-    static final Logger logger = Logger.getLogger("Minecraft");
-    private Set<String> echoCommand = new HashSet<String>();
-    private PermissionsResolverManager perms;
-    public static CommandHelperPlugin parent;
-
-    /**
-     * This constructor accepts the configuration settings for the plugin, and ensures
-     * that the manager uses these settings.
-     * @param allowCustomAliases Whether or not to allow users to add their own personal aliases
-     * @param maxCustomAliases How many aliases a player is allowed to have. -1 is unlimited.
-     * @param maxCommands How many commands an alias may contain. Since aliases can be used like a
-     * macro, this can help prevent command spamming.
-     */
-    public AliasCore(File aliasConfig, File prefFile, PermissionsResolverManager perms, CommandHelperPlugin parent) throws ConfigCompileException {
-        this.aliasConfig = aliasConfig;
-        this.prefFile = prefFile;
-        this.perms = perms;
-        this.parent = parent;
-        reload();
-    }
-
-    /**
-     * This is the workhorse function. It takes a given command, then converts it
-     * into the actual command(s). If the command maps to a defined alias, it will
-     * run the specified alias. It will search through the
-     * global list of aliases, as well as the aliases defined for that specific player.
-     * This function doesn't handle the /alias command however.
-     * @param command
-     * @return
-     */
-    public boolean alias(String command, final CommandSender player, ArrayList<Script> playerCommands) {
-
-        if (scripts == null) {
-            throw new ConfigRuntimeException("Cannot run alias commands, no config file is loaded", 0, null);
-        }
-
-        boolean match = false;
-        try { //catch RuntimeException
-            //If player is null, we are running the test harness, so don't
-            //actually add the player to the array.
-            if (player != null && player instanceof Player && echoCommand.contains(((Player) player).getName())) {
-                //we are running one of the expanded commands, so exit with false
-                return false;
-            }
-
-            //Global aliases override personal ones, so check the list first
-            //a = config.getRunnableAliases(command, player);
-            for (Script s : scripts) {
-                try {
-                    if (s.match(command)) {
-                        this.addPlayerReference(player);
-                        if ((Boolean) Static.getPreferences().getPreference("console-log-commands")) {
-                            Static.getLogger().log(Level.INFO, "CH: Running original command ----> " + command);
-                            if (player instanceof Player) {
-                                Static.getLogger().log(Level.INFO, "on player " + ((Player) player).getName());
-                            } else {
-                                Static.getLogger().log(Level.INFO, "from a CommandSender");
-                            }
-                        }
-                        try {
-                            s.run(s.getVariables(command), player, new MScriptComplete() {
-
-                                public void done(String output) {
-                                    try {
-                                        if (output != null) {
-                                            if (!output.trim().equals("") && output.trim().startsWith("/")) {
-                                                if ((Boolean) Static.getPreferences().getPreference("debug-mode")) {
-                                                    if (player instanceof Player) {
-                                                        Static.getLogger().log(Level.INFO, "[CommandHelper]: Executing command on " + ((Player) player).getName() + ": " + output.trim());
-                                                    } else {
-                                                        Static.getLogger().log(Level.INFO, "[CommandHelper]: Executing command from console equivalent: " + output.trim());
-                                                    }
-                                                }
-                                                //Sometimes bukkit works with one version of this, sometimes with the other. performCommand would be prefered, but
-                                                //chat works more often, because chat actually triggers a CommandPreprocessEvent, unlike performCommand.
-                                                if (player instanceof Player) {
-                                                    ((Player) player).chat(output.trim());
-                                                } else {
-                                                    Static.getServer().dispatchCommand(player, output.trim().substring(1));
-                                                }
-                                                //player.performCommand(output.trim().substring(1));
-                                            }
-                                        }
-                                    } catch (Throwable e) {
-                                        System.err.println(e.getMessage());
-                                        player.sendMessage(ChatColor.RED + e.getMessage());
-                                    } finally {
-                                        Static.getAliasCore().removePlayerReference(player);
-                                    }
-                                }
-                            });
-                        } catch (/*ConfigRuntimeException*/Throwable e) {
-                            System.err.println("An unexpected exception occured: " + e.getClass().getSimpleName());
-                            player.sendMessage("An unexpected exception occured: " + ChatColor.RED + e.getClass().getSimpleName());
-                            e.printStackTrace();
-                        } finally {
-                            Static.getAliasCore().removePlayerReference(player);
-                        }
-                        match = true;
-                        break;
-                    }
-                } catch (Exception e) {
-                    System.err.println("An unexpected exception occured inside the command " + s.toString());
-                    e.printStackTrace();
-                }
-            }
-
-            if (player instanceof Player) {
-                if (match == false && playerCommands != null) {
-                    //if we are still looking, look in the aliases for this player
-                    for (Script ac : playerCommands) {
-                        //RunnableAlias b = ac.getRunnableAliases(command, player);
-                        try {
-                            ac.compile();
-                            if (ac.match(command)) {
-                                Static.getAliasCore().addPlayerReference(player);
-                                try {
-                                    ac.run(ac.getVariables(command), player, new MScriptComplete() {
-
-                                        public void done(String output) {
-                                            if (output != null) {
-                                                if (!output.trim().equals("") && output.trim().startsWith("/")) {
-                                                    if ((Boolean) Static.getPreferences().getPreference("debug-mode")) {
-                                                        Static.getLogger().log(Level.INFO, "[CommandHelper]: Executing command on " + ((Player)player).getName() + ": " + output.trim());
-                                                    }
-                                                    ((Player)player).chat(output.trim());
-                                                }
-                                            }
-                                            Static.getAliasCore().removePlayerReference(player);
-                                        }
-                                    });
-                                } catch (/*ConfigRuntimeException*/Throwable e) {
-                                    System.err.println(e.getMessage());
-                                    player.sendMessage(ChatColor.RED + e.getMessage());
-                                    Static.getAliasCore().removePlayerReference(player);
-                                }
-                                match = true;
-                            }
-                        } catch (Exception e) {
-                            ((Player)player).chat("An exception occured while trying to compile/run your alias: " + e.getMessage());
-                        }
-                    }
-
-                }
-            }
-        } catch (Throwable e) {
-            throw new InternalException("An error occured in the CommandHelper plugin: " + e.getMessage() + Arrays.asList(e.getStackTrace()));
-        }
-        return match;
-    }
-
-    /**
-     * Loads the global alias file in from
-     */
-    public final boolean reload() throws ConfigCompileException {
-        boolean is_loaded = false;
-        try {
-            IncludeCache.clearCache(); //Clear the include cache, so it re-pulls files
-            if (!aliasConfig.exists()) {
-                aliasConfig.getParentFile().mkdirs();
-                aliasConfig.createNewFile();
-                try {
-                    String samp_config = getStringResource(AliasCore.class.getResourceAsStream("/samp_config.txt"));
-                    //Because the sample config may have been written an a machine that isn't this type, replace all
-                    //line endings
-                    samp_config = samp_config.replaceAll("\n|\r\n", System.getProperty("line.separator"));
-                    file_put_contents(aliasConfig, samp_config, "o");
-                } catch (Exception e) {
-                    logger.log(Level.WARNING, "CommandHelper: Could not write sample config file");
-                }
-            }
-
-            Preferences prefs = Static.getPreferences();
-            prefs.init(prefFile);
-
-            String alias_config = file_get_contents(aliasConfig.getAbsolutePath()); //get the file again
-            //config = new AliasConfig(alias_config, null, perms);
-            scripts = MScriptCompiler.preprocess(MScriptCompiler.lex(alias_config, aliasConfig));
-            for (Script s : scripts) {
-                try {
-                    s.compile();
-                    s.checkAmbiguous((ArrayList<Script>) scripts);
-                } catch (ConfigCompileException e) {
-                    logger.log(Level.SEVERE, "[CommandHelper]: " + e.toString() + "\nCompilation will continue.");
-                }
-            }
-            int errors = 0;
-            for (Script s : scripts) {
-                if (s.compilerError) {
-                    errors++;
-                }
-            }
-            if (errors > 0) {
-                System.out.println("[CommandHelper]: " + (scripts.size() - errors) + " alias(es) defined, with " + errors + " aliases with compile errors.");
-            } else {
-                System.out.println("[CommandHelper]: " + scripts.size() + " alias(es) defined.");
-            }
-            is_loaded = true;
-        } catch (ConfigCompileException ex) {
-            logger.log(Level.SEVERE, "CommandHelper: " + ex.toString());
-        } catch (IOException ex) {
-            logger.log(Level.SEVERE, "CommandHelper: Path to config file is not correct/accessable. Please"
-                    + " check the location and try loading the plugin again.");
-        } catch (Throwable t) {
-            t.printStackTrace();
-        }
-
-        return is_loaded;
-    }
-
-//    public ArrayList<AliasConfig> parse_user_config(ArrayList<String> config, User u) throws ConfigCompileException {
-//        if (config == null) {
-//            return null;
-//        }
-//        ArrayList<AliasConfig> alac = new ArrayList<AliasConfig>();
-//        for (int i = 0; i < config.size(); i++) {
-//            alac.add(new AliasConfig(config.get(i), u, perms));
-//        }
-//        return alac;
-//    }
-    /**
-     * Returns the contents of a file as a string. Accepts the file location
-     * as a string.
-     * @param file_location
-     * @return the contents of the file as a string
-     * @throws Exception if the file cannot be found
-     */
-    public static String file_get_contents(String file_location) throws IOException {
-        BufferedReader in = new BufferedReader(new FileReader(file_location));
-        String ret = "";
-        String str;
-        while ((str = in.readLine()) != null) {
-            ret += str + "\n";
-        }
-        in.close();
-        return ret;
-    }
-
-    /**
-     * This function writes the contents of a string to a file.
-     * @param file_location the location of the file on the disk
-     * @param contents the string to be written to the file
-     * @param mode the mode in which to write the file: <br />
-     * <ul>
-     * <li>"o" - overwrite the file if it exists, without asking</li>
-     * <li>"a" - append to the file if it exists, without asking</li>
-     * <li>"c" - cancel the operation if the file exists, without asking</li>
-     * </ul>
-     * @return true if the file was written, false if it wasn't. Throws an exception
-     * if the file could not be created, or if the mode is not valid.
-     * @throws Exception if the file could not be created
-     */
-    public static boolean file_put_contents(File file_location, String contents, String mode)
-            throws Exception {
-        BufferedWriter out = null;
-        File f = file_location;
-        if (f.exists()) {
-            //do different things depending on our mode
-            if (mode.equalsIgnoreCase("o")) {
-                out = new BufferedWriter(new FileWriter(file_location));
-            } else if (mode.equalsIgnoreCase("a")) {
-                out = new BufferedWriter(new FileWriter(file_location, true));
-            } else if (mode.equalsIgnoreCase("c")) {
-                return false;
-            } else {
-                throw new RuntimeException("Undefined mode in file_put_contents: " + mode);
-            }
-        } else {
-            out = new BufferedWriter(new FileWriter(file_location));
-        }
-        //At this point, we are assured that the file is open, and ready to be written in
-        //from this point in the file.
-        if (out != null) {
-            out.write(contents);
-            out.close();
-            return true;
-        } else {
-            return false;
-        }
-    }
-
-    public static String getStringResource(InputStream is) throws IOException {
-        Writer writer = new StringWriter();
-        char[] buffer = new char[1024];
-        try {
-            Reader reader = new BufferedReader(new InputStreamReader(is));
-            int n;
-            while ((n = reader.read(buffer)) != -1) {
-                writer.write(buffer, 0, n);
-            }
-        } finally {
-            if (is != null) {
-                is.close();
-            }
-        }
-        return writer.toString();
-    }
-
-    public void removePlayerReference(CommandSender p) {
-        //If they're not a player, oh well.
-        if (p instanceof Player) {
-            echoCommand.remove(((Player) p).getName());
-        }
-    }
-
-    public void addPlayerReference(CommandSender p) {
-        if (p instanceof Player) {
-            echoCommand.add(((Player) p).getName());
-        }
-    }
-}
diff --git a/src/main/java/com/laytonsmith/aliasengine/Constructs/CArray.java b/src/main/java/com/laytonsmith/aliasengine/Constructs/CArray.java
deleted file mode 100644
index da0f326..0000000
--- a/src/main/java/com/laytonsmith/aliasengine/Constructs/CArray.java
+++ /dev/null
@@ -1,93 +0,0 @@
-/*
- * To change this template, choose Tools | Templates
- * and open the template in the editor.
- */
-
-package com.laytonsmith.aliasengine.Constructs;
-
-import com.laytonsmith.aliasengine.functions.exceptions.ConfigRuntimeException;
-import com.laytonsmith.aliasengine.functions.Exceptions.ExceptionType;
-import java.io.File;
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.List;
-
-/**
- *
- * @author layton
- */
-public class CArray extends Construct{
-    
-    public static final long serialVersionUID = 1L;
-    private List<Construct> array;
-    private String mutVal;
-    public CArray(int line_num, File file, Construct ... items){
-        super(null, ConstructType.ARRAY, line_num, file);
-        array = new ArrayList<Construct>();
-        array.addAll(Arrays.asList(items));
-        regenValue();
-    }
-
-    private void regenValue(){
-        StringBuilder b = new StringBuilder();
-        b.append("{");
-        for(int i = 0; i < array.size(); i++){
-            if(i > 0){
-                b.append(", ");
-                b.append(array.get(i).val());
-            } else {
-                b.append(array.get(i).val());
-            }
-        }
-        b.append("}");
-        mutVal = b.toString();
-    }
-
-    /**
-     * Pushes a new Construct onto the array
-     * @param c 
-     */
-    public void push(Construct c){
-        array.add(c);
-        regenValue();
-    }
-
-    /**
-     * 
-     * @param index
-     * @param c 
-     */
-    public void set(int index, Construct c){
-        array.set(index, c);
-        regenValue();
-    }
-
-    public Construct get(int index, int line_num){
-        try{
-            return array.get(index);
-        } catch(IndexOutOfBoundsException e){
-            throw new ConfigRuntimeException("The element at index " + index + " does not exist", ExceptionType.IndexOverflowException, line_num, file);
-        }
-    }
-    
-    @Override
-    public String val(){
-        return mutVal;
-    }
-    
-    @Override
-    public String toString(){
-        return mutVal;
-    }
-    
-    public int size(){
-        return array.size();
-    }
-    
-    @Override
-    public CArray clone() throws CloneNotSupportedException{
-        CArray clone = (CArray) super.clone();
-        if(array != null) clone.array = new ArrayList<Construct>(this.array);
-        return clone;
-    }
-}
diff --git a/src/main/java/com/laytonsmith/aliasengine/Constructs/CBoolean.java b/src/main/java/com/laytonsmith/aliasengine/Constructs/CBoolean.java
deleted file mode 100644
index 0eeae85..0000000
--- a/src/main/java/com/laytonsmith/aliasengine/Constructs/CBoolean.java
+++ /dev/null
@@ -1,70 +0,0 @@
-/*
- * To change this template, choose Tools | Templates
- * and open the template in the editor.
- */
-
-package com.laytonsmith.aliasengine.Constructs;
-
-import com.laytonsmith.aliasengine.functions.exceptions.ConfigRuntimeException;
-import com.laytonsmith.aliasengine.functions.Exceptions.ExceptionType;
-import java.io.File;
-
-/**
- *
- * @author layton
- */
-public class CBoolean extends Construct implements Cloneable{
-    
-    public static final long serialVersionUID = 1L;
-    private boolean val;
-    public CBoolean(boolean value, int line_num, File file){
-        super(Boolean.toString(value), ConstructType.BOOLEAN, line_num, file);
-        val = value;
-    }
-
-    public CBoolean(String value, int line_num, File file){
-        super(value, ConstructType.BOOLEAN, line_num, file);
-        try{
-            int i = Integer.parseInt(value);
-            if(i == 0){
-                val = false;
-            } else {
-                val = true;
-            }
-        } catch(NumberFormatException e){
-            try{
-                double d = Double.parseDouble(value);
-                if(d == 0){
-                    val = false;
-                } else {
-                    val = true;
-                }
-            } catch(NumberFormatException f){
-                try{
-                    val = Boolean.parseBoolean(value);
-                } catch(NumberFormatException g){
-                    throw new ConfigRuntimeException("Could not parse value " + value + " into a Boolean type", ExceptionType.FormatException, line_num, file);
-                }
-            }
-        }
-    }
-
-    public boolean getBoolean(){
-        return val;
-    }
-
-    @Override
-    public String val() {
-        if(val){
-            return "true";
-        } else{
-            return "false";
-        }
-    }
-    
-    @Override
-    public CBoolean clone() throws CloneNotSupportedException{
-        return (CBoolean) super.clone();
-    }
-
-}
diff --git a/src/main/java/com/laytonsmith/aliasengine/Constructs/CClosure.java b/src/main/java/com/laytonsmith/aliasengine/Constructs/CClosure.java
deleted file mode 100644
index 6f42c9f..0000000
--- a/src/main/java/com/laytonsmith/aliasengine/Constructs/CClosure.java
+++ /dev/null
@@ -1,40 +0,0 @@
-/*
- * To change this template, choose Tools | Templates
- * and open the template in the editor.
- */
-package com.laytonsmith.aliasengine.Constructs;
-
-import com.laytonsmith.aliasengine.GenericTreeNode;
-import java.io.File;
-
-/**
- *
- * @author Layton
- */
-public class CClosure extends Construct {
-    
-    public static final long serialVersionUID = 1L;
-
-    GenericTreeNode<Construct> node;
-
-    public CClosure(String name, GenericTreeNode<Construct> node, int line_num, File file) {
-        super(node!=null?node.toString():"", ConstructType.CLOSURE, line_num, file);
-        this.node = node;
-    }
-    
-    @Override
-    public String val(){
-        throw new UnsupportedOperationException(".val() cannot be used in CClosure");
-    }
-
-    public GenericTreeNode<Construct> getNode() {
-        return node;
-    }        
-    
-    @Override
-    public CClosure clone() throws CloneNotSupportedException{
-        CClosure clone = (CClosure) super.clone();
-        if(this.node != null) clone.node = this.node.clone();
-        return clone;
-    }
-}
diff --git a/src/main/java/com/laytonsmith/aliasengine/Constructs/CDouble.java b/src/main/java/com/laytonsmith/aliasengine/Constructs/CDouble.java
deleted file mode 100644
index e272a56..0000000
--- a/src/main/java/com/laytonsmith/aliasengine/Constructs/CDouble.java
+++ /dev/null
@@ -1,43 +0,0 @@
-/*
- * To change this template, choose Tools | Templates
- * and open the template in the editor.
- */
-
-package com.laytonsmith.aliasengine.Constructs;
-
-import com.laytonsmith.aliasengine.functions.exceptions.ConfigRuntimeException;
-import com.laytonsmith.aliasengine.functions.Exceptions.ExceptionType;
-import java.io.File;
-
-/**
- *
- * @author layton
- */
-public class CDouble extends Construct implements Cloneable{
-    
-    public static final long serialVersionUID = 1L;
-    final double val;
-
-    public CDouble(String value, int line_num, File file){
-        super(value, ConstructType.INT, line_num, file);
-        try{
-            val = Double.parseDouble(value);
-        } catch(NumberFormatException e){
-            throw new ConfigRuntimeException("Could not cast " + value + " to double", ExceptionType.FormatException, line_num, file);
-        }
-    }
-
-    public CDouble(double value, int line_num, File file){
-        super(Double.toString(value), ConstructType.DOUBLE, line_num, file);
-        val = value;
-    }
-
-    public double getDouble(){
-        return val;
-    }
-    
-    @Override
-    public CDouble clone() throws CloneNotSupportedException{
-        return (CDouble) super.clone();
-    }
-}
diff --git a/src/main/java/com/laytonsmith/aliasengine/Constructs/CFunction.java b/src/main/java/com/laytonsmith/aliasengine/Constructs/CFunction.java
deleted file mode 100644
index a7ab461..0000000
--- a/src/main/java/com/laytonsmith/aliasengine/Constructs/CFunction.java
+++ /dev/null
@@ -1,29 +0,0 @@
-/*
- * To change this template, choose Tools | Templates
- * and open the template in the editor.
- */
-package com.laytonsmith.aliasengine.Constructs;
-
-import java.io.File;
-
-/**
- *
- * @author layton
- */
-public class CFunction extends Construct {
-    
-    public static final long serialVersionUID = 1L;
-
-    public CFunction(String name, int line_num, File file) {
-        super(name, ConstructType.FUNCTION, line_num, file);
-    }
-
-    public String toString() {
-        return this.value;
-    }
-    
-    @Override
-    public CFunction clone() throws CloneNotSupportedException{
-        return (CFunction) super.clone();
-    }
-}
diff --git a/src/main/java/com/laytonsmith/aliasengine/Constructs/CInt.java b/src/main/java/com/laytonsmith/aliasengine/Constructs/CInt.java
deleted file mode 100644
index 10d9494..0000000
--- a/src/main/java/com/laytonsmith/aliasengine/Constructs/CInt.java
+++ /dev/null
@@ -1,42 +0,0 @@
-/*
- * To change this template, choose Tools | Templates
- * and open the template in the editor.
- */
-
-package com.laytonsmith.aliasengine.Constructs;
-
-import com.laytonsmith.aliasengine.functions.exceptions.ConfigRuntimeException;
-import com.laytonsmith.aliasengine.functions.Exceptions.ExceptionType;
-import java.io.File;
-
-/**
- *
- * @author layton
- */
-public class CInt extends Construct implements Cloneable{
-    
-    public static final long serialVersionUID = 1L;
-    final long val;
-    public CInt(String value, int line_num, File file){
-        super(value, ConstructType.INT, line_num, file);
-        try{
-            val = Long.parseLong(value);
-        } catch(NumberFormatException e){
-            throw new ConfigRuntimeException("Could not parse " + value + " as an integer", ExceptionType.FormatException, line_num, file);
-        }
-    }
-
-    public CInt(long value, int line_num, File file){
-        super(Long.toString(value), ConstructType.INT, line_num, file);
-        val = value;
-    }
-
-    public long getInt(){
-        return val;
-    }
-    
-    public CInt clone() throws CloneNotSupportedException{
-        return (CInt) super.clone();
-    }
-
-}
diff --git a/src/main/java/com/laytonsmith/aliasengine/Constructs/CNull.java b/src/main/java/com/laytonsmith/aliasengine/Constructs/CNull.java
deleted file mode 100644
index ad2d9c1..0000000
--- a/src/main/java/com/laytonsmith/aliasengine/Constructs/CNull.java
+++ /dev/null
@@ -1,25 +0,0 @@
-/*
- * To change this template, choose Tools | Templates
- * and open the template in the editor.
- */
-
-package com.laytonsmith.aliasengine.Constructs;
-
-import java.io.File;
-
-/**
- *
- * @author layton
- */
-public class CNull extends Construct implements Cloneable{
-    
-    public static final long serialVersionUID = 1L;
-    public CNull(int line_num, File file){
-        super("null", ConstructType.NULL, line_num, file);
-    }
-    
-    @Override
-    public CNull clone() throws CloneNotSupportedException{
-        return (CNull) super.clone();
-    }
-}
diff --git a/src/main/java/com/laytonsmith/aliasengine/Constructs/CString.java b/src/main/java/com/laytonsmith/aliasengine/Constructs/CString.java
deleted file mode 100644
index 2538fa5..0000000
--- a/src/main/java/com/laytonsmith/aliasengine/Constructs/CString.java
+++ /dev/null
@@ -1,24 +0,0 @@
-/*
- * To change this template, choose Tools | Templates
- * and open the template in the editor.
- */
-package com.laytonsmith.aliasengine.Constructs;
-
-import java.io.File;
-
-/**
- *
- * @author Layton
- */
-public class CString extends Construct implements Cloneable{
-    
-    public static final long serialVersionUID = 1L;
-    public CString(String value, int line_num, File file){
-        super(value, ConstructType.STRING, line_num, file);
-    }
-    
-    @Override
-    public CString clone() throws CloneNotSupportedException{
-        return (CString) super.clone();
-    }
-}
diff --git a/src/main/java/com/laytonsmith/aliasengine/Constructs/CVoid.java b/src/main/java/com/laytonsmith/aliasengine/Constructs/CVoid.java
deleted file mode 100644
index aed980f..0000000
--- a/src/main/java/com/laytonsmith/aliasengine/Constructs/CVoid.java
+++ /dev/null
@@ -1,24 +0,0 @@
-/*
- * To change this template, choose Tools | Templates
- * and open the template in the editor.
- */
-package com.laytonsmith.aliasengine.Constructs;
-
-import java.io.File;
-
-/**
- *
- * @author Layton
- */
-public class CVoid extends Construct implements Cloneable{
-    
-    public static final long serialVersionUID = 1L;
-    public CVoid(int line_num, File file){
-        super("", ConstructType.VOID, line_num, file);
-    }
-    
-    @Override
-    public CVoid clone() throws CloneNotSupportedException{
-        return (CVoid) super.clone();
-    }
-}
diff --git a/src/main/java/com/laytonsmith/aliasengine/Constructs/Command.java b/src/main/java/com/laytonsmith/aliasengine/Constructs/Command.java
deleted file mode 100644
index bab4c3c..0000000
--- a/src/main/java/com/laytonsmith/aliasengine/Constructs/Command.java
+++ /dev/null
@@ -1,24 +0,0 @@
-/*
- * To change this template, choose Tools | Templates
- * and open the template in the editor.
- */
-package com.laytonsmith.aliasengine.Constructs;
-
-import java.io.File;
-
-/**
- *
- * @author layton
- */
-public class Command extends Construct implements Cloneable {
-    
-    public Command(String name, int line_num, File file) {
-        super(name, ConstructType.COMMAND, line_num, file);
-    }
-
-    @Override
-    public Command clone() throws CloneNotSupportedException{
-        return (Command) super.clone();
-    }
-
-}
diff --git a/src/main/java/com/laytonsmith/aliasengine/Constructs/Construct.java b/src/main/java/com/laytonsmith/aliasengine/Constructs/Construct.java
deleted file mode 100644
index 6fb9d41..0000000
--- a/src/main/java/com/laytonsmith/aliasengine/Constructs/Construct.java
+++ /dev/null
@@ -1,171 +0,0 @@
-/*
- * To change this template, choose Tools | Templates
- * and open the template in the editor.
- */
-package com.laytonsmith.aliasengine.Constructs;
-
-import com.laytonsmith.aliasengine.functions.exceptions.MarshalException;
-import java.io.File;
-import org.json.simple.JSONArray;
-import org.json.simple.JSONObject;
-import org.json.simple.JSONValue;
-
-/**
- *
- * @author layton
- */
-public abstract class Construct implements Cloneable {
-
-    public static final long serialVersionUID = 1L;
-
-    public enum ConstructType {
-
-        TOKEN, COMMAND, FUNCTION, VARIABLE, LITERAL, ARRAY, MAP, ENTRY, INT, DOUBLE, BOOLEAN, NULL, STRING, VOID, IVARIABLE, CLOSURE
-    }
-    protected ConstructType ctype;
-    protected String value;
-    protected int line_num;
-    transient protected File file;
-
-    public ConstructType getCType() {
-        return ctype;
-    }
-
-    public String getValue() {
-        return value;
-    }
-
-    public int getLineNum() {
-        return line_num;
-    }
-
-    public File getFile() {
-        return file;
-    }
-
-    public Construct(String value, ConstructType ctype, int line_num, File file) {
-        this.value = value;
-        this.ctype = ctype;
-        this.line_num = line_num;
-        this.file = file;
-    }
-
-    public String val() {
-        return value;
-    }
-
-    @Override
-    public String toString() {
-        return value;
-    }
-
-    @Override
-    public Construct clone() throws CloneNotSupportedException {
-        return (Construct) super.clone();
-    }
-
-    /**
-     * This function takes a Construct, and turns it into a JSON value. If the construct is
-     * not one of the following, a MarshalException is thrown: CArray, CBoolean, CDouble, CInt, CNull, 
-     * CString, CVoid, Command. Currently unsupported, but will be in the future are: CClosure/CFunction
-     * The following map is applied when encoding and decoding:
-     * <table border='1'>
-     * <tr><th>JSON</th><th>MScript</th></tr>
-     * <tr><td>string</td><td>CString, CVoid, Command, but all are decoded into CString</td></tr>
-     * <tr><td>number</td><td>CInt, CDouble, and it is decoded intelligently</td></tr>
-     * <tr><td>boolean</td><td>CBoolean</td></tr>
-     * <tr><td>null</td><td>CNull</td></tr>
-     * <tr><td>array</td><td>CArray</td></tr>
-     * <tr><td>object</td><td>A MarshalException is currently thrown, but this will eventually return a CArray</td></tr>
-     * </table>
-     * @param c
-     * @return 
-     */
-    public static String json_encode(Construct c) throws MarshalException {
-        if (c instanceof CString || c instanceof Command) {
-            return "\"" + JSONObject.escape(c.getValue()) + "\"";
-        } else if (c instanceof CVoid) {
-            return "\"\"";
-        } else if (c instanceof CInt) {
-            return Long.toString(((CInt) c).getInt());
-        } else if (c instanceof CDouble) {
-            return Double.toString(((CDouble) c).getDouble());
-        } else if (c instanceof CBoolean) {
-            if (((CBoolean) c).getBoolean()) {
-                return "true";
-            } else {
-                return "false";
-            }
-        } else if (c instanceof CNull) {
-            return "null";
-        } else if (c instanceof CArray) {
-            CArray ca = (CArray) c;
-            StringBuilder b = new StringBuilder();
-            b.append("[");
-            for (int i = 0; i < ca.size(); i++) {
-                if (i != 0) {
-                    b.append(", ");
-                }
-                b.append(json_encode(ca.get(i, 0)));
-            }
-            b.append("]");
-            return b.toString();
-        } else {
-            throw new MarshalException("The type of " + c.getClass().getSimpleName() + " is not currently supported", c);
-        }
-    }
-
-    /**
-     * Takes a string and converts it into a 
-     * @param s
-     * @return 
-     */
-    public static Construct json_decode(String s) throws MarshalException {
-        if (s.startsWith("{")) {
-            //Object, for now throw an exception
-            throw new MarshalException("JSON Objects are not currently supported");
-        } else if (s.startsWith("[")) {
-            //It's an array
-            JSONArray array = (JSONArray) JSONValue.parse(s);
-            CArray carray = new CArray(0, null);
-            for (int i = 0; i < array.size(); i++) {
-                carray.push(convertJSON(array.get(i)));
-            }
-            return carray;
-        } else {
-            //It's a single value, but we're gonna wrap it in an array, then deconstruct it
-            s = "[" + s + "]";
-            JSONArray array = (JSONArray) JSONValue.parse(s);
-            Object o = array.get(0);
-            return convertJSON(o);
-        }
-    }
-
-    private static Construct convertJSON(Object o) throws MarshalException {
-        if (o instanceof String) {
-            return new CString((String) o, 0, null);
-        } else if (o instanceof Number) {
-            Number n = (Number) o;
-            if (n.longValue() == n.doubleValue()) {
-                //It's an int
-                return new CInt(n.longValue(), 0, null);
-            } else {
-                //It's a double
-                return new CDouble(n.doubleValue(), 0, null);
-            }
-        } else if (o instanceof Boolean) {
-            return new CBoolean(((Boolean) o).booleanValue(), 0, null);
-        } else if(o instanceof java.util.List){
-            java.util.List l = (java.util.List)o;
-            CArray ca = new CArray(0, null);
-            for(int i = 0; i < l.size(); i++){
-                ca.push(convertJSON(l.get(i)));
-            }
-            return ca;
-        } else if(o == null){
-            return new CNull(0, null);
-        } else {
-            throw new MarshalException(o.getClass().getSimpleName() + " are not currently supported");
-        }
-    }
-}
diff --git a/src/main/java/com/laytonsmith/aliasengine/Constructs/IVariable.java b/src/main/java/com/laytonsmith/aliasengine/Constructs/IVariable.java
deleted file mode 100644
index 9ed8638..0000000
--- a/src/main/java/com/laytonsmith/aliasengine/Constructs/IVariable.java
+++ /dev/null
@@ -1,57 +0,0 @@
-/*
- * To change this template, choose Tools | Templates
- * and open the template in the editor.
- */
-
-package com.laytonsmith.aliasengine.Constructs;
-
-import java.io.File;
-
-/**
- *
- * @author layton
- */
-public class IVariable extends Construct implements Cloneable{
-    
-    public static final long serialVersionUID = 1L;
-    private Construct var_value;
-    final private String name;
-
-    public IVariable(String name, int line_num, File file){
-        super(name, ConstructType.IVARIABLE, line_num, file);
-        this.var_value = new CString("", line_num, file);
-        this.name = name;
-    }
-    public IVariable(String name, Construct value, int line_num, File file){
-        super(name, ConstructType.IVARIABLE, line_num, file);
-        this.var_value = value;
-        this.name = name;
-    }
-    @Override
-    public String val(){
-        return var_value.val();
-    }
-    public Construct ival(){
-        return var_value;
-    }
-    public String getName(){
-        return name;
-    }
-    public void setIval(Construct c){
-        var_value = c;
-    }
-
-    @Override
-    public String toString() {
-        return this.name + ":(" + this.ival().getClass().getSimpleName() + ") '" + this.ival().val() + "'";
-    }
-    
-    
-    @Override
-    public IVariable clone() throws CloneNotSupportedException{
-        IVariable clone = (IVariable) super.clone();
-        if(this.var_value != null) clone.var_value = this.var_value.clone();
-        return (IVariable) clone;
-    }
-
-}
diff --git a/src/main/java/com/laytonsmith/aliasengine/Constructs/Token.java b/src/main/java/com/laytonsmith/aliasengine/Constructs/Token.java
deleted file mode 100644
index 19ce858..0000000
--- a/src/main/java/com/laytonsmith/aliasengine/Constructs/Token.java
+++ /dev/null
@@ -1,75 +0,0 @@
-/*
- * To change this template, choose Tools | Templates
- * and open the template in the editor.
- */
-package com.laytonsmith.aliasengine.Constructs;
-
-import java.io.File;
-
-/**
- *
- * @author layton
- */
-public class Token{
-    public TType type;
-    public String value;
-    public int line_num;
-    public File file;
-    
-    public enum TType{
-        UNKNOWN, LSQUARE_BRACKET, RSQUARE_BRACKET, OPT_VAR_ASSIGN, ALIAS_END, COMMA, FUNC_NAME, FUNC_START,
-        FUNC_END, STRING, NEWLINE, MULTILINE_START, MULTILINE_END, COMMAND, SEPERATOR, VARIABLE,
-        IVARIABLE, FINAL_VAR, LIT, ROOT, IDENT
-    }
-    public Token(TType type, String value, int line_num, File file) {
-        this.type = type;
-        this.value = value;
-        this.line_num = line_num;
-        this.file = file;
-    }
-    
-    public String val(){
-        return value;
-    }
-
-    @Override
-    public int hashCode() {
-        int hash = 7;
-        hash = 59 * hash + (this.type != null ? this.type.hashCode() : 0);
-        hash = 59 * hash + (this.value != null ? this.value.hashCode() : 0);
-        return hash;
-    }
-    
-    public boolean equals(Object o){
-        if(o instanceof Token){
-            Token t = (Token)o;
-            return (this.type.equals(t.type) && this.value.equals(t.value));
-        }
-        return false;
-    }
-
-    @Override
-    public String toString() {
-        if (type.equals(TType.NEWLINE)) {
-            return "newline";
-        }
-        if (type.equals(TType.STRING)) {
-            return "string:'" + value + "'";
-        }
-        return type + ":" + value;
-    }
-
-    public String toSimpleString() {
-        if (type.equals(TType.STRING)) {
-            return "'" + value + "'";
-        }
-        return value;
-    }
-
-    public String toOutputString() {
-        if (type.equals(TType.STRING)) {
-            return value.replace("'", "\\'");
-        }
-        return value;
-    }
-}
diff --git a/src/main/java/com/laytonsmith/aliasengine/Constructs/Variable.java b/src/main/java/com/laytonsmith/aliasengine/Constructs/Variable.java
deleted file mode 100644
index 6f6b951..0000000
--- a/src/main/java/com/laytonsmith/aliasengine/Constructs/Variable.java
+++ /dev/null
@@ -1,77 +0,0 @@
-/*
- * To change this template, choose Tools | Templates
- * and open the template in the editor.
- */
-package com.laytonsmith.aliasengine.Constructs;
-
-import com.laytonsmith.aliasengine.Static;
-import java.io.File;
-
-/**
- *
- * @author layton
- */
-public class Variable extends Construct {
-    
-    public static final long serialVersionUID = 1L;
-
-    final private String name;
-    private String def;
-    private boolean optional;
-    private boolean final_var;
-    private Construct var_value;
-    
-
-    public Variable(String name, String def, boolean optional, boolean final_var, int line_num, File file) {
-        super(name, ConstructType.VARIABLE, line_num, file);
-        this.name = name;
-        this.def = def;
-        this.final_var = final_var;
-        this.optional = optional;
-        this.var_value = Static.resolveConstruct(def, line_num, file);
-    }
-    
-    public Variable(String name, String def, int line_num, File file){
-        this(name, def, false, false, line_num, file);
-    }
-
-    @Override
-    public String toString() {
-        return "var:" + name;
-    }
-    public String getName(){
-        return name;
-    }
-    public void setFinal(boolean final_var){
-        this.final_var = final_var;
-    }
-    public boolean isFinal(){
-        return final_var;
-    }
-    public void setOptional(boolean optional){
-        this.optional = optional;
-    }
-    public boolean isOptional(){
-        return optional;
-    }
-    public String getDefault(){
-        return def;
-    }
-    public void setDefault(String def){
-        this.def = def;
-    }
-    @Override
-    public String val(){
-        return var_value.toString();
-    }
-    public void setVal(Construct val){
-        this.var_value = val;
-    }
-    @Override
-    public Variable clone() throws CloneNotSupportedException{
-        Variable clone = (Variable) super.clone();
-        if(this.var_value != null) clone.var_value = var_value;
-        return clone;
-    }
-
-}
diff --git a/src/main/java/com/laytonsmith/aliasengine/DirtyRegisteredListener.java b/src/main/java/com/laytonsmith/aliasengine/DirtyRegisteredListener.java
deleted file mode 100644
index 179a6f9..0000000
--- a/src/main/java/com/laytonsmith/aliasengine/DirtyRegisteredListener.java
+++ /dev/null
@@ -1,169 +0,0 @@
-/*
- * To change this template, choose Tools | Templates
- * and open the template in the editor.
- */
-package com.laytonsmith.aliasengine;
-
-import java.lang.reflect.Field;
-import java.lang.reflect.Method;
-import java.lang.reflect.Modifier;
-import java.util.Comparator;
-import java.util.EnumMap;
-import java.util.HashMap;
-import java.util.Iterator;
-import java.util.LinkedList;
-import java.util.List;
-import java.util.Map;
-import java.util.Map.Entry;
-import java.util.Queue;
-import java.util.Set;
-import java.util.SortedSet;
-import java.util.TreeSet;
-import java.util.concurrent.LinkedBlockingQueue;
-import java.util.logging.Level;
-import java.util.logging.Logger;
-import org.bukkit.event.Cancellable;
-import org.bukkit.event.Event;
-import org.bukkit.event.Event.Type;
-import org.bukkit.event.Listener;
-import org.bukkit.plugin.EventExecutor;
-import org.bukkit.plugin.Plugin;
-import org.bukkit.plugin.PluginManager;
-import org.bukkit.plugin.RegisteredListener;
-import org.bukkit.plugin.SimplePluginManager;
-
-/**
- *
- * @author Layton
- */
-public class DirtyRegisteredListener extends RegisteredListener {
-
-
-    private final Listener listener;
-    private final Event.Priority priority;
-    private final Plugin plugin;
-    private final EventExecutor executor;
-    
-    private static final int queueCapacity = 20;
-    private static Queue<Event> cancelledEvents = new LinkedBlockingQueue<Event>(queueCapacity);
-
-    public DirtyRegisteredListener(final Listener pluginListener, final EventExecutor eventExecutor, final Event.Priority eventPriority, final Plugin registeredPlugin) {
-        super(pluginListener, eventExecutor, eventPriority, registeredPlugin);
-        listener = pluginListener;
-        priority = eventPriority;
-        plugin = registeredPlugin;
-        executor = eventExecutor;
-    }
-    
-    public static void Repopulate() throws NoSuchFieldException, ClassCastException, IllegalArgumentException, IllegalAccessException, NoSuchMethodException {
-        //Go through the list of registered listeners, and inject our
-        //our own poisoned DirtyRegisteredListeners in instead
-        SimplePluginManager pm = (SimplePluginManager)AliasCore.parent.getServer().getPluginManager();
-        Field fListener = SimplePluginManager.class.getDeclaredField("listeners");
-        //set it to public
-        fListener.setAccessible(true);        
-        EnumMap<Event.Type, SortedSet<RegisteredListener>> listeners = 
-                (EnumMap<Event.Type, SortedSet<RegisteredListener>>) fListener.get(pm);
-        
-        //Remove final from the listeners, so we can modify it
-        Field modifiersField = Field.class.getDeclaredField("modifiers");
-        modifiersField.setAccessible(true);
-        modifiersField.setInt(fListener, fListener.getModifiers() & ~Modifier.FINAL);
-        
-        Map<Event.Type, SortedSet<RegisteredListener>> newListeners = new EnumMap<Event.Type, SortedSet<RegisteredListener>>(Event.Type.class);
-
-        
-        //We need the comparator, so we can create a new listener map
-        Field fComparator = SimplePluginManager.class.getDeclaredField("comparer");
-        fComparator.setAccessible(true);
-        Comparator<RegisteredListener> comparator = (Comparator<RegisteredListener>) fComparator.get(pm);
-        
-        //Ok, now we have the listeners, so lets loop through them, and shove them into our own newListener object, so that
-        //we can replace the reference later, without modifying the existing variable, because it is currently being walked
-        //through elsewhere in the code.
-        
-        boolean doReplace = false;
-        
-        Set<Map.Entry<Event.Type, SortedSet<RegisteredListener>>> entrySet = listeners.entrySet();
-        Iterator i = entrySet.iterator();
-        while(i.hasNext()){
-            final Map.Entry<Event.Type, SortedSet<RegisteredListener>> mySet = (Map.Entry<Event.Type, SortedSet<RegisteredListener>>)i.next();
-            Iterator k = mySet.getValue().iterator();
-            SortedSet<RegisteredListener> rls = new TreeSet<RegisteredListener>(comparator);
-            newListeners.put(mySet.getKey(), rls);
-            while(k.hasNext()){
-                final RegisteredListener rl = (RegisteredListener)k.next();
-                if(!(rl instanceof DirtyRegisteredListener)){
-                    doReplace = true;
-                }
-                rls.add(DirtyRegisteredListener.Generate(rl));
-            }
-        }
-        
-        if(doReplace){
-            //Only replace it if we've made changes
-            fListener.set(pm, newListeners);
-        }
-        
-    }
-    
-    public static class MyEntry{
-        public Type key;
-        public DirtyRegisteredListener value;
-    }
-    
-    public static void setCancelled(Event superCancelledEvent){
-        if(cancelledEvents.size() >= queueCapacity){
-            cancelledEvents.poll();
-        }
-        cancelledEvents.offer(superCancelledEvent);
-    }
-
-    public static DirtyRegisteredListener Generate(RegisteredListener real) throws NoSuchFieldException, IllegalArgumentException, IllegalAccessException {
-        if(real instanceof DirtyRegisteredListener){
-            return (DirtyRegisteredListener)real;
-        }
-        Field rListener = real.getClass().getDeclaredField("listener");
-        rListener.setAccessible(true);
-        Listener nListener = (Listener)rListener.get(real);
-        
-        Field rPriority = real.getClass().getDeclaredField("priority");
-        rPriority.setAccessible(true);
-        Event.Priority nPriority = (Event.Priority)rPriority.get(real);
-        
-        Field rPlugin = real.getClass().getDeclaredField("plugin");
-        rPlugin.setAccessible(true);
-        Plugin nPlugin = (Plugin)rPlugin.get(real);
-        
-        Field rExecutor = real.getClass().getDeclaredField("executor");
-        rExecutor.setAccessible(true);
-        EventExecutor nExecutor = (EventExecutor)rExecutor.get(real);
-        
-        return new DirtyRegisteredListener(nListener, nExecutor, nPriority, nPlugin);
-    }
-    
-    /**
-     * This is the magic method we need to override. When we call the event, if it
-     * is "super cancelled", then we don't run it. Cancelled events are still run
-     * if they aren't "super cancelled", which mirrors existing behavior.
-     * @param event 
-     */
-    @Override
-    public void callEvent(Event event){
-        //If it isn't super cancelled, call it, even if it is cancelled
-        if(!DirtyRegisteredListener.cancelledEvents.contains(event)){
-            callEvent0(event);
-        } else {
-            //If it's a cancellable event, and this listener isn't Monitor priority, just return
-            if(event instanceof Cancellable && this.priority != Event.Priority.Monitor){
-                return;
-            } else {
-                callEvent0(event);
-            }
-        }
-    }
-    
-    private void callEvent0(Event event){
-        executor.execute(listener, event);
-    }
-}
diff --git a/src/main/java/com/laytonsmith/aliasengine/DocGen.java b/src/main/java/com/laytonsmith/aliasengine/DocGen.java
deleted file mode 100644
index ba8792d..0000000
--- a/src/main/java/com/laytonsmith/aliasengine/DocGen.java
+++ /dev/null
@@ -1,197 +0,0 @@
-/*
- * To change this template, choose Tools | Templates
- * and open the template in the editor.
- */
-package com.laytonsmith.aliasengine;
-
-import com.laytonsmith.aliasengine.functions.Exceptions.ExceptionType;
-import com.laytonsmith.aliasengine.functions.Function;
-import com.laytonsmith.aliasengine.functions.FunctionList;
-import java.lang.reflect.InvocationTargetException;
-import java.lang.reflect.Method;
-import java.lang.reflect.Modifier;
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.Collections;
-import java.util.HashMap;
-import java.util.List;
-import java.util.Map;
-import java.util.regex.Matcher;
-import java.util.regex.Pattern;
-
-/**
- *
- * @author Layton
- */
-public class DocGen {
-
-    public static void start(String type) {
-        ArrayList<Function> functions = FunctionList.getFunctionList();
-        HashMap<Class, ArrayList<Function>> functionlist = new HashMap<Class, ArrayList<Function>>();
-        for (int i = 0; i < functions.size(); i++) {
-            //Sort the functions into classes
-            Function f = functions.get(i);
-            Class apiClass = (f.getClass().getEnclosingClass() != null
-                    ? f.getClass().getEnclosingClass()
-                    : null);
-            ArrayList<Function> fl = functionlist.get(apiClass);
-            if (fl == null) {
-                fl = new ArrayList<Function>();
-                functionlist.put(apiClass, fl);
-            }
-            fl.add(f);
-        }
-        if(type.equals("html")){
-            System.out.println("Command Helper uses a language called MScript, which greatly extend the capabilities of the plugin, "
-                    + "and make the plugin a fully "
-                    + "<a href=\"http://en.wikipedia.org/wiki/Turing_Complete\">Turing Complete</a> language. "
-                    + "There are several functions defined, and they are grouped into \"classes\". ");            
-        } else if(type.equals("wiki")){            
-            System.out.println("Command Helper uses a language called MScript, which greatly extend the capabilities of the plugin, "
-                    + "and make the plugin a fully "
-                    + "[http://en.wikipedia.org/wiki/Turing_Complete Turing Complete] language. "
-                    + "There are several functions defined, and they are grouped into \"classes\". ");
-            System.out.println("<p>Each function has its own page for documentation, where you can put examples for how to use"
-                    + " particular functions. Because this is a wiki, it is encouraged that you edit the pages if you see errors, "
-                    + "or can think of a better example to show. Please copy over [[CommandHelper/API/Function Template|this template]]"
-                    + " and use it.");
-        } else if(type.equals("text")){
-            System.out.println("Command Helper uses a language called MScript, which greatly extend the capabilities of the plugin, "
-                    + "and make the plugin a fully "
-                    + "Turing Complete language [http://en.wikipedia.org/wiki/Turing_Complete].\n"
-                    + "There are several functions defined, and they are grouped into \"classes\".");
-        }
-
-        for (Map.Entry<Class, ArrayList<Function>> entry : functionlist.entrySet()) {
-            Class apiClass = entry.getKey();
-            String className = apiClass.getName().split("\\.")[apiClass.getName().split("\\.").length - 1];
-            if(className.equals("Sandbox")){
-                continue; //Skip Sandbox functions
-            }
-            String classDocs = null;
-            try {
-                Method m = apiClass.getMethod("docs", (Class[]) null);
-                Object o = null;
-                if((m.getModifiers() & Modifier.STATIC) == 0){
-                    try {
-                        o = apiClass.newInstance();
-                    } catch (InstantiationException ex) {}
-                }
-                classDocs = (String) m.invoke(o, (Object[]) null);
-            } catch (IllegalAccessException ex) {
-            } catch (IllegalArgumentException ex) {
-            } catch (InvocationTargetException ex) {
-            } catch (NoSuchMethodException e) {}
-            if(type.equals("html")){
-                if(className != null){
-                    System.out.println("<h1>" + className + "</h1>");
-                    System.out.println(classDocs == null?"":classDocs);
-                } else {
-                    System.out.println("<h1>Other Functions</h1>");
-                }
-                System.out.println("<table>");
-            } else if(type.equals("wiki")){
-                if(className != null){
-                    System.out.println("===" + className + "===");
-                    System.out.println(classDocs == null?"":classDocs);
-                } else {
-                    System.out.println("===Other Functions===");
-                }
-                System.out.println("{| width=\"100%\" cellspacing=\"1\" cellpadding=\"1\" border=\"1\" align=\"left\" class=\"wikitable\"\n" +
-                                    "|-\n" +
-                                    "! scope=\"col\" width=\"6%\" | Function Name\n" + 
-                                    "! scope=\"col\" width=\"5%\" | Returns\n" + 
-                                    "! scope=\"col\" width=\"10%\" | Arguments\n" + 
-                                    "! scope=\"col\" width=\"10%\" | Throws\n" +
-                                    "! scope=\"col\" width=\"61%\" | Description\n" +
-                                    "! scope=\"col\" width=\"3%\" | Since\n" + 
-                                    "! scope=\"col\" width=\"5%\" | Restricted");
-            } else if(type.equals("text")){
-                System.out.println("**********************************************************************************************");
-                if(className != null){
-                    System.out.println(classDocs == null?"":classDocs);
-                } else {
-                    System.out.println("Other Functions");
-                }
-                System.out.println("**********************************************************************************************");
-            }
-            for(Function f : entry.getValue()){
-                String doc = f.docs();
-                String ret = null;
-                String args = null;
-                String desc = null;
-                String restricted = f.isRestricted()?"<div style=\"background-color: red; font-weight: bold; text-align: center;\">Yes</div>":
-                        "<div style=\"background-color: green; font-weight: bold; text-align: center;\">No</div>";
-                StringBuilder thrown = new StringBuilder();
-                if(f.thrown() != null){
-                    List thrownList = Arrays.asList(f.thrown());
-                    for(int i = 0; i < thrownList.size(); i++){
-                        ExceptionType t = (ExceptionType)thrownList.get(i);
-                        if(type.equals("html") || type.equals("text")){
-                            if(i != 0){
-                                thrown.append((type.equals("html")?"<br />\n":" | "));
-                            }
-                            thrown.append(t.toString());
-                        } else {
-                            if(i != 0){
-                                thrown.append("<br />\n");
-                            }
-                            thrown.append("[[Exceptions#").append(t.toString()).append("|").append(t.toString()).append("]]");
-                        }
-                    }
-                }
-                
-                String since = f.since();
-                Pattern p = Pattern.compile("\\s*(.*?)\\s*\\{(.*?)\\}\\s*(.*)\\s*");
-                Matcher m = p.matcher(doc);
-                if(m.find()){
-                    ret = m.group(1);
-                    args = m.group(2);
-                    desc = m.group(3);
-                }
-                if(ret == null || args == null || desc == null){
-                    System.out.println(f.getName() + "'s documentation is not correctly formatted. Please check it and try again.");
-                }
-                if(type.equals("html")){
-                    System.out.println("<tr><td>" + ret + "</td><td>" + args + "</td><td>" + thrown.toString() + "</td><td>" + desc + "</td><td>" + since + "</td><td>" + restricted + "</td></tr>\n");
-                } else if(type.equals("wiki")){
-                    //Turn args into a prettified version
-                    args = args.replaceAll("\\|", "<hr />").replaceAll("\\[(.*?)\\]", "<strong>[</strong>$1<strong>]</strong>");
-                    System.out.println("|-\n"
-                            + "! scope=\"row\" | [[CommandHelper/API/" + f.getName() + "|" + f.getName() + "]]\n"
-                            + "| " + ret + "\n"
-                            + "| " + args + "\n"
-                            + "| " + thrown.toString() + "\n"
-                            + "| " + desc + "\n"
-                            + "| " + since + "\n"
-                            + "| " + restricted);
-                   
-                } else if(type.equals("text")){
-                    System.out.println(ret + f.getName() + "(" + args + ")" + " {" + thrown.toString() + "}\n\t" + desc + "\n\t" + since + (f.isRestricted()?"\n\tThis function is restricted":
-                            "\n\tThis function is not restricted"));
-                }
-            }
-            if(type.equals("html")){
-                System.out.println("</table>");
-            } else if(type.equals("wiki")){
-                System.out.println("|}");
-            } else if(type.equals("text")){
-                System.out.println();
-            }
-        }
-        if(type.equals("html")){
-            System.out.println(""
-                    + "<h2>Errors in documentation</h2>\n"
-                    + "<em>Please note that this documentation is generated automatically,"
-                    + " if you notice an error in the documentation, please file a bug report for the"
-                    + " plugin itself!</em>");
-        } else if(type.equals("wiki")){
-            System.out.println(""
-                    + "===Errors in documentation===\n"
-                    + "''Please note that this documentation is generated automatically,"
-                    + " if you notice an error in the documentation, please file a bug report for the"
-                    + " plugin itself!'' For information on undocumented functions, see [[CommandHelper/Sandbox|this page]]");
-        }
-    }
-
-}
diff --git a/src/main/java/com/laytonsmith/aliasengine/GenericTree.java b/src/main/java/com/laytonsmith/aliasengine/GenericTree.java
deleted file mode 100644
index e20f7c5..0000000
--- a/src/main/java/com/laytonsmith/aliasengine/GenericTree.java
+++ /dev/null
@@ -1,192 +0,0 @@
-/*
- Copyright 2010 Vivin Suresh Paliath
- Distributed under the BSD License
-*/
-
-package com.laytonsmith.aliasengine;
-
-import java.util.*;
-
-public class GenericTree<T> {
-
-    private GenericTreeNode<T> root;
-
-    public GenericTree() {
-        super();
-    }
-
-    public GenericTreeNode<T> getRoot() {
-        return this.root;
-    }
-
-    public void setRoot(GenericTreeNode<T> root) {
-        this.root = root;
-    }
-
-    public int getNumberOfNodes() {
-        int numberOfNodes = 0;
-
-        if(root != null) {
-            numberOfNodes = auxiliaryGetNumberOfNodes(root) + 1; //1 for the root!
-        }
-
-        return numberOfNodes;
-    }
-
-    private int auxiliaryGetNumberOfNodes(GenericTreeNode<T> node) {
-        int numberOfNodes = node.getNumberOfChildren();
-
-        for(GenericTreeNode<T> child : node.getChildren()) {
-            numberOfNodes += auxiliaryGetNumberOfNodes(child);
-        }
-
-        return numberOfNodes;
-    }
-
-    public boolean exists(GenericTreeNode<T> nodeToFind) {
-        return (find(nodeToFind) != null);
-    }
-
-    public GenericTreeNode<T> find(GenericTreeNode<T> nodeToFind) {
-        GenericTreeNode<T> returnNode = null;
-
-        if(root != null) {
-            returnNode = auxiliaryFind(root, nodeToFind);
-        }
-
-        return returnNode;
-    }
-
-    private GenericTreeNode<T> auxiliaryFind(GenericTreeNode<T> currentNode, GenericTreeNode<T> nodeToFind) {
-        GenericTreeNode<T> returnNode = null;
-        int i = 0;
-
-        if (currentNode.equals(nodeToFind)) {
-            returnNode = currentNode;
-        }
-
-        else if(currentNode.hasChildren()) {
-            i = 0;
-            while(returnNode == null && i < currentNode.getNumberOfChildren()) {
-                returnNode = auxiliaryFind(currentNode.getChildAt(i), nodeToFind);
-                i++;
-            }
-        }
-
-        return returnNode;
-    }
-
-    public boolean isEmpty() {
-        return (root == null);
-    }
-
-    public List<GenericTreeNode<T>> build(GenericTreeTraversalOrderEnum traversalOrder) {
-        List<GenericTreeNode<T>> returnList = null;
-
-        if(root != null) {
-            returnList = build(root, traversalOrder);
-        }
-
-        return returnList;
-    }
-
-    public List<GenericTreeNode<T>> build(GenericTreeNode<T> node, GenericTreeTraversalOrderEnum traversalOrder) {
-        List<GenericTreeNode<T>> traversalResult = new ArrayList<GenericTreeNode<T>>();
-
-        if(traversalOrder == GenericTreeTraversalOrderEnum.PRE_ORDER) {
-            buildPreOrder(node, traversalResult);
-        }
-
-        else if(traversalOrder == GenericTreeTraversalOrderEnum.POST_ORDER) {
-            buildPostOrder(node, traversalResult);
-        }
-
-        return traversalResult;
-    }
-
-    private synchronized void buildPreOrder(GenericTreeNode<T> node, List<GenericTreeNode<T>> traversalResult) {
-        traversalResult.add(node);
-        
-        for(int i = 0; i < node.getNumberOfChildren(); i++){
-        //for(GenericTreeNode<T> child : node.getChildren()) {
-            buildPreOrder(node.getChildAt(i), traversalResult);
-        }
-    }
-
-    private void buildPostOrder(GenericTreeNode<T> node, List<GenericTreeNode<T>> traversalResult) {
-        for(GenericTreeNode<T> child : node.getChildren()) {
-            buildPostOrder(child, traversalResult);
-        }
-
-        traversalResult.add(node);
-    }
-
-    public Map<GenericTreeNode<T>, Integer> buildWithDepth(GenericTreeTraversalOrderEnum traversalOrder) {
-        Map<GenericTreeNode<T>, Integer> returnMap = null;
-
-        if(root != null) {
-            returnMap = buildWithDepth(root, traversalOrder);
-        }
-
-        return returnMap;
-    }
-
-    public Map<GenericTreeNode<T>, Integer> buildWithDepth(GenericTreeNode<T> node, GenericTreeTraversalOrderEnum traversalOrder) {
-        Map<GenericTreeNode<T>, Integer> traversalResult = new LinkedHashMap<GenericTreeNode<T>, Integer>();
-
-        if(traversalOrder == GenericTreeTraversalOrderEnum.PRE_ORDER) {
-            buildPreOrderWithDepth(node, traversalResult, 0);
-        }
-
-        else if(traversalOrder == GenericTreeTraversalOrderEnum.POST_ORDER) {
-            buildPostOrderWithDepth(node, traversalResult, 0);
-        }
-
-        return traversalResult;
-    }
-
-    private void buildPreOrderWithDepth(GenericTreeNode<T> node, Map<GenericTreeNode<T>, Integer> traversalResult, int depth) {
-        traversalResult.put(node, depth);
-
-        for(GenericTreeNode<T> child : node.getChildren()) {
-            buildPreOrderWithDepth(child, traversalResult, depth + 1);
-        }
-    }
-
-    private void buildPostOrderWithDepth(GenericTreeNode<T> node, Map<GenericTreeNode<T>, Integer> traversalResult, int depth) {
-        for(GenericTreeNode<T> child : node.getChildren()) {
-            buildPostOrderWithDepth(child, traversalResult, depth + 1);
-        }
-
-        traversalResult.put(node, depth);
-    }
-
-    public String toString() {
-        /*
-        We're going to assume a pre-order traversal by default
-         */
-
-        String stringRepresentation = "";
-
-        if(root != null) {
-            stringRepresentation = build(GenericTreeTraversalOrderEnum.PRE_ORDER).toString();
-
-        }
-
-        return stringRepresentation;
-    }
-
-    public String toStringWithDepth() {
-        /*
-        We're going to assume a pre-order traversal by default
-         */
-
-        String stringRepresentation = "";
-
-        if(root != null) {
-            stringRepresentation = buildWithDepth(GenericTreeTraversalOrderEnum.PRE_ORDER).toString();
-        }
-
-        return stringRepresentation;
-    }
-}
diff --git a/src/main/java/com/laytonsmith/aliasengine/GenericTreeNode.java b/src/main/java/com/laytonsmith/aliasengine/GenericTreeNode.java
deleted file mode 100644
index 726f571..0000000
--- a/src/main/java/com/laytonsmith/aliasengine/GenericTreeNode.java
+++ /dev/null
@@ -1,154 +0,0 @@
-/*
- Copyright 2010 Visin Suresh Paliath
- Distributed under the BSD license
-*/
-
-package com.laytonsmith.aliasengine;
-
-import java.lang.reflect.InvocationTargetException;
-import java.lang.reflect.Method;
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.List;
-import java.util.logging.Level;
-import java.util.logging.Logger;
-import java.util.regex.Matcher;
-import java.util.regex.Pattern;
-
-public class GenericTreeNode<T> implements Cloneable{
-
-    public T data;
-    public List<GenericTreeNode<T>> children;
-    
-    @Override
-    public GenericTreeNode<T> clone() throws CloneNotSupportedException{
-        GenericTreeNode<T> clone = (GenericTreeNode<T>) super.clone();
-        Class c = data.getClass();
-        if(Arrays.asList(c.getInterfaces()).contains(Cloneable.class)){
-            try{
-                Method m = c.getMethod("clone", new Class[]{});
-                Object obj = m.invoke(data, new Object[]{});
-                clone.data = (T) obj;
-                clone.children = new ArrayList<GenericTreeNode<T>>(children);
-            } catch (IllegalAccessException ex) {
-                throw new CloneNotSupportedException();
-            } catch (IllegalArgumentException ex) {
-                throw new CloneNotSupportedException();
-            } catch (InvocationTargetException ex) {
-                throw new CloneNotSupportedException();
-            } catch(NoSuchMethodException e){
-                throw new CloneNotSupportedException();
-            }
-        }
-        return clone;
-    }
-
-    public GenericTreeNode() {
-        super();
-        children = new ArrayList<GenericTreeNode<T>>();
-    }
-
-    public GenericTreeNode(T data) {
-        this();
-        setData(data);
-    }
-
-    public synchronized List<GenericTreeNode<T>> getChildren() {
-        return this.children;
-    }
-
-    public int getNumberOfChildren() {
-        return getChildren().size();
-    }
-
-    public boolean hasChildren() {
-        return (getNumberOfChildren() > 0);
-    }
-
-    public void setChildren(List<GenericTreeNode<T>> children) {
-        this.children = children;
-    }
-
-    public void addChild(GenericTreeNode<T> child) {
-        children.add(child);
-    }
-
-    public void addChildAt(int index, GenericTreeNode<T> child) throws IndexOutOfBoundsException {
-        children.add(index, child);
-    }
-
-    public void removeChildren() {
-        this.children = new ArrayList<GenericTreeNode<T>>();
-    }
-
-    public void removeChildAt(int index) throws IndexOutOfBoundsException {
-        children.remove(index);
-    }
-
-    public GenericTreeNode<T> getChildAt(int index) throws IndexOutOfBoundsException {
-        return children.get(index);
-    }
-
-    public T getData() {
-        return this.data;
-    }
-
-    public void setData(T data) {
-        this.data = data;
-    }
-
-    public String toString() {
-        return getData().toString();
-    }
-
-	@Override
-	public boolean equals(Object obj) {
-		if (this == obj) {
-			return true;
-		}
-		if (obj == null) {
-			return false;
-		}
-		if (getClass() != obj.getClass()) {
-			return false;
-		}
-		GenericTreeNode<?> other = (GenericTreeNode<?>) obj;
-		if (data == null) {
-			if (other.data != null) {
-				return false;
-			}
-		} else if (!data.equals(other.data)) {
-			return false;
-		}
-		return true;
-	}
-
-	/* (non-Javadoc)
-	 * @see java.lang.Object#hashCode()
-	 */
-	@Override
-	public int hashCode() {
-		final int prime = 31;
-		int result = 1;
-		result = prime * result + ((data == null) ? 0 : data.hashCode());
-		return result;
-	}
-
-    public String toStringVerbose() {
-        String stringRepresentation = getData().toString() + ":[";
-
-        for (GenericTreeNode<T> node : getChildren()) {
-            stringRepresentation += node.getData().toString() + ", ";
-        }
-
-        //Pattern.DOTALL causes ^ and $ to match. Otherwise it won't. It's retarded.
-        Pattern pattern = Pattern.compile(", $", Pattern.DOTALL);
-        Matcher matcher = pattern.matcher(stringRepresentation);
-
-        stringRepresentation = matcher.replaceFirst("");
-        stringRepresentation += "]";
-
-        return stringRepresentation;
-    }
-}
-
diff --git a/src/main/java/com/laytonsmith/aliasengine/GenericTreeTraversalOrderEnum.java b/src/main/java/com/laytonsmith/aliasengine/GenericTreeTraversalOrderEnum.java
deleted file mode 100644
index 107e8f7..0000000
--- a/src/main/java/com/laytonsmith/aliasengine/GenericTreeTraversalOrderEnum.java
+++ /dev/null
@@ -1,11 +0,0 @@
-/*
- Copyright 2010 Vivin Suresh Paliath
- Distributed under the BSD License
-*/
-
-package com.laytonsmith.aliasengine;
-
-public enum GenericTreeTraversalOrderEnum {
-    PRE_ORDER,
-    POST_ORDER
-}
diff --git a/src/main/java/com/laytonsmith/aliasengine/Installer.java b/src/main/java/com/laytonsmith/aliasengine/Installer.java
deleted file mode 100644
index 53e5f0b..0000000
--- a/src/main/java/com/laytonsmith/aliasengine/Installer.java
+++ /dev/null
@@ -1,52 +0,0 @@
-/*
- * To change this template, choose Tools | Templates
- * and open the template in the editor.
- */
-package com.laytonsmith.aliasengine;
-
-import com.laytonsmith.PureUtilities.fileutility.FileUtility;
-import java.io.File;
-import java.io.IOException;
-import java.util.logging.Level;
-import java.util.logging.Logger;
-
-/**
- *
- * @author Layton
- */
-public class Installer {
-
-    public static void Install() {
-        //Check to see if the auto_include file exists. If not, include it now
-        new File("plugins/CommandHelper/includes").mkdirs();
-        File auto_include = new File("plugins/CommandHelper/auto_include.ms");
-        if(!auto_include.exists()){
-            String sample = parseISToString(Installer.class.getResourceAsStream("/samp_auto_include.txt"));
-            sample = sample.replaceAll("\n|\r\n", System.getProperty("line.separator"));
-            try {
-                FileUtility.write(sample, auto_include);
-            } catch (IOException ex) {
-                Logger.getLogger(Installer.class.getName()).log(Level.SEVERE, null, ex);
-            }
-        }
-    }
-
-    public static String parseISToString(java.io.InputStream is) {
-        java.io.DataInputStream din = new java.io.DataInputStream(is);
-        StringBuilder sb = new StringBuilder();
-        try {
-            String line = null;
-            while ((line = din.readLine()) != null) {
-                sb.append(line).append("\n");
-            }
-        } catch (Exception ex) {
-            ex.getMessage();
-        } finally {
-            try {
-                is.close();
-            } catch (Exception ex) {
-            }
-        }
-        return sb.toString();
-    }
-}
diff --git a/src/main/java/com/laytonsmith/aliasengine/InternalException.java b/src/main/java/com/laytonsmith/aliasengine/InternalException.java
deleted file mode 100644
index c160142..0000000
--- a/src/main/java/com/laytonsmith/aliasengine/InternalException.java
+++ /dev/null
@@ -1,28 +0,0 @@
-/*
- * To change this template, choose Tools | Templates
- * and open the template in the editor.
- */
-package com.laytonsmith.aliasengine;
-
-/**
- * An internal exception is thrown when an unexpected error occurs
- * in the actual plugin itself, not the user scripts. If this exception
- * is thrown, the plugin is effectively disabled.
- * @author Layton
- */
-public class InternalException extends RuntimeException {
-
-    /**
-     * Creates a new instance of <code>InternalException</code> without detail message.
-     */
-    public InternalException() {
-    }
-
-    /**
-     * Constructs an instance of <code>InternalException</code> with the specified detail message.
-     * @param msg the detail message.
-     */
-    public InternalException(String msg) {
-        super(msg);
-    }
-}
diff --git a/src/main/java/com/laytonsmith/aliasengine/LICENSE b/src/main/java/com/laytonsmith/aliasengine/LICENSE
deleted file mode 100644
index 2b15665..0000000
--- a/src/main/java/com/laytonsmith/aliasengine/LICENSE
+++ /dev/null
@@ -1,12 +0,0 @@
-THIS LICENSE APPLIES ONLY TO THE GENERIC TREE CLASSES, NOT THE MAIN CLASS FILES
-
-Copyright (c) 2010, Vivin Suresh Paliath 
-All rights reserved.
-
-Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
-
-    * Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
-    * Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
-    * Neither the name of the <ORGANIZATION> nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.
-
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
diff --git a/src/main/java/com/laytonsmith/aliasengine/MScriptCompiler.java b/src/main/java/com/laytonsmith/aliasengine/MScriptCompiler.java
deleted file mode 100644
index ff7ffbf..0000000
--- a/src/main/java/com/laytonsmith/aliasengine/MScriptCompiler.java
+++ /dev/null
@@ -1,513 +0,0 @@
-/*
- * To change this template, choose Tools | Templates
- * and open the template in the editor.
- */
-package com.laytonsmith.aliasengine;
-
-import com.laytonsmith.aliasengine.functions.exceptions.ConfigCompileException;
-import com.laytonsmith.aliasengine.Constructs.*;
-import com.laytonsmith.aliasengine.Constructs.Token.TType;
-import com.laytonsmith.aliasengine.functions.FunctionList;
-import com.laytonsmith.aliasengine.functions.IVariableList;
-import java.io.File;
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.EmptyStackException;
-import java.util.List;
-import java.util.Stack;
-import java.util.concurrent.atomic.AtomicInteger;
-import org.bukkit.command.CommandSender;
-
-/**
- *
- * @author Layton
- */
-public class MScriptCompiler {
-
-    public static List<Token> lex(String config, File file) throws ConfigCompileException {
-        config = config.replaceAll("\r\n", "\n");
-        config = config + "\n";
-        List<Token> token_list = new ArrayList<Token>();
-        //Set our state variables
-        boolean state_in_quote = false;
-        boolean in_comment = false;
-            boolean comment_is_block = false;
-        boolean in_opt_var = false;
-        StringBuffer buf = new StringBuffer();
-        int line_num = 1;
-        //first we lex
-        for (int i = 0; i < config.length(); i++) {
-            Character c = config.charAt(i);
-            Character c2 = null;
-            if (i < config.length() - 1) {
-                c2 = config.charAt(i + 1);
-            }
-            if (c == '\n') {
-                line_num++;
-            }
-//            if ((token_list.isEmpty() || token_list.get(token_list.size() - 1).type.equals(TType.NEWLINE))
-//                    && c == '#') {
-            if((c == '#' || (c == '/' && (c2 == '*'))) && !in_comment && !state_in_quote){
-                in_comment = true;
-                if(c2 == '*'){
-                    comment_is_block = true;
-                }
-                continue;
-            }
-            if (in_comment){                
-                if(!comment_is_block && c != '\n' || comment_is_block && c != '*' && (c2 != null && c2 != '/')){
-                    continue;
-                }
-            }
-            if(c == '*' && c2 == '/' && in_comment && comment_is_block){
-                in_comment = false;
-                comment_is_block = false;
-                i++;
-                continue;
-            }
-            if (c == '[' && !state_in_quote) {
-                if (buf.length() > 0) {
-                    token_list.add(new Token(TType.UNKNOWN, buf.toString(), line_num, file));
-                    buf = new StringBuffer();
-                }
-                token_list.add(new Token(TType.LSQUARE_BRACKET, "[", line_num, file));
-                in_opt_var = true;
-                continue;
-            }
-            if (c == '=' && !state_in_quote) {
-                if (buf.length() > 0) {
-                    token_list.add(new Token(TType.UNKNOWN, buf.toString(), line_num, file));
-                    buf = new StringBuffer();
-                }
-                if (in_opt_var) {
-                    token_list.add(new Token(TType.OPT_VAR_ASSIGN, "=", line_num, file));
-                } else {
-                    token_list.add(new Token(TType.ALIAS_END, "=", line_num, file));
-                }
-                continue;
-            }
-            if (c == ']' && !state_in_quote) {
-                if (buf.length() > 0) {
-                    token_list.add(new Token(TType.UNKNOWN, buf.toString(), line_num, file));
-                    buf = new StringBuffer();
-                }
-                token_list.add(new Token(TType.RSQUARE_BRACKET, "]", line_num, file));
-                in_opt_var = false;
-                continue;
-            }
-            if (c == ':' && !state_in_quote) {
-                if (buf.length() > 0) {
-                    token_list.add(new Token(TType.UNKNOWN, buf.toString(), line_num, file));
-                    buf = new StringBuffer();
-                }
-                token_list.add(new Token(TType.IDENT, ":", line_num, file));
-                continue;
-            }
-            if (c == ',' && !state_in_quote) {
-                if (buf.length() > 0) {
-                    token_list.add(new Token(TType.UNKNOWN, buf.toString(), line_num, file));
-                    buf = new StringBuffer();
-                }
-                token_list.add(new Token(TType.COMMA, ",", line_num, file));
-                continue;
-            }
-            if (c == '(' && !state_in_quote) {
-                if (buf.length() > 0) {
-                    token_list.add(new Token(TType.FUNC_NAME, buf.toString(), line_num, file));
-                    buf = new StringBuffer();
-                }
-                token_list.add(new Token(TType.FUNC_START, "(", line_num, file));
-                continue;
-            }
-            if (c == ')' && !state_in_quote) {
-                if (buf.length() > 0) {
-                    token_list.add(new Token(TType.UNKNOWN, buf.toString(), line_num, file));
-                    buf = new StringBuffer();
-                }
-                token_list.add(new Token(TType.FUNC_END, ")", line_num, file));
-                continue;
-            }
-            if (Character.isWhitespace(c) && !state_in_quote && c != '\n') {
-                //ignore the whitespace, but end the previous token
-                if (buf.length() > 0) {
-                    token_list.add(new Token(TType.UNKNOWN, buf.toString(), line_num, file));
-                    buf = new StringBuffer();
-                }
-            } else if (c == '\'') {
-                if (state_in_quote) {
-                    token_list.add(new Token(TType.STRING, buf.toString(), line_num, file));
-                    buf = new StringBuffer();
-                    state_in_quote = false;
-                    continue;
-                } else {
-                    state_in_quote = true;
-                    if (buf.length() > 0) {
-                        token_list.add(new Token(TType.UNKNOWN, buf.toString(), line_num, file));
-                        buf = new StringBuffer();
-                    }
-                    continue;
-                }
-            } else if (c == '\\') {
-                //escaped characters
-                if (state_in_quote) {
-                    if (c2 == '\\') {
-                        buf.append("\\");
-                    } else if (c2 == '\'') {
-                        buf.append("'");
-                    } else if(c2 == 'n'){
-                        buf.append("\n");
-                    } else if(c2 == 'u'){
-                        //Grab the next 4 characters, and check to see if they are numbers
-                        StringBuilder unicode = new StringBuilder();
-                        for(int m = 0; m < 4; m++){
-                            unicode.append(config.charAt(i + 2 + m));
-                        }
-                        try{
-                            Integer.parseInt(unicode.toString(), 16);
-                        } catch(NumberFormatException e){
-                            throw new ConfigCompileException("Unrecognized unicode escape sequence", line_num);
-                        }
-                        buf.append(Character.toChars(Integer.parseInt(unicode.toString(), 16)));                        
-                        i += 4;
-                    } else {
-                        //Since we might expand this list later, don't let them
-                        //use unescaped backslashes
-                        throw new ConfigCompileException("The escape sequence \\" + c2 + " is not a recognized escape sequence", line_num);
-                    }
-
-                    i++;
-                    continue;
-                } else {
-                    //Control character backslash
-                    token_list.add(new Token(TType.SEPERATOR, "\\", line_num, file));
-                }
-            } else if (state_in_quote) {
-                buf.append(c);
-                continue;
-            } else if (c == '\n' && !comment_is_block) {
-                if (buf.length() > 0) {
-                    token_list.add(new Token(TType.UNKNOWN, buf.toString(), line_num, file));
-                    buf = new StringBuffer();
-                }
-                token_list.add(new Token(TType.NEWLINE, "\n", line_num, file));
-                in_comment = false;
-                comment_is_block = false;
-                continue;
-            } else { //in a literal
-                buf.append(c);
-                continue;
-            }
-        } //end lexing
-        if(state_in_quote){
-            throw new ConfigCompileException("Unended string literal", line_num);
-        }
-        if(in_comment || comment_is_block){
-            throw new ConfigCompileException("Unended comment", line_num);
-        }
-                //look at the tokens, and get meaning from them
-        for (Token t : token_list) {
-            if (t.type.equals(TType.UNKNOWN)) {
-                if (t.val().matches("/.*")) {
-                    t.type = TType.COMMAND;
-                } else if (t.val().matches("\\\\")) {
-                    t.type = TType.SEPERATOR;
-                } else if (t.val().matches("\\$[a-zA-Z0-9_]+")) {
-                    t.type = TType.VARIABLE;
-                } else if (t.val().matches("\\@[a-zA-Z0-9_]+")) {
-                    t.type = TType.IVARIABLE;
-                } else if (t.val().equals("$")) {
-                    t.type = TType.FINAL_VAR;
-                } else {
-                    t.type = TType.LIT;
-                }
-            }
-        }
-        return token_list;
-    }
-
-    /**
-     * This function breaks the token stream into parts, seperating the aliases/MScript from the command triggers
-     * @param tokenStream
-     * @return
-     * @throws ConfigCompileException 
-     */
-    public static List<Script> preprocess(List<Token> tokenStream) throws ConfigCompileException {
-        //First, pull out the duplicate newlines
-        ArrayList<Token> temp = new ArrayList<Token>();
-        for (int i = 0; i < tokenStream.size(); i++) {
-            try {
-                if (tokenStream.get(i).type.equals(TType.NEWLINE)) {
-                    temp.add(new Token(TType.NEWLINE, "\n", tokenStream.get(i).line_num, tokenStream.get(i).file));
-                    while (tokenStream.get(++i).type.equals(TType.NEWLINE)) {
-                    }
-                }
-                temp.add(tokenStream.get(i));
-            } catch (IndexOutOfBoundsException e) {
-            }
-        }
-
-        if (temp.size() > 0 && temp.get(0).type.equals(TType.NEWLINE)) {
-            temp.remove(0);
-        }
-
-        tokenStream = temp;
-        temp = new ArrayList<Token>();
-
-        //Handle multiline constructs
-        ArrayList<Token> tokens1_1 = new ArrayList<Token>();
-        boolean inside_multiline = false;
-        for (int i = 0; i < tokenStream.size(); i++) {
-            Token prevToken = i - 1 >= tokenStream.size() ? tokenStream.get(i - 1) : new Token(TType.UNKNOWN, "", 0, null);
-            Token thisToken = tokenStream.get(i);
-            Token nextToken = i + 1 < tokenStream.size() ? tokenStream.get(i + 1) : new Token(TType.UNKNOWN, "", 0, null);
-            //take out newlines between the = >>> and <<< tokens (also the tokens)
-            if (thisToken.type.equals(TType.ALIAS_END) && nextToken.val().equals(">>>")) {
-                inside_multiline = true;
-                tokens1_1.add(thisToken);
-                i++;
-                continue;
-            }
-            if (thisToken.val().equals("<<<")) {
-                if (!inside_multiline) {
-                    throw new ConfigCompileException("Found multiline end symbol, and no multiline start found",
-                            thisToken.line_num);
-                }
-                inside_multiline = false;
-                continue;
-            }
-            if (thisToken.val().equals(">>>") && !prevToken.type.equals(TType.ALIAS_END)) {
-                throw new ConfigCompileException("Multiline symbol must follow the alias_end token", thisToken.line_num);
-            }
-
-            //If we're not in a multiline construct, or we are in it and it's not a newline, add
-            //it
-            if (!inside_multiline || (inside_multiline && !thisToken.type.equals(TType.NEWLINE))) {
-                tokens1_1.add(thisToken);
-            }
-        }
-
-        //take out newlines that are behind a \
-        ArrayList<Token> tokens2 = new ArrayList<Token>();
-        for (int i = 0; i < tokens1_1.size(); i++) {
-            if (!tokens1_1.get(i).type.equals(TType.STRING) && tokens1_1.get(i).val().equals("\\") && tokens1_1.size() > i
-                    && tokens1_1.get(i + 1).type.equals(TType.NEWLINE)) {
-                tokens2.add(tokens1_1.get(i));
-                i++;
-                continue;
-            }
-            tokens2.add(tokens1_1.get(i));
-        }
-
-
-
-
-
-        //Now that we have all lines minified, we should be able to split
-        //on newlines, and easily find the left and right sides
-
-        List<Token> left = new ArrayList<Token>();
-        List<Token> right = new ArrayList<Token>();
-        List<Script> scripts = new ArrayList<Script>();
-        boolean inLeft = true;
-        for (Token t : tokens2) {
-            if (inLeft) {
-                if (t.type == TType.ALIAS_END) {
-                    inLeft = false;
-                } else {
-                    left.add(t);
-                }
-            } else {
-                if (t.type == TType.NEWLINE) {
-                    inLeft = true;
-                    Script s = new Script(left, right);
-                    scripts.add(s);
-                    left = new ArrayList();
-                    right = new ArrayList();
-                } else {
-                    right.add(t);
-                }
-            }
-        }
-        return scripts;
-    }
-
-    public static GenericTreeNode<Construct> compile(List<Token> stream) throws ConfigCompileException {
-        GenericTreeNode<Construct> tree = new GenericTreeNode<Construct>();
-        tree.setData(new CNull(0, null));
-        Stack<GenericTreeNode> parents = new Stack<GenericTreeNode>();
-        Stack<AtomicInteger> constructCount = new Stack<AtomicInteger>();
-        constructCount.push(new AtomicInteger(0));
-        Stack<AtomicInteger> arrayStack = new Stack<AtomicInteger>();
-        arrayStack.add(new AtomicInteger(-1));
-        parents.push(tree);
-        int parens = 0;
-        Token t = null;
-        for (int i = 0; i < stream.size(); i++) {
-            t = stream.get(i);
-            Token prev = i - 1 >= 0 ? stream.get(i - 1) : new Token(TType.UNKNOWN, "", t.line_num, t.file);
-            
-            //Array notation handling
-            if(t.type.equals(TType.LSQUARE_BRACKET)){                
-                arrayStack.push(new AtomicInteger(tree.getChildren().size() - 1));
-                continue;
-            } else if(t.type.equals(TType.RSQUARE_BRACKET)){
-                boolean emptyArray = false;
-                if(prev.type.equals(TType.LSQUARE_BRACKET)){
-                    //throw new ConfigCompileException("Empty array_get operator ([])", t.line_num); 
-                    emptyArray = true;
-                }
-                if(arrayStack.size() == 1){
-                    throw new ConfigCompileException("Mismatched square bracket", t.line_num);
-                }
-                int array = arrayStack.pop().get();
-                int index = array + 1;
-                GenericTreeNode<Construct> myArray = tree.getChildAt(array);
-                GenericTreeNode<Construct> myIndex;
-                if(!emptyArray){
-                    myIndex = tree.getChildAt(index);
-                } else {
-                    myIndex = new GenericTreeNode<Construct>(new CString("0..-1", t.line_num, t.file));
-                }
-                tree.setChildren(tree.getChildren().subList(0, array));
-                GenericTreeNode<Construct> arrayGet = new GenericTreeNode<Construct>(new CFunction("array_get", t.line_num, t.file));
-                arrayGet.addChild(myArray);
-                arrayGet.addChild(myIndex);
-                tree.addChild(arrayGet);
-                constructCount.peek().decrementAndGet();
-            }
-            /*if (t.type.equals(TType.OPT_VAR_ASSIGN) || t.type.equals(TType.LSQUARE_BRACKET)
-                    || t.type.equals(TType.RSQUARE_BRACKET)) {
-                throw new ConfigCompileException("Unexpected " + t.type.toString(), t.line_num);
-            } else */if (t.type == TType.LIT) {
-                tree.addChild(new GenericTreeNode<Construct>(Static.resolveConstruct(t.val(), t.line_num, t.file)));
-                constructCount.peek().incrementAndGet();
-            } else if (t.type.equals(TType.STRING) || t.type.equals(TType.COMMAND)) {
-                tree.addChild(new GenericTreeNode<Construct>(new CString(t.val(), t.line_num, t.file)));
-                constructCount.peek().incrementAndGet();
-            } else if (t.type.equals(TType.IVARIABLE)) {
-                tree.addChild(new GenericTreeNode<Construct>(new IVariable(t.val(), t.line_num, t.file)));
-                constructCount.peek().incrementAndGet();
-            } else if(t.type.equals(TType.UNKNOWN)){
-                tree.addChild(new GenericTreeNode<Construct>(Static.resolveConstruct(t.val(), t.line_num, t.file)));
-                constructCount.peek().incrementAndGet();
-            } else if (t.type.equals(TType.VARIABLE) || t.type.equals(TType.FINAL_VAR)) {
-                tree.addChild(new GenericTreeNode<Construct>(new Variable(t.val(), null, false, t.type.equals(TType.FINAL_VAR), t.line_num, t.file)));
-                constructCount.peek().incrementAndGet();
-                //right_vars.add(new Variable(t.val(), null, t.line_num));
-            } else if (t.type.equals(TType.FUNC_NAME)) {
-                CFunction func = new CFunction(t.val(), t.line_num, t.file);
-                //This will throw an exception for us if the function doesn't exist
-                if(!func.val().matches("^_[^_].*")){
-                    FunctionList.getFunction(func);
-                }
-                GenericTreeNode<Construct> f = new GenericTreeNode<Construct>(func);
-                tree.addChild(f);
-                constructCount.push(new AtomicInteger(0));
-                tree = f;
-                parents.push(f);
-            } else if (t.type.equals(TType.FUNC_START)) {
-                if (!prev.type.equals(TType.FUNC_NAME)) {
-                    throw new ConfigCompileException("Unexpected parenthesis", t.line_num);
-                }
-                parens++;
-            } else if (t.type.equals(TType.FUNC_END)) {
-                if (parens < 0) {
-                    throw new ConfigCompileException("Unexpected parenthesis", t.line_num);
-                }
-                parens--;
-                parents.pop();
-                if(constructCount.peek().get() > 1){
-                    //We need to autoconcat some stuff
-                    int stacks = constructCount.peek().get();
-                    int replaceAt = tree.getChildren().size() - stacks;
-                    GenericTreeNode<Construct> c = new GenericTreeNode<Construct>(new CFunction("sconcat", 0, null));
-                    List<GenericTreeNode<Construct>> subChildren = new ArrayList<GenericTreeNode<Construct>>();
-                    for(int b = replaceAt; b < tree.getNumberOfChildren(); b++){
-                        subChildren.add(tree.getChildAt(b));
-                    }
-                    c.setChildren(subChildren);                    
-                    if(replaceAt > 0){
-                        List<GenericTreeNode<Construct>> firstChildren = new ArrayList<GenericTreeNode<Construct>>();
-                        for(int d = 0; d < replaceAt; d++){
-                            firstChildren.add(tree.getChildAt(d));
-                        }
-                        tree.setChildren(firstChildren);
-                    } else {
-                        tree.removeChildren();
-                    }
-                    tree.addChild(c);
-                }
-                //Check argument number now
-                if(!tree.getData().val().matches("^_[^_].*")){
-                    Integer [] numArgs = FunctionList.getFunction(tree.getData()).numArgs();
-                    if(!Arrays.asList(numArgs).contains(Integer.MAX_VALUE) && !Arrays.asList(numArgs).contains(tree.getChildren().size())){
-                        throw new ConfigCompileException("Incorrect number of arguments passed to " + tree.getData().val(), tree.getData().getLineNum());
-                    }
-                }
-                constructCount.pop();
-                constructCount.peek().incrementAndGet();
-                try{
-                    tree = parents.peek();
-                } catch(EmptyStackException e){
-                    throw new ConfigCompileException("Unexpected end parenthesis", t.line_num);
-                }
-            } else if (t.type.equals(TType.COMMA)) {
-                if(constructCount.peek().get() > 1){
-                    int stacks = constructCount.peek().get();
-                    int replaceAt = tree.getChildren().size() - stacks;
-                    GenericTreeNode<Construct> c = new GenericTreeNode<Construct>(new CFunction("sconcat", 0, null));
-                    List<GenericTreeNode<Construct>> subChildren = new ArrayList<GenericTreeNode<Construct>>();
-                    for(int b = replaceAt; b < tree.getNumberOfChildren(); b++){
-                        subChildren.add(tree.getChildAt(b));
-                    }
-                    c.setChildren(subChildren);                    
-                    if(replaceAt > 0){
-                        List<GenericTreeNode<Construct>> firstChildren = new ArrayList<GenericTreeNode<Construct>>();
-                        for(int d = 0; d < replaceAt; d++){
-                            firstChildren.add(tree.getChildAt(d));
-                        }
-                        tree.setChildren(firstChildren);
-                    } else {
-                        tree.removeChildren();
-                    }
-                    tree.addChild(c);                   
-                }
-                constructCount.peek().set(0);
-                continue;
-            } 
-        }
-        if(arrayStack.size() != 1){
-            throw new ConfigCompileException("Mismatched square brackets", t.line_num);
-        }
-        if (parens != 0) {
-            throw new ConfigCompileException("Mismatched parenthesis", t.line_num);
-        }
-        return tree;
-    }      
-    
-    /**
-     * Executes a pre-compiled mscript, given the specified Script environment. Both done and script 
-     * may be null, and if so, reasonable defaults will be provided. Technically, this function doesn't
-     * check to see if p is null either.
-     * @param root
-     * @param p
-     * @param done
-     * @param script 
-     */
-    public static void execute(GenericTreeNode<Construct> root, CommandSender p, MScriptComplete done, Script script){
-        if(script == null){
-            script = new Script(null, null);
-            script.varList = new IVariableList();
-        }
-        StringBuilder b = new StringBuilder();
-        for (GenericTreeNode<Construct> gg : root.getChildren()) {
-            String ret = script.eval(gg, p).val();
-            if (ret != null && !ret.trim().equals("")) {
-                b.append(ret).append(" ");
-            }
-        }
-        if(done != null){
-            done.done(b.toString().trim());
-        }
-    }
-}
diff --git a/src/main/java/com/laytonsmith/aliasengine/MScriptComplete.java b/src/main/java/com/laytonsmith/aliasengine/MScriptComplete.java
deleted file mode 100644
index 9e915e5..0000000
--- a/src/main/java/com/laytonsmith/aliasengine/MScriptComplete.java
+++ /dev/null
@@ -1,19 +0,0 @@
-/*
- * To change this template, choose Tools | Templates
- * and open the template in the editor.
- */
-package com.laytonsmith.aliasengine;
-
-/**
- *
- * @author Layton
- */
-public interface MScriptComplete {
-    /**
-     * This function is called when the mscript has finished. Any output generated
-     * by the script is sent here. If the script generated an error, null is sent.
-     * If the script ran successfully, but did not return any output, an empty string
-     * is sent.
-     */
-    public void done(String output);
-}
diff --git a/src/main/java/com/laytonsmith/aliasengine/Main.java b/src/main/java/com/laytonsmith/aliasengine/Main.java
deleted file mode 100644
index a498df1..0000000
--- a/src/main/java/com/laytonsmith/aliasengine/Main.java
+++ /dev/null
@@ -1,153 +0,0 @@
-/*
- * To change this template, choose Tools | Templates
- * and open the template in the editor.
- */
-package com.laytonsmith.aliasengine;
-
-import com.laytonsmith.PureUtilities.SerializedPersistance;
-import java.io.File;
-import java.io.FileNotFoundException;
-import java.io.IOException;
-import java.io.InputStream;
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.List;
-import java.util.jar.JarEntry;
-import java.util.jar.JarFile;
-import org.bukkit.plugin.InvalidDescriptionException;
-import org.bukkit.plugin.InvalidPluginException;
-import org.bukkit.plugin.PluginDescriptionFile;
-
-/**
- *
- * @author Layton
- */
-public class Main {
-
-    static List<String> doctypes = new ArrayList<String>(Arrays.asList(new String[]{"html", "wiki", "text"}));
-
-    public static void main(String[] args) throws Exception {
-        System.out.println("Running with arguments: " + Arrays.asList(args));
-        try {
-            Static.getPreferences().init(new File("CommandHelper/preferences.txt"));
-            List l = Arrays.asList(args);
-            if (args.length == 0) {
-                l.add("-help");
-            }
-            if (l.contains("-help") || l.contains("-h") || l.contains("--help") || l.contains("/?")) {
-                System.out.println("CommandHelper can be run as a standalone jar with the command:\n\n"
-                        + "     java -jar CommandHelper.jar <options>\n\n"
-                        + "where options can be one of the following:\n\n"
-                        + "--version - Prints the version and exits\n"
-                        + "--help - Displays this message and exits\n"
-                        + "--docs [type] - Creates documentation for the functions that CommandHelper knows about.\n"
-                        + "     'type' can be one of the following: " + doctypes.toString() + ". Defaults to 'html'.\n"
-                        + "--test-compile [file] - Attempts to compile the config file, but does not actually start up. Any\n"
-                        + "     compile errors or warnings can be shown this way, without actually running the program.\n"
-                        + "     The location of the config file to test can be given, so that you don't actually have to\n"
-                        + "     edit your live config file. If you don't provide a file, the default config file is used.\n"
-                        + "     Regardless, the program will look in ./CommandHelper/ for the file.\n"
-                        + "--copyright - Displays the copyright notice and exits\n"
-                        //broken :(
-                        //+ "--print-db - Prints out the built in database in a human readable form, then exits."
-                        );
-            }
-            if (l.contains("--version")) {
-                PluginDescriptionFile me = loadSelf();
-                System.out.println("You are running CommandHelper version " + me.getVersion());
-                return;
-            }
-            if (l.contains("--copyright")) {
-                System.out.println("CommandHelper\n"
-                        + "Copyright (C) 2010-2011 sk89q <http://www.sk89q.com> and \n"
-                        + "wraithguard01 <http://www.laytonsmith.com>\n"
-                        + "\n"
-                        + "This program is free software: you can redistribute it and/or modify\n"
-                        + "it under the terms of the GNU General Public License as published by\n"
-                        + "the Free Software Foundation, either version 3 of the License, or\n"
-                        + "(at your option) any later version.\n"
-                        + "\n"
-                        + "This program is distributed in the hope that it will be useful,\n"
-                        + "but WITHOUT ANY WARRANTY; without even the implied warranty of\n"
-                        + "MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n"
-                        + "GNU General Public License for more details.\n"
-                        + "\n"
-                        + "You should have received a copy of the GNU General Public License\n"
-                        + "along with this program. If not, see <http://www.gnu.org/licenses/>.\n");
-                return;
-            }
-            if (l.contains("--print-db")) {
-                new SerializedPersistance(new File("CommandHelper/persistance.ser"), null).printValues(System.out);
-                return;
-            }
-            for (int i = 0; i < l.size(); i++) {
-                String s = l.get(i).toString();
-                if (s.matches("--docs")) {
-                    //Documentation generator
-                    String type = (i + 1 <= l.size() - 1 ? l.get(i + 1).toString().toLowerCase() : null);
-                    if (type == null) {
-                        type = "html";
-                    }
-                    if (!doctypes.contains(type)) {
-                        System.out.println("The type of documentation must be one of the following: " + doctypes.toString());
-                        return;
-                    }
-                    System.out.println("Creating " + type + " documentation.");
-                    DocGen.start(type);
-                } else if (s.matches("--test-compile")) {
-                    System.out.println("This functionality is not currently implemented!");
-//                    File f = new File(".");
-//                    for (File a : f.listFiles()) {
-//                        if (a.getName().equals("CommandHelper.jar")) {
-//                            //We are in the plugins folder
-//                            f = new File("CommandHelper/bukkit.jar");
-//                            if (!f.exists()) {
-//                                System.out.println("In order to run the --test-compile command, you must include the latest build of bukkit (not craftbukkit)"
-//                                        + " in the CommandHelper folder. You MUST rename it to bukkit.jar. See the wiki for more information.");
-//                                System.exit(1);
-//                            }
-//                            break;
-//                        }
-//                    }
-//                    String file = (i + 1 <= l.size() - 1 ? l.get(i + 1).toString().toLowerCase() : null);
-//                    
-//                    return;
-                }
-            }
-        } catch (NoClassDefFoundError error) {
-            System.err.println("The main class requires craftbukkit or bukkit to be included in order to run. If you are seeing"
-                    + " this message, you have two options. First, it seems you have renamed your craftbukkit jar, or"
-                    + " you are altogether not using craftbukkit. If this is the case, you can download craftbukkit and place"
-                    + " it in the correct directory (one above this one) or you can download bukkit, rename it to bukkit.jar,"
-                    + " and put it in the CommandHelper directory.");
-        }
-    }
-    
-    private static PluginDescriptionFile loadSelf() throws InvalidPluginException, IOException, InvalidDescriptionException{
-        PluginDescriptionFile description = null;
-        System.out.println(new File(".").getAbsolutePath());
-        File file = new File("./target/commandhelper-3.1.2-ShadedBundle.jar");
-        if (!file.exists()) {
-            throw new InvalidPluginException(new FileNotFoundException(String.format("%s does not exist", file.getPath())));
-        }
-        try {
-            JarFile jar = new JarFile(file);
-            JarEntry entry = jar.getJarEntry("plugin.yml");
-
-            if (entry == null) {
-                throw new InvalidPluginException(new FileNotFoundException("Jar does not contain plugin.yml"));
-            }
-
-            InputStream stream = jar.getInputStream(entry);
-            description = new PluginDescriptionFile(stream);
-
-            stream.close();
-            jar.close();
-        } catch (IOException ex) {
-            throw new InvalidPluginException(ex);
-        } catch (Exception ex) {
-            throw new InvalidPluginException(ex);
-        }
-        return description;
-    }
-}
diff --git a/src/main/java/com/laytonsmith/aliasengine/MainSandbox.java b/src/main/java/com/laytonsmith/aliasengine/MainSandbox.java
deleted file mode 100644
index a3a596d..0000000
--- a/src/main/java/com/laytonsmith/aliasengine/MainSandbox.java
+++ /dev/null
@@ -1,44 +0,0 @@
-/*
- * To change this template, choose Tools | Templates
- * and open the template in the editor.
- */
-package com.laytonsmith.aliasengine;
-
-import com.laytonsmith.aliasengine.Constructs.CNull;
-import com.laytonsmith.aliasengine.functions.ClassDiscovery;
-import java.lang.reflect.Constructor;
-import java.util.Arrays;
-import java.util.logging.Level;
-import java.util.logging.Logger;
-//import net.minecraft.server.Packet;
-
-/**
- * This class is for testing concepts
- * @author Layton
- */
-public class MainSandbox {
-    public static void main(String[] args) throws Exception{
-        System.out.println("\u0037");
-    }
-    
-    public static void printPackets(){
-//        Class [] classes = ClassDiscovery.DiscoverClasses(net.minecraft.server.Packet.class, null, null);
-//        for(Class c : classes){
-//            //The superclass can be null if it's an interface
-//            if(c != null && c.getSuperclass() != null && c.getSuperclass().equals(net.minecraft.server.Packet.class)){
-//                try {
-//                    System.out.println("Packet subclass: " + c.getSimpleName());
-//                    Constructor [] constructors = c.getConstructors();
-//                    for(Constructor constructor : constructors){
-//                        if(constructor.getParameterTypes().length != 0){
-//                            //Candidate for use
-//                            System.out.println("\tConstructor: " + Arrays.toString(constructor.getParameterTypes()));
-//                        } //Else it's a no-arg constructor, which happens from time to time
-//                    }
-//                } catch (Exception ex) {
-//                    Logger.getLogger(MainSandbox.class.getName()).log(Level.SEVERE, null, ex);
-//                }
-//            }
-//        }
-    }
-}
diff --git a/src/main/java/com/laytonsmith/aliasengine/NotInitializedYetException.java b/src/main/java/com/laytonsmith/aliasengine/NotInitializedYetException.java
deleted file mode 100644
index 680f2dc..0000000
--- a/src/main/java/com/laytonsmith/aliasengine/NotInitializedYetException.java
+++ /dev/null
@@ -1,15 +0,0 @@
-/*
- * To change this template, choose Tools | Templates
- * and open the template in the editor.
- */
-package com.laytonsmith.aliasengine;
-
-/**
- *
- * @author Layton
- */
-public class NotInitializedYetException extends RuntimeException{
-    public NotInitializedYetException(String msg){
-        super(msg);
-    }
-}
diff --git a/src/main/java/com/laytonsmith/aliasengine/Procedure.java b/src/main/java/com/laytonsmith/aliasengine/Procedure.java
deleted file mode 100644
index 103e07d..0000000
--- a/src/main/java/com/laytonsmith/aliasengine/Procedure.java
+++ /dev/null
@@ -1,122 +0,0 @@
-/*
- * To change this template, choose Tools | Templates
- * and open the template in the editor.
- */
-package com.laytonsmith.aliasengine;
-
-import com.laytonsmith.aliasengine.Constructs.*;
-import com.laytonsmith.aliasengine.functions.Exceptions.ExceptionType;
-import com.laytonsmith.aliasengine.functions.IVariableList;
-import com.laytonsmith.aliasengine.functions.exceptions.ConfigRuntimeException;
-import com.laytonsmith.aliasengine.functions.exceptions.FunctionReturnException;
-import com.sk89q.util.StringUtil;
-import java.util.ArrayList;
-import java.util.HashMap;
-import java.util.List;
-import java.util.Map;
-import org.bukkit.command.CommandSender;
-
-/**
- *
- * @author Layton
- */
-public class Procedure implements Cloneable {
-    private String name;
-    private Map<String, IVariable> varList;
-    private Map<String, Construct> originals = new HashMap<String, Construct>();
-    private List<IVariable> varIndex = new ArrayList<IVariable>();
-    private GenericTreeNode<Construct> tree;
-
-    
-    public Procedure(String name, List<IVariable> varList, GenericTreeNode<Construct> tree, CFunction f){
-        this.name = name;        
-        this.varList = new HashMap<String, IVariable>();
-        for(IVariable var : varList){
-            this.varList.put(var.getName(), var);
-            this.varIndex.add(var);
-            this.originals.put(var.getName(), var.ival());
-        }        
-        this.tree = tree;
-        if(!this.name.matches("^_[^_].*")){
-            throw new ConfigRuntimeException("Procedure names must start with an underscore", ExceptionType.FormatException, f.getLineNum(), f.getFile());
-        }
-    }
-    
-    public String getName(){
-        return name;
-    }
-    
-    @Override
-    public String toString(){
-        return name + "(" + StringUtil.joinString(varList.keySet(), ", ", 0) + ")";
-    }
-    
-    
-    public Construct execute(List<Construct> variables, CommandSender player, Map<String, Procedure> procStack, String label){
-        resetVariables();
-        GenericTree<Construct> root = new GenericTree<Construct>();
-        root.setRoot(tree);
-        Script fakeScript = new Script(null, null);
-        fakeScript.varList = new IVariableList();
-        fakeScript.knownProcs = procStack;
-        fakeScript.label = label;
-        CArray array = new CArray(0, null);
-        for(Construct d : variables){
-            array.push(d);
-        }
-        fakeScript.varList.set(new IVariable("@arguments", array, 0, null));
-        for(GenericTreeNode<Construct> c : root.build(GenericTreeTraversalOrderEnum.PRE_ORDER)){
-            if(c.getData() instanceof IVariable){
-
-                String varname = ((IVariable)c.getData()).getName();
-                IVariable var = varList.get(((IVariable)c.getData()).getName());
-                if(var == null){
-                    var = new IVariable(varname, c.getData().getLineNum(), c.getData().getFile());
-                }
-                if(varname.equals("@arguments")){
-                    var.setIval(fakeScript.varList.get("@arguments"));
-                }
-                int index = indexOf(varname);
-                if(index != -1){
-                    //This variable has not been explicitly set, so we use the default
-                    try{
-                        var.setIval(Static.resolveConstruct(variables.get(index).val(), var.getLineNum(), var.getFile()));
-                    } catch(ArrayIndexOutOfBoundsException e){
-                        //var.setIval(new CNull(var.line_num, var.file));
-                    }
-                }
-                fakeScript.varList.set(var);
-            }
-        }
-        
-        try{
-            fakeScript.eval(tree, player);
-        } catch(FunctionReturnException e){
-            return e.getReturn();
-        }
-        return new CVoid(0, null);
-    }
-    
-    private int indexOf(String name){
-        for(IVariable v : varIndex){
-            if(v.getName().equals(name)){
-                return varIndex.indexOf(v);
-            }
-        }
-        return -1;
-    }
-    
-    private void resetVariables(){
-        for(Map.Entry<String, IVariable> varEntry : varList.entrySet()){
-            varEntry.getValue().setIval(originals.get(varEntry.getKey()));
-        }
-    }
-    
-    @Override
-    public Procedure clone() throws CloneNotSupportedException{
-        Procedure clone = (Procedure) super.clone();
-        if(this.varList != null) clone.varList = new HashMap<String, IVariable>(this.varList);
-        if(this.tree != null) clone.tree = this.tree.clone();
-        return clone;
-    }
-}
diff --git a/src/main/java/com/laytonsmith/aliasengine/RunnableAlias.java b/src/main/java/com/laytonsmith/aliasengine/RunnableAlias.java
deleted file mode 100644
index b2467ae..0000000
--- a/src/main/java/com/laytonsmith/aliasengine/RunnableAlias.java
+++ /dev/null
@@ -1,190 +0,0 @@
-
-
-package com.laytonsmith.aliasengine;
-
-
-//import com.laytonsmith.aliasengine.Constructs.*;
-//import com.laytonsmith.aliasengine.Constructs.Construct.ConstructType;
-//import com.laytonsmith.aliasengine.functions.BasicLogic._if;
-//import com.laytonsmith.aliasengine.functions.DataHandling._for;
-//import com.laytonsmith.aliasengine.functions.DataHandling.foreach;
-//import com.laytonsmith.aliasengine.functions.Function;
-//import com.laytonsmith.aliasengine.functions.FunctionList;
-//import com.laytonsmith.aliasengine.functions.IVariableList;
-//import com.sk89q.bukkit.migration.PermissionsResolverManager;
-//import com.sk89q.commandhelper.CommandHelperPlugin;
-//import java.util.ArrayList;
-//import java.util.List;
-//import java.util.logging.Level;
-//import java.util.logging.Logger;
-//import org.bukkit.entity.Player;
-
-/**
- * This class is the bridge between the Bukkit API and the generic Alias Engine.
- * It essentially accepts an array of GenericTrees, which it then parses. It
- * expects that the variables are already filled in with their values from
- * the user command.
- * @author Layton
- */
-public class RunnableAlias {
-//    Player player;
-//    ArrayList<GenericTree<Construct>> actions;
-//    FunctionList func_list;
-//    String label;
-//    IVariableList varList = new IVariableList();
-//    String originalCommand;
-//
-//    String performAs = null;
-//    boolean inPerformAs = false;
-//
-//    public RunnableAlias(String label, ArrayList<GenericTree<Construct>> actions, Player player,
-//            FunctionList func_list, String originalCommand){
-//        this.label = label;
-//        this.actions = actions;
-//        this.player = player;
-//        this.func_list = func_list;
-//        this.originalCommand = originalCommand;
-//    }
-//
-//    public boolean run(){
-//        boolean ret = true;
-//        for(GenericTree t : actions){
-//            try{
-//            StringBuilder b = new StringBuilder();
-//            List<GenericTreeNode<Construct>> l = t.build(GenericTreeTraversalOrderEnum.PRE_ORDER);
-//            try{
-//                for(GenericTreeNode<Construct> g : l){
-//                    if(((Construct)g.data).val() == null){
-//                        b.append("");
-//                    }
-//                    else if(((Construct)g.data).val().equals("root")){
-//                        for(GenericTreeNode<Construct> gg : g.getChildren()){
-//                            b.append(eval(gg).val()).append(" ");
-//                        }
-//                    }
-//                }
-//                String cmd = b.toString().trim();
-//                if((Boolean)Static.getPreferences().getPreference("console-log-commands")){                    
-//                    System.out.println("CH: Running original command ----> " + originalCommand);
-//                    System.out.println("on " + player.getName());
-//                }
-//                if(player == null){
-//                    System.out.println("Player is null, assuming test harness is running");
-//                } else {
-//                    if(cmd.length() > 0 && cmd.charAt(0) == '/'){
-//                        Static.getServer().dispatchCommand(player, cmd.substring(1));
-//                    }
-//                }
-//            } catch(CancelCommandException e){
-//                if(player == null){
-//                    System.out.println("Command Cancelled with message: " + e.message);
-//                } else{
-//                    player.sendMessage(e.message);
-//                }
-//            } finally {
-//                ret = false;
-//            }
-//            } catch(ConfigRuntimeException e){
-//                CommandHelperPlugin.logger.log(Level.WARNING, "Script runtime exeption: " + e.getMessage());
-//            }
-//        }
-//        return ret;
-//    }
-//
-//    public Construct eval(GenericTreeNode<Construct> c) throws CancelCommandException{
-//        Construct m = c.getData();
-//        if(m.ctype == ConstructType.FUNCTION){
-//            try {
-//                Function f;
-//                f = func_list.getFunction(m);
-//                f.varList(varList);
-//                //We have special handling for loop and other control flow functions
-//                if(f instanceof _for){
-//                    _for fr = (_for)f;
-//                    List<GenericTreeNode<Construct>> ch = c.getChildren();
-//                    try{
-//                        return fr.execs(m.line_num, player, this, ch.get(0), ch.get(1), ch.get(2), ch.get(3));
-//                    } catch(IndexOutOfBoundsException e){
-//                        throw new ConfigRuntimeException("Invalid number of parameters passed to for");
-//                    }
-//                } else if(f instanceof _if){
-//                    _if fr = (_if)f;
-//                    List<GenericTreeNode<Construct>> ch = c.getChildren();
-//                    try{
-//                        return fr.execs(m.line_num, player, this, ch.get(0), ch.get(1), ch.size() > 2?ch.get(2):null);
-//                    } catch(IndexOutOfBoundsException e){
-//                        throw new ConfigRuntimeException("Invalid number of parameters passed to if");
-//                    }
-//                } else if(f instanceof foreach){
-//                    foreach fe = (foreach)f;
-//                    List<GenericTreeNode<Construct>> ch = c.getChildren();
-//                    try{
-//                        return fe.execs(m.line_num, player, this, ch.get(0), ch.get(1), ch.get(2));
-//                    } catch(IndexOutOfBoundsException e){
-//                        throw new ConfigRuntimeException("Invalid number of parameters passed to foreach");
-//                    }
-//                }
-//                ArrayList<Construct> args = new ArrayList<Construct>();
-//                for (GenericTreeNode<Construct> c2 : c.getChildren()) {
-//                    args.add(eval(c2));
-//                }
-//                if(f.isRestricted()){
-//                    boolean perm;
-//                    PermissionsResolverManager perms = Static.getPermissionsResolverManager();
-//                    if(perms != null){
-//                        perm = perms.hasPermission(player.getName(), "ch.func.use." + f.getName())
-//                                || perms.hasPermission(player.getName(), "commandhelper.func.use." + f.getName());
-//                        if(label != null && (perms.hasPermission(player.getName(), "ch.alias." + label)) ||
-//                                perms.hasPermission(player.getName(), "commandhelper.alias." + label)){
-//                            perm = true;
-//                        }
-//                    } else {
-//                        perm = true;
-//                    }
-//                    if(player.isOp()){
-//                        perm = true;
-//                    }
-//                    if(!perm){
-//                        throw new CancelCommandException("You do not have permission to use the " + f.getName() + " function.");
-//                    }
-//                }
-//                Object [] a = args.toArray();
-//                Construct[] ca = new Construct[a.length];
-//                for(int i = 0; i < a.length; i++){
-//                    ca[i] = (Construct) a[i];
-//                    //if it's a variable, go ahead and cast it to the correct data type
-//                    if(ca[i].ctype == ConstructType.VARIABLE){
-//                        ca[i] = Static.resolveConstruct(ca[i].val(), ca[i].line_num);
-//                    }
-//                    //CArray, CBoolean, CDouble, CInt, CMap, CNull, CString, CVoid.
-//                    if(!(ca[i] instanceof CArray || ca[i] instanceof CBoolean || ca[i] instanceof CDouble 
-//                            || ca[i] instanceof CInt || ca[i] instanceof CMap || ca[i] instanceof CNull
-//                            || ca[i] instanceof CString || ca[i] instanceof CVoid || ca[i] instanceof IVariable)){
-//                        throw new ConfigRuntimeException("Invalid Construct being passed as an argument to a function");
-//                    }
-//                }
-//                if(f.preResolveVariables()){
-//                    for(int i = 0; i < ca.length; i++){
-//                        if(ca[i] instanceof IVariable){
-//                            IVariable v = (IVariable) ca[i];
-//                            ca[i] = varList.get(v.getName()).ival();
-//                        }
-//                    }
-//                }
-//                
-//                return f.exec(m.line_num, player, ca);
-//                //            } else if(f.name == FunctionName.PERFORM){
-//                //                //Construct m = eval(c.getChildren().get(0));
-//                //            }
-//            } catch (ConfigCompileException ex) {
-//                Logger.getLogger(RunnableAlias.class.getName()).log(Level.SEVERE, null, ex);
-//            }
-//
-//        } else if(m.ctype == ConstructType.VARIABLE){
-//            return ((Variable)m);
-//        } else{
-//            return m;
-//        }
-//        return null;
-//    }
-}
diff --git a/src/main/java/com/laytonsmith/aliasengine/Script.java b/src/main/java/com/laytonsmith/aliasengine/Script.java
deleted file mode 100644
index 571107d..0000000
--- a/src/main/java/com/laytonsmith/aliasengine/Script.java
+++ /dev/null
@@ -1,816 +0,0 @@
-/*
- * To change this template, choose Tools | Templates
- * and open the template in the editor.
- */
-package com.laytonsmith.aliasengine;
-
-import com.laytonsmith.aliasengine.functions.exceptions.CancelCommandException;
-import com.laytonsmith.aliasengine.functions.exceptions.ConfigCompileException;
-import com.laytonsmith.aliasengine.functions.exceptions.ConfigRuntimeException;
-import com.laytonsmith.aliasengine.functions.exceptions.LoopBreakException;
-import com.laytonsmith.aliasengine.functions.exceptions.LoopContinueException;
-import com.laytonsmith.aliasengine.Constructs.*;
-import com.laytonsmith.aliasengine.Constructs.Construct.ConstructType;
-import com.laytonsmith.aliasengine.Constructs.Token.TType;
-import com.laytonsmith.aliasengine.Constructs.Variable;
-import com.laytonsmith.aliasengine.functions.BasicLogic._if;
-import com.laytonsmith.aliasengine.functions.DataHandling._for;
-import com.laytonsmith.aliasengine.functions.DataHandling.call_proc;
-import com.laytonsmith.aliasengine.functions.DataHandling.foreach;
-import com.laytonsmith.aliasengine.functions.DataHandling.include;
-import com.laytonsmith.aliasengine.functions.DataHandling.is_proc;
-import com.laytonsmith.aliasengine.functions.DataHandling.proc;
-import com.laytonsmith.aliasengine.functions.Exceptions.ExceptionType;
-import com.laytonsmith.aliasengine.functions.Exceptions._try;
-import com.laytonsmith.aliasengine.functions.Function;
-import com.laytonsmith.aliasengine.functions.FunctionList;
-import com.laytonsmith.aliasengine.functions.IVariableList;
-import com.laytonsmith.aliasengine.functions.IncludeCache;
-import com.laytonsmith.aliasengine.functions.Meta.eval;
-import com.laytonsmith.aliasengine.functions.exceptions.FunctionReturnException;
-import com.sk89q.bukkit.migration.PermissionsResolverManager;
-import java.io.File;
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.HashMap;
-import java.util.List;
-import java.util.Map;
-import java.util.logging.Level;
-import java.util.logging.Logger;
-import org.bukkit.command.CommandSender;
-import org.bukkit.command.ConsoleCommandSender;
-import org.bukkit.entity.Player;
-
-/**
- * A script is a section of code that has been preprocessed and split into separate 
- * commands/actions. For instance, the config script:
- * 
- * /command = /cmd
- * 
- * /test = /test
- * 
- * would be two seperate scripts, the first being the /command, and the second being /test.
- * Certain key information is stored in the Script class. First, the information needed
- * to see if a target string should trigger this script. Secondly, the default values
- * of any variables, and thirdly, the unparsed tree for the right side of the script.
- * @author Layton
- */
-public class Script {
-
-    private List<Token> left;
-    private List<List<Token>> right;
-    private List<Token> fullRight;
-    private List<Construct> cleft;
-    private List<GenericTreeNode<Construct>> cright;
-    String label;
-    private Map<String, Variable> left_vars;
-    IVariableList varList = new IVariableList();
-    boolean hasBeenCompiled = false;
-    boolean compilerError = false;
-    Map<String, Procedure> knownProcs = new HashMap<String, Procedure>();
-
-    @Override
-    public String toString() {
-        StringBuilder b = new StringBuilder();
-        for (Token t : left) {
-            b.append(t.val()).append(" ");
-        }
-        b.append("compiled: ").append(hasBeenCompiled).append("; errors? ").append(compilerError);
-        return b.toString();
-    }
-
-    private Procedure getProc(String name) {
-        return knownProcs.get(name);
-    }
-
-    private List<Procedure> getProcList() {
-        List<Procedure> procs = new ArrayList<Procedure>();
-        for (Map.Entry<String, Procedure> m : knownProcs.entrySet()) {
-            procs.add(m.getValue());
-        }
-        return procs;
-    }
-
-    public Script(List<Token> left, List<Token> right) {
-        this.left = left;
-        this.fullRight = right;
-        this.left_vars = new HashMap<String, Variable>();
-    }
-
-    public boolean uncompilable() {
-        return compilerError;
-    }
-
-    public void run(final List<Variable> vars, final CommandSender p, final MScriptComplete done) {
-        if (!hasBeenCompiled || compilerError) {
-            int line_num = 0;
-            if (left.size() >= 1) {
-                line_num = left.get(0).line_num;
-            }
-            throw new ConfigRuntimeException("Unable to run command, script not yet compiled, or a compiler error occured for that command.",
-                    null, line_num, null);
-        }
-        if (p instanceof Player) {
-            if (label != null) {
-                PermissionsResolverManager perms = Static.getPermissionsResolverManager();
-                String[] groups = label.substring(1).split("/");
-                for (String group : groups) {
-                    if (group.startsWith("-") && perms.inGroup(((Player)p).getName(), group.substring(1))) {
-                        //negative permission
-                        throw new ConfigRuntimeException("You do not have permission to use that command", ExceptionType.InsufficientPermissionException,
-                                0, null);
-                    } else if (perms.inGroup(((Player)p).getName(), group)) {
-                        //They do have permission.
-                        break;
-                    }
-                }
-            }
-        }
-
-//        final Plugin self = CommandHelperPlugin.self;
-//        Static.getServer().getScheduler().scheduleAsyncDelayedTask(self, new Runnable() {
-
-//            public void run() {
-        try {
-            for (GenericTreeNode<Construct> rootNode : cright) {
-                GenericTree<Construct> tree = new GenericTree<Construct>();
-                tree.setRoot(rootNode);
-                for (GenericTreeNode<Construct> tempNode : tree.build(GenericTreeTraversalOrderEnum.PRE_ORDER)) {
-                    if (tempNode.data instanceof Variable) {
-                        ((Variable) tempNode.data).setVal(
-                                Static.resolveConstruct(
-                                Static.resolveDollarVar(left_vars.get(((Variable) tempNode.data).getName()), vars).toString(), tempNode.data.getLineNum(), tempNode.data.getFile()));
-                    }
-                }
-                File auto_include = new File("plugins/CommandHelper/auto_include.ms");
-                if (auto_include.exists()) {
-                    MScriptCompiler.execute(IncludeCache.get(auto_include, 0, auto_include), p, null, this);
-                }
-                MScriptCompiler.execute(tree.getRoot(), p, done, this);
-            }
-        } catch (ConfigRuntimeException e) {
-            p.sendMessage(e.getMessage() + " :: " + e.getExceptionType() + ":" + e.getSimpleFile() + ":" + e.getLineNum());
-            System.out.println(e.getMessage() + " :: " + e.getExceptionType() + ":" + e.getFile() + ":" + e.getLineNum());
-        } catch (CancelCommandException e) {
-            //p.sendMessage(e.getMessage());
-            //The message in the exception is actually empty
-        } catch (LoopBreakException e) {
-            p.sendMessage("The break() function must be used inside a for() or foreach() loop");
-        } catch (LoopContinueException e) {
-            p.sendMessage("The continue() function must be used inside a for() or foreach() loop");
-        } catch (FunctionReturnException e) {
-            p.sendMessage("The return() function must be used inside a procedure.");
-        } catch (Throwable t) {
-            System.out.println("An unexpected exception occured during the execution of a script.");
-            t.printStackTrace();
-            p.sendMessage("An unexpected exception occured during the execution of your script. Please check the console for more information.");
-        }
-        if (done != null) {
-            done.done(null);
-        }
-//            }
-//        });
-    }
-
-    public Construct eval(GenericTreeNode<Construct> c, final CommandSender player) throws CancelCommandException {
-        final Construct m = c.getData();
-        if (m.getCType() == ConstructType.FUNCTION) {
-                if (m.val().matches("^_[^_].*")) {
-                    //Not really a function, so we can't put it in Function.
-                    Procedure p = getProc(m.val());
-                    if (p == null) {
-                        throw new ConfigRuntimeException("Unknown procedure \"" + m.val() + "\"", ExceptionType.InvalidProcedureException, m.getLineNum(), m.getFile());
-                    }
-                    List<Construct> variables = new ArrayList<Construct>();
-                    for (GenericTreeNode<Construct> child : c.getChildren()) {
-                        variables.add(eval(child, player));
-                    }
-                    variables = Arrays.asList(preResolveVariables(variables.toArray(new Construct[]{})));
-                    return p.execute(variables, player, new HashMap<String, Procedure>(knownProcs), this.label);
-                }
-                final Function f;
-                try{
-                    f = FunctionList.getFunction(m);
-                } catch(ConfigCompileException e){
-                    //Turn it into a config runtime exception. This shouldn't ever happen though.
-                    throw new ConfigRuntimeException("Unable to find function " + m.val(), m.getLineNum(), m.getFile());
-                }
-                f.varList(varList);
-                //We have special handling for loop and other control flow functions
-                if (f instanceof _for) {
-                    _for fr = (_for) f;
-                    List<GenericTreeNode<Construct>> ch = c.getChildren();
-                    try {
-                        return fr.execs(m.getLineNum(), m.getFile(), player, this, ch.get(0), ch.get(1), ch.get(2), ch.get(3));
-                    } catch (IndexOutOfBoundsException e) {
-                        throw new ConfigRuntimeException("Invalid number of parameters passed to for", ExceptionType.InsufficientArgumentsException, m.getLineNum(), m.getFile());
-                    }
-                } else if (f instanceof _if) {
-                    _if fr = (_if) f;
-                    List<GenericTreeNode<Construct>> ch = c.getChildren();
-                    try {
-                        return fr.execs(m.getLineNum(), m.getFile(), player, this, ch.get(0), ch.get(1), ch.size() > 2 ? ch.get(2) : null);
-                    } catch (IndexOutOfBoundsException e) {
-                        throw new ConfigRuntimeException("Invalid number of parameters passed to if", ExceptionType.InsufficientArgumentsException, m.getLineNum(), m.getFile());
-                    }
-                } else if (f instanceof foreach) {
-                    foreach fe = (foreach) f;
-                    List<GenericTreeNode<Construct>> ch = c.getChildren();
-                    try {
-                        return fe.execs(m.getLineNum(), m.getFile(), player, this, ch.get(0), ch.get(1), ch.get(2));
-                    } catch (IndexOutOfBoundsException e) {
-                        throw new ConfigRuntimeException("Invalid number of parameters passed to foreach", ExceptionType.InsufficientArgumentsException, m.getLineNum(), m.getFile());
-                    }
-                } else if (f instanceof eval) {
-                    List<GenericTreeNode<Construct>> ch = c.getChildren();
-                    if (ch.size() > 1) {
-                        throw new ConfigRuntimeException("Invalid number of parameters passed to eval", ExceptionType.InsufficientArgumentsException, m.getLineNum(), m.getFile());
-                    }
-                    try{
-                        GenericTreeNode<Construct> root = MScriptCompiler.compile(MScriptCompiler.lex(ch.get(0).getData().val(), null));
-                        StringBuilder b = new StringBuilder();
-                        for (GenericTreeNode<Construct> child : root.getChildren()) {
-                            CString cs = new CString(eval(child, player).val(), 0, null);
-                            if (!cs.val().trim().equals("")) {
-                                b.append(cs.val()).append(" ");
-                            }
-                        }
-                        return new CString(b.toString(), 0, null);
-                    } catch(ConfigCompileException e){
-                        
-                    }
-                } else if (f instanceof _try) {
-                    List<GenericTreeNode<Construct>> ch = c.getChildren();
-                    if (ch.size() != 4 && ch.size() != 3) {
-                        throw new ConfigRuntimeException("Invalid number of parameters passed to try", ExceptionType.InsufficientArgumentsException, m.getLineNum(), m.getFile());
-                    }
-                    GenericTreeNode<Construct> fourth = null;
-                    if (ch.size() == 4) {
-                        fourth = ch.get(3);
-                    }
-                    return ((_try) f).execs(m.getLineNum(), m.getFile(), player, this, ch.get(0), ch.get(1), ch.get(2), fourth);
-                } else if (f instanceof proc) {
-                    List<GenericTreeNode<Construct>> ch = c.getChildren();
-                    if (ch.size() <= 1) {
-                        throw new ConfigRuntimeException("Invalid number of parameters sent to proc()", ExceptionType.InvalidProcedureException, m.getLineNum(), m.getFile());
-                    }
-                    String name = "";
-                    List<IVariable> vars = new ArrayList<IVariable>();
-                    GenericTreeNode<Construct> tree = null;
-                    for (int i = 0; i < ch.size(); i++) {
-                        if (i == ch.size() - 1) {
-                            tree = ch.get(i);
-                        } else {
-                            Construct cons = eval(ch.get(i), player);
-                            if (i == 0 && cons instanceof IVariable) {
-                                //Soon, this will be allowed, so anonymous procedures can be created, but for now
-                                //it's not allowed
-                                throw new ConfigRuntimeException("Anonymous Procedures are not allowed", ExceptionType.InvalidProcedureException, m.getLineNum(), m.getFile());
-                            } else {
-                                if (i == 0 && !(cons instanceof IVariable)) {
-                                    name = cons.val();
-                                } else {
-                                    if (!(cons instanceof IVariable)) {
-                                        throw new ConfigRuntimeException("You must use IVariables as the arguments", ExceptionType.InvalidProcedureException, m.getLineNum(), m.getFile());
-                                    } else {
-                                        vars.add((IVariable) cons);
-                                    }
-                                }
-                            }
-                        }
-                    }
-                    Procedure myProc = new Procedure(name, vars, tree, (CFunction) c.getData());
-                    knownProcs.put(name, myProc);
-                    return new CVoid(m.getLineNum(), m.getFile());
-                } else if (f instanceof is_proc) {
-                    Construct[] ar = new Construct[c.getChildren().size()];
-                    for (int i = 0; i < c.getChildren().size(); i++) {
-                        ar[i] = eval(c.getChildAt(i), player);
-                    }
-                    ar = preResolveVariables(ar);
-                    return ((is_proc) f).execs(m.getLineNum(), m.getFile(), player, getProcList(), ar);
-                } else if (f instanceof call_proc) {
-                    Construct[] ar = new Construct[c.getChildren().size()];
-                    for (int i = 0; i < c.getChildren().size(); i++) {
-                        ar[i] = eval(c.getChildAt(i), player);
-                    }
-                    ar = preResolveVariables(ar);
-                    return ((call_proc) f).execs(m.getLineNum(), m.getFile(), player, knownProcs, this.label, ar);
-                } else if (f instanceof include) {
-                    return ((include) f).execs(m.getLineNum(), m.getFile(), player, c.getChildren(), this);
-                }
-
-
-                ArrayList<Construct> args = new ArrayList<Construct>();
-                for (GenericTreeNode<Construct> c2 : c.getChildren()) {
-                    args.add(eval(c2, player));
-                }
-                if (f.isRestricted()) {
-                    boolean perm = false;
-                    PermissionsResolverManager perms = Static.getPermissionsResolverManager();
-                    if (perms != null) {
-                        if(player instanceof Player){
-                            perm = perms.hasPermission(((Player)player).getName(), "ch.func.use." + f.getName())
-                                    || perms.hasPermission(((Player)player).getName(), "commandhelper.func.use." + f.getName());
-                            if (label != null && label.startsWith("~")) {
-                                String[] groups = label.substring(1).split("/");
-                                for (String group : groups) {
-                                    if (perms.inGroup(((Player)player).getName(), group)) {
-                                        perm = true;
-                                        break;
-                                    }
-                                }
-                            } else {
-                                if (label != null && (perms.hasPermission(((Player)player).getName(), "ch.alias." + label))
-                                        || perms.hasPermission(((Player)player).getName(), "commandhelper.alias." + label)) {
-                                    perm = true;
-                                }
-                            }
-                        } else if(player instanceof ConsoleCommandSender){
-                            perm = true;
-                        }
-                    } else {
-                        perm = true;
-                    }
-                    if (player.isOp()) {
-                        perm = true;
-                    }
-                    if (!perm) {
-                        throw new ConfigRuntimeException("You do not have permission to use the " + f.getName() + " function.",
-                                ExceptionType.InsufficientPermissionException, m.getLineNum(), m.getFile());
-                    }
-                }
-                Object[] a = args.toArray();
-                Construct[] ca = new Construct[a.length];
-                for (int i = 0; i < a.length; i++) {
-                    ca[i] = (Construct) a[i];
-                    //CArray, CBoolean, CDouble, CInt, CNull, CString, CVoid.
-                    if (!(ca[i] instanceof CArray || ca[i] instanceof CBoolean || ca[i] instanceof CDouble
-                            || ca[i] instanceof CInt || ca[i] instanceof CNull
-                            || ca[i] instanceof CString || ca[i] instanceof CVoid || ca[i] instanceof IVariable)) {
-                        throw new ConfigRuntimeException("Invalid Construct being passed as an argument to a function", null, m.getLineNum(), m.getFile());
-                    }
-                }
-                f.varList(varList);
-                if (f.preResolveVariables()) {
-                    ca = preResolveVariables(ca);
-                }
-                //TODO: Will revisit this in the future. For now, remove the ability for
-                //functions to run asyncronously.
-                //if(f.runAsync() == true || f.runAsync() == null){
-                Construct ret = f.exec(m.getLineNum(), m.getFile(), player, ca);
-                return ret;
-                /*} else {
-                return blockingNonThreadSafe(player, new Callable<Construct>() {
-                
-                public Construct call() throws Exception {
-                return f.exec(m.getLineNum(), player, ca);
-                }
-                });
-                }*/
-
-        } else if (m.getCType() == ConstructType.VARIABLE) {
-            return Static.resolveConstruct(m.val(), m.getLineNum(), m.getFile());
-        } else {
-            return m;
-        }
-    }
-
-    public Construct[] preResolveVariables(Construct[] ca) {
-        for (int i = 0; i < ca.length; i++) {
-            if (ca[i] instanceof IVariable) {
-                IVariable v = (IVariable) ca[i];
-                ca[i] = varList.get(v.getName()).ival();
-            } else if (ca[i] instanceof CArray) {
-//                CArray ca2 = (CArray) ca[i];
-//                Construct [] ca_raw = new Construct[ca2.size()];
-//                for(int j = 0; j < ca_raw.length; j++){
-//                    ca_raw[j] = ca2.get(j, 0);
-//                }
-//                List<Construct> resolved = Arrays.asList(preResolveVariables(ca_raw));
-//                for(int j = 0; j < resolved.size(); j++){
-//                    
-//                }
-            }
-        }
-        return ca;
-    }
-
-//    private Construct blockingNonThreadSafe(final Player p, Callable task) throws CancelCommandException {
-//        Plugin self = CommandHelperPlugin.self;
-//        try {
-//            Future<Construct> f = Static.getServer().getScheduler().callSyncMethod(self, task);
-//            while (!f.isDone()) {
-//                Thread.sleep(10);
-//            }
-//            return f.get();
-//        } catch (InterruptedException ex) {
-//            Logger.getLogger(Script.class.getName()).log(Level.SEVERE, null, ex);
-//        } catch (ExecutionException ex) {
-//            if (ex.getCause() instanceof CancelCommandException) {
-//                CancelCommandException e = (CancelCommandException) ex.getCause();
-//                throw e;
-//            } else {
-//                Logger.getLogger(Script.class.getName()).log(Level.SEVERE, null, ex.getCause());
-//            }
-//        }
-//        return null;
-//    }
-    public boolean match(String command) {
-        boolean case_sensitive = (Boolean)Static.getPreferences().getPreference("case-sensitive");
-        String[] cmds = command.split(" ");
-        List<String> args = new ArrayList(Arrays.asList(cmds));
-        boolean isAMatch = true;
-        StringBuilder lastVar = new StringBuilder();
-        int lastJ = 0;
-        try {
-            for (int j = 0; j < cleft.size(); j++) {
-                if (!isAMatch) {
-                    break;
-                }
-                lastJ = j;
-                Construct c = cleft.get(j);
-                String arg = args.get(j);
-                if (c.getCType() != ConstructType.VARIABLE) {
-//                        || c.getCType() == ConstructType.TOKEN
-//                        || c.getCType() == ConstructType.LITERAL
-//                        || c.getCType() == ConstructType.STRING || ConstructType.) {
-                    if (case_sensitive && !c.val().equals(arg) || !case_sensitive && !c.val().equalsIgnoreCase(arg)) {
-                        isAMatch = false;
-                        continue;
-                    }
-                } else {
-                    //It's a variable. If it's optional, the rest of them are optional too, so as long as the size of
-                    //args isn't greater than the size of cleft, it's a match
-                    if (((Variable) c).isOptional()) {
-                        if (args.size() <= cleft.size()) {
-                            return true;
-                        } else {
-                            Construct fin = cleft.get(cleft.size() - 1);
-                            if (fin instanceof Variable) {
-                                if (((Variable) fin).isFinal()) {
-                                    return true;
-                                }
-                            }
-                            return false;
-                        }
-                    }
-                }
-                if (j == cleft.size() - 1) {
-                    if (cleft.get(j).getCType() == ConstructType.VARIABLE) {
-                        Variable lv = (Variable) cleft.get(j);
-                        if (lv.isFinal()) {
-                            for (int a = j; a < args.size(); a++) {
-                                if (lastVar.length() == 0) {
-                                    lastVar.append(args.get(a));
-                                } else {
-                                    lastVar.append(" ").append(args.get(a));
-                                }
-                            }
-                        }
-                    }
-                }
-            }
-        } catch (IndexOutOfBoundsException e) {
-            if (cleft.get(lastJ).getCType() != ConstructType.VARIABLE
-                    || cleft.get(lastJ).getCType() == ConstructType.VARIABLE
-                    && !((Variable) cleft.get(lastJ)).isOptional()) {
-                isAMatch = false;
-            }
-        }
-        boolean lastIsFinal = false;
-        if (cleft.get(cleft.size() - 1) instanceof Variable) {
-            Variable v = (Variable) cleft.get(cleft.size() - 1);
-            if (v.isFinal()) {
-                lastIsFinal = true;
-            }
-        }
-        if ((cleft.get(lastJ) instanceof Variable && ((Variable) cleft.get(lastJ)).isOptional())) {
-            return true;
-        }
-
-        if (cleft.size() != cmds.length && !lastIsFinal) {
-            isAMatch = false;
-        }
-        ArrayList<Variable> vars = new ArrayList<Variable>();
-        Variable v = null;
-        for (int j = 0; j < cleft.size(); j++) {
-            try {
-                if (cleft.get(j).getCType() == ConstructType.VARIABLE) {
-                    if (((Variable) cleft.get(j)).getName().equals("$")) {
-                        v = new Variable(((Variable) cleft.get(j)).getName(),
-                                lastVar.toString(), 0, null);
-                    } else {
-                        v = new Variable(((Variable) cleft.get(j)).getName(),
-                                args.get(j), 0, null);
-                    }
-                }
-            } catch (IndexOutOfBoundsException e) {
-                v = new Variable(((Variable) cleft.get(j)).getName(),
-                        ((Variable) cleft.get(j)).getDefault(), 0, null);
-            }
-            if (v != null) {
-                vars.add(v);
-            }
-        }
-        return isAMatch;
-    }
-
-    public List<Variable> getVariables(String command) {
-        String[] cmds = command.split(" ");
-        List<String> args = new ArrayList(Arrays.asList(cmds));
-
-        StringBuilder lastVar = new StringBuilder();
-
-        ArrayList<Variable> vars = new ArrayList<Variable>();
-        Variable v = null;
-        for (int j = 0; j < cleft.size(); j++) {
-            try {
-                if (cleft.get(j).getCType() == ConstructType.VARIABLE) {
-                    if (((Variable) cleft.get(j)).getName().equals("$")) {
-                        for (int k = j; k < args.size(); k++) {
-                            lastVar.append(args.get(k).trim()).append(" ");
-                        }
-                        v = new Variable(((Variable) cleft.get(j)).getName(),
-                                lastVar.toString().trim(), 0, null);
-                    } else {
-                        v = new Variable(((Variable) cleft.get(j)).getName(),
-                                args.get(j), 0, null);
-                    }
-                }
-            } catch (IndexOutOfBoundsException e) {
-                v = new Variable(((Variable) cleft.get(j)).getName(),
-                        ((Variable) cleft.get(j)).getDefault(), 0, null);
-            }
-            if (v != null) {
-                vars.add(v);
-            }
-        }
-        return vars;
-    }
-
-    public void compile() throws ConfigCompileException {
-        try {
-            verifyLeft();
-            compileLeft();
-            compileRight();
-        } catch (ConfigCompileException e) {
-            compilerError = true;
-            throw e;
-        }
-        compilerError = false;
-        hasBeenCompiled = true;
-    }
-
-    private boolean verifyLeft() throws ConfigCompileException {
-        boolean inside_opt_var = false;
-        boolean after_no_def_opt_var = false;
-        String lastVar = null;
-        for (int j = 0; j < left.size(); j++) {
-            Token t = left.get(j);
-            //Token prev_token = j - 2 >= 0?c.tokens.get(j - 2):new Token(TType.UNKNOWN, "", t.line_num);
-            Token last_token = j - 1 >= 0 ? left.get(j - 1) : new Token(TType.UNKNOWN, "", t.line_num, t.file);
-            Token next_token = j + 1 < left.size() ? left.get(j + 1) : new Token(TType.UNKNOWN, "", t.line_num, t.file);
-            Token after_token = j + 2 < left.size() ? left.get(j + 2) : new Token(TType.UNKNOWN, "", t.line_num, t.file);
-
-            if (j == 0) {
-                if (next_token.type == TType.IDENT) {
-                    label = t.val();
-                    j--;
-                    left.remove(0);
-                    left.remove(0);
-                    continue;
-                }
-            }
-
-            if (t.type == TType.IDENT) {
-                continue;
-            }
-
-            if (t.type.equals(TType.FINAL_VAR) && left.size() - j >= 5) {
-                throw new ConfigCompileException("FINAL_VAR must be the last argument in the alias", t.line_num);
-            }
-            if (t.type.equals(TType.VARIABLE) || t.type.equals(TType.FINAL_VAR)) {
-                Variable v = new Variable(t.val(), null, t.line_num, t.file);
-                lastVar = t.val();
-                v.setOptional(last_token.type.equals(TType.LSQUARE_BRACKET));
-                left_vars.put(t.val(), v);
-                if (v.isOptional()) {
-                    after_no_def_opt_var = true;
-                } else {
-                    v.setDefault("");
-                }
-            }
-            if (j == 0 && !t.type.equals(TType.COMMAND)) {
-                if (!(next_token.type == TType.IDENT && after_token.type == TType.COMMAND)) {
-                    throw new ConfigCompileException("Expected command (/command) at start of alias."
-                            + " Instead, found " + t.type + " (" + t.val() + ")", t.line_num);
-                }
-            }
-            if (last_token.type.equals(TType.LSQUARE_BRACKET)) {
-                inside_opt_var = true;
-                if (!(t.type.equals(TType.FINAL_VAR) || t.type.equals(TType.VARIABLE))) {
-                    throw new ConfigCompileException("Unexpected " + t.type.toString() + " (" + t.val() + ")", t.line_num);
-                }
-            }
-            if (after_no_def_opt_var && !inside_opt_var) {
-                if (t.type.equals(TType.VARIABLE) || t.type.equals(TType.FINAL_VAR)) {
-                    throw new ConfigCompileException("You cannot have anything other than optional arguments after your"
-                            + " first optional argument, other that other optional arguments with no default", t.line_num);
-                }
-            }
-            if (!t.type.equals(TType.LSQUARE_BRACKET)
-                    && !t.type.equals(TType.OPT_VAR_ASSIGN)
-                    && !t.type.equals(TType.RSQUARE_BRACKET)
-                    && !t.type.equals(TType.VARIABLE)
-                    && !t.type.equals(TType.LIT)
-                    && !t.type.equals(TType.COMMAND)
-                    && !t.type.equals(TType.FINAL_VAR)) {
-                if (!(t.type.equals(TType.STRING) && j - 1 > 0 && left.get(j - 1).type.equals(TType.OPT_VAR_ASSIGN))) {
-                    throw new ConfigCompileException("Unexpected " + t.type + " (" + t.val() + ")", t.line_num);
-                }
-            }
-            if (last_token.type.equals(TType.COMMAND)) {
-                if (!(t.type.equals(TType.VARIABLE) || t.type.equals(TType.LSQUARE_BRACKET) || t.type.equals(TType.FINAL_VAR)
-                        || t.type.equals(TType.LIT))) {
-                    throw new ConfigCompileException("Unexpected " + t.type + " (" + t.val() + ") after command", t.line_num);
-                }
-            }
-            if (inside_opt_var && t.type.equals(TType.OPT_VAR_ASSIGN)) {
-                if (!((next_token.type.equals(TType.STRING) || next_token.type.equals(TType.LIT)) && after_token.type.equals(TType.RSQUARE_BRACKET)
-                        || (next_token.type.equals(TType.RSQUARE_BRACKET)))) {
-                    throw new ConfigCompileException("Unexpected token in optional variable", t.line_num);
-                } else if (next_token.type.equals(TType.STRING) || next_token.type.equals(TType.LIT)) {
-                    left_vars.get(lastVar).setDefault(next_token.val());
-                }
-            }
-            if (t.type.equals(TType.RSQUARE_BRACKET)) {
-                if (!inside_opt_var) {
-                    throw new ConfigCompileException("Unexpected " + t.type.toString(), t.line_num);
-                }
-                inside_opt_var = false;
-//                if (last_token.type.equals(TType.VARIABLE)
-//                        || last_token.type.equals(TType.FINAL_VAR)) {
-//                    after_no_def_opt_var = true;
-//                }
-            }
-        }
-
-        return true;
-    }
-
-    private boolean compileLeft() {
-        cleft = new ArrayList<Construct>();
-        for (int i = 0; i < left.size(); i++) {
-            Token t = left.get(i);
-            if (t.type == Token.TType.COMMAND) {
-                cleft.add(new Command(t.val(), t.line_num, t.file));
-            } else if (t.type == Token.TType.VARIABLE) {
-                cleft.add(new Variable(t.val(), null, t.line_num, t.file));
-            } else if (t.type.equals(TType.FINAL_VAR)) {
-                Variable v = new Variable(t.val(), null, t.line_num, t.file);
-                v.setFinal(true);
-                cleft.add(v);
-            } else if (t.type.equals(TType.LSQUARE_BRACKET)) {
-                if (i + 2 < left.size() && left.get(i + 2).type.equals(TType.OPT_VAR_ASSIGN)) {
-                    Variable v = new Variable(left.get(i + 1).val(),
-                            left.get(i + 3).val(), t.line_num, t.file);
-                    v.setOptional(true);
-                    if (left.get(i + 1).type.equals(TType.FINAL_VAR)) {
-                        v.setFinal(true);
-                    }
-                    cleft.add(v);
-                    i += 4;
-                } else {
-                    t = left.get(i + 1);
-                    Variable v = new Variable(t.val(), null, t.line_num, t.file);
-                    v.setOptional(true);
-                    if (t.val().equals("$")) {
-                        v.setFinal(true);
-                    }
-                    cleft.add(v);
-                    i += 2;
-                }
-            } else {
-                cleft.add(new CString(t.val(), t.line_num, t.file));
-            }
-        }
-        return true;
-    }
-
-    public void compileRight() throws ConfigCompileException {
-        List<Token> temp = new ArrayList<Token>();
-        right = new ArrayList<List<Token>>();
-        for (Token t : fullRight) {
-            if (t.type == TType.SEPERATOR) {
-                right.add(temp);
-                temp = new ArrayList<Token>();
-            } else {
-                temp.add(t);
-            }
-        }
-        right.add(temp);
-        cright = new ArrayList<GenericTreeNode<Construct>>();
-        for (List<Token> l : right) {
-            cright.add(MScriptCompiler.compile(l));
-        }
-    }
-
-    public void checkAmbiguous(ArrayList<Script> scripts) throws ConfigCompileException {
-        //for (int i = 0; i < scripts.size(); i++) {
-        List<Construct> thisCommand = this.cleft;
-        for (int j = 0; j < scripts.size(); j++) {
-            List<Construct> thatCommand = scripts.get(j).cleft;
-            if (thatCommand == null) {
-                //it hasn't been compiled yet.
-                return;
-            }
-            if (this.cleft == scripts.get(j).cleft) {
-                //Of course this command is going to match it's own signature
-                continue;
-            }
-            boolean soFarAMatch = true;
-            for (int k = 0; k < thisCommand.size(); k++) {
-                try {
-                    Construct c1 = thisCommand.get(k);
-                    Construct c2 = thatCommand.get(k);
-                    if (c1.getCType() != c2.getCType() || ((c1 instanceof Variable) && !((Variable) c1).isOptional())) {
-                        soFarAMatch = false;
-                    } else {
-                        //It's a literal, check to see if it's the same literal
-                        if (c1.val() == null || !c1.val().equals(c2.val())) {
-                            soFarAMatch = false;
-                        }
-                    }
-                } catch (IndexOutOfBoundsException e) {
-                    /**
-                     * The two commands:
-                     * /cmd $var1 [$var2]
-                     * /cmd $var1
-                     * would cause this exception to be thrown, but the signatures
-                     * are the same, so the fact that they've matched this far means
-                     * they are ambiguous. However,
-                     * /cmd $var1 $var2
-                     * /cmd $var1
-                     * is not ambiguous
-                     */
-                    //thatCommand is the short one
-                    if (!(thisCommand.get(k) instanceof Variable)
-                            || (thisCommand.get(k) instanceof Variable
-                            && !((Variable) thisCommand.get(k)).isOptional())) {
-                        soFarAMatch = false;
-                    }
-                }
-            }
-            if (thatCommand.size() > thisCommand.size()) {
-                int k = thisCommand.size();
-                //thisCommand is the short one
-                if (!(thatCommand.get(k) instanceof Variable)
-                        || (thatCommand.get(k) instanceof Variable
-                        && !((Variable) thatCommand.get(k)).isOptional())) {
-                    soFarAMatch = false;
-                }
-            }
-
-            if (soFarAMatch) {
-                String commandThis = "";
-                for (Construct c : thisCommand) {
-                    commandThis += c.val() + " ";
-                }
-                String commandThat = "";
-                for (Construct c : thatCommand) {
-                    commandThat += c.val() + " ";
-                }
-                scripts.get(j).compilerError = true;
-                this.compilerError = true;
-                throw new ConfigCompileException("The command " + commandThis.trim() + " is ambiguous because it "
-                        + "matches the signature of " + commandThat.trim(), thisCommand.get(0).getLineNum());
-            }
-        }
-
-        //Also, check for undefined variables on the right, and unused variables on the left
-        ArrayList<String> left_copy = new ArrayList<String>();
-        for (Map.Entry<String, Variable> v : left_vars.entrySet()) {
-            left_copy.add(v.getValue().getName());
-        }
-        Arrays.asList(new String[]{}).toArray(new String[]{});
-        for (GenericTreeNode<Construct> gtn : cright) {
-            GenericTree<Construct> tree = new GenericTree<Construct>();
-            tree.setRoot(gtn);
-            List<GenericTreeNode<Construct>> builtTree = tree.build(GenericTreeTraversalOrderEnum.PRE_ORDER);
-            for (GenericTreeNode<Construct> c : builtTree) {
-                if (c.getData() instanceof Variable) {
-                    for (Map.Entry<String, Variable> v : left_vars.entrySet()) {
-                        if (v.getValue().getName().equals(((Variable) c.getData()).getName())) {
-                            //Found it, remove this from the left_copy, and break
-                            left_copy.remove(v.getValue().getName());
-                            break;
-                            //TODO: Layton!
-                        }
-                    }
-                }
-            }
-        }
-        //}
-    }
-}
diff --git a/src/main/java/com/laytonsmith/aliasengine/Static.java b/src/main/java/com/laytonsmith/aliasengine/Static.java
deleted file mode 100644
index d891af5..0000000
--- a/src/main/java/com/laytonsmith/aliasengine/Static.java
+++ /dev/null
@@ -1,540 +0,0 @@
-/*
- * To change this template, choose Tools | Templates
- * and open the template in the editor.
- */
-package com.laytonsmith.aliasengine;
-
-import com.laytonsmith.aliasengine.functions.exceptions.ConfigRuntimeException;
-import com.laytonsmith.PureUtilities.SerializedPersistance;
-import com.laytonsmith.PureUtilities.Preferences;
-import com.laytonsmith.aliasengine.Constructs.*;
-import com.laytonsmith.PureUtilities.Preferences.Preference;
-import com.laytonsmith.PureUtilities.Preferences.Type;
-import com.laytonsmith.PureUtilities.fileutility.LineCallback;
-import com.laytonsmith.PureUtilities.rParser;
-import com.laytonsmith.aliasengine.functions.Exceptions.ExceptionType;
-import com.sk89q.bukkit.migration.PermissionsResolverManager;
-import com.sk89q.commandhelper.CommandHelperPlugin;
-import com.sk89q.worldedit.bukkit.WorldEditPlugin;
-import java.io.File;
-import java.nio.channels.FileLockInterruptionException;
-import java.util.ArrayList;
-import java.util.List;
-import java.util.logging.Logger;
-
-import com.sk89q.worldguard.bukkit.WorldGuardPlugin;
-import org.bukkit.Bukkit;
-import org.bukkit.Location;
-import org.bukkit.Material;
-import org.bukkit.Server;
-import org.bukkit.World;
-import org.bukkit.command.CommandSender;
-import org.bukkit.entity.Player;
-import org.bukkit.inventory.ItemStack;
-import org.bukkit.material.MaterialData;
-import org.bukkit.plugin.Plugin;
-
-/**
- * This class contains several static methods to get various objects that really should be static in the first
- * place, but aren't. For the most part, when any code is running, these things will have been initialized, but
- * in the event they aren't, each function will throw a NotInitializedYetException, which is a RuntimeException,
- * so you don't have to check for exceptions whenever you use them. The Exception is caught on a higher
- * level though, so it shouldn't bubble up too far.
- * @author Layton
- */
-public class Static {
-
-    /**
-     * This function pulls a numerical equivalent from any given construct. It throws a ConfigRuntimeException
-     * if it cannot be converted, for instance the string "s" cannot be cast to a number. The number returned
-     * will always be a double.
-     * @param c
-     * @return 
-     */
-    public static double getNumber(Construct c) {
-        double d;
-        if (c == null) {
-            return 0.0;
-        }
-        if (c instanceof CInt) {
-            d = ((CInt) c).getInt();
-        } else if (c instanceof CDouble) {
-            d = ((CDouble) c).getDouble();
-        } else if (c instanceof CString) {
-            try {
-                d = Double.parseDouble(c.val());
-            } catch (NumberFormatException e) {
-                throw new ConfigRuntimeException("Expecting a number, but received " + c.val() + " instead",
-                        ExceptionType.CastException, c.getLineNum(), c.getFile());
-            }
-        } else {
-            throw new ConfigRuntimeException("Expecting a number, but recieved " + c.val() + " instead",
-                    ExceptionType.CastException, c.getLineNum(), c.getFile());
-        }
-        return d;
-    }
-
-    /**
-     * Alias to getNumber
-     * @param c
-     * @return 
-     */
-    public static double getDouble(Construct c) {
-        try {
-            return getNumber(c);
-        } catch (ConfigRuntimeException e) {
-            throw new ConfigRuntimeException("Expecting a double, but recieved " + c.val() + " instead",
-                    ExceptionType.CastException, c.getLineNum(), c.getFile());
-        }
-    }
-
-    /**
-     * Returns an integer from any given construct. If the number is not castable to an int, a ConfigRuntimeException
-     * is thrown.
-     * @param c
-     * @return 
-     */
-    public static long getInt(Construct c) {
-        long i;
-        if (c == null) {
-            return 0;
-        }
-        if (c instanceof CInt) {
-            i = ((CInt) c).getInt();
-        } else {
-            try {
-                i = Integer.parseInt(c.val());
-            } catch (NumberFormatException e) {
-                throw new ConfigRuntimeException("Expecting an integer, but recieved " + c.val() + " instead",
-                        ExceptionType.CastException, c.getLineNum(), c.getFile());
-            }
-        }
-        return i;
-    }
-
-    /**
-     * Returns a boolean from any given construct. Depending on the type of the construct being converted, it follows the following rules:
-     * If it is an integer or a double, it is false if 0, true otherwise. If it is a string, if it is empty, it is false, otherwise it is true.
-     * @param c
-     * @return 
-     */
-    public static boolean getBoolean(Construct c) {
-        boolean b = false;
-        if (c == null) {
-            return false;
-        }
-        if (c instanceof CBoolean) {
-            b = ((CBoolean) c).getBoolean();
-        } else if (c instanceof CString) {
-            b = (c.val().length() > 0);
-        } else if (c instanceof CInt || c instanceof CDouble) {
-            b = (getNumber(c) > 0 || getNumber(c) < 0);
-        }
-        return b;
-    }
-
-    /**
-     * Returns true if any of the constructs are a CDouble, false otherwise.
-     * @param c
-     * @return 
-     */
-    public static boolean anyDoubles(Construct... c) {
-        for (int i = 0; i < c.length; i++) {
-            if (c[i] instanceof CDouble) {
-                return true;
-            }
-        }
-        return false;
-    }
-
-    /**
-     * Return true if any of the constructs are CStrings, false otherwise.
-     * @param c
-     * @return 
-     */
-    public static boolean anyStrings(Construct... c) {
-        for (int i = 0; i < c.length; i++) {
-            if (c[i] instanceof CString) {
-                return true;
-            }
-        }
-        return false;
-    }
-
-    /**
-     * Returns true if any of the constructs are CBooleans, false otherwise.
-     * @param c
-     * @return 
-     */
-    public static boolean anyBooleans(Construct... c) {
-        for (int i = 0; i < c.length; i++) {
-            if (c[i] instanceof CBoolean) {
-                return true;
-            }
-        }
-        return false;
-    }
-
-    /**
-     * Returns the logger for the plugin
-     * @return
-     * @throws NotInitializedYetException 
-     */
-    public static Logger getLogger() throws NotInitializedYetException {
-        Logger l = com.sk89q.commandhelper.CommandHelperPlugin.logger;
-        if (l == null) {
-            throw new NotInitializedYetException("The logger has not been initialized yet");
-        }
-        return l;
-    }
-
-    /**
-     * Returns the server for this plugin
-     * @return
-     * @throws NotInitializedYetException 
-     */
-    public static Server getServer() throws NotInitializedYetException {
-        Server s = com.sk89q.commandhelper.CommandHelperPlugin.myServer;
-        if (s == null) {
-            throw new NotInitializedYetException("The server has not been initialized yet");
-        }
-        return s;
-    }
-
-    /**
-     * Gets the reference to the AliasCore for this plugin
-     * @return
-     * @throws NotInitializedYetException 
-     */
-    public static AliasCore getAliasCore() throws NotInitializedYetException {
-        AliasCore ac = com.sk89q.commandhelper.CommandHelperPlugin.getCore();
-        if (ac == null) {
-            throw new NotInitializedYetException("The core has not been initialized yet");
-        }
-        return ac;
-    }
-
-    /**
-     * Gets the persistance object for this plugin
-     * @return
-     * @throws NotInitializedYetException 
-     */
-    public static SerializedPersistance getPersistance() throws NotInitializedYetException {
-        SerializedPersistance p = com.sk89q.commandhelper.CommandHelperPlugin.persist;
-        if (p == null) {
-            throw new NotInitializedYetException("The persistance framework has not been initialized yet");
-        }
-        return p;
-    }
-
-    /**
-     * Gets the permissions resolver manager this plugin uses
-     * @return
-     * @throws NotInitializedYetException 
-     */
-    public static PermissionsResolverManager getPermissionsResolverManager() throws NotInitializedYetException {
-        PermissionsResolverManager prm = com.sk89q.commandhelper.CommandHelperPlugin.perms;
-        if (prm == null) {
-            throw new NotInitializedYetException("The permissions framework has not been initialized yet");
-        }
-        return prm;
-    }
-
-    /**
-     * Gets the current version of the plugin
-     * @return
-     * @throws NotInitializedYetException 
-     */
-    public static Version getVersion() throws NotInitializedYetException {
-        Version v = com.sk89q.commandhelper.CommandHelperPlugin.version;
-        if (v == null) {
-            throw new NotInitializedYetException("The plugin has not been initialized yet");
-        }
-        return v;
-    }
-
-    /**
-     * Gets the preferences object for this plugin, as well as setting it up if
-     * it is not already activated.
-     * @return
-     * @throws NotInitializedYetException 
-     */
-    public static Preferences getPreferences() throws NotInitializedYetException {
-        if (com.sk89q.commandhelper.CommandHelperPlugin.prefs == null) {
-            ArrayList<Preferences.Preference> a = new ArrayList<Preferences.Preference>();
-            //a.add(new Preference("check-for-updates", "false", Type.BOOLEAN, "Whether or not to check to see if there's an update for CommandHelper"));
-            a.add(new Preference("debug-mode", "false", Type.BOOLEAN, "Whether or not to display debug information in the console"));
-            a.add(new Preference("show-warnings", "true", Type.BOOLEAN, "Whether or not to display warnings in the console, while compiling"));
-            a.add(new Preference("console-log-commands", "true", Type.BOOLEAN, "Whether or not to display the original command in the console when it is run"));
-            //a.add(new Preference("max-sleep-time", "5", Type.INT, "The maximum number of seconds a sleep function can sleep for. If <= 0, no limit is imposed. Must be an integer."));
-            a.add(new Preference("script-name", "config.txt", Type.STRING, "The path to the config file, relative to the CommandHelper plugin folder"));
-            a.add(new Preference("enable-interpreter", "false", Type.BOOLEAN, "Whether or not to enable the /interpreter command. Note that even with this enabled, a player must still have the commandhelper.interpreter permission, but"
-                    + " setting it to false prevents all players from accessing the interpreter regardless of their permissions."));
-            a.add(new Preference("base-dir", "", Type.STRING, "The base directory that scripts can read and write to. If left blank, then the default of the Bukkit directory will be used. "
-                    + "This setting affects functions like include and read."));
-            a.add(new Preference("play-dirty", "false", Type.BOOLEAN, "Makes CommandHelper play dirty and break all sorts of programming rules, so that other plugins can't interfere with the operations that you defined. Note that doing this essentially makes CommandHelper have absolute say over commands. Use this setting only if you can't get another plugin to cooperate with CH, because it is a global setting."));
-            a.add(new Preference("case-sensitive", "true", Type.BOOLEAN, "Makes command matching be case sensitive. If set to false, if your config defines /cmd, but the user runs /CMD, it will trigger the command anyways."));
-            com.sk89q.commandhelper.CommandHelperPlugin.prefs = new Preferences("CommandHelper", getLogger(), a);
-        }
-        return com.sk89q.commandhelper.CommandHelperPlugin.prefs;
-    }
-
-    public static WorldEditPlugin getWorldEditPlugin() {
-        if(CommandHelperPlugin.wep == null){
-            Plugin pwep = getServer().getPluginManager().getPlugin("WorldEdit");
-            if(pwep != null && pwep.isEnabled() && pwep instanceof WorldEditPlugin){
-                CommandHelperPlugin.wep = (WorldEditPlugin)pwep;
-            }
-        }
-        return CommandHelperPlugin.wep;
-    }
-    
-    public static WorldGuardPlugin getWorldGuardPlugin() {
-        Plugin pwgp = getServer().getPluginManager().getPlugin("WorldGuard");
-        if(pwgp != null && pwgp.isEnabled() && pwgp instanceof WorldGuardPlugin){
-            return (WorldGuardPlugin) pwgp;
-        }
-        return null;
-    }
-    
-
-    public static void checkPlugin(String name, int line_number, File f) throws ConfigRuntimeException {
-        if (Bukkit.getServer().getPluginManager().getPlugin(name) == null) {
-            throw new ConfigRuntimeException("Needed plugin " + name + " not found!",
-                    ExceptionType.InvalidPluginException, line_number, f);
-        }
-    }
-
-    /**
-     * Given a string input, creates and returns a Construct of the appropriate
-     * type. This takes into account that null, true, and false are keywords.
-     * @param val
-     * @param line_num
-     * @return 
-     */
-    public static Construct resolveConstruct(String val, int line_num, File file) {
-        if (val == null) {
-            return new CString("", line_num, file);
-        }
-        if (val.equalsIgnoreCase("null")) {
-            return new CNull(line_num, file);
-        } else if (val.equalsIgnoreCase("true")) {
-            return new CBoolean(true, line_num, file);
-        } else if (val.equalsIgnoreCase("false")) {
-            return new CBoolean(false, line_num, file);
-        } else {
-            try {
-                return new CInt(Integer.parseInt(val), line_num, file);
-            } catch (NumberFormatException e) {
-                try {
-                    return new CDouble(Double.parseDouble(val), line_num, file);
-                } catch (NumberFormatException g) {
-                    //It's a literal, but not a keyword. Push it in as a string to standardize everything
-                    //later
-                    return new CString(val, line_num, file);
-                }
-            }
-        }
-    }
-
-    public static Construct resolveDollarVar(Construct variable, List<Variable> vars) {
-        if (variable.getCType() == Construct.ConstructType.VARIABLE) {
-            for (Variable var : vars) {
-                if (var.getName().equals(((Variable) variable).getName())) {
-                    return Static.resolveConstruct(var.val(), var.getLineNum(), var.getFile());
-                }
-            }
-            return Static.resolveConstruct(((Variable)variable).getDefault(), variable.getLineNum(), variable.getFile());
-        } else {
-            return variable;
-        }
-    }
-
-    /**
-     * This function breaks a string into chunks based on Minecraft line length,
-     * and newlines, then calls the LineCallback with each line.
-     * @param c
-     * @param msg 
-     */
-    public static void SendMessage(LineCallback c, String msg) {
-        String[] newlines = msg.split("\n");
-        for (String line : newlines) {
-            String[] arr = rParser.wordWrap(line);
-            for (String toMsg : arr) {
-                c.run(toMsg.trim());
-            }
-        }
-
-    }
-
-    /**
-     * This function sends a message to the player. It is useful to use this function because:
-     * It handles newlines and wordwrapping for you.
-     * @param p
-     * @param msg 
-     */
-    public static void SendMessage(final CommandSender m, String msg, final int line_num, final File f) {
-        SendMessage(new LineCallback() {
-
-            public void run(String line) {
-                Player p = null;
-                if(m instanceof Player){
-                    p = (Player)m;
-                    if (p == null || !p.isOnline()) {
-                        throw new ConfigRuntimeException("The player " + p.getName() + " is not online", ExceptionType.PlayerOfflineException, line_num, f);
-                    }
-                    p.sendMessage(line);
-                } else {
-                    if(m != null){
-                        m.sendMessage(line);
-                    }
-                }
-            }
-        }, msg);
-    }
-
-    public static void SendMessage(final CommandSender m, String msg) {
-        SendMessage(new LineCallback() {
-
-            public void run(String line) {
-                Player p = null;
-                if(m instanceof Player){
-                    p = (Player)m;
-                    if (p != null && p.isOnline()) {
-                        p.sendMessage(line);
-                    }
-                } else {
-                    if(m != null){
-                        m.sendMessage(line);
-                    }
-                }
-            }
-        }, msg);
-    }
-
-    /**
-     * Returns true if this filepath is accessible to CH, false otherwise.
-     * @param location
-     * @return 
-     */
-    public static boolean CheckSecurity(String location) {
-        String pref = (String) Static.getPreferences().getPreference("base-dir");
-        if (pref.trim().equals("")) {
-            pref = ".";
-        }
-        File base_dir = new File(pref);
-        String base_final = base_dir.getAbsolutePath();
-        if (base_final.endsWith(".")) {
-            base_final = base_final.substring(0, base_final.length() - 1);
-        }
-        File loc = new File(location);
-        return loc.getAbsolutePath().startsWith(base_final);
-    }
-
-    /**
-     * Returns whether or not this location appears to be a url.
-     */
-    public static boolean ApparentURL(String toCheck) {
-        return false;
-    }
-
-    public static ItemStack ParseItemNotation(String functionName, String notation, int qty, int line_num, File f) {
-        int type = 0;
-        byte data = 0;
-        ItemStack is = null;
-        if (notation.matches("\\d*:\\d*")) {
-            String[] sData = notation.split(":");
-            try {
-                type = (int) Integer.parseInt(sData[0]);
-                if(sData.length > 1){
-                    data = (byte) Integer.parseInt(sData[1]);
-                }
-            } catch (NumberFormatException e) {
-                throw new ConfigRuntimeException("Item value passed to " + functionName + " is invalid: " + notation, ExceptionType.FormatException, line_num, f);
-            }
-        } else {
-            type = (int) Static.getInt(Static.resolveConstruct(notation, line_num, f));
-        }
-        
-        is = new ItemStack(type, qty);
-        is.setDurability(data);
-        //is.setData(new MaterialData(type, data));
-        return is;
-    }
-    
-    public static Player GetPlayer(String player, int line_num, File f) throws ConfigRuntimeException{
-        Player m = Static.getServer().getPlayer(player);
-        if(m == null || !m.isOnline()){
-            throw new ConfigRuntimeException("The specified player (player) is not online", ExceptionType.PlayerOfflineException, line_num, f);
-        }
-        return m;
-    }
-    
-    /**
-     * Location "objects" are mscript arrays that represent a location in game. There are 
-     * 4 usages:
-     * <ul>
-     * <li>(x, y, z)</li>
-     * <li>(world, x, y, z)</li>
-     * <li>(x, y, z, yaw, pitch)</li>
-     * <li>(world, x, y, z, yaw, pitch)</li>
-     * </ul>
-     * In all cases, the pitch and yaw default to 0, and the world defaults to the specified world.
-     * <em>More conveniently: ([world], x, y, z, [yaw, pitch])</em> 
-     * @param c
-     * @param w
-     * @param line_num
-     * @param f
-     * @return 
-     */
-    public static Location GetLocation(Construct c, World w, int line_num, File f){
-        if(!(c instanceof CArray)){
-            throw new ConfigRuntimeException("Expecting an array, received " + c.getCType(), ExceptionType.FormatException, line_num, f);
-        }
-        CArray array = (CArray)c;
-        World world = w;
-        double x = 0;
-        double y = 0;
-        double z = 0;
-        float yaw = 0;
-        float pitch = 0;
-        if(array.size() == 3){
-            //Just the xyz, with default yaw and pitch, and given world
-            x = Static.getNumber(array.get(0, line_num));
-            y = Static.getNumber(array.get(1, line_num));
-            z = Static.getNumber(array.get(2, line_num));
-        } else if(array.size() == 4){
-            //world, x, y, z
-            world = Static.getServer().getWorld(array.get(0, line_num).val());
-            x = Static.getNumber(array.get(1, line_num));
-            y = Static.getNumber(array.get(2, line_num));
-            z = Static.getNumber(array.get(3, line_num));
-        } else if(array.size() == 5){
-            //x, y, z, yaw, pitch, with given world
-            x = Static.getNumber(array.get(0, line_num));
-            y = Static.getNumber(array.get(1, line_num));
-            z = Static.getNumber(array.get(2, line_num));
-            yaw = (float)Static.getNumber(array.get(3, line_num));
-            pitch = (float)Static.getNumber(array.get(4, line_num));
-        } else if(array.size() == 6){
-            //All have been given
-            world = Static.getServer().getWorld(array.get(0, line_num).val());
-            x = Static.getNumber(array.get(1, line_num));
-            y = Static.getNumber(array.get(2, line_num));
-            z = Static.getNumber(array.get(3, line_num));
-            yaw = (float)Static.getNumber(array.get(4, line_num));
-            pitch = (float)Static.getNumber(array.get(5, line_num));
-        } else {
-            throw new ConfigRuntimeException("Expecting a Location array, but the array did not meet the format specifications", ExceptionType.FormatException, line_num, f);
-        }
-        return new Location(world, x, y, z, yaw, pitch);
-    }
-
-    public static boolean isNull(Construct construct) {
-        return construct instanceof CNull;
-    }
-    
-    public static int Normalize(int i, int min, int max){
-        return java.lang.Math.min(max, java.lang.Math.max(min, i));
-    }
-}
diff --git a/src/main/java/com/laytonsmith/aliasengine/User.java b/src/main/java/com/laytonsmith/aliasengine/User.java
deleted file mode 100644
index e64fbc9..0000000
--- a/src/main/java/com/laytonsmith/aliasengine/User.java
+++ /dev/null
@@ -1,100 +0,0 @@
-/*
- * To change this template, choose Tools | Templates
- * and open the template in the editor.
- */
-
-package com.laytonsmith.aliasengine;
-
-import com.laytonsmith.PureUtilities.SerializedPersistance;
-import java.util.ArrayList;
-import java.util.Map;
-import java.util.logging.Level;
-import java.util.logging.Logger;
-import org.bukkit.ChatColor;
-import org.bukkit.entity.Player;
-
-/**
- *
- * @author layton
- */
-public class User {
-    Player player;
-    SerializedPersistance persist;
-    
-
-    public User(Player player, SerializedPersistance persist){
-        //(new PermissionsResolverServerListener(perms)).register(this);
-        this.player = player;
-        this.persist = persist;
-    }
-
-    public int addAlias(String alias){
-        try {
-            ArrayList<Map.Entry> list = persist.getNamespaceValues(new String[]{player.getName(), "aliases"});
-            System.out.println(list);
-            Integer nextValue = 0;
-            for (Map.Entry e : list) {
-                String[] x = e.getKey().toString().split("\\.");
-                Integer thisX = Integer.parseInt(x[x.length - 1]);
-                nextValue = Math.max(thisX + 1, nextValue + 1);
-                System.out.println("Next Value is: " + nextValue);
-            }
-            persist.setValue(new String[]{player.getName(), "aliases", nextValue.toString()}, alias);
-            persist.save();
-            return nextValue;
-        } catch (Exception ex) {
-            player.sendMessage("Could not add the alias. Please check the error logs for more information.");
-            Logger.getLogger("Minecraft").log(Level.SEVERE, null, ex);
-            return -1;
-        }
-    }
-
-    public String getAlias(int id){
-        return (String) persist.getValue(new String[]{player.getName(), "aliases", Integer.toString(id)});
-    }
-
-    public String getAllAliases(){
-        ArrayList<Map.Entry> al = persist.getNamespaceValues(new String[]{player.getName(), "aliases"});
-        StringBuilder b = new StringBuilder();
-        System.out.println(al);
-        for(Map.Entry e : al){
-            String [] key = e.getKey().toString().split("\\.");
-            b.append(ChatColor.AQUA)
-                    .append(key[key.length - 1])
-                    .append(":")
-                    .append(e.getValue().toString().substring(0, Math.min(e.getValue().toString().length(), 45)))
-                    .append(e.getValue().toString().length() > 45?"...":"")
-                    .append("\n");
-        }
-        if(al.isEmpty()){
-            b.append(ChatColor.AQUA).append("You have no aliases defined");
-        }
-        return b.toString();
-    }
-
-    public ArrayList<String> getAliasesAsArray(){
-        ArrayList<Map.Entry> al = persist.getNamespaceValues(new String[]{player.getName(), "aliases"});
-        StringBuilder b = new StringBuilder();
-        ArrayList<String> commands = new ArrayList<String>();
-        for(Map.Entry e : al){
-            String [] key = e.getKey().toString().split("\\.");
-            b.append(e.getValue().toString()).append("\n");
-            commands.add(b.toString());
-            b = new StringBuilder();
-        }
-        return commands;
-    }
-
-    public int getTotalAliases(){
-        return persist.getNamespaceValues(new String[]{player.getName(), "aliases"}).size();
-    }
-
-    public void removeAlias(int id){
-        try {
-            persist.setValue(new String[]{player.getName(), "aliases", Integer.toString(id)}, null);
-            persist.save();
-        } catch (Exception ex) {
-            Logger.getLogger(User.class.getName()).log(Level.SEVERE, null, ex);
-        }
-    }
-}
diff --git a/src/main/java/com/laytonsmith/aliasengine/Version.java b/src/main/java/com/laytonsmith/aliasengine/Version.java
deleted file mode 100644
index 1123082..0000000
--- a/src/main/java/com/laytonsmith/aliasengine/Version.java
+++ /dev/null
@@ -1,105 +0,0 @@
-/*
- * To change this template, choose Tools | Templates
- * and open the template in the editor.
- */
-package com.laytonsmith.aliasengine;
-
-import java.util.regex.Matcher;
-import java.util.regex.Pattern;
-
-/**
- * A version is formatted as such: 1.2.10 beta-1 where 1 is the major version,
- * 2 is the minor version, 10 is the supplemental version, and beta-1 is the tag.
- * When comparing two versions, the tag is not considered.
- * @author Layton
- */
-public class Version implements Comparable<Version>{
-    
-    private int major;
-    private int minor;
-    private int supplemental;
-    private String tag;
-    
-    /**
-     * Creates a new Version object from a string version number. The tag is
-     * optional, but all other parameters are required. If left off, each version
-     * part is set to 0.
-     * @param version 
-     */
-    public Version(String version){
-        Pattern p = Pattern.compile("(\\d+)\\.(\\d+)\\.(\\d+)\\s+(.*)?");
-        Matcher m = p.matcher(version);
-        if(m.find()){
-            major = Integer.parseInt(m.group(1)==null?"0":m.group(1));
-            minor = Integer.parseInt(m.group(2)==null?"0":m.group(2));
-            supplemental = Integer.parseInt(m.group(3)==null?"0":m.group(3));
-            tag = m.group(4)==null?"":m.group(4);
-        } else {
-            major = minor = supplemental = 0;
-            tag = "";
-        }
-    }
-    
-    public Version(int major, int minor, int supplemental, String tag){
-        this.major = major;
-        this.minor = minor;
-        this.supplemental = supplemental;
-        this.tag = tag;
-    }
-    
-    public Version(int major, int minor, int supplemental){
-        this(major, minor, supplemental, "");
-    }
-    
-    @Override
-    public String toString(){
-        return (major + "." + minor + "." + supplemental + " " + tag).trim();
-    }
-
-    public int compareTo(Version o) {
-        if(major < o.major){
-            return -1;
-        } else if(major > o.major){
-            return 1;
-        } else {
-            if(minor < o.minor){
-                return -1;
-            } else if(minor > o.minor){
-                return 1;
-            } else {
-                if(supplemental < o.supplemental){
-                    return -1;
-                } else if(supplemental > o.supplemental){
-                    return 1;
-                } else {
-                    return 0;
-                }
-            }
-        }
-    }
-
-    @Override
-    public boolean equals(Object obj) {
-        if(obj instanceof Version){
-            Version v = (Version) obj;
-            if(major == v.major && minor == v.minor && supplemental == v.supplemental){
-                return true;
-            } else {
-                return false;
-            }
-        } else {
-            return false;
-        }
-    }
-
-    @Override
-    public int hashCode() {
-        int hash = 5;
-        hash = 97 * hash + this.major;
-        hash = 97 * hash + this.minor;
-        hash = 97 * hash + this.supplemental;
-        return hash;
-    }
-    
-    
-}
diff --git a/src/main/java/com/laytonsmith/aliasengine/functions/ArrayHandling.java b/src/main/java/com/laytonsmith/aliasengine/functions/ArrayHandling.java
deleted file mode 100644
index af08d69..0000000
--- a/src/main/java/com/laytonsmith/aliasengine/functions/ArrayHandling.java
+++ /dev/null
@@ -1,490 +0,0 @@
-/*
- * To change this template, choose Tools | Templates
- * and open the template in the editor.
- */
-package com.laytonsmith.aliasengine.functions;
-
-import com.laytonsmith.aliasengine.functions.exceptions.CancelCommandException;
-import com.laytonsmith.aliasengine.functions.exceptions.ConfigRuntimeException;
-import com.laytonsmith.aliasengine.Constructs.CArray;
-import com.laytonsmith.aliasengine.Constructs.CBoolean;
-import com.laytonsmith.aliasengine.Constructs.CInt;
-import com.laytonsmith.aliasengine.Constructs.CNull;
-import com.laytonsmith.aliasengine.Constructs.CVoid;
-import com.laytonsmith.aliasengine.Constructs.Construct;
-import com.laytonsmith.aliasengine.Static;
-import com.laytonsmith.aliasengine.functions.BasicLogic.equals;
-import com.laytonsmith.aliasengine.functions.Exceptions.ExceptionType;
-import java.io.File;
-import org.bukkit.command.CommandSender;
-
-/**
- *
- * @author Layton
- */
-public class ArrayHandling {
-    public static String docs(){
-        return "This class contains functions that provide a way to manipulate arrays. To create an array, use the <code>array</code> function."
-                + " For more detailed information on array usage, see the page on [[CommandHelper/Arrays|arrays]]";
-    }
-    @api public static class array_size implements Function{
-
-        public String getName() {
-            return "array_size";
-        }
-
-        public Integer[] numArgs() {
-            return new Integer[]{1};
-        }
-
-        public Construct exec(int line_num, File f, CommandSender p, Construct... args) throws CancelCommandException, ConfigRuntimeException {
-            if(args[0] instanceof CArray){
-                return new CInt(((CArray)args[0]).size(), line_num, f);
-            }
-            throw new ConfigRuntimeException("Argument 1 of array_size must be an array", ExceptionType.CastException, line_num, f);
-        }
-        
-        public ExceptionType[] thrown(){
-            return new ExceptionType[]{ExceptionType.CastException};
-        }
-
-        public String docs() {
-            return "int {array} Returns the size of this array as an integer.";
-        }
-
-        public boolean isRestricted() {
-            return false;
-        }
-
-        public void varList(IVariableList varList) {}
-
-        public boolean preResolveVariables() {
-            return true;
-        }
-
-        public String since() {
-            return "3.0.1";
-        }
-
-        public Boolean runAsync() {
-            return null;
-        }
-        
-    }
-    
-    @api public static class array_get implements Function{
-
-        public String getName() {
-            return "array_get";
-        }
-
-        public Integer[] numArgs() {
-            return new Integer[]{1, 2};
-        }
-
-        public Construct exec(int line_num, File f, CommandSender p, Construct... args) throws CancelCommandException, ConfigRuntimeException {
-            if(args[0] instanceof CArray){
-                CArray ca = (CArray)args[0];
-                String index = "0..-1";
-                if(args.length == 2){
-                    index = args[1].val();
-                }
-                if(index.contains("..")){
-                    //It's a range
-                    int start = 0;
-                    int finish = 0;
-                    String[] split = index.split("\\.\\.");
-                    try{
-                        if(split[0].isEmpty()){
-                            start = 0;
-                        } else {
-                            start = Integer.parseInt(split[0]);
-                        }
-                        if(split.length == 1 || split[1].isEmpty()){
-                            finish = ca.size() - 1;
-                        } else {
-                            finish = Integer.parseInt(split[1]);
-                        }
-                        //Convert negative indexes 
-                        if(start < 0){
-                            start = ca.size() + start;
-                        }
-                        if(finish < 0){
-                            finish = ca.size() + finish;
-                        }
-                        CArray na = new CArray(line_num, f);
-                        if(finish <= start){
-                            //return an empty array in cases where the indexes don't make sense
-                            return na;
-                        }
-                        for(int i = start; i <= finish; i++){
-                            try{
-                                na.push(ca.get(i, line_num).clone());
-                            } catch(CloneNotSupportedException e){
-                                na.push(ca.get(i, line_num));
-                            }
-                        }
-                        return na;
-                    } catch(NumberFormatException e){
-                        throw new ConfigRuntimeException("Ranges must be integer numbers, i.e., [0..5]", ExceptionType.CastException, line_num, f);
-                    }
-                } else {
-                    int iindex = (int)Static.getInt(args[1]);
-                    if(iindex < 0){
-                        //negative index, convert to positive index
-                        iindex = ca.size() + iindex;
-                    }
-                    return ca.get(iindex, line_num);
-                }
-            } else{
-                throw new ConfigRuntimeException("Argument 1 of array_get must be an array", ExceptionType.CastException, line_num, f);
-            }
-        }
-        
-        public ExceptionType[] thrown(){
-            return new ExceptionType[]{ExceptionType.CastException, ExceptionType.IndexOverflowException};
-        }
-
-        public String docs() {
-            return "mixed {array, index} Returns the element specified at the index of the array. If the element doesn't exist, an exception is thrown. "
-                    + "array_get(array, index). Note also that as of 3.1.2, you can use a more traditional method to access elements in an array: "
-                    + "array[index] is the same as array_get(array, index), where array is a variable, or function that is an array. In fact, the compiler"
-                    + " does some magic under the covers, and literally converts array[index] into array_get(array, index), so if there is a problem "
-                    + "with your code, you will get an error message about a problem with the array_get function, even though you may not be using "
-                    + "that function directly.";
-        }
-
-        public boolean isRestricted() {
-            return false;
-        }
-
-        public void varList(IVariableList varList) {}
-
-        public boolean preResolveVariables() {
-            return true;
-        }
-        public String since() {
-            return "3.0.1";
-        }
-        
-        public Boolean runAsync() {
-            return null;
-        }
-        
-    }
-    
-    @api public static class array_set implements Function{
-
-        public String getName() {
-            return "array_set";
-        }
-
-        public Integer[] numArgs() {
-            return new Integer[]{3};
-        }
-
-        public Construct exec(int line_num, File f, CommandSender p, Construct... args) throws CancelCommandException, ConfigRuntimeException {
-            if(args[0] instanceof CArray && args[1] instanceof CInt){
-                try{
-                ((CArray)args[0]).set((int)((CInt)args[1]).getInt(), args[2]);
-                } catch(IndexOutOfBoundsException e){
-                    throw new ConfigRuntimeException("The index " + args[1].val() + " is out of bounds", ExceptionType.IndexOverflowException, line_num, f);
-                }
-                return new CVoid(line_num, f);
-            }
-            throw new ConfigRuntimeException("Argument 1 of array_set must be an array, and argument 2 must be an integer", ExceptionType.CastException, line_num, f);        
-        }
-
-        public ExceptionType[] thrown(){
-            return new ExceptionType[]{ExceptionType.CastException, ExceptionType.IndexOverflowException};
-        }
-        
-        public String docs() {
-            return "void {array, index, value} Sets the value of the array at the specified index. array_set(array, index, value). Returns void. If"
-                    + " the element at the specified index isn't already set, throws an exception. Use array_push to avoid this.";
-        }
-
-        public boolean isRestricted() {
-            return false;
-        }
-
-        public void varList(IVariableList varList) {}
-
-        public boolean preResolveVariables() {
-            return true;
-        }
-        public String since() {
-            return "3.0.1";
-        }
-        
-        public Boolean runAsync() {
-            return null;
-        }
-    }
-    
-    @api public static class array_push implements Function{
-
-        public String getName() {
-            return "array_push";
-        }
-
-        public Integer[] numArgs() {
-            return new Integer[]{2};
-        }
-
-        public Construct exec(int line_num, File f, CommandSender p, Construct... args) throws CancelCommandException, ConfigRuntimeException {
-            if(args[0] instanceof CArray){
-                ((CArray)args[0]).push(args[1]);
-                return new CVoid(line_num, f);
-            }
-            throw new ConfigRuntimeException("Argument 1 of array_push must be an array", ExceptionType.CastException, line_num, f);
-        }
-        
-        public ExceptionType[] thrown(){
-            return new ExceptionType[]{ExceptionType.CastException};
-        }
-
-        public String docs() {
-            return "void {array, value} Pushes the specified value onto the end of the array";
-        }
-
-        public boolean isRestricted() {
-            return false;
-        }
-
-        public void varList(IVariableList varList) {}
-
-        public boolean preResolveVariables() {
-            return true;
-        }
-        public String since() {
-            return "3.0.1";
-        }
-        
-        public Boolean runAsync() {
-            return null;
-        }
-        
-    }
-    @api public static class array_contains implements Function {
-
-        public String getName() {
-            return "array_contains";
-        }
-
-        public Integer[] numArgs() {
-            return new Integer[]{2};
-        }
-
-        public Construct exec(int line_num, File f, CommandSender p, Construct... args) throws CancelCommandException, ConfigRuntimeException {
-            equals e = new equals();
-            if(args[0] instanceof CArray){
-                CArray ca = (CArray) args[0];
-                for(int i = 0; i < ca.size(); i++){
-                    if(((CBoolean)e.exec(line_num, f, p, ca.get(i, line_num), args[1])).getBoolean()){
-                        return new CBoolean(true, line_num, f);
-                    }
-                }
-                return new CBoolean(false, line_num, f);
-            } else {
-                throw new ConfigRuntimeException("Argument 1 of array_contains must be an array", ExceptionType.CastException, line_num, f);
-            }
-        }
-        
-        public ExceptionType[] thrown(){
-            return new ExceptionType[]{ExceptionType.CastException};
-        }
-
-        public String docs() {
-            return "boolean {array, testValue} Checks to see if testValue is in array.";
-        }
-
-        public boolean isRestricted() {
-            return false;
-        }
-
-        public void varList(IVariableList varList) {}
-
-        public boolean preResolveVariables() {
-            return true;
-        }
-        public String since() {
-            return "3.0.1";
-        }
-        
-        public Boolean runAsync() {
-            return null;
-        }
-        
-    }
-    
-    @api public static class array_index_exists implements Function{
-
-        public String getName() {
-            return "array_index_exists";
-        }
-
-        public Integer[] numArgs() {
-            return new Integer[]{2};
-        }
-
-        public String docs() {
-            return "boolean {array, index} Checks to see if the specified array has an element at index";
-        }
-
-        public ExceptionType[] thrown() {
-            return new ExceptionType[]{ExceptionType.CastException};
-        }
-
-        public boolean isRestricted() {
-            return false;
-        }
-
-        public void varList(IVariableList varList) {}
-
-        public boolean preResolveVariables() {
-            return true;
-        }
-
-        public String since() {
-            return "3.1.2";
-        }
-
-        public Boolean runAsync() {
-            return null;
-        }
-
-        public Construct exec(int line_num, File f, CommandSender p, Construct... args) throws ConfigRuntimeException {
-            if(args[0] instanceof CArray){
-                int index = (int)Static.getInt(args[1]);
-                CArray ca = (CArray)args[0];
-                return new CBoolean(index <= ca.size() - 1, line_num, f);
-            } else {
-                throw new ConfigRuntimeException("Expecting argument 1 to be an array", ExceptionType.CastException, line_num, f);
-            }
-        }
-        
-    }
-    
-    @api public static class array_resize implements Function{
-
-        public String getName() {
-            return "array_resize";
-        }
-
-        public Integer[] numArgs() {
-            return new Integer[]{2, 3};
-        }
-
-        public String docs() {
-            return "void {array, size, [fill]} Resizes the given array so that it is at least of size size, filling the blank spaces with"
-                    + " fill, or null by default. If the size of the array is already at least size, nothing happens; in other words this"
-                    + " function can only be used to increase the size of the array.";
-                    //+ " If the array is an associative array, the non numeric values are simply copied over.";
-        }
-
-        public ExceptionType[] thrown() {
-            return new ExceptionType[]{ExceptionType.CastException};
-        }
-
-        public boolean isRestricted() {
-            return false;
-        }
-
-        public void varList(IVariableList varList) {}
-
-        public boolean preResolveVariables() {
-            return true;
-        }
-
-        public String since() {
-            return "3.2.0";
-        }
-
-        public Boolean runAsync() {
-            return null;
-        }
-
-        public Construct exec(int line_num, File f, CommandSender p, Construct... args) throws ConfigRuntimeException {
-            if(args[0] instanceof CArray && args[1] instanceof CInt){
-                CArray original = (CArray)args[0];
-                int size = (int)((CInt)args[1]).getInt();
-                Construct fill = new CNull(line_num, f);
-                if(args.length == 3){
-                    fill = args[2];
-                }
-                for(int i = original.size(); i < size; i++){
-                    original.push(fill);
-                }
-            } else {
-                throw new ConfigRuntimeException("Argument 1 must be an array, and argument 2 must be an integer in array_resize", ExceptionType.CastException, line_num, f);
-            }
-            return new CVoid(line_num, f);
-        }
-        
-    }
-    
-    @api public static class range implements Function{
-
-        public String getName() {
-            return "range";
-        }
-
-        public Integer[] numArgs() {
-            return new Integer[]{1, 2, 3};
-        }
-
-        public String docs() {
-            return "array {start, finish, [increment] | finish} Returns an array of numbers from start to (finish - 1)"
-                    + " skipping increment integers per count. start defaults to 0, and increment defaults to 1. All inputs"
-                    + " must be integers. If the input doesn't make sense, it will reasonably degrade, and return an empty array.";
-        }
-
-        public ExceptionType[] thrown() {
-            return new ExceptionType[]{ExceptionType.CastException};
-        }
-
-        public boolean isRestricted() {
-            return false;
-        }
-
-        public void varList(IVariableList varList) {}
-
-        public boolean preResolveVariables() {
-            return true;
-        }
-
-        public String since() {
-            return "3.2.0";
-        }
-
-        public Boolean runAsync() {
-            return null;
-        }
-
-        public Construct exec(int line_num, File f, CommandSender p, Construct... args) throws ConfigRuntimeException {
-            long start = 0;
-            long finish = 0;
-            long increment = 1;
-            if(args.length == 1){
-                finish = Static.getInt(args[0]);
-            } else if(args.length == 2){
-                start = Static.getInt(args[0]);
-                finish = Static.getInt(args[1]);
-            } else if(args.length == 3){
-                start = Static.getInt(args[0]);
-                finish = Static.getInt(args[1]);
-                increment = Static.getInt(args[2]);
-            }
-            if(start < finish && increment < 0 || start > finish && increment > 0  || increment == 0){
-                return new CArray(line_num, f);
-            }
-            CArray ret = new CArray(line_num, f);
-            for(long i = start; (increment > 0?i < finish:i > finish); i = i + increment){
-                ret.push(new CInt(i, line_num, f));
-            }
-            return ret;
-        }
-        
-    }
-}
diff --git a/src/main/java/com/laytonsmith/aliasengine/functions/BasicLogic.java b/src/main/java/com/laytonsmith/aliasengine/functions/BasicLogic.java
deleted file mode 100644
index f11f32e..0000000
--- a/src/main/java/com/laytonsmith/aliasengine/functions/BasicLogic.java
+++ /dev/null
@@ -1,487 +0,0 @@
-/*
- * To change this template, choose Tools | Templates
- * and open the template in the editor.
- */
-package com.laytonsmith.aliasengine.functions;
-
-import com.laytonsmith.aliasengine.GenericTreeNode;
-import com.laytonsmith.aliasengine.functions.exceptions.CancelCommandException;
-import com.laytonsmith.aliasengine.functions.exceptions.ConfigRuntimeException;
-import com.laytonsmith.aliasengine.Constructs.*;
-import com.laytonsmith.aliasengine.Constructs.Construct;
-import com.laytonsmith.aliasengine.Script;
-import com.laytonsmith.aliasengine.Static;
-import com.laytonsmith.aliasengine.functions.Exceptions.ExceptionType;
-import java.io.File;
-import org.bukkit.command.CommandSender;
-
-/**
- *
- * @author Layton
- */
-public class BasicLogic {
-    public static String docs(){
-        return "These functions provide basic logical operations.";
-    }
-    @api public static class _if implements Function{
-
-        public String getName() {
-            return "if";
-        }
-
-        public Integer[] numArgs() {
-            return new Integer[]{2, 3};
-        }
-        
-        public Construct execs(int line_num, File f, CommandSender p, Script parent, 
-                GenericTreeNode<Construct> condition, GenericTreeNode<Construct> __if, 
-                GenericTreeNode<Construct> __else) throws CancelCommandException{
-            if(Static.getBoolean(parent.eval(condition, p))){
-                return parent.eval(__if, p);
-            } else {
-                if(__else == null){
-                    return new CVoid(line_num, f);
-                }
-                return parent.eval(__else, p);
-            }
-        }
-
-        public Construct exec(int line_num, File f, CommandSender p, Construct... args) throws CancelCommandException, ConfigRuntimeException {
-            return new CVoid(line_num, f);
-        }
-        
-        public ExceptionType[] thrown(){
-            return new ExceptionType[]{ExceptionType.CastException};
-        }
-
-        public String docs() {
-            return "mixed {cond, trueRet, [falseRet]} If the first argument evaluates to a true value, the second argument is returned, otherwise the third argument is returned."
-                    + " If there is no third argument, it returns void.";
-        }
-
-        public boolean isRestricted() {
-            return false;
-        }
-
-        public void varList(IVariableList varList) {}
-
-        public boolean preResolveVariables() {
-            return false;
-        }
-        public String since() {
-            return "3.0.1";
-        }
-        //Doesn't matter, this function is run out of state
-        public Boolean runAsync() {
-            return false;
-        }
-        
-    }
-    
-    @api public static class equals implements Function{
-
-        public String getName() {
-            return "equals";
-        }
-
-        public Integer[] numArgs() {
-            return new Integer[]{2};
-        }
-
-        public Construct exec(int line_num, File f, CommandSender p, Construct... args) throws CancelCommandException, ConfigRuntimeException {
-            if(Static.anyBooleans(args)){
-                boolean arg1 = Static.getBoolean(args[0]);
-                boolean arg2 = Static.getBoolean(args[1]);
-                return new CBoolean(arg1 == arg2, line_num, f);
-            }
-            if(args[0].val().equals(args[1].val())){
-                return new CBoolean(true, line_num, f);
-            }
-            try{
-                double arg1 = Static.getNumber(args[0]);
-                double arg2 = Static.getNumber(args[1]);
-                return new CBoolean(arg1 == arg2, line_num, f);
-            } catch (ConfigRuntimeException e){
-                return new CBoolean(false, line_num, f);
-            }
-        }
-        
-        public ExceptionType[] thrown(){
-            return new ExceptionType[]{ExceptionType.CastException};
-        }
-
-        public String docs() {
-            return "boolean {var1, var2} Returns true or false if the two arguments are equal";
-        }
-
-        public boolean isRestricted() {
-            return false;
-        }
-
-        public void varList(IVariableList varList) {}
-
-        public boolean preResolveVariables() {
-            return true;
-        }
-        public String since() {
-            return "3.0.1";
-        }
-        public Boolean runAsync() {
-            return null;
-        }
-    }
-    
-    @api public static class equals_ic implements Function{
-
-        public String getName() {
-            return "equals_ic";
-        }
-
-        public Integer[] numArgs() {
-            return new Integer[]{2};
-        }
-
-        public String docs() {
-            return "boolean {val1, val2} Returns true if the two values are equal to each other, while"
-                    + " ignoring case.";
-        }
-
-        public ExceptionType[] thrown() {
-            return new ExceptionType[]{};
-        }
-
-        public boolean isRestricted() {
-            return false;
-        }
-
-        public void varList(IVariableList varList) {}
-
-        public boolean preResolveVariables() {
-            return true;
-        }
-
-        public String since() {
-            return "3.2.0";
-        }
-
-        public Boolean runAsync() {
-            return null;
-        }
-
-        public Construct exec(int line_num, File f, CommandSender p, Construct... args) throws ConfigRuntimeException {
-            if(Static.anyBooleans(args)){
-                boolean arg1 = Static.getBoolean(args[0]);
-                boolean arg2 = Static.getBoolean(args[1]);
-                return new CBoolean(arg1 == arg2, line_num, f);
-            }
-            if(args[0].val().equalsIgnoreCase(args[1].val())){
-                return new CBoolean(true, line_num, f);
-            }
-            try{
-                double arg1 = Static.getNumber(args[0]);
-                double arg2 = Static.getNumber(args[1]);
-                return new CBoolean(arg1 == arg2, line_num, f);
-            } catch (ConfigRuntimeException e){
-                return new CBoolean(false, line_num, f);
-            }
-        }
-        
-    }
-    
-    @api public static class lt implements Function{
-
-        public String getName() {
-            return "lt";
-        }
-
-        public Integer[] numArgs() {
-            return new Integer[]{2};
-        }
-
-        public Construct exec(int line_num, File f, CommandSender p, Construct... args) throws CancelCommandException, ConfigRuntimeException {
-            double arg1 = Static.getNumber(args[0]);
-            double arg2 = Static.getNumber(args[1]);
-            return new CBoolean(arg1 < arg2, line_num, f);
-        }
-        
-        public ExceptionType[] thrown(){
-            return new ExceptionType[]{ExceptionType.CastException};
-        }
-
-        public String docs() {
-            return "boolean {var1, var2} Returns the results of a less than operation";
-        }
-
-        public boolean isRestricted() {
-            return false;
-        }
-
-        public void varList(IVariableList varList) {}
-
-        public boolean preResolveVariables() {
-            return true;
-        }
-        public String since() {
-            return "3.0.1";
-        }
-        public Boolean runAsync() {
-            return null;
-        }
-    }
-    
-    @api public static class gt implements Function{
-
-        public String getName() {
-            return "gt";
-        }
-
-        public Integer[] numArgs() {
-            return new Integer[]{2};
-        }
-
-        public Construct exec(int line_num, File f, CommandSender p, Construct... args) throws CancelCommandException, ConfigRuntimeException {
-            double arg1 = Static.getNumber(args[0]);
-            double arg2 = Static.getNumber(args[1]);
-            return new CBoolean(arg1 > arg2, line_num, f);
-        }
-        
-        public ExceptionType[] thrown(){
-            return new ExceptionType[]{ExceptionType.CastException};
-        }
-
-        public String docs() {
-            return "boolean {var1, var2} Returns the result of a greater than operation";
-        }
-
-        public boolean isRestricted() {
-            return false;
-        }
-
-        public void varList(IVariableList varList) {}
-
-        public boolean preResolveVariables() {
-            return true;
-        }
-        public String since() {
-            return "3.0.1";
-        }
-        
-        public Boolean runAsync() {
-            return null;
-        }
-    }
-    
-    @api public static class lte implements Function{
-
-        public String getName() {
-            return "lte";
-        }
-
-        public Integer[] numArgs() {
-            return new Integer[]{2};
-        }
-
-        public Construct exec(int line_num, File f, CommandSender p, Construct... args) throws CancelCommandException, ConfigRuntimeException {
-            double arg1 = Static.getNumber(args[0]);
-            double arg2 = Static.getNumber(args[1]);
-            return new CBoolean(arg1 <= arg2, line_num, f);
-        }
-        
-        public ExceptionType[] thrown(){
-            return new ExceptionType[]{ExceptionType.CastException};
-        }
-
-        public String docs() {
-            return "boolean {var1, var2} Returns the result of a less than or equal to operation";
-        }
-
-        public boolean isRestricted() {
-            return false;
-        }
-
-        public void varList(IVariableList varList) {}
-
-        public boolean preResolveVariables() {
-            return true;
-        }
-        public String since() {
-            return "3.0.1";
-        }
-        public Boolean runAsync() {
-            return null;
-        }
-    }
-    
-    @api public static class gte implements Function{
-
-        public String getName() {
-            return "gte";
-        }
-
-        public Integer[] numArgs() {
-            return new Integer[]{2};
-        }
-
-        public Construct exec(int line_num, File f, CommandSender p, Construct... args) throws CancelCommandException, ConfigRuntimeException {
-            double arg1 = Static.getNumber(args[0]);
-            double arg2 = Static.getNumber(args[1]);
-            return new CBoolean(arg1 >= arg2, line_num, f);
-        }
-        
-        public ExceptionType[] thrown(){
-            return new ExceptionType[]{ExceptionType.CastException};
-        }
-
-        public String docs() {
-            return "boolean {var1, var2} Returns the result of a greater than or equal to operation";
-        }
-
-        public boolean isRestricted() {
-            return false;
-        }
-
-        public void varList(IVariableList varList) {}
-
-        public boolean preResolveVariables() {
-            return true;
-        }
-        public String since() {
-            return "3.0.1";
-        }
-        public Boolean runAsync() {
-            return null;
-        }
-    }
-    
-    @api public static class and implements Function{
-
-        public String getName() {
-            return "and";
-        }
-
-        public Integer[] numArgs() {
-            return new Integer[]{Integer.MAX_VALUE};
-        }
-
-        public Construct exec(int line_num, File f, CommandSender p, Construct... args) throws CancelCommandException, ConfigRuntimeException {
-            for(Construct c : args){
-                boolean b = Static.getBoolean(c);
-                if(b == false){
-                    return new CBoolean(false, line_num, f);
-                }
-            }
-            return new CBoolean(true, line_num, f);
-        }
-        
-        public ExceptionType[] thrown(){
-            return new ExceptionType[]{ExceptionType.CastException};
-        }
-
-        public String docs() {
-            return "boolean {var1, [var2...]} Returns the boolean value of a logical AND across all arguments. Uses lazy determination, so once "
-                    + "an argument returns false, the function returns.";
-        }
-
-        public boolean isRestricted() {
-            return false;
-        }
-
-        public void varList(IVariableList varList) {}
-
-        public boolean preResolveVariables() {
-            return true;
-        }
-        public String since() {
-            return "3.0.1";
-        }
-        public Boolean runAsync() {
-            return null;
-        }
-    }
-    
-    @api public static class or implements Function{
-
-        public String getName() {
-            return "or";
-        }
-
-        public Integer[] numArgs() {
-            return new Integer[]{Integer.MAX_VALUE};
-        }
-
-        public Construct exec(int line_num, File f, CommandSender p, Construct... args) throws CancelCommandException, ConfigRuntimeException {
-            for(Construct c : args){
-                if(Static.getBoolean(c)){
-                    return new CBoolean(true, line_num, f);
-                }
-            }
-            return new CBoolean(false, line_num, f);
-        }
-        
-        public ExceptionType[] thrown(){
-            return new ExceptionType[]{ExceptionType.CastException};
-        }
-
-        public String docs() {
-            return "boolean {var1, [var2...]} Returns the boolean value of a logical OR across all arguments. Uses lazy determination, so once an "
-                    + "argument resolves to true, the function returns.";
-        }
-
-        public boolean isRestricted() {
-            return false;
-        }
-
-        public void varList(IVariableList varList) {}
-
-        public boolean preResolveVariables() {
-            return true;
-        }
-        public String since() {
-            return "3.0.1";
-        }
-        public Boolean runAsync() {
-            return null;
-        }
-    }
-    
-    @api public static class not implements Function{
-
-        public String getName() {
-            return "not";
-        }
-
-        public Integer[] numArgs() {
-            return new Integer[]{1};
-        }
-
-        public Construct exec(int line_num, File f, CommandSender p, Construct... args) throws CancelCommandException, ConfigRuntimeException {
-            return new CBoolean(!Static.getBoolean(args[0]), line_num, f);
-        }
-        
-        public ExceptionType[] thrown(){
-            return new ExceptionType[]{ExceptionType.CastException};
-        }
-
-        public String docs() {
-            return "boolean {var1} Returns the boolean value of a logical NOT for this argument";
-        }
-
-        public boolean isRestricted() {
-            return false;
-        }
-
-        public void varList(IVariableList varList) {}
-
-        public boolean preResolveVariables() {
-            return true;
-        }
-        public String since() {
-            return "3.0.1";
-        }
-        public Boolean runAsync() {
-            return null;
-        }
-    }
-    
-    
-}
diff --git a/src/main/java/com/laytonsmith/aliasengine/functions/ClassDiscovery.java b/src/main/java/com/laytonsmith/aliasengine/functions/ClassDiscovery.java
deleted file mode 100644
index fb3e32a..0000000
--- a/src/main/java/com/laytonsmith/aliasengine/functions/ClassDiscovery.java
+++ /dev/null
@@ -1,284 +0,0 @@
-/*
- * To change this template, choose Tools | Templates
- * and open the template in the editor.
- */
-package com.laytonsmith.aliasengine.functions;
-
-import java.io.*;
-import java.util.*;
-import java.util.jar.JarEntry;
-import java.util.jar.JarFile;
-import java.util.regex.Pattern;
-
-public class ClassDiscovery {
-
-    static private String GetClassName_afterPackageAsPath(
-            final String pFileName,
-            final String pPkgAsPath) {
-        final String CName = pFileName.substring(0, pFileName.length() - 6).replace('/', '.').replace('\\', '.');
-        final String CName_AfterPackageAsPath = CName.substring(pPkgAsPath.length());
-        return CName_AfterPackageAsPath;
-    }
-
-    static private String GetClassName_ofPackageAsPath(
-            final String pFileName,
-            final String pPkgAsPath) {
-
-        final boolean aIsClass = pFileName.endsWith(".class");
-        if (!aIsClass) {
-            return null;
-        }
-
-        final boolean aIsBelongToPackage = pFileName.startsWith(pPkgAsPath);
-        if (!aIsBelongToPackage) {
-            return null;
-        }
-
-        final String aClassName = ClassDiscovery.GetClassName_afterPackageAsPath(pFileName, pPkgAsPath);
-        return aClassName;
-    }
-
-    static private File GetPackageFile(
-            final String pPkgName,
-            final File pPkgPath) {
-
-        final String aPkgFileName = pPkgPath.getAbsoluteFile().toString() + '/' + pPkgName.replace('.', '/');
-        final File aPkgFile = new File(aPkgFileName);
-
-        final boolean aIsExist = aPkgFile.exists();
-        final boolean aIsDirectory = aPkgFile.isDirectory();
-        final boolean aIsExist_asDirectory = aIsExist && aIsDirectory;
-        if (!aIsExist_asDirectory) {
-            return null;
-        }
-
-        return aPkgFile;
-    }
-
-    static private boolean Check_isJarFile(final File pFile) {
-        final boolean aIsJarFile = pFile.toString().endsWith(".jar");
-        return aIsJarFile;
-    }
-
-    static private ArrayList<String> DiscoverClassNames_fromJarFile(final PkgInfo pPkgInfo) {
-
-        final ArrayList<String> aClassNames = new ArrayList<String>();
-        try {
-            final JarFile JF = new JarFile(pPkgInfo.PkgPath);
-            final Enumeration<JarEntry> JEs = JF.entries();
-
-            while (JEs.hasMoreElements()) {
-                final JarEntry aJE = JEs.nextElement();
-                final String aJEName = aJE.getName();
-
-                final String aSimpleName = GetClassName_ofPackageAsPath(aJEName, pPkgInfo.PkgAsPath);
-                if (aSimpleName == null) {
-                    continue;
-                }
-
-                final String aClassName = pPkgInfo.PkgName + '.' + aSimpleName;
-                aClassNames.add(aClassName);
-            }
-
-            JF.close();
-        } catch (IOException e) {
-        }
-
-        return aClassNames;
-    }
-
-    static private void DiscoverClassNames_fromDirectory(
-            final String pAbsolutePackagePath,
-            final String pPackageName,
-            final File pPackageFolder,
-            final ArrayList<String> pClassNames) {
-        final File[] aFiles = pPackageFolder.listFiles();
-        for (File aFile : aFiles) {
-            if (aFile.isDirectory()) {
-                DiscoverClassNames_fromDirectory(pAbsolutePackagePath, pPackageName, aFile, pClassNames);
-                continue;
-            }
-
-            final String aFileName = aFile.getAbsolutePath().substring(pAbsolutePackagePath.length() + 1);
-            final boolean aIsClassFile = aFileName.endsWith(".class");
-            if (!aIsClassFile) {
-                continue;
-            }
-
-            final String aSimpleName = aFileName.substring(0, aFileName.length() - 6).replace('/', '.').replace('\\', '.');
-            final String aClassName = pPackageName + '.' + aSimpleName;
-            pClassNames.add(aClassName);
-        }
-    }
-
-    static private ArrayList<String> DiscoverClassNames_fromDirectory(PkgInfo pPkgInfo) {
-
-        final ArrayList<String> aClassNames = new ArrayList<String>();
-        final File aPkgFile = ClassDiscovery.GetPackageFile(pPkgInfo.PkgName, pPkgInfo.PkgPath);
-        if (aPkgFile == null) {
-            return aClassNames;
-        }
-
-        DiscoverClassNames_fromDirectory(aPkgFile.getAbsolutePath(), pPkgInfo.PkgName, aPkgFile, aClassNames);
-        return aClassNames;
-    }
-
-    static public class PkgInfo {
-
-        PkgInfo(
-                final File pPkgPath,
-                final String pPkgName,
-                final String pPkgAsPath) {
-
-            this.PkgPath = pPkgPath;
-            this.PkgName = pPkgName;
-            this.PkgAsPath = pPkgAsPath;
-        }
-        final File PkgPath;
-        final String PkgName;
-        final String PkgAsPath;
-    }
-
-    static public PkgInfo GetPackageInfoOf(Class<?> pClass) {
-        File aPkgPath = null;
-        String aPkgName = null;
-        String aPkgAsPath = null;
-
-        try {
-            aPkgPath = new File(pClass.getProtectionDomain().getCodeSource().getLocation().toURI());
-            aPkgName = pClass.getPackage().getName();
-            aPkgAsPath = aPkgName.replace('.', '/') + '/';
-        } catch (Throwable e) {
-        }
-
-        if (aPkgPath == null) {
-            return null;
-        }
-
-        final PkgInfo aPkgInfo = new PkgInfo(aPkgPath, aPkgName, aPkgAsPath);
-        return aPkgInfo;
-    }
-
-    static public ArrayList<String> DiscoverClassNames_inPackage(final PkgInfo pPkgInfo) {
-
-        if (pPkgInfo == null) {
-            return null;
-        }
-
-        ArrayList<String> aClassNames = new ArrayList<String>();
-        if (pPkgInfo.PkgPath.isDirectory()) {
-
-            aClassNames = ClassDiscovery.DiscoverClassNames_fromDirectory(pPkgInfo);
-
-        } else if (pPkgInfo.PkgPath.isFile()) {
-            boolean aIsJarFile = ClassDiscovery.Check_isJarFile(pPkgInfo.PkgPath);
-            if (!aIsJarFile) {
-                return null;
-            }
-
-            aClassNames = ClassDiscovery.DiscoverClassNames_fromJarFile(pPkgInfo);
-        }
-
-        return aClassNames;
-    }
-
-    /**
-     * Returns an array of class in the same package as the the SeedClass
-     * 
-     * @param pFilterName     - Regular expression to match the desired classes' name (nullif no filtering needed)
-     * @param pFilterClass   - The super class of the desired classes (null if no filtering needed)
-     * 
-     * @return                - The array of matched classes, null if there is a problem.
-     * 
-     * @author The rest       - Nawaman  http://nawaman.net
-     * @author Package as Dir - Jon Peck http://jonpeck.com
-     *                              (adapted from http://www.javaworld.com/javaworld/javatips/jw-javatip113.html)
-     */
-    @SuppressWarnings("unchecked")
-    public static <T> Class<? extends T>[] DiscoverClasses(
-            final Class<?> pSeedClass,
-            final String pFilterName,
-            final Class<T> pFilterClass) {
-
-        final Pattern aClsNamePattern = (pFilterName == null) ? null : Pattern.compile(pFilterName);
-
-        PkgInfo aPkgInfo = null;
-
-        try {
-            aPkgInfo = GetPackageInfoOf(pSeedClass);
-        } catch (Throwable e) {
-        }
-
-        if (aPkgInfo == null) {
-            return null;
-        }
-
-        final ArrayList<String> aClassNames = DiscoverClassNames_inPackage(aPkgInfo);
-
-        if (aClassNames == null) {
-            return null;
-        }
-
-        if (aClassNames.size() == 0) {
-            return null;
-        }
-
-        final ArrayList<Class<?>> aClasses = new ArrayList<Class<?>>();
-        for (final String aClassName : aClassNames) {
-
-            if ((aClsNamePattern != null) && !aClsNamePattern.matcher(aClassName).matches()) {
-                continue;
-            }
-
-            // Get the class and filter it
-            Class<?> aClass = null;
-            try {
-                aClass = Class.forName(aClassName);
-            } catch (ClassNotFoundException e) {
-                continue;
-            } catch (NoClassDefFoundError e) {
-                continue;
-            }
-
-            if ((pFilterClass != null) && !pFilterClass.isAssignableFrom(aClass)) {
-                continue;
-            }
-
-            if (pFilterClass != null) {
-                if (!pFilterClass.isAssignableFrom(aClass)) {
-                    continue;
-                }
-
-                aClasses.add(aClass.asSubclass(pFilterClass));
-            } else {
-                aClasses.add(aClass);
-            }
-        }
-
-        Class<? extends T>[] aClassesArray = aClasses.toArray((Class<? extends T>[]) (new Class[aClasses.size()]));
-
-        return aClassesArray;
-    }
-
-    static public void main(String... pArgs) {
-        Class<?> aSeedClass = ClassDiscovery.class;
-        try {
-            aSeedClass = Class.forName(pArgs[0]);
-        } catch (Exception E) {
-        }
-
-        if (aSeedClass == null) {
-            aSeedClass = ClassDiscovery.class;
-        }
-
-        final Class<?>[] aClasses = DiscoverClasses(aSeedClass, null, null);
-
-        System.out.println("[");
-        if (aClasses != null) {
-            for (Class aClass : aClasses) {
-                System.out.println("\t" + aClass);
-            }
-        }
-        System.out.println("]");
-    }
-}
diff --git a/src/main/java/com/laytonsmith/aliasengine/functions/DataHandling.java b/src/main/java/com/laytonsmith/aliasengine/functions/DataHandling.java
deleted file mode 100644
index 5137aef..0000000
--- a/src/main/java/com/laytonsmith/aliasengine/functions/DataHandling.java
+++ /dev/null
@@ -1,912 +0,0 @@
-/*
- * To change this template, choose Tools | Templates
- * and open the template in the editor.
- */
-package com.laytonsmith.aliasengine.functions;
-
-import com.laytonsmith.aliasengine.GenericTreeNode;
-import com.laytonsmith.aliasengine.functions.exceptions.CancelCommandException;
-import com.laytonsmith.aliasengine.functions.exceptions.ConfigRuntimeException;
-import com.laytonsmith.aliasengine.Constructs.CArray;
-import com.laytonsmith.aliasengine.Constructs.CBoolean;
-import com.laytonsmith.aliasengine.Constructs.CNull;
-import com.laytonsmith.aliasengine.Constructs.CVoid;
-import com.laytonsmith.aliasengine.Constructs.Construct;
-import com.laytonsmith.aliasengine.Constructs.IVariable;
-import com.laytonsmith.aliasengine.Procedure;
-import com.laytonsmith.aliasengine.functions.exceptions.LoopBreakException;
-import com.laytonsmith.aliasengine.functions.exceptions.LoopContinueException;
-import com.laytonsmith.aliasengine.Script;
-import com.laytonsmith.aliasengine.Static;
-import com.laytonsmith.aliasengine.functions.Exceptions.ExceptionType;
-import com.laytonsmith.aliasengine.functions.exceptions.FunctionReturnException;
-import java.io.File;
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.HashMap;
-import java.util.List;
-import java.util.Map;
-import org.bukkit.command.CommandSender;
-
-/**
- *
- * @author Layton
- */
-public class DataHandling {
-    public static String docs(){
-        return "This class provides various methods to control script data and program flow.";
-    }
-    @api public static class array implements Function{
-
-        public String getName() {
-            return "array";
-        }
-
-        public Integer[] numArgs() {
-            return new Integer[]{Integer.MAX_VALUE};
-        }
-
-        public Construct exec(int line_num, File f, CommandSender p, Construct... args) throws CancelCommandException, ConfigRuntimeException {
-            return new CArray(line_num, f, args);
-        }
-        
-        public ExceptionType[] thrown(){
-            return new ExceptionType[]{};
-        }
-
-        public String docs() {
-            return "array {[var1, [var2...]]} Creates an array of values.";
-        }
-
-        public boolean isRestricted() {
-            return false;
-        }
-
-        public void varList(IVariableList varList) {}
-
-        public boolean preResolveVariables() {
-            return true;
-        }
-        public String since() {
-            return "3.0.1";
-        }
-        public Boolean runAsync() {
-            return null;
-        }
-    }
-    
-    @api public static class assign implements Function{
-        IVariableList varList;
-        public String getName() {
-            return "assign";
-        }
-
-        public Integer[] numArgs() {
-            return new Integer[]{2};
-        }
-
-        public Construct exec(int line_num, File f, CommandSender p, Construct... args) throws CancelCommandException, ConfigRuntimeException {
-            Construct c = args[1];
-            while(c instanceof IVariable){
-                c = varList.get(((IVariable)c).getName()).ival();
-            }
-            if(args[0] instanceof IVariable){
-                IVariable v = new IVariable(((IVariable)args[0]).getName(), c, line_num, f);
-                varList.set(v);
-                return v;
-            }
-            throw new ConfigRuntimeException("assign only accepts an ivariable as the first argument", ExceptionType.CastException, line_num, f);
-        }
-        
-        public ExceptionType[] thrown(){
-            return new ExceptionType[]{ExceptionType.CastException};
-        }
-
-        public String docs() {
-            return "ivariable {ivar, mixed} Accepts an ivariable ivar as a parameter, and puts the specified value mixed in it. Returns the variable that was assigned.";
-        }
-
-        public boolean isRestricted() {
-            return false;
-        }
-
-        public void varList(IVariableList varList) {
-            this.varList = varList;
-        }
-
-        public boolean preResolveVariables() {
-            return false;
-        }
-        public String since() {
-            return "3.0.1";
-        }
-        public Boolean runAsync() {
-            return null;
-        }
-    }
-    
-    @api public static class _for implements Function{
-        IVariableList varList;
-        public String getName() {
-            return "for";
-        }
-
-        public Integer[] numArgs() {
-            return new Integer[]{4};
-        }
-        public Construct execs(int line_num, File f, CommandSender p, Script parent, GenericTreeNode<Construct> assign, 
-                GenericTreeNode<Construct> condition, GenericTreeNode<Construct> expression, 
-                GenericTreeNode<Construct> runnable) throws CancelCommandException{
-            Construct counter = parent.eval(assign, p);
-            if(!(counter instanceof IVariable)){
-                throw new ConfigRuntimeException("First parameter of for must be an ivariable", ExceptionType.CastException, line_num, f);
-            }
-            int _continue = 0;
-            while(true){
-                Construct cond = Static.resolveConstruct(parent.eval(condition, p).val(), line_num, f);
-                if(!(cond instanceof CBoolean)){
-                    throw new ConfigRuntimeException("Second parameter of for must return a boolean", ExceptionType.CastException, line_num, f);
-                }
-                CBoolean bcond = ((CBoolean) cond);
-                if(bcond.getBoolean() == false){
-                    break;
-                }
-                if(_continue >= 1){
-                    --_continue;                    
-                    parent.eval(expression, p);
-                    continue;
-                }
-                try{
-                    Static.resolveConstruct(parent.eval(runnable, p).val(), line_num, f);
-                } catch(LoopBreakException e){
-                    int num = e.getTimes();
-                    if(num > 1){
-                        e.setTimes(--num);
-                        throw e;
-                    }
-                    return new CVoid(line_num, f);
-                } catch(LoopContinueException e){
-                    _continue = e.getTimes() - 1;                    
-                    parent.eval(expression, p);
-                    continue;
-                }
-                parent.eval(expression, p);
-            }
-            return new CVoid(line_num, f);
-        }
-        public ExceptionType[] thrown(){
-            return new ExceptionType[]{ExceptionType.CastException};
-        }
-        public Construct exec(int line_num, File f, CommandSender p, Construct... args) throws CancelCommandException, ConfigRuntimeException {
-            return null;
-        }
-
-        public String docs() {
-            return "void {assign, condition, expression1, expression2} Acts as a typical for loop. The assignment is first run. Then, a"
-                    + " condition is checked. If that condition is checked and returns true, expression2 is run. After that, expression1 is run. In java"
-                    + " syntax, this would be: for(assign; condition; expression1){expression2}. assign must be an ivariable, either a "
-                    + "pre defined one, or the results of the assign() function. condition must be a boolean.";
-        }
-
-        public boolean isRestricted() {
-            return false;
-        }
-
-        public void varList(IVariableList varList) {
-            this.varList = varList;
-        }
-
-        public boolean preResolveVariables() {
-            return false;
-        }
-        public String since() {
-            return "3.0.1";
-        }
-        //Doesn't matter, run out of state
-        public Boolean runAsync() {
-            return null;
-        }
-    }
-    
-    @api public static class foreach implements Function{
-        IVariableList varList;
-        public String getName() {
-            return "foreach";
-        }
-
-        public Integer[] numArgs() {
-            return new Integer[]{3};
-        }
-
-        public Construct exec(int line_num, File f, CommandSender p, Construct... args) throws CancelCommandException, ConfigRuntimeException {
-            return new CVoid(line_num, f);
-        }
-        
-        public Construct execs(int line_num, File f, CommandSender p, Script that, GenericTreeNode<Construct> array, 
-                GenericTreeNode<Construct> ivar, GenericTreeNode<Construct> code) throws CancelCommandException{
-            
-            Construct arr = that.eval(array, p);
-            if(arr instanceof IVariable){
-                arr = varList.get(((IVariable)arr).getName()).ival();
-            }
-            Construct iv = that.eval(ivar, p);
-            
-            if(arr instanceof CArray){
-                if(iv instanceof IVariable){
-                    CArray one = (CArray)arr;
-                    IVariable two = (IVariable)iv;
-                    for(int i = 0; i < one.size(); i++){
-                        varList.set(new IVariable(two.getName(), one.get(i, line_num), line_num, f));
-                        try{
-                            that.eval(code, p);
-                        } catch(LoopBreakException e){
-                            int num = e.getTimes();
-                            if(num > 1){
-                                e.setTimes(--num);
-                                throw e;
-                            }
-                            return new CVoid(line_num, f);
-                        } catch(LoopContinueException e){
-                            i += e.getTimes() - 1;
-                            continue;
-                        }
-                    }
-                } else {
-                    throw new ConfigRuntimeException("Parameter 2 of foreach must be an ivariable", ExceptionType.CastException, line_num, f);
-                }
-            } else {
-                throw new ConfigRuntimeException("Parameter 1 of foreach must be an array", ExceptionType.CastException, line_num, f);
-            }
-            
-            return new CVoid(line_num, f);
-        }
-        
-        public ExceptionType[] thrown(){
-            return new ExceptionType[]{ExceptionType.CastException};
-        }
-
-        public String docs() {
-            return "void {array, ivar, code} Walks through array, setting ivar equal to each element in the array, then running code.";
-        }
-
-        public boolean isRestricted() {
-            return false;
-        }
-
-        public void varList(IVariableList varList) {
-            this.varList = varList;
-        }
-
-        public boolean preResolveVariables() {
-            return false;
-        }
-        public String since() {
-            return "3.0.1";
-        }
-        //Doesn't matter, runs out of state anyways
-        public Boolean runAsync(){
-            return null;
-        }
-    }
-    
-    @api public static class _break implements Function{
-
-        public String getName() {
-            return "break";
-        }
-
-        public Integer[] numArgs() {
-            return new Integer[]{0,1};
-        }
-
-        public String docs() {
-            return "nothing {[int]} Stops the current loop. If int is specified, and is greater than 1, the break travels that many loops up. So, if you had"
-                    + " a loop embedded in a loop, and you wanted to break in both loops, you would call break(2). If this function is called outside a loop"
-                    + " (or the number specified would cause the break to travel up further than any loops are defined), the function will fail. If no"
-                    + " argument is specified, it is the same as calling break(1).";
-        }
-        
-        public ExceptionType[] thrown(){
-            return new ExceptionType[]{ExceptionType.CastException};
-        }
-
-        public boolean isRestricted() {
-            return false;
-        }
-
-        public void varList(IVariableList varList) {}
-
-        public boolean preResolveVariables() {
-            return true;
-        }
-
-        public String since() {
-            return "3.1.0";
-        }
-
-        public Boolean runAsync() {
-            return null;
-        }
-
-        public Construct exec(int line_num, File f, CommandSender p, Construct... args) throws CancelCommandException, ConfigRuntimeException {
-            int num = 1;
-            if(args.length == 1){
-                num = (int)Static.getInt(args[0]);
-            }
-            throw new LoopBreakException(num);
-        }
-        
-    }
-    
-    @api public static class _continue implements Function{
-
-        public String getName() {
-            return "continue";
-        }
-
-        public Integer[] numArgs() {
-            return new Integer[]{0, 1};
-        }
-
-        public String docs() {
-            return "void {[int]} Skips the rest of the code in this loop, and starts the loop over, with it continuing at the next index. If this function"
-                    + " is called outside of a loop, the command will fail. If int is set, it will skip 'int' repetitions. If no argument is specified,"
-                    + " 1 is used.";
-        }
-        
-        public ExceptionType[] thrown(){
-            return new ExceptionType[]{ExceptionType.CastException};
-        }
-
-        public boolean isRestricted() {
-            return false;
-        }
-
-        public void varList(IVariableList varList) {}
-
-        public boolean preResolveVariables() {
-            return true;
-        }
-
-        public String since() {
-            return "3.1.0";
-        }
-
-        public Boolean runAsync() {
-            return null;
-        }
-
-        public Construct exec(int line_num, File f, CommandSender p, Construct... args) throws CancelCommandException, ConfigRuntimeException {
-            int num = 1;
-            if(args.length == 1){
-                num = (int)Static.getInt(args[0]);
-            }
-            throw new LoopContinueException(num);
-        }
-        
-    }
-    
-    @api public static class is_string implements Function{
-
-        public String getName() {
-            return "is_string";
-        }
-
-        public Integer[] numArgs() {
-            return new Integer[]{1};
-        }
-
-        public String docs() {
-            return "boolean {item} Returns whether or not the item is a string. Everything but arrays can be used as strings.";
-        }
-
-        public ExceptionType[] thrown() {
-            return null;
-        }
-
-        public boolean isRestricted() {
-            return false;
-        }
-
-        public void varList(IVariableList varList) {}
-
-        public boolean preResolveVariables() {
-            return true;
-        }
-
-        public String since() {
-            return "3.1.2";
-        }
-
-        public Boolean runAsync() {
-            return null;
-        }
-
-        public Construct exec(int line_num, File f, CommandSender p, Construct... args) throws ConfigRuntimeException {
-            return new CBoolean(!(args[0] instanceof CArray), line_num, f);
-        }
-        
-    }
-    
-    @api public static class is_array implements Function{
-
-        public String getName() {
-            return "is_array";
-        }
-
-        public Integer[] numArgs() {
-            return new Integer[]{1};
-        }
-
-        public String docs() {
-            return "boolean {item} Returns whether or not the item is an array";
-        }
-
-        public ExceptionType[] thrown() {
-            return null;
-        }
-
-        public boolean isRestricted() {
-            return false;
-        }
-
-        public void varList(IVariableList varList) {}
-
-        public boolean preResolveVariables() {
-            return true;
-        }
-
-        public String since() {
-            return "3.1.2";
-        }
-
-        public Boolean runAsync() {
-            return null;
-        }
-
-        public Construct exec(int line_num, File f, CommandSender p, Construct... args) throws ConfigRuntimeException {
-            return new CBoolean(args[0] instanceof CArray, line_num, f);
-        }
-        
-    }
-    
-    @api public static class is_double implements Function{
-
-        public String getName() {
-            return "is_double";
-        }
-
-        public Integer[] numArgs() {
-            return new Integer[]{1};
-        }
-
-        public String docs() {
-            return "boolean {item} Returns whether or not the given item is a double. Note that a numeric string will return true, and so"
-                    + " will integers.";
-        }
-
-        public ExceptionType[] thrown() {
-            return null;
-        }
-
-        public boolean isRestricted() {
-            return false;
-        }
-
-        public void varList(IVariableList varList) {}
-
-        public boolean preResolveVariables() {
-            return true;
-        }
-
-        public String since() {
-            return "3.1.2";
-        }
-
-        public Boolean runAsync() {
-            return null;
-        }
-
-        public Construct exec(int line_num, File f, CommandSender p, Construct... args) throws ConfigRuntimeException {
-            boolean b = true;
-            try{
-                Static.getDouble(args[0]);
-            } catch(ConfigRuntimeException e){
-                b = false;
-            }
-            return new CBoolean(b, line_num, f);
-        }
-        
-    }
-    
-    @api public static class is_integer implements Function{
-
-        public String getName() {
-            return "is_integer";
-        }
-
-        public Integer[] numArgs() {
-            return new Integer[]{1};
-        }
-
-        public String docs() {
-            return "boolean {item} Returns whether or not the given item is an integer. Note that numeric strings can be used as integers.";
-        }
-
-        public ExceptionType[] thrown() {
-            return null;
-        }
-
-        public boolean isRestricted() {
-            return false;
-        }
-
-        public void varList(IVariableList varList) {}
-
-        public boolean preResolveVariables() {
-            return true;
-        }
-
-        public String since() {
-            return "3.1.2";
-        }
-
-        public Boolean runAsync() {
-            return null;
-        }
-
-        public Construct exec(int line_num, File f, CommandSender p, Construct... args) throws ConfigRuntimeException {
-            boolean b = true;
-            try{
-                Static.getInt(args[0]);
-            } catch(ConfigRuntimeException e){
-                b = false;
-            }
-            return new CBoolean(b, line_num, f);
-        }
-        
-    }
-    
-    @api public static class is_boolean implements Function{
-
-        public String getName() {
-            return "is_boolean";
-        }
-
-        public Integer[] numArgs() {
-            return new Integer[]{1};
-        }
-
-        public String docs() {
-            return "boolean {item} Returns whether the given item is a boolean. Note that all datatypes can be used as booleans, however"
-                    + " null and arrays always return false. Essentially, this mean that this function ALWAYS returns true. Really, you"
-                    + " probably shouldn't ever use it.";
-        }
-
-        public ExceptionType[] thrown() {
-            return null;
-        }
-
-        public boolean isRestricted() {
-            return false;
-        }
-
-        public void varList(IVariableList varList) {}
-
-        public boolean preResolveVariables() {
-            return true;
-        }
-
-        public String since() {
-            return "3.1.2";
-        }
-
-        public Boolean runAsync() {
-            return null;
-        }
-
-        public Construct exec(int line_num, File f, CommandSender p, Construct... args) throws ConfigRuntimeException {
-            return new CBoolean(true, line_num, f);
-        }
-        
-    }
-    
-    @api public static class is_null implements Function{
-
-        public String getName() {
-            return "is_null";
-        }
-
-        public Integer[] numArgs() {
-            return new Integer[]{1};
-        }
-
-        public String docs() {
-            return "boolean {item} Returns whether or not the given item is null.";
-        }
-
-        public ExceptionType[] thrown() {
-            return null;
-        }
-
-        public boolean isRestricted() {
-            return false;
-        }
-
-        public void varList(IVariableList varList) {}
-
-        public boolean preResolveVariables() {
-            return true;
-        }
-
-        public String since() {
-            return "3.1.2";
-        }
-
-        public Boolean runAsync() {
-            return null;
-        }
-
-        public Construct exec(int line_num, File f, CommandSender p, Construct... args) throws ConfigRuntimeException {
-            return new CBoolean(args[0] instanceof CNull, line_num, f);
-        }
-        
-    }
-    //TODO: proc
-    @api public static class proc implements Function{
-        
-        IVariableList varList;
-
-        public String getName() {
-            return "proc";
-        }
-
-        public Integer[] numArgs() {
-            return new Integer[]{Integer.MAX_VALUE};
-        }
-
-        public String docs() {
-            return "void {[name], [ivar...], procCode} Creates a new user defined procedure (also known as \"function\") that can be called later in code. Please see the more detailed"
-                    + " documentation on procedures for more information.";
-        }
-
-        public ExceptionType[] thrown() {
-            return new ExceptionType[]{ExceptionType.FormatException};
-        }
-
-        public boolean isRestricted() {
-            return true;
-        }
-
-        public void varList(IVariableList varList) {
-            this.varList = varList;
-        }
-
-        public boolean preResolveVariables() {
-            return false;
-        }
-
-        public String since() {
-            return "3.1.3";
-        }
-
-        public Boolean runAsync() {
-            return null;
-        }
-        
-        
-
-        public Construct exec(int line_num, File f, CommandSender p, Construct... args) throws ConfigRuntimeException {
-            return new CVoid(line_num, f);
-        }
-        
-    }
-    //TODO: proc
-    @api public static class _return implements Function{
-
-        public String getName() {
-            return "return";
-        }
-
-        public Integer[] numArgs() {
-            return new Integer[]{0, 1};
-        }
-
-        public String docs() {
-            return "nothing {mixed} Returns the specified value from this procedure. It cannot be called outside a procedure.";
-        }
-
-        public ExceptionType[] thrown() {
-            return null;
-        }
-
-        public boolean isRestricted() {
-            return false;
-        }
-
-        public void varList(IVariableList varList) {}
-
-        public boolean preResolveVariables() {
-            return true;
-        }
-
-        public String since() {
-            return "3.2.0";
-        }
-
-        public Boolean runAsync() {
-            return null;
-        }
-
-        public Construct exec(int line_num, File f, CommandSender p, Construct... args) throws ConfigRuntimeException {
-            Construct ret = (args.length == 1?args[0]:new CVoid(line_num, f));
-            throw new FunctionReturnException(ret);
-        }
-        
-    }
-    
-    //TODO: proc
-    @api public static class include implements Function{
-
-        public String getName() {
-            return "include";
-        }
-
-        public Integer[] numArgs() {
-            return new Integer[]{1};
-        }
-
-        public String docs() {
-            return "void {path} Includes external code at the specified path.";
-        }
-
-        public ExceptionType[] thrown() {
-            return new ExceptionType[]{ExceptionType.IncludeException};
-        }
-
-        public boolean isRestricted() {
-            return true;
-        }
-
-        public void varList(IVariableList varList) {}
-
-        public boolean preResolveVariables() {
-            return true;
-        }
-
-        public String since() {
-            return "3.2.0";
-        }
-
-        public Boolean runAsync() {
-            return true;
-        }
-
-        public Construct exec(int line_num, File f, CommandSender p, Construct... args) throws ConfigRuntimeException {
-            return new CVoid(line_num, f);
-        }
-        
-        public Construct execs(int line_num, File f, CommandSender p, List<GenericTreeNode<Construct>> children, Script parent){
-            GenericTreeNode<Construct> tree = children.get(0);
-            Construct arg = parent.eval(tree, p);
-            arg = parent.preResolveVariables(new Construct[]{arg})[0];
-            String location = arg.val();
-            GenericTreeNode<Construct> include = IncludeCache.get(new File(location), line_num, f);
-            parent.eval(include.getChildAt(0), p);
-            return new CVoid(line_num, f);
-        }
-        
-    }
-    
-    //TODO: proc
-    @api public static class call_proc implements Function{
-
-        public String getName() {
-            return "call_proc";
-        }
-
-        public Integer[] numArgs() {
-            return new Integer[]{Integer.MAX_VALUE};
-        }
-
-        public String docs() {
-            return "mixed {proc_name, [var1...]} Dynamically calls a user defined procedure. call_proc(_myProc, 'var1') is the equivalent of"
-                    + " _myProc('var1'), except you could dynamically build the procedure name if need be. This is useful for having callbacks"
-                    + " in procedures. Throws an InvalidProcedureException if the procedure isn't defined.";
-        }
-
-        public ExceptionType[] thrown() {
-            return new ExceptionType[]{ExceptionType.InvalidProcedureException};
-        }
-
-        public boolean isRestricted() {
-            return true;
-        }
-
-        public void varList(IVariableList varList) {}
-
-        public boolean preResolveVariables() {
-            return true;
-        }
-
-        public String since() {
-            return "3.2.0";
-        }
-
-        public Boolean runAsync() {
-            return null;
-        }
-
-        public Construct exec(int line_num, File f, CommandSender p, Construct... args) throws ConfigRuntimeException {
-            return new CVoid(line_num, f);
-        }
-        
-        public Construct execs(int line_num, File f, CommandSender p, Map<String, Procedure> procs, String label, Construct ... args){
-            Procedure proc = procs.get(args[0].val());
-            if(proc != null){
-                List<Construct> vars = new ArrayList<Construct>(Arrays.asList(args));
-                vars.remove(0);                
-                return proc.execute(vars, p, new HashMap<String, Procedure>(procs), label);
-            }            
-            throw new ConfigRuntimeException("Unknown procedure \"" + args[0].val() + "\"", 
-                    ExceptionType.InvalidProcedureException, line_num, f);
-        }
-        
-    }
-    
-    //TODO: proc
-    @api public static class is_proc implements Function{
-
-        public String getName() {
-            return "is_proc";
-        }
-
-        public Integer[] numArgs() {
-            return new Integer[]{1};
-        }
-
-        public String docs() {
-            return "boolean {procName} Returns whether or not the given procName is currently defined, i.e. if calling this proc wouldn't"
-                    + " throw an exception.";
-        }
-
-        public ExceptionType[] thrown() {
-            return null;
-        }
-
-        public boolean isRestricted() {
-            return true;
-        }
-
-        public void varList(IVariableList varList) {}
-
-        public boolean preResolveVariables() {
-            return true;
-        }
-
-        public String since() {
-            return "3.2.0";
-        }
-
-        public Boolean runAsync() {
-            return null;
-        }
-
-        public Construct exec(int line_num, File f, CommandSender p, Construct... args) throws ConfigRuntimeException {
-            return new CVoid(line_num, f);
-        }
-        
-        public Construct execs(int line_num, File f, CommandSender p, List<Procedure> procs, Construct ... args){
-            for(Procedure proc : procs){
-                if(proc.getName().equals(args[0].val())){
-                    return new CBoolean(true, line_num, f);
-                }
-            }
-            return new CBoolean(false, line_num, f);
-        }
-        
-    }
-    
-    
-    
-}
diff --git a/src/main/java/com/laytonsmith/aliasengine/functions/Echoes.java b/src/main/java/com/laytonsmith/aliasengine/functions/Echoes.java
deleted file mode 100644
index b91686e..0000000
--- a/src/main/java/com/laytonsmith/aliasengine/functions/Echoes.java
+++ /dev/null
@@ -1,433 +0,0 @@
-/*
- * To change this template, choose Tools | Templates
- * and open the template in the editor.
- */
-
-package com.laytonsmith.aliasengine.functions;
-
-import com.laytonsmith.PureUtilities.fileutility.LineCallback;
-import com.laytonsmith.aliasengine.functions.exceptions.ConfigRuntimeException;
-import com.laytonsmith.aliasengine.Constructs.Construct;
-import com.laytonsmith.aliasengine.functions.exceptions.CancelCommandException;
-import com.laytonsmith.aliasengine.Constructs.CNull;
-import com.laytonsmith.aliasengine.Constructs.CString;
-import com.laytonsmith.aliasengine.Constructs.CVoid;
-import com.laytonsmith.aliasengine.Static;
-import com.laytonsmith.aliasengine.functions.Exceptions.ExceptionType;
-import java.io.File;
-import java.util.logging.Level;
-import org.bukkit.ChatColor;
-import org.bukkit.Server;
-import org.bukkit.command.CommandSender;
-import org.bukkit.entity.Player;
-
-/**
- *
- * @author layton
- */
-public class Echoes {
-    public static String docs(){
-        return "These functions allow you to echo information to the screen";
-    }
-    @api public static class die implements Function{
-        public Integer []numArgs() {
-            return new Integer[] {0,1};
-        }
-
-        public Construct exec(int line_num, File f, CommandSender p, Construct... args) throws CancelCommandException{
-            if(args.length == 0){
-                throw new CancelCommandException("");
-            } else if(args.length == 1){
-                try{
-                    Static.SendMessage(p, args[0].val(), line_num, f);
-                } finally{
-                    throw new CancelCommandException("");
-                }
-            } else{
-                return null;
-            }
-        }
-        
-        public ExceptionType[] thrown(){
-            return new ExceptionType[]{};
-        }
-
-        public String getName(){ return "die"; }
-        public String docs(){
-            return "nothing {[var1]} Kills the command immediately, without completing it. A message is optional, but if provided, displayed to the user.";
-        }
-
-        public boolean isRestricted() {
-            return false;
-        }
-
-        public void varList(IVariableList varList) {}
-
-        public boolean preResolveVariables() {
-            return true;
-        }
-        public String since() {
-            return "3.0.1";
-        }
-        public Boolean runAsync(){
-            return false;
-        }
-    }
-    
-    @api public static class msg implements Function{
-
-        public String getName() {
-            return "msg";
-        }
-
-        public Integer[] numArgs() {
-            return new Integer[]{Integer.MAX_VALUE};
-        }
-
-        public Construct exec(int line_num, File f, CommandSender p, Construct... args) throws CancelCommandException, ConfigRuntimeException {
-            StringBuilder b = new StringBuilder();
-            for(int i = 0; i < args.length; i++){
-                b.append(args[i].val());
-            }
-            Static.SendMessage(p, b.toString(), line_num, f);
-//            int start = 0;
-//            String s = b.toString();
-//            while(true){
-//                if(start >= s.length()) break;
-//                p.sendMessage(s.substring(start, start + 100 >= s.length()?s.length():start + 100));
-//                start += 100;
-//            }
-            return new CVoid(line_num, f);
-        }
-        
-        public ExceptionType[] thrown(){
-            return new ExceptionType[]{ExceptionType.PlayerOfflineException};
-        }
-
-        public String docs() {
-            return "void {var1, [var2...]} Echoes a message to the player running the command";
-        }
-
-        public boolean isRestricted() {
-            return false;
-        }
-
-        public void varList(IVariableList varList) {}
-
-        public boolean preResolveVariables() {
-            return true;
-        }
-        public String since() {
-            return "3.0.1";
-        }
-        public Boolean runAsync(){
-            return false;
-        }
-    
-    }
-    
-    @api public static class tmsg implements Function{
-
-        public String getName() {
-            return "tmsg";
-        }
-
-        public Integer[] numArgs() {
-            return new Integer[]{Integer.MAX_VALUE};
-        }
-
-        public Construct exec(int line_num, File f, CommandSender p, Construct... args) throws CancelCommandException, ConfigRuntimeException {
-            if(args.length < 2){
-                throw new ConfigRuntimeException("You must send at least 2 arguments to tmsg", ExceptionType.InsufficientArgumentsException, line_num, f);
-            }
-            p = Static.getServer().getPlayer(args[0].val());
-            if(p == null){
-                throw new ConfigRuntimeException("The player " + args[0].val() + " is not online", ExceptionType.PlayerOfflineException, line_num, f);
-            }
-            StringBuilder b = new StringBuilder();
-            for(int i = 1; i < args.length; i++){
-                b.append(args[i].val());
-            }
-            Static.SendMessage(p, b.toString(), line_num, f);
-//            int start = 0;
-//            String s = b.toString();
-//            while(true){
-//                if(start >= s.length()) break;
-//                p.sendMessage(s.substring(start, start + 100 >= s.length()?s.length():start + 100));
-//                start += 100;
-//            }
-            return new CVoid(line_num, f);
-        }
-
-        public String docs() {
-            return "void {player, msg, [...]} Displays a message on the specified players screen, similar to msg, but targets a specific user.";
-        }
-        public ExceptionType[] thrown(){
-            return new ExceptionType[]{ExceptionType.PlayerOfflineException, ExceptionType.InsufficientArgumentsException};
-        }
-
-        public boolean isRestricted() {
-            return true;
-        }
-
-        public void varList(IVariableList varList) {}
-
-        public boolean preResolveVariables() {
-            return true;
-        }
-        public String since() {
-            return "3.0.1";
-        }
-        public Boolean runAsync(){
-            return false;
-        }
-    }
-    
-    @api public static class color implements Function{
-
-        public String getName() {
-            return "color";
-        }
-
-        public Integer[] numArgs() {
-            return new Integer[]{1};
-        }
-
-        public Construct exec(int line_num, File f, CommandSender p, Construct... args) throws CancelCommandException, ConfigRuntimeException {
-            String color = ChatColor.WHITE.toString();
-            try{
-                color = ChatColor.valueOf(args[0].val().toUpperCase()).toString();
-            } catch(IllegalArgumentException e){}
-            
-            return new CString(color, line_num, f);
-        }
-
-        public String docs() {
-            return "string {name} Returns the color modifier given a color name. If the given color name isn't valid, white is used instead."
-                    + " The list of valid color names can be found in the ChatColor class, and case doesn't matter. For your reference,"
-                    + " here is the list of valid colors: BLACK, DARK_BLUE, DARK_GREEN, DARK_AQUA, DARK_RED, DARK_PURPLE, GOLD GRAY, DARK_GRAY,"
-                    + " BLUE, GREEN, AQUA, RED, LIGHT_PURPLE, YELLOW, WHITE";
-        }
-        
-        public ExceptionType[] thrown(){
-            return new ExceptionType[]{};
-        }
-
-        public boolean isRestricted() {
-            return true;
-        }
-
-        public void varList(IVariableList varList) {}
-
-        public boolean preResolveVariables() {
-            return true;
-        }
-        public String since() {
-            return "3.0.1";
-        }
-        public Boolean runAsync(){
-            return null;
-        }
-    }
-    
-    @api public static class chat implements Function{
-
-        public String getName() {
-            return "chat";
-        }
-
-        public Integer[] numArgs() {
-            return new Integer[]{1};
-        }
-
-        public Construct exec(final int line_num, final File f, final CommandSender p, Construct... args) throws CancelCommandException, ConfigRuntimeException {
-            Static.SendMessage(new LineCallback() {
-
-                public void run(String line) {
-                    if(!(p instanceof Player)){
-                        throw new ConfigRuntimeException("The current player is not online, or this is being run from the console", ExceptionType.PlayerOfflineException, line_num, f);
-                    }
-                    ((Player)p).chat(line);
-                }
-            }, args[0].val());
-
-            return new CVoid(line_num, f);
-        }
-
-        public String docs() {
-            return "void {string} Echoes string to the chat, as if the user simply typed something into the chat bar.";
-        }
-        
-        public ExceptionType[] thrown(){
-            return new ExceptionType[]{ExceptionType.PlayerOfflineException};
-        }
-
-        public boolean isRestricted() {
-            return true;
-        }
-
-        public void varList(IVariableList varList) {}
-
-        public boolean preResolveVariables() {
-            return true;
-        }
-        public String since() {
-            return "3.0.1";
-        }
-        public Boolean runAsync(){
-            return false;
-        }
-        
-    }
-    
-    @api public static class chatas implements Function{
-
-        public String getName() {
-            return "chatas";
-        }
-
-        public Integer[] numArgs() {
-            return new Integer[]{2};
-        }
-
-        public String docs() {
-            return "void {player, msg} Sends a chat message to the server, as the given player. Otherwise the same as the chat"
-                    + " function";
-        }
-        
-        public ExceptionType[] thrown(){
-            return new ExceptionType[]{};
-        }
-
-        public boolean isRestricted() {
-            return true;
-        }
-
-        public void varList(IVariableList varList) {}
-
-        public boolean preResolveVariables() {
-            return true;
-        }
-
-        public String since() {
-            return "3.0.2";
-        }
-
-        public Construct exec(int line_num, File f, CommandSender p, Construct... args) throws CancelCommandException, ConfigRuntimeException {
-            final Player player = Static.getServer().getPlayer(args[0].val());
-            Static.SendMessage(new LineCallback() {
-
-                public void run(String line) {
-                    if(player != null){
-                        player.chat(line);
-                    }
-                }
-            }, args[1].val());
-            
-            return new CVoid(line_num, f);
-        }
-        public Boolean runAsync(){
-            return false;
-        }
-        
-    }
-    
-    @api public static class broadcast implements Function{
-
-        public String getName() {
-            return "broadcast";
-        }
-
-        public Integer[] numArgs() {
-            return new Integer[]{1};
-        }
-
-        public String docs() {
-            return "void {message} Broadcasts a message to all players on the server";
-        }
-        
-        public ExceptionType[] thrown(){
-            return new ExceptionType[]{ExceptionType.CastException};
-        }
-
-        public boolean isRestricted() {
-            return true;
-        }
-
-        public void varList(IVariableList varList) {}
-
-        public boolean preResolveVariables() {
-            return true;
-        }
-
-        public String since() {
-            return "3.0.1";
-        }
-
-        public Construct exec(int line_num, File f, CommandSender p, Construct... args) throws CancelCommandException, ConfigRuntimeException {
-            if(args[0] instanceof CNull){
-                throw new ConfigRuntimeException("Trying to broadcast null won't work", ExceptionType.CastException, line_num, f);
-            }
-            final Server server = Static.getServer();
-            Static.SendMessage(new LineCallback() {
-
-                public void run(String line) {
-                    server.broadcastMessage(line);
-                }
-            }, args[0].val());
-            return new CVoid(line_num, f);
-        }
-        public Boolean runAsync(){
-            return false;
-        }
-        
-    }
-    
-    @api public static class console implements Function{
-
-        public String getName() {
-            return "console";
-        }
-
-        public Integer[] numArgs() {
-            return new Integer[]{1, 2};
-        }
-
-        public String docs() {
-            return "void {message, [prefix]} Logs a message to the console. If prefix is true, prepends \"CommandHelper:\""
-                    + " to the message. Default is true.";
-        }
-        
-        public ExceptionType[] thrown(){
-            return new ExceptionType[]{ExceptionType.CastException};
-        }
-
-        public boolean isRestricted() {
-            return true;
-        }
-
-        public void varList(IVariableList varList) {}
-
-        public boolean preResolveVariables() {
-            return true;
-        }
-
-        public String since() {
-            return "3.0.2";
-        }
-
-        public Construct exec(int line_num, File f, CommandSender p, Construct... args) throws CancelCommandException, ConfigRuntimeException {
-            String mes = args[0].val();
-            boolean prefix = true;
-            if(args.length > 1){
-                prefix = Static.getBoolean(args[1]);
-            }
-            com.laytonsmith.aliasengine.Static.getLogger().log(Level.INFO, (prefix?"CommandHelper: ":"") + mes);
-            return new CVoid(line_num, f);
-        }
-        public Boolean runAsync(){
-            return null;
-        }
-        
-    }
-}
diff --git a/src/main/java/com/laytonsmith/aliasengine/functions/Economy.java b/src/main/java/com/laytonsmith/aliasengine/functions/Economy.java
deleted file mode 100644
index 7d25ec8..0000000
--- a/src/main/java/com/laytonsmith/aliasengine/functions/Economy.java
+++ /dev/null
@@ -1,698 +0,0 @@
-/*
- * To change this template, choose Tools | Templates
- * and open the template in the editor.
- */
-package com.laytonsmith.aliasengine.functions;
-
-import com.laytonsmith.aliasengine.Constructs.CDouble;
-import com.laytonsmith.aliasengine.Constructs.CVoid;
-import com.laytonsmith.aliasengine.Constructs.Construct;
-import com.laytonsmith.aliasengine.Static;
-import com.laytonsmith.aliasengine.functions.Exceptions.ExceptionType;
-import com.laytonsmith.aliasengine.functions.exceptions.ConfigRuntimeException;
-import com.nijikokun.register.payment.Method;
-import com.nijikokun.register.payment.Method.MethodAccount;
-import com.nijikokun.register.payment.Method.MethodBankAccount;
-import com.nijikokun.register.payment.Methods;
-import java.io.File;
-import org.bukkit.Bukkit;
-import org.bukkit.command.CommandSender;
-import org.bukkit.plugin.Plugin;
-
-/**
- *
- * @author Layton
- */
-public class Economy {
-    
-    public static String docs(){
-        return "Provides functions to hook into the server's economy plugin. To use any of these functions, you must have one of the"
-                + " following economy plugins installed: iConomy 4, 5, & 6+, BOSEconomy 6 & 7, Essentials Economy 2.2.17+, MultiCurrency."
-                + " No special installation is required beyond simply getting the economy plugin working by itself. Using any of these functions"
-                + " without one of the economy plugins will cause it to throw a InvalidPluginException at runtime.";
-    }
-    
-    @api public static class acc_balance implements Function{
-
-        public String getName() {
-            return "acc_balance";
-        }
-
-        public Integer[] numArgs() {
-            return new Integer[]{1};
-        }
-
-        public String docs() {
-            return "double {account_name} Returns the balance of the given account name.";
-        }
-
-        public ExceptionType[] thrown() {
-            return new ExceptionType[]{ExceptionType.PluginInternalException, ExceptionType.InvalidPluginException};
-        }
-
-        public boolean isRestricted() {
-            return true;
-        }
-
-        public void varList(IVariableList varList) {}
-
-        public boolean preResolveVariables() {
-            return true;
-        }
-
-        public String since() {
-            return "3.2.0";
-        }
-
-        public Boolean runAsync() {
-            return null;
-        }
-
-        public Construct exec(int line_num, File f, CommandSender p, Construct... args) throws ConfigRuntimeException {
-            MethodAccount ma = GetAccount(this.getName(), line_num, f, args);
-            return new CDouble(ma.balance(), line_num, f);
-        }
-        
-    }
-    @api public static class acc_set implements Function{
-
-        public String getName() {
-            return "acc_set";
-        }
-
-        public Integer[] numArgs() {
-            return new Integer[]{2};
-        }
-
-        public String docs() {
-            return "void {account_name, value} Sets the account's balance to the given amount";
-        }
-
-        public ExceptionType[] thrown() {
-            return new ExceptionType[]{ExceptionType.PluginInternalException, ExceptionType.InvalidPluginException, ExceptionType.CastException};
-        }
-
-        public boolean isRestricted() {
-            return true;
-        }
-
-        public void varList(IVariableList varList) {}
-
-        public boolean preResolveVariables() {
-            return true;
-        }
-
-        public String since() {
-            return "3.2.0";
-        }
-
-        public Boolean runAsync() {
-            return null;
-        }
-
-        public Construct exec(int line_num, File f, CommandSender p, Construct... args) throws ConfigRuntimeException {
-            if(GetAccount(this.getName(), line_num, f, args).set(Static.getNumber(args[1]))){
-                return new CVoid(line_num, f);
-            } else {
-                throw new ConfigRuntimeException("An error occured when trying to set the balance on account " + args[0].val(), ExceptionType.PluginInternalException, line_num, f);
-            }
-        }
-        
-    }
-    @api public static class acc_add implements Function{
-
-        public String getName() {
-            return "acc_add";
-        }
-
-        public Integer[] numArgs() {
-            return new Integer[]{2};
-        }
-
-        public String docs() {
-            return "void {account_name, to_add} Adds an amount to the specified account";
-        }
-
-        public ExceptionType[] thrown() {
-            return new ExceptionType[]{ExceptionType.PluginInternalException, ExceptionType.InvalidPluginException, ExceptionType.CastException};
-        }
-
-        public boolean isRestricted() {
-            return true;
-        }
-
-        public void varList(IVariableList varList) {}
-
-        public boolean preResolveVariables() {
-            return true;
-        }
-
-        public String since() {
-            return "3.2.0";
-        }
-
-        public Boolean runAsync() {
-            return null;
-        }
-
-        public Construct exec(int line_num, File f, CommandSender p, Construct... args) throws ConfigRuntimeException {
-            if(GetAccount(this.getName(), line_num, f, args).add(Static.getNumber(args[1]))){
-                return new CVoid(line_num, f);
-            } else {
-                throw new ConfigRuntimeException("An error occured when trying to add to the balance on account " + args[0].val(), ExceptionType.PluginInternalException, line_num, f);
-            }
-        }
-        
-    }
-    @api public static class acc_subtract implements Function{
-
-        public String getName() {
-            return "acc_subtract";
-        }
-
-        public Integer[] numArgs() {
-            return new Integer[]{2};
-        }
-
-        public String docs() {
-            return "void {account_name, to_subtract} Subtracts the given amount from the specified account";
-        }
-
-        public ExceptionType[] thrown() {
-            return new ExceptionType[]{ExceptionType.PluginInternalException, ExceptionType.InvalidPluginException, ExceptionType.CastException};
-        }
-
-        public boolean isRestricted() {
-            return true;
-        }
-
-        public void varList(IVariableList varList) {}
-
-        public boolean preResolveVariables() {
-            return true;
-        }
-
-        public String since() {
-            return "3.2.0";
-        }
-
-        public Boolean runAsync() {
-            return null;
-        }
-
-        public Construct exec(int line_num, File f, CommandSender p, Construct... args) throws ConfigRuntimeException {
-            if(GetAccount(this.getName(), line_num, f, args).subtract(Static.getNumber(args[1]))){
-                return new CVoid(line_num, f);
-            } else {
-                throw new ConfigRuntimeException("An error occured when trying to subtract from the balance on account " + args[0].val(), ExceptionType.PluginInternalException, line_num, f);
-            }
-        }
-        
-    }
-    @api public static class acc_multiply implements Function{
-
-        public String getName() {
-            return "acc_multiply";
-        }
-
-        public Integer[] numArgs() {
-            return new Integer[]{2};
-        }
-
-        public String docs() {
-            return "void {account_name, to_multiply} Multiplies the account balance by the given amount";
-        }
-
-        public ExceptionType[] thrown() {
-            return new ExceptionType[]{ExceptionType.PluginInternalException, ExceptionType.InvalidPluginException, ExceptionType.CastException};
-        }
-
-        public boolean isRestricted() {
-            return true;
-        }
-
-        public void varList(IVariableList varList) {}
-
-        public boolean preResolveVariables() {
-            return true;
-        }
-
-        public String since() {
-            return "3.2.0";
-        }
-
-        public Boolean runAsync() {
-            return null;
-        }
-
-        public Construct exec(int line_num, File f, CommandSender p, Construct... args) throws ConfigRuntimeException {
-            if(GetAccount(this.getName(), line_num, f, args).multiply(Static.getNumber(args[1]))){
-                return new CVoid(line_num, f);
-            } else {
-                throw new ConfigRuntimeException("An error occured when trying to multiply the balance on account " + args[0].val(), ExceptionType.PluginInternalException, line_num, f);
-            }
-        }
-        
-    }
-    @api public static class acc_divide implements Function{
-
-        public String getName() {
-            return "acc_divide";
-        }
-
-        public Integer[] numArgs() {
-            return new Integer[]{2};
-        }
-
-        public String docs() {
-            return "void {account_name, to_divide} Divides the account by the given amount";
-        }
-
-        public ExceptionType[] thrown() {
-            return new ExceptionType[]{ExceptionType.PluginInternalException, ExceptionType.InvalidPluginException, ExceptionType.CastException};
-        }
-
-        public boolean isRestricted() {
-            return true;
-        }
-
-        public void varList(IVariableList varList) {}
-
-        public boolean preResolveVariables() {
-            return true;
-        }
-
-        public String since() {
-            return "3.2.0";
-        }
-
-        public Boolean runAsync() {
-            return null;
-        }
-
-        public Construct exec(int line_num, File f, CommandSender p, Construct... args) throws ConfigRuntimeException {
-            if(GetAccount(this.getName(), line_num, f, args).divide(Static.getNumber(args[1]))){
-                return new CVoid(line_num, f);
-            } else {
-                throw new ConfigRuntimeException("An error occured when trying to divide the balance on account " + args[0].val(), ExceptionType.PluginInternalException, line_num, f);
-            }
-        }
-        
-    }
-    @api public static class acc_remove implements Function{
-
-        public String getName() {
-            return "acc_remove";
-        }
-
-        public Integer[] numArgs() {
-            return new Integer[]{1};
-        }
-
-        public String docs() {
-            return "void {account_name} Removes the specified account from the game";
-        }
-
-        public ExceptionType[] thrown() {
-            return new ExceptionType[]{ExceptionType.PluginInternalException, ExceptionType.InvalidPluginException};
-        }
-
-        public boolean isRestricted() {
-            return true;
-        }
-
-        public void varList(IVariableList varList) {}
-
-        public boolean preResolveVariables() {
-            return true;
-        }
-
-        public String since() {
-            return "3.2.0";
-        }
-
-        public Boolean runAsync() {
-            return null;
-        }
-
-        public Construct exec(int line_num, File f, CommandSender p, Construct... args) throws ConfigRuntimeException {
-            if(GetAccount(this.getName(), line_num, f, args).remove()){
-                return new CVoid(line_num, f);
-            } else {
-                throw new ConfigRuntimeException("An error occured when trying to set the balance on account " + args[0].val(), ExceptionType.PluginInternalException, line_num, f);
-            }
-        }
-        
-    }
-    @api public static class bacc_balance implements Function{
-
-        public String getName() {
-            return "bacc_balance";
-        }
-
-        public Integer[] numArgs() {
-            return new Integer[]{2};
-        }
-
-        public String docs() {
-            return "void {bank_name, account_name} Gets the specified bank account's balance";
-        }
-
-        public ExceptionType[] thrown() {
-            return new ExceptionType[]{ExceptionType.PluginInternalException, ExceptionType.InvalidPluginException};
-        }
-
-        public boolean isRestricted() {
-            return true;
-        }
-
-        public void varList(IVariableList varList) {}
-
-        public boolean preResolveVariables() {
-            return true;
-        }
-
-        public String since() {
-            return "3.2.0";
-        }
-
-        public Boolean runAsync() {
-            return null;
-        }
-
-        public Construct exec(int line_num, File f, CommandSender p, Construct... args) throws ConfigRuntimeException {
-            return new CDouble(GetBankAccount(this.getName(), line_num, f, args).balance(), line_num, f);
-        }
-        
-    }
-    @api public static class bacc_set implements Function{
-
-        public String getName() {
-            return "bacc_set";
-        }
-
-        public Integer[] numArgs() {
-            return new Integer[]{3};
-        }
-
-        public String docs() {
-            return "void {bank_name, account_name, value} Sets the bank account's balance to the given amount";
-        }
-
-        public ExceptionType[] thrown() {
-            return new ExceptionType[]{ExceptionType.PluginInternalException, ExceptionType.InvalidPluginException, ExceptionType.CastException};
-        }
-
-        public boolean isRestricted() {
-            return true;
-        }
-
-        public void varList(IVariableList varList) {}
-
-        public boolean preResolveVariables() {
-            return true;
-        }
-
-        public String since() {
-            return "3.2.0";
-        }
-
-        public Boolean runAsync() {
-            return null;
-        }
-
-        public Construct exec(int line_num, File f, CommandSender p, Construct... args) throws ConfigRuntimeException {
-            if(GetBankAccount(this.getName(), line_num, f, args).set(Static.getNumber(args[2]))){
-                return new CVoid(line_num, f);
-            } else {
-                throw new ConfigRuntimeException("An error occured when trying to set the balance on bank account " + args[0].val() + ":" + args[1].val(), ExceptionType.PluginInternalException, line_num, f);
-            }
-        }
-        
-    }
-    @api public static class bacc_add implements Function{
-
-        public String getName() {
-            return "bacc_add";
-        }
-
-        public Integer[] numArgs() {
-            return new Integer[]{3};
-        }
-
-        public String docs() {
-            return "void {bank_name, account_name, value} Adds the specified amount to the bank account's balance";
-        }
-
-        public ExceptionType[] thrown() {
-            return new ExceptionType[]{ExceptionType.PluginInternalException, ExceptionType.InvalidPluginException, ExceptionType.CastException};
-        }
-
-        public boolean isRestricted() {
-            return true;
-        }
-
-        public void varList(IVariableList varList) {}
-
-        public boolean preResolveVariables() {
-            return true;
-        }
-
-        public String since() {
-            return "3.2.0";
-        }
-
-        public Boolean runAsync() {
-            return null;
-        }
-
-        public Construct exec(int line_num, File f, CommandSender p, Construct... args) throws ConfigRuntimeException {
-            if(GetBankAccount(this.getName(), line_num, f, args).add(Static.getNumber(args[2]))){
-                return new CVoid(line_num, f);
-            } else {
-                throw new ConfigRuntimeException("An error occured when trying to add to the balance on bank account " + args[0].val() + ":" + args[1].val(), ExceptionType.PluginInternalException, line_num, f);
-            }
-        }
-        
-    }
-    @api public static class bacc_subtract implements Function{
-
-        public String getName() {
-            return "bacc_subtract";
-        }
-
-        public Integer[] numArgs() {
-            return new Integer[]{3};
-        }
-
-        public String docs() {
-            return "void {bank_name, account_name, value} Subtracts the specified amount from the bank account's balance";
-        }
-
-        public ExceptionType[] thrown() {
-            return new ExceptionType[]{ExceptionType.PluginInternalException, ExceptionType.InvalidPluginException, ExceptionType.CastException};
-        }
-
-        public boolean isRestricted() {
-            return true;
-        }
-
-        public void varList(IVariableList varList) {}
-
-        public boolean preResolveVariables() {
-            return true;
-        }
-
-        public String since() {
-            return "3.2.0";
-        }
-
-        public Boolean runAsync() {
-            return null;
-        }
-
-        public Construct exec(int line_num, File f, CommandSender p, Construct... args) throws ConfigRuntimeException {
-            if(GetBankAccount(this.getName(), line_num, f, args).subtract(Static.getNumber(args[2]))){
-                return new CVoid(line_num, f);
-            } else {
-                throw new ConfigRuntimeException("An error occured when trying to subtract from the balance on bank account " + args[0].val() + ":" + args[1].val(), ExceptionType.PluginInternalException, line_num, f);
-            }
-        }
-        
-    }
-    @api public static class bacc_multiply implements Function{
-
-        public String getName() {
-            return "bacc_multiply";
-        }
-
-        public Integer[] numArgs() {
-            return new Integer[]{3};
-        }
-
-        public String docs() {
-            return "void {bank_name, account_name, value} Multiplies the given bank account's balance by the given value";
-        }
-
-        public ExceptionType[] thrown() {
-            return new ExceptionType[]{ExceptionType.PluginInternalException, ExceptionType.InvalidPluginException, ExceptionType.CastException};
-        }
-
-        public boolean isRestricted() {
-            return true;
-        }
-
-        public void varList(IVariableList varList) {}
-
-        public boolean preResolveVariables() {
-            return true;
-        }
-
-        public String since() {
-            return "3.2.0";
-        }
-
-        public Boolean runAsync() {
-            return null;
-        }
-
-        public Construct exec(int line_num, File f, CommandSender p, Construct... args) throws ConfigRuntimeException {
-            if(GetBankAccount(this.getName(), line_num, f, args).multiply(Static.getNumber(args[2]))){
-                return new CVoid(line_num, f);
-            } else {
-                throw new ConfigRuntimeException("An error occured when trying to multiply the balance on bank account " + args[0].val() + ":" + args[1].val(), ExceptionType.PluginInternalException, line_num, f);
-            }
-        }
-        
-    }
-    @api public static class bacc_divide implements Function{
-
-        public String getName() {
-            return "bacc_divide";
-        }
-
-        public Integer[] numArgs() {
-            return new Integer[]{3};
-        }
-
-        public String docs() {
-            return "void {bank_name, account_name, value} Divides the bank account's balance by the given value";
-        }
-
-        public ExceptionType[] thrown() {
-            return new ExceptionType[]{ExceptionType.PluginInternalException, ExceptionType.InvalidPluginException, ExceptionType.CastException};
-        }
-
-        public boolean isRestricted() {
-            return true;
-        }
-
-        public void varList(IVariableList varList) {}
-
-        public boolean preResolveVariables() {
-            return true;
-        }
-
-        public String since() {
-            return "3.2.0";
-        }
-
-        public Boolean runAsync() {
-            return null;
-        }
-
-        public Construct exec(int line_num, File f, CommandSender p, Construct... args) throws ConfigRuntimeException {
-            if(GetBankAccount(this.getName(), line_num, f, args).divide(Static.getNumber(args[2]))){
-                return new CVoid(line_num, f);
-            } else {
-                throw new ConfigRuntimeException("An error occured when trying to divide the balance on bank account " + args[0].val() + ":" + args[1].val(), ExceptionType.PluginInternalException, line_num, f);
-            }
-        }
-        
-    }
-    @api public static class bacc_remove implements Function{
-
-        public String getName() {
-            return "bacc_remove";
-        }
-
-        public Integer[] numArgs() {
-            return new Integer[]{2};
-        }
-
-        public String docs() {
-            return "void {bank_name, account_name} Removes the given bank account from the game";
-        }
-
-        public ExceptionType[] thrown() {
-            return new ExceptionType[]{ExceptionType.PluginInternalException, ExceptionType.InvalidPluginException};
-        }
-
-        public boolean isRestricted() {
-            return true;
-        }
-
-        public void varList(IVariableList varList) {}
-
-        public boolean preResolveVariables() {
-            return true;
-        }
-
-        public String since() {
-            return "3.2.0";
-        }
-
-        public Boolean runAsync() {
-            return null;
-        }
-
-        public Construct exec(int line_num, File f, CommandSender p, Construct... args) throws ConfigRuntimeException {
-            if(GetBankAccount(this.getName(), line_num, f, args).remove()){
-                return new CVoid(line_num, f);
-            } else {
-                throw new ConfigRuntimeException("An error occured when trying to remove the bank account " + args[0].val() + ":" + args[1].val(), ExceptionType.PluginInternalException, line_num, f);
-            }
-        }
-        
-    }
-    
-    public static Method GetMethod(int line_num, File file){
-        com.nijikokun.register.payment.Methods m = new Methods();
-        if(!m.hasMethod()){
-            //initialize our plugin if it isn't already
-            Plugin [] plugins = Static.getServer().getPluginManager().getPlugins();
-            for(Plugin plugin : plugins){
-                if(m.setMethod(plugin)){
-                    break;
-                }
-            }
-        }
-        if(m.getMethod() == null){
-            throw new ConfigRuntimeException("No Economy plugins appear to be loaded", ExceptionType.InvalidPluginException, line_num, file);
-        } else {
-            return m.getMethod();
-        }
-    }
-    
-    public static MethodAccount GetAccount(String fname, int line_num, File file, Construct ... args){
-        String name = args[0].val();
-        MethodAccount m = GetMethod(line_num, file).getAccount(name);
-        if(m == null){
-            throw new ConfigRuntimeException("Could not access an account by that name (" + args[0].val() + ")", ExceptionType.PluginInternalException, line_num, file);
-        } else {
-            return m;
-        }
-    }
-    
-    public static MethodBankAccount GetBankAccount(String fname, int line_num, File file, Construct ... args){
-        String bank_name = args[0].val();
-        String account_name = args[1].val();
-        MethodBankAccount m = GetMethod(line_num, file).getBankAccount(bank_name, account_name);
-        if(m == null){
-            throw new ConfigRuntimeException("Could not access a bank account by that name (" + args[0].val() + ":" + args[1].val() + ")", ExceptionType.PluginInternalException, line_num, file);
-        } else {
-            return m;
-        }
-    }
-
-}
diff --git a/src/main/java/com/laytonsmith/aliasengine/functions/Environment.java b/src/main/java/com/laytonsmith/aliasengine/functions/Environment.java
deleted file mode 100644
index 6b462ff..0000000
--- a/src/main/java/com/laytonsmith/aliasengine/functions/Environment.java
+++ /dev/null
@@ -1,238 +0,0 @@
-/*
- * To change this template, choose Tools | Templates
- * and open the template in the editor.
- */
-package com.laytonsmith.aliasengine.functions;
-
-import com.laytonsmith.aliasengine.functions.exceptions.CancelCommandException;
-import com.laytonsmith.aliasengine.functions.exceptions.ConfigRuntimeException;
-import com.laytonsmith.aliasengine.Constructs.CArray;
-import com.laytonsmith.aliasengine.Constructs.CString;
-import com.laytonsmith.aliasengine.Constructs.CVoid;
-import com.laytonsmith.aliasengine.Constructs.Construct;
-import com.laytonsmith.aliasengine.Static;
-import com.laytonsmith.aliasengine.functions.Exceptions.ExceptionType;
-import java.io.File;
-import org.bukkit.World;
-import org.bukkit.block.Block;
-import org.bukkit.command.CommandSender;
-import org.bukkit.entity.Player;
-
-/**
- *
- * @author Layton
- */
-public class Environment {
-    public static String docs(){
-        return "Allows you to manipulate the environment around the player";
-    }
-    
-    @api public static class get_block_at implements Function{
-
-        public String getName() {
-            return "get_block_at";
-        }
-
-        public Integer[] numArgs() {
-            return new Integer[]{1, 2, 3, 4};
-        }
-
-        public String docs() {
-            return "string {x, y, z, [world] | xyzArray, [world]} Gets the id of the block at x, y, z. This function expects "
-                    + "either 1 or 3 arguments. If 1 argument is passed, it should be an array with the x, y, z"
-                    + " coordinates. The format of the return will be x:y where x is the id of the block, and"
-                    + " y is the meta data for the block. All blocks will return in this format, but blocks"
-                    + " that don't have meta data normally will return 0 in y. If world isn't specified, the current"
-                    + " player's world is used.";
-        }
-        
-        public ExceptionType[] thrown(){
-            return new ExceptionType[]{ExceptionType.CastException, ExceptionType.LengthException, ExceptionType.InvalidWorldException};
-        }
-
-        public boolean isRestricted() {
-            return true;
-        }
-
-        public void varList(IVariableList varList) {}
-
-        public boolean preResolveVariables() {
-            return true;
-        }
-
-        public String since() {
-            return "3.0.2";
-        }
-
-        public Construct exec(int line_num, File f, CommandSender p, Construct... args) throws CancelCommandException, ConfigRuntimeException {
-            double x = 0;
-            double y = 0;
-            double z = 0;
-            World w = null;
-            String world = null;
-            if(p instanceof Player){
-                w = ((Player)p).getWorld();
-            }
-            if(args.length == 1 || args.length == 2){
-                if(args[0] instanceof CArray){
-                    CArray ca = (CArray)args[0];
-                    if(ca.size() == 3){
-                        x = Static.getDouble(ca.get(0, line_num));
-                        y = Static.getDouble(ca.get(1, line_num));
-                        z = Static.getDouble(ca.get(2, line_num));
-                    } else {
-                        throw new ConfigRuntimeException("get_block_at expects the array at param 1 to have 3 arguments", ExceptionType.LengthException,
-                                line_num, f);
-                    }
-                } else {
-                    throw new ConfigRuntimeException("get_block_at expects param 1 to be an array", ExceptionType.CastException, line_num, f);
-                }
-                if(args.length == 2){
-                    world = args[1].val();
-                }
-            } else if(args.length == 3 || args.length == 4){
-                x = Static.getDouble(args[0]);
-                y = Static.getDouble(args[1]);
-                z = Static.getDouble(args[2]);
-                if(args.length == 4){
-                    world = args[3].val();
-                }
-            }
-            if(world != null){
-                w = Static.getServer().getWorld(world);
-            }
-            if(w == null){
-                throw new ConfigRuntimeException("The specified world " + world + " doesn't exist", ExceptionType.InvalidWorldException, line_num, f);
-            }
-            x = java.lang.Math.floor(x);
-            y = java.lang.Math.floor(y);
-            z = java.lang.Math.floor(z);
-            Block b = w.getBlockAt((int)x, (int)y, (int)z);
-            return new CString(b.getTypeId() + ":" + b.getData(), line_num, f);
-        }
-        public Boolean runAsync(){
-            return false;
-        }
-        
-    }
-    
-    @api public static class set_block_at implements Function{
-
-        public String getName() {
-            return "set_block_at";
-        }
-
-        public Integer[] numArgs() {
-            return new Integer[]{2, 3, 4, 5};
-        }
-
-        public String docs() {
-            return "void {x, y, z, id, [world] | xyzArray, id, [world]} Sets the id of the block at the x y z coordinates specified. If the"
-                    + " first argument passed is an array, it should be x y z coordinates. id must"
-                    + " be a blocktype identifier similar to the type returned from get_block_at, except if the meta"
-                    + " value is not specified, 0 is used. If world isn't specified, the current player's world"
-                    + " is used.";
-        }
-        
-        public ExceptionType[] thrown(){
-            return new ExceptionType[]{ExceptionType.CastException, ExceptionType.LengthException, ExceptionType.FormatException, ExceptionType.InvalidWorldException};
-        }
-
-        public boolean isRestricted() {
-            return true;
-        }
-
-        public void varList(IVariableList varList) {}
-
-        public boolean preResolveVariables() {
-            return true;
-        }
-
-        public String since() {
-            return "3.0.2";
-        }
-
-        public Construct exec(int line_num, File f, CommandSender p, Construct... args) throws CancelCommandException, ConfigRuntimeException {
-            double x = 0;
-            double y = 0;
-            double z = 0;
-            String id = null;
-            String world = null;
-            World w = null;
-            if(p instanceof Player){
-                w = ((Player)p).getWorld();
-            }
-            if((args.length == 2 || args.length == 3) && args[0] instanceof CArray){
-                CArray ca = (CArray)args[0];
-                if(ca.size() != 3){
-                    throw new ConfigRuntimeException("set_block_at expects the parameter 1 to be an array with 3 elements.", ExceptionType.LengthException,
-                            line_num, f);
-                }
-                x = Static.getNumber(ca.get(0, line_num));
-                y = Static.getNumber(ca.get(1, line_num));
-                z = Static.getNumber(ca.get(2, line_num));
-                id = args[1].val();
-                if(args.length == 3){
-                    world = args[2].val();
-                }
-                
-            } else {
-                x = Static.getNumber(args[0]);
-                y = Static.getNumber(args[1]);
-                z = Static.getNumber(args[2]);
-                id = args[3].val();
-                if(args.length == 5){
-                    world = args[4].val();
-                }
-            }
-            if(world != null){
-                w = Static.getServer().getWorld(world);
-            }
-            if(w == null){
-                throw new ConfigRuntimeException("The specified world " + world + " doesn't exist", ExceptionType.InvalidWorldException, line_num, f);
-            }
-            x = java.lang.Math.floor(x);
-            y = java.lang.Math.floor(y);
-            z = java.lang.Math.floor(z);
-            int ix = (int)x;
-            int iy = (int)y;
-            int iz = (int)z;
-            System.out.println("Setting block at " + ix + "," + iy + "," + iz);
-            Block b = w.getBlockAt(ix, iy, iz);
-            StringBuilder data = new StringBuilder();
-            StringBuilder meta = new StringBuilder();
-            boolean inMeta = false;
-            for(int i = 0; i < id.length(); i++){
-                Character c = id.charAt(i);
-                if(!inMeta){
-                    if(!Character.isDigit(c) && c != ':'){
-                        throw new ConfigRuntimeException("id must be formatted as such: 'x:y' where x and y are integers", ExceptionType.FormatException,
-                                line_num, f);
-                    }
-                    if(c == ':'){
-                        inMeta = true;
-                        continue;
-                    }
-                    data.append(c);
-                } else {
-                    meta.append(c);
-                }
-            }
-            if(meta.length() == 0){
-                meta.append("0");
-            }
-            
-            int idata = Integer.parseInt(data.toString());
-            byte imeta = Byte.parseByte(meta.toString());
-            b.setTypeId(idata);
-            b.setData(imeta);
-            
-            return new CVoid(line_num, f);
-        }
-        public Boolean runAsync(){
-            return false;
-        }
-        
-    }
-    
-}
diff --git a/src/main/java/com/laytonsmith/aliasengine/functions/Exceptions.java b/src/main/java/com/laytonsmith/aliasengine/functions/Exceptions.java
deleted file mode 100644
index 2c57fdf..0000000
--- a/src/main/java/com/laytonsmith/aliasengine/functions/Exceptions.java
+++ /dev/null
@@ -1,257 +0,0 @@
-/*
- * To change this template, choose Tools | Templates
- * and open the template in the editor.
- */
-package com.laytonsmith.aliasengine.functions;
-
-import com.laytonsmith.aliasengine.functions.exceptions.CancelCommandException;
-import com.laytonsmith.aliasengine.functions.exceptions.ConfigRuntimeException;
-import com.laytonsmith.aliasengine.Constructs.*;
-import com.laytonsmith.aliasengine.GenericTreeNode;
-import com.laytonsmith.aliasengine.Script;
-import com.laytonsmith.aliasengine.Static;
-import java.io.File;
-import java.util.ArrayList;
-import java.util.List;
-import org.bukkit.command.CommandSender;
-
-/**
- *
- * @author Layton
- */
-public class Exceptions {
-    public static String docs(){
-        return "This class contains functions related to Exception handling in MScript";
-    }
-    public enum ExceptionType{
-        /**
-         * This exception is thrown if a value cannot be cast into an appropriate type. Functions that require
-         * a numeric value, for instance, would throw this if the string "hi" were passed in.
-         */
-        CastException,
-        /**
-         * This exception is thrown if a value is requested from an array that is above the highest index of the array,
-         * or a negative number.
-         */
-        IndexOverflowException,
-        /**
-         * This exception is thrown if a function expected a numeric value to be in a particular range, and it wasn't
-         */
-        RangeException,
-        /**
-         * This exception is thrown if a function expected the length of something to be a particular value, but it was not.
-         */
-        LengthException,
-        /**
-         * This exception is thrown if the user running the command does not have permission to run the function
-         */
-        InsufficientPermissionException,
-        /**
-         * This exception is thrown if a function expected an online player, but that player was offline, or the
-         * command is being run from somewhere not in game, and the function was trying to use the current player.
-         */
-        PlayerOfflineException, 
-        /**
-         * Some var arg functions may require at least a certain number of arguments to be passed to the function
-         */
-        InsufficientArgumentsException, 
-        /**
-         * This exception is thrown if a function expected a string to be formatted in a particular way, but it could not interpret the 
-         * given value.
-         */
-        FormatException,
-        /**
-         * This exception is thrown if a procedure is used without being defined, or if a procedure name does not follow proper naming
-         * conventions.
-         */
-        InvalidProcedureException, 
-        /**
-         * This exception is thrown if there is a problem with an include. This is thrown if there is
-         * a compile error in the included script.
-         */
-        IncludeException,
-        /**
-         * This exception is thrown if a script tries to read or write to a location of the filesystem that is not allowed.
-         */
-        SecurityException, 
-        /**
-         * This exception is thrown if a file cannot be read or written to.
-         */
-        IOException, 
-        /**
-         * This exception is thrown if a function uses an external plugin, and that plugin is not loaded, 
-         * or otherwise unusable.
-         */
-        InvalidPluginException,
-        /**
-         * This exception is thrown when a plugin is loaded, but a call to the plugin failed, usually
-         * for some reason specific to the plugin. Check the error message for more details about this
-         * error.
-         */
-        PluginInternalException,
-        /**
-         * If a function requests a world, and the world given doesn't exist, this is thrown
-         */
-        InvalidWorldException,
-    }
-    @api public static class _try implements Function{      
-        
-        IVariableList varList;
-        public String getName() {
-            
-            return "try";
-        }
-
-        public Integer[] numArgs() {
-            return new Integer[]{3,4};
-        }
-
-        public String docs() {
-            return "void {tryCode, varName, catchCode, [exceptionTypes]} This function works similar to a try-catch block in most languages. If the code in"
-                    + " tryCode throws an exception, instead of killing the whole script, it stops running, and begins running the catchCode."
-                    + " var should be an ivariable, and it is set to an array containing the following information about the exception:"
-                    + " 0 - The class of the exception; 1 - The message generated by the exception; 2 - The file the exception was generated from; 3 - The line the exception"
-                    + " occured on. If exceptionTypes is provided, it should be an array of exception types, or a single string that this try function is interested in."
-                    + " If the exception type matches one of the values listed, the exception will be caught, otherwise, the exception will continue up the stack."
-                    + " If exceptionTypes is missing, it will catch all exceptions."
-                    + " PLEASE NOTE! This function will not catch exceptions thrown by CommandHelper, only built in exceptions. "
-                    + " Please see the wiki for more information about what possible exceptions can be thrown and where.";
-        }
-        
-        public ExceptionType[] thrown(){
-            return new ExceptionType[]{ExceptionType.CastException, ExceptionType.FormatException};
-        }
-
-        public boolean isRestricted() {
-            return false;
-        }
-
-        public void varList(IVariableList varList) {
-            this.varList = varList;
-        }
-
-        public boolean preResolveVariables() {
-            return false;
-        }
-
-        public String since() {
-            return "3.1.2";
-        }
-
-        public Boolean runAsync() {
-            return null;
-        }
-        public Construct execs(int line_num, File f, CommandSender p, Script that, GenericTreeNode<Construct> tryCode,
-                GenericTreeNode<Construct> varName, GenericTreeNode<Construct> catchCode, GenericTreeNode<Construct> types) throws CancelCommandException{
-            Construct pivar = that.eval(varName, p);
-            IVariable ivar;
-            if(pivar instanceof IVariable){
-                ivar = (IVariable)pivar;
-            } else {
-                throw new ConfigRuntimeException("Expected argument 2 to be an IVariable", ExceptionType.CastException, line_num, f);
-            }
-            List<String> interest = new ArrayList<String>();
-            if(types != null){
-            Construct ptypes = that.eval(types, p);
-                if(ptypes instanceof CString){
-                    interest.add(ptypes.val());
-                } else if(ptypes instanceof CArray){
-                    CArray ca = (CArray)ptypes;
-                    for(int i = 0; i < ca.size(); i++){
-                        interest.add(ca.get(i, line_num).val());
-                    }
-                } else {
-                    throw new ConfigRuntimeException("Expected argument 4 to be a string, or an array of strings.", 
-                            ExceptionType.CastException, line_num, f);
-                }
-            }
-            
-            for(String in : interest){
-                try{
-                    ExceptionType.valueOf(in);
-                } catch(IllegalArgumentException e){
-                    throw new ConfigRuntimeException("Invalid exception type passed to try():" + in, 
-                            ExceptionType.FormatException, line_num, f);
-                }
-            }
-            
-            try{
-                that.eval(tryCode, p);
-            } catch (ConfigRuntimeException e){
-                if((Boolean)Static.getPreferences().getPreference("debug-mode")){
-                    System.out.println("[CommandHelper]: Exception thrown -> " + e.getMessage() + " :: " + e.getExceptionType() + ":" + e.getFile() + ":" + e.getLineNum());
-                }
-                if(e.getExceptionType() != null  && (interest.isEmpty() || interest.contains(e.getExceptionType().toString()))){
-                    CArray ex = new CArray(line_num, f);
-                    ex.push(new CString(e.getExceptionType().toString(), line_num, f));
-                    ex.push(new CString(e.getMessage(), line_num, f));
-                    ex.push(new CString((e.getFile()!=null?e.getFile().getAbsolutePath():"null"), line_num, f));
-                    ex.push(new CInt(e.getLineNum(), line_num, f));
-                    ivar.setIval(ex);
-                    varList.set(ivar);
-                    that.eval(catchCode, p);
-                } else {
-                    throw e;
-                }
-            }
-            
-            
-            return new CVoid(line_num, f);
-        }
-        public Construct exec(int line_num, File f, CommandSender p, Construct... args) throws CancelCommandException, ConfigRuntimeException {
-            throw new UnsupportedOperationException("Not supported yet.");
-        }
-        
-    }
-    
-    @api public static class _throw implements Function{
-
-        public String getName() {
-            return "throw";
-        }
-
-        public Integer[] numArgs() {
-            return new Integer[]{2};
-        }
-
-        public String docs() {
-            return "nothing {exceptionType, msg} This function causes an exception to be thrown. If the exception type is null,"
-                    + " it will be uncatchable. Otherwise, exceptionType may be any valid exception type.";
-        }
-        
-        public ExceptionType[] thrown(){
-            return new ExceptionType[]{ExceptionType.FormatException};
-        }
-
-        public boolean isRestricted() {
-            return false;
-        }
-
-        public void varList(IVariableList varList) {}
-
-        public boolean preResolveVariables() {
-            return true;
-        }
-
-        public String since() {
-            return "3.1.2";
-        }
-
-        public Boolean runAsync() {
-            return null;
-        }
-
-        public Construct exec(int line_num, File f, CommandSender p, Construct... args) throws CancelCommandException, ConfigRuntimeException {
-            try{
-                ExceptionType c = null;
-                if(!(args[0] instanceof CNull)){
-                    c = ExceptionType.valueOf(args[0].val());
-                }
-                throw new ConfigRuntimeException(args[1].val(), c, line_num, f);
-            } catch(IllegalArgumentException e){
-                throw new ConfigRuntimeException("Expected a valid exception type", ExceptionType.FormatException, line_num, f);
-            }
-        }
-        
-    }
-}
diff --git a/src/main/java/com/laytonsmith/aliasengine/functions/Function.java b/src/main/java/com/laytonsmith/aliasengine/functions/Function.java
deleted file mode 100644
index b6b2d5c..0000000
--- a/src/main/java/com/laytonsmith/aliasengine/functions/Function.java
+++ /dev/null
@@ -1,111 +0,0 @@
-/*
- * To change this template, choose Tools | Templates
- * and open the template in the editor.
- */
-
-package com.laytonsmith.aliasengine.functions;
-
-import com.laytonsmith.aliasengine.Constructs.Construct;
-import com.laytonsmith.aliasengine.functions.exceptions.CancelCommandException;
-import com.laytonsmith.aliasengine.functions.exceptions.ConfigRuntimeException;
-import com.laytonsmith.aliasengine.functions.Exceptions.ExceptionType;
-import java.io.File;
-import org.bukkit.command.CommandSender;
-
-/**
- * Note that to "activate" this class as a function, you must prefix the '@api' annotation
- * to it.
- * @author layton
- */
-public interface Function {
-    /**
-     * The name of this function, exactly as should be used in a script. Note that the name of
-     * the function must match the regex:
-     * <pre>
-     * [a-zA-Z_][a-zA-Z_0-9]*
-     * </pre>
-     * In other words, it must start with a letter or underscore, and may have any number of
-     * letters, numbers, or underscores after it.
-     * @return 
-     */
-    public String getName();
-    /**
-     * The number of arguments this function can accept. Some functions may be able to accept multiple numbers
-     * of arguments, so this function returns an array. If you return Integer.MAX_VALUE as one of the
-     * items in the array, then any number of arguments may be sent.
-     * @return 
-     */
-    public Integer[] numArgs();
-    /**
-     * If a user asks for information about a particular function, this method is called to obtain the functions
-     * usage. The returned string must follow the following format:
-     * @return A string with the documentation, or null, which will give a standard message to the user telling them there
-     * is no documentation for this function yet.
-     */
-    public String docs();
-    
-    /**
-     * Returns the types of catchable exceptions this function can throw. (Uncatchable exceptions need not be listed)
-     * @return An array of the exception enums, or null, if the function throws no catchable exceptions.
-     */
-    public ExceptionType[] thrown();
-    /**
-     * Whether or not a function needs to be checked against the permissions file, if there are possible security concerns
-     * with a user compiling, or running this function. If this function returns true, the permissions file will be checked for
-     * commandhelper.func.compile.&lt;function name&gt; upon compilation, and commandhelper.func.use.&lt;function name&gt; upon
-     * usage in game. Note that the config script is never barred from compiling any function.
-     * @return 
-     */
-    public boolean isRestricted();
-    /**
-     * Most functions don't care that a construct is a variable, they simply care about the value stored in the variable.
-     * If the function is concerned with the variable listing however, then it has direct access to the variable list for
-     * this command.
-     * @param varList 
-     */
-    public void varList(IVariableList varList);
-    /**
-     * If a function doesn't want to have to deal with a variable as a variable, but instead wants to recieve it as
-     * an atomic, resolved value, the function can return true from this function. This will signal the interpreter
-     * to go ahead and resolve the variable into one of the atomic Constructs. If it returns false, it is possible
-     * the exec function will receive an IVariable Construct.
-     * @return 
-     */
-    public boolean preResolveVariables();
-    
-    /**
-     * The version this function was added to CommandHelper. Used in documentation, so users know what version they must have
-     * in order to use this function.
-     * @return 
-     */
-    public String since();
-    
-    /**
-     * Whether or not to run this function asynchronously from the main server thread. If you 
-     * return true, you may NOT have any interaction with the bukkit api, other than
-     * bukkit thread safe methods. Returning true WILL run this function in the CH thread, returning
-     * false WILL run this function in the main server thread, and returning null will run this
-     * function in whatever context the script is currently running in.
-     * @return 
-     */
-    public Boolean runAsync();
-    /**
-     * This function is invoked when the alias is run. The line number is provided so that if there is an error,
-     * the function can provide a more specific error message for the user. The function can throw a CancelCommandException
-     * which indicates that the command was purposefully canceled. If the command was canceled due to a fatal error
-     * in the syntax of the user input or some similar situation, it is better to throw a ConfigRuntimeException instead.
-     * Throwing either Exception will prevent the command from completing, however functions that had been run earlier will
-     * may have already completed successfully, so there is no guarantee of atomicity. All parameters sent to the
-     * function have already been resolved into an atomic value though, so functions do not have to worry about
-     * resolving parameters. There is an explicit check made before calling exec to ensure that Construct ... args
-     * will only be one of the following:
-     * CBoolean, CDouble, CInt, CNull, CString, CVoid, or IVariable. If you care, you'll need to do further checks
-     * on the datatype to verify what the type actually is.
-     * @param line_num The line that this function call is being run from
-     * @param f The file that this function call is being run from
-     * @param args An array of evaluated Constructs
-     * @return
-     * @throws CancelCommandException 
-     */
-    public Construct exec(int line_num, File f, CommandSender p, Construct ... args) throws ConfigRuntimeException;
-}
diff --git a/src/main/java/com/laytonsmith/aliasengine/functions/FunctionList.java b/src/main/java/com/laytonsmith/aliasengine/functions/FunctionList.java
deleted file mode 100644
index 07683eb..0000000
--- a/src/main/java/com/laytonsmith/aliasengine/functions/FunctionList.java
+++ /dev/null
@@ -1,142 +0,0 @@
-/*
- * To change this template, choose Tools | Templates
- * and open the template in the editor.
- */
-package com.laytonsmith.aliasengine.functions;
-
-import com.laytonsmith.aliasengine.Constructs.Construct;
-import com.laytonsmith.aliasengine.functions.exceptions.ConfigCompileException;
-import com.laytonsmith.aliasengine.Constructs.CFunction;
-import com.laytonsmith.aliasengine.User;
-import java.lang.annotation.Annotation;
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.logging.Level;
-import java.util.logging.Logger;
-
-/**
- *
- * @author layton
- */
-public class FunctionList {
-
-    private static ArrayList<Function> functions = new ArrayList<Function>();
-    static {
-        //Initialize all our functions as soon as we start up
-        initFunctions();
-    }
-
-    private static void initFunctions() {
-        //Register internal classes first, so they can't be overridden
-        Class[] classes = ClassDiscovery.DiscoverClasses(FunctionList.class, null, null);
-        for (int i = 0; i < classes.length; i++) {
-            Annotation[] a = classes[i].getAnnotations();
-            for (int j = 0; j < a.length; j++) {
-                Annotation ann = a[j];
-                if (ann.annotationType().equals(api.class)) {
-                    Class api = classes[i];
-                    String apiClass = (api.getEnclosingClass() != null
-                            ? api.getEnclosingClass().getName().split("\\.")[api.getEnclosingClass().getName().split("\\.").length - 1]
-                            : "<global>");
-                    if (Function.class.isAssignableFrom(api)) {
-                        try {
-                            Function f = (Function) api.newInstance();
-                            registerFunction(f, apiClass);
-                            //System.out.println("Loaded " + apiClass + "." + f.getName());
-                        } catch (InstantiationException ex) {
-                            Logger.getLogger(FunctionList.class.getName()).log(Level.SEVERE, null, ex);
-                        } catch (IllegalAccessException ex) {
-                            Logger.getLogger(FunctionList.class.getName()).log(Level.SEVERE, null, ex);
-                        }
-                    } else {
-                        System.out.println("@api functions must implement " + FunctionList.class.getPackage().getName() + ".Function! " + api.getSimpleName() + " cannot be loaded.");
-                    }
-                }
-            }
-        }
-        
-        if((Boolean)com.laytonsmith.aliasengine.Static.getPreferences().getPreference("debug-mode")){
-            System.out.println("CommandHelper: Loaded " + functions.size() + " function" + (functions.size()==1?"":"s"));
-        }
-        
-        
-
-        //Now pull all the jars from plugins/CommandHelper/functions
-        //TODO Finishing this has been defered until a later date
-        //        File f = new File("plugins/CommandHelper/functions");
-        //        f.mkdirs();
-        //        PluginLoader.loadJars(f.getAbsolutePath());
-        //        for(File file : f.listFiles()){
-        //            try {
-        //                Yaml yaml = new Yaml(new SafeConstructor());
-        //                JarFile jar = new JarFile(file);
-        //                JarEntry entry = jar.getJarEntry("main.yml");
-        //                if (entry == null) {
-        //                    throw new InvalidPluginException(new FileNotFoundException("Jar does not contain main.yml"));
-        //                }
-        //                InputStream stream = jar.getInputStream(entry);
-        //                Map<String, Object> map = (Map<String, Object>)yaml.load(stream);
-        //                System.out.println(map);
-        //                stream.close();
-        //                jar.close();
-        //            } catch(InvalidPluginException ex){
-        //                Logger.getLogger(FunctionList.class.getName()).log(Level.SEVERE, null, ex);
-        //            } catch (IOException ex) {
-        //                Logger.getLogger(FunctionList.class.getName()).log(Level.SEVERE, null, ex);
-        //        }
-        //        }
-
-    }
-
-    
-    public static void registerFunction(Function f, String apiClass) {
-        if(!apiClass.equals("Sandbox")){
-            if((Boolean)com.laytonsmith.aliasengine.Static.getPreferences().getPreference("debug-mode")){
-                System.out.println("CommandHelper: Loaded function \"" + f.getName() + "\"");
-            }
-        }
-        functions.add(f);
-    }
-
-    public static Function getFunction(Construct c) throws ConfigCompileException {
-        if (c instanceof CFunction) {
-            for (Function m : functions) {
-                if (m.getName().equals(c.val())) {
-                    return m;
-                }
-            }
-            throw new ConfigCompileException("The function \"" + c.val() + "\" does not exist");
-        }
-        throw new ConfigCompileException("Excpecting CFunction type");
-    }
-
-//    public FunctionList(User u) {
-//        this.u = u;
-//        if (functions.isEmpty()) {
-//            initFunctions();
-//        }
-//    }
-
-//    public Construct exec(String name, int line_num, Player p, Construct... args) throws ConfigCompileException, CancelCommandException {
-//        for (Function f : functions) {
-//            if (f.getName().equals(name)) {
-//                return f.exec(line_num, p, args);
-//            }
-//        }
-//        throw new ConfigCompileException("Function " + name + " is not defined");
-//    }
-//
-//    public Integer[] numArgs(String name) throws ConfigCompileException {
-//        for (Function f : functions) {
-//            if (f.getName().equals(name)) {
-//                return f.numArgs();
-//            }
-//        }
-//        throw new ConfigCompileException("Function " + name + " is not defined");
-//    }
-
-    public static ArrayList<Function> getFunctionList() {
-        return functions;
-    }
-    
-}
diff --git a/src/main/java/com/laytonsmith/aliasengine/functions/IVariableList.java b/src/main/java/com/laytonsmith/aliasengine/functions/IVariableList.java
deleted file mode 100644
index 76d0d26..0000000
--- a/src/main/java/com/laytonsmith/aliasengine/functions/IVariableList.java
+++ /dev/null
@@ -1,62 +0,0 @@
-/*
- * To change this template, choose Tools | Templates
- * and open the template in the editor.
- */
-package com.laytonsmith.aliasengine.functions;
-
-import com.laytonsmith.aliasengine.Constructs.IVariable;
-import java.util.ArrayList;
-
-/**
- *
- * @author Layton
- */
-public class IVariableList {
-    ArrayList<IVariable> varList = new ArrayList<IVariable>();
-    
-    public void set(IVariable v){
-        boolean set = false;
-        for(int i = 0; i < varList.size(); i++){
-            IVariable l = varList.get(i);
-            if(l.getName().equals(v.getName())){
-                varList.set(i, v);
-                set = true;
-                break;
-            }
-        }
-        if(!set){
-            varList.add(v);
-        }
-    }
-    
-    public IVariable get(String name){
-        for(int i = 0; i < varList.size(); i++){
-            IVariable l = varList.get(i);
-            if(l.getName().equals(name)){
-                return l;
-            }
-        }
-        IVariable v = new IVariable(name, 0, null);
-        varList.add(v);
-        return v;
-    }
-
-    @Override
-    public String toString() {
-        StringBuilder b = new StringBuilder();
-        b.append("[");
-        boolean first = true;
-        for(IVariable iv : varList){
-            if(first){
-                first = false;
-            } else {
-                b.append(", ");
-            }
-            b.append(iv.getName()).append(":").append("(").append(iv.ival().getClass().getSimpleName()).append(")").append(iv.ival().val());
-        }
-        b.append("]");
-        return b.toString();
-    }
-    
-    
-}
diff --git a/src/main/java/com/laytonsmith/aliasengine/functions/IncludeCache.java b/src/main/java/com/laytonsmith/aliasengine/functions/IncludeCache.java
deleted file mode 100644
index 89482bd..0000000
--- a/src/main/java/com/laytonsmith/aliasengine/functions/IncludeCache.java
+++ /dev/null
@@ -1,56 +0,0 @@
-/*
- * To change this template, choose Tools | Templates
- * and open the template in the editor.
- */
-package com.laytonsmith.aliasengine.functions;
-
-import com.laytonsmith.PureUtilities.fileutility.FileUtility;
-import com.laytonsmith.aliasengine.Constructs.Construct;
-import com.laytonsmith.aliasengine.GenericTreeNode;
-import com.laytonsmith.aliasengine.MScriptCompiler;
-import com.laytonsmith.aliasengine.Static;
-import com.laytonsmith.aliasengine.functions.exceptions.ConfigCompileException;
-import com.laytonsmith.aliasengine.functions.exceptions.ConfigRuntimeException;
-import java.io.File;
-import java.io.FileNotFoundException;
-import java.util.HashMap;
-
-/**
- *
- * @author Layton
- */
-public class IncludeCache {
-    private static HashMap<File, GenericTreeNode<Construct>> cache = new HashMap<File, GenericTreeNode<Construct>>();
-    
-    public static void add(File file, GenericTreeNode<Construct> tree){
-        cache.put(file, tree);
-    }
-    
-    public static GenericTreeNode<Construct> get(File file, int line_num, File myFile){
-        if(!cache.containsKey(file)){
-            //We have to pull the file from the FS, and compile it.
-            if(Static.CheckSecurity(file.getAbsolutePath())){
-                try {
-                    String s = FileUtility.read(file);
-                    GenericTreeNode<Construct> tree = MScriptCompiler.compile(MScriptCompiler.lex("g(\n" + s + "\n)", file));
-                    IncludeCache.add(file, tree);
-                } catch (ConfigCompileException ex) {
-                    throw new ConfigRuntimeException("There was a compile error when trying to include the script at " + file
-                            + "\n" + ex.getMessage() + " :: " + file.getName() + ":" + ex.getLineNum(), 
-                            Exceptions.ExceptionType.IncludeException, line_num, myFile);
-                } catch (FileNotFoundException ex) {
-                    throw new ConfigRuntimeException("The script at " + file + " could not be found.", 
-                            Exceptions.ExceptionType.IOException, line_num, myFile);
-                }
-            } else {
-                throw new ConfigRuntimeException("The script cannot access " + file + " due to restrictions imposed by the base-dir setting.", 
-                        Exceptions.ExceptionType.SecurityException, line_num, myFile);
-            }
-        }
-        return cache.get(file);
-    }
-    
-    public static void clearCache(){
-        cache.clear();
-    }
-}
diff --git a/src/main/java/com/laytonsmith/aliasengine/functions/Math.java b/src/main/java/com/laytonsmith/aliasengine/functions/Math.java
deleted file mode 100644
index eba1a96..0000000
--- a/src/main/java/com/laytonsmith/aliasengine/functions/Math.java
+++ /dev/null
@@ -1,811 +0,0 @@
-/*
- * To change this template, choose Tools | Templates
- * and open the template in the editor.
- */
-package com.laytonsmith.aliasengine.functions;
-
-import com.laytonsmith.aliasengine.functions.exceptions.CancelCommandException;
-import com.laytonsmith.aliasengine.functions.exceptions.ConfigRuntimeException;
-import com.laytonsmith.aliasengine.Constructs.*;
-import com.laytonsmith.aliasengine.Static;
-import com.laytonsmith.aliasengine.functions.Exceptions.ExceptionType;
-import java.io.File;
-import java.util.ArrayList;
-import java.util.List;
-import java.util.Random;
-import org.bukkit.command.CommandSender;
-
-/**
- *
- * @author Layton
- */
-public class Math {
-    public static String docs(){
-        return "Provides mathematical functions to scripts";
-    }
-    @api public static class add implements Function{
-
-        public String getName() {
-            return "add";
-        }
-
-        public Integer[] numArgs() {
-            return new Integer[]{Integer.MAX_VALUE};
-        }
-
-        public Construct exec(int line_num, File f, CommandSender p, Construct... args) throws CancelCommandException, ConfigRuntimeException {
-            double tally = Static.getNumber(args[0]);
-            for(int i = 1; i < args.length; i++){
-                tally += Static.getNumber(args[i]);
-            }
-            if(Static.anyDoubles(args)){
-                return new CDouble(tally, line_num, f);
-            } else {
-                return new CInt((long)tally, line_num, f);
-            }
-        }
-        
-        public ExceptionType[] thrown(){
-            return new ExceptionType[]{ExceptionType.CastException};
-        }
-
-        public String docs() {
-            return "mixed {var1, [var2...]} Adds all the arguments together, and returns either a double or an integer";
-        }
-
-        public boolean isRestricted() {
-            return false;
-        }
-
-        public void varList(IVariableList varList) {}
-
-        public boolean preResolveVariables() {
-            return true;
-        }
-        public String since() {
-            return "3.0.1";
-        }
-        public Boolean runAsync(){
-            return null;
-        }
-    }
-    
-    @api public static class subtract implements Function{
-
-        public String getName() {
-            return "subtract";
-        }
-
-        public Integer[] numArgs() {
-            return new Integer[]{Integer.MAX_VALUE};
-        }
-
-        public Construct exec(int line_num, File f, CommandSender p, Construct... args) throws CancelCommandException, ConfigRuntimeException {
-            double tally = Static.getNumber(args[0]);
-            for(int i = 1; i < args.length; i++){
-                tally -= Static.getNumber(args[i]);
-            }
-            if(Static.anyDoubles(args)){
-                return new CDouble(tally, line_num, f);
-            } else {
-                return new CInt((long)tally, line_num, f);
-            }
-        }
-        
-        public ExceptionType[] thrown(){
-            return new ExceptionType[]{ExceptionType.CastException};
-        }
-
-        public String docs() {
-            return "mixed {var1, [var2...]} Subtracts the arguments from left to right, and returns either a double or an integer";
-        }
-
-        public boolean isRestricted() {
-            return false;
-        }
-
-        public void varList(IVariableList varList) {}
-
-        public boolean preResolveVariables() {
-            return true;
-        }
-        public String since() {
-            return "3.0.1";
-        }
-        public Boolean runAsync(){
-            return null;
-        }
-    }
-    
-    @api public static class multiply implements Function{
-
-        public String getName() {
-            return "multiply";
-        }
-
-        public Integer[] numArgs() {
-            return new Integer[]{Integer.MAX_VALUE};
-        }
-
-        public Construct exec(int line_num, File f, CommandSender p, Construct... args) throws CancelCommandException, ConfigRuntimeException {
-            double tally = Static.getNumber(args[0]);
-            for(int i = 1; i < args.length; i++){
-                tally *= Static.getNumber(args[i]);
-            }
-            if(Static.anyDoubles(args)){
-                return new CDouble(tally, line_num, f);
-            } else {
-                return new CInt((long)tally, line_num, f);
-            }
-        }
-        
-        public ExceptionType[] thrown(){
-            return new ExceptionType[]{ExceptionType.CastException};
-        }
-
-        public String docs() {
-            return "mixed {var1, [var2...]} Multiplies the arguments together, and returns either a double or an integer";
-        }
-
-        public boolean isRestricted() {
-            return false;
-        }
-
-        public void varList(IVariableList varList) {}
-
-        public boolean preResolveVariables() {
-            return true;
-        }
-        public String since() {
-            return "3.0.1";
-        }
-        public Boolean runAsync(){
-            return null;
-        }
-    }
-    
-    @api public static class divide implements Function{
-
-        public String getName() {
-            return "divide";
-        }
-
-        public Integer[] numArgs() {
-            return new Integer[]{Integer.MAX_VALUE};
-        }
-
-        public Construct exec(int line_num, File f, CommandSender p, Construct... args) throws CancelCommandException, ConfigRuntimeException {
-            double tally = Static.getNumber(args[0]);
-            for(int i = 1; i < args.length; i++){
-                tally /= Static.getNumber(args[i]);
-            }
-            if(tally == (int)tally){
-                return new CInt((long)tally, line_num, f);
-            } else {
-                return new CDouble(tally, line_num, f);
-            }
-        }
-        
-        public ExceptionType[] thrown(){
-            return new ExceptionType[]{ExceptionType.CastException};
-        }
-
-        public String docs() {
-            return "mixed {var1, [var2...]} Divides the arguments from left to right, and returns either a double or an integer";
-        }
-
-        public boolean isRestricted() {
-            return false;
-        }
-
-        public void varList(IVariableList varList) {}
-
-        public boolean preResolveVariables() {
-            return true;
-        }
-        public String since() {
-            return "3.0.1";
-        }
-        public Boolean runAsync(){
-            return null;
-        }
-    }
-    
-    @api public static class mod implements Function{
-
-        public String getName() {
-            return "mod";
-        }
-
-        public Integer[] numArgs() {
-            return new Integer[]{2};
-        }
-
-        public Construct exec(int line_num, File f, CommandSender p, Construct... args) throws CancelCommandException, ConfigRuntimeException {
-            long arg1 = Static.getInt(args[0]);
-            long arg2 = Static.getInt(args[1]);
-            return new CInt(arg1 % arg2, line_num, f);
-        }
-        
-        public ExceptionType[] thrown(){
-            return new ExceptionType[]{ExceptionType.CastException};
-        }
-
-        public String docs() {
-            return "int {x, n} Returns x modulo n";
-        }
-
-        public boolean isRestricted() {
-            return false;
-        }
-
-        public void varList(IVariableList varList) {}
-
-        public boolean preResolveVariables() {
-            return true;
-        }
-        public String since() {
-            return "3.0.1";
-        }
-        public Boolean runAsync(){
-            return null;
-        }
-    }
-    
-    @api public static class pow implements Function{
-
-        public String getName() {
-            return "pow";
-        }
-
-        public Integer[] numArgs() {
-            return new Integer[]{2};
-        }
-
-        public Construct exec(int line_num, File f, CommandSender p, Construct... args) throws CancelCommandException, ConfigRuntimeException {
-            double arg1 = Static.getNumber(args[0]);
-            double arg2 = Static.getNumber(args[1]);
-            return new CDouble(java.lang.Math.pow(arg1, arg2), line_num, f);
-        }
-
-        public String docs() {
-            return "double {x, n} Returns x to the power of n";
-        }
-        
-        public ExceptionType[] thrown(){
-            return new ExceptionType[]{ExceptionType.CastException};
-        }
-
-        public boolean isRestricted() {
-            return false;
-        }
-
-        public void varList(IVariableList varList) {}
-
-        public boolean preResolveVariables() {
-            return true;
-        }
-        public String since() {
-            return "3.0.1";
-        }
-        public Boolean runAsync(){
-            return null;
-        }
-    }
-    
-    @api public static class inc implements Function{
-
-        IVariableList varList;
-        
-        public String getName() {
-            return "inc";
-        }
-
-        public Integer[] numArgs() {
-            return new Integer[]{1, 2};
-        }
-
-        public Construct exec(int line_num, File f, CommandSender p, Construct... args) throws CancelCommandException, ConfigRuntimeException {
-            if(args[0] instanceof IVariable){
-                IVariable v = varList.get(((IVariable)args[0]).getName());
-                Construct newVal;
-                long value = 1;
-                if(args.length == 2){
-                    value = Static.getInt(args[1]);
-                }
-                if(Static.anyDoubles(v.ival())){
-                    newVal = new CDouble(Static.getDouble(v.ival()) + value, line_num, f);
-                } else {
-                    newVal = new CInt(Static.getInt(v.ival()) + value, line_num, f);
-                }
-                v = new IVariable(v.getName(), newVal, line_num, f);
-                varList.set(v);
-                return v;
-            }
-            throw new ConfigRuntimeException("inc expects argument 1 to be an ivar", 
-                    ExceptionType.CastException, line_num, f);
-        }
-
-        public String docs() {
-            return "ivar {var} Adds 1 to var, and stores the new value. Equivalent to ++var in other languages. Expects ivar to be a variable, then"
-                    + " returns the ivar.";
-        }
-        
-        public ExceptionType[] thrown(){
-            return new ExceptionType[]{ExceptionType.CastException};
-        }
-
-        public boolean isRestricted() {
-            return false;
-        }
-
-        public void varList(IVariableList varList) {
-            this.varList = varList;
-        }
-
-        public boolean preResolveVariables() {
-            return false;
-        }
-        public String since() {
-            return "3.0.1";
-        }
-        public Boolean runAsync(){
-            return null;
-        }
-    }
-    
-    @api public static class dec implements Function{
-
-        IVariableList varList;
-        
-        public String getName() {
-            return "dec";
-        }
-
-        public Integer[] numArgs() {
-            return new Integer[]{1, 2};
-        }
-
-        public Construct exec(int line_num, File f, CommandSender p, Construct... args) throws CancelCommandException, ConfigRuntimeException {
-            if(args[0] instanceof IVariable){
-                IVariable v = varList.get(((IVariable)args[0]).getName());
-                long value = 1;
-                if(args.length == 2){
-                    value = Static.getInt(args[1]);
-                }
-                Construct newVal;
-                if(Static.anyDoubles(v.ival())){
-                    newVal = new CDouble(Static.getDouble(v.ival()) - value, line_num, f);
-                } else {
-                    newVal = new CInt(Static.getInt(v.ival()) - value, line_num, f);
-                }
-                v = new IVariable(v.getName(), newVal, line_num, f);
-                varList.set(v);
-                return v;
-            }
-            throw new ConfigRuntimeException("dec expects argument 1 to be an ivar", 
-                    ExceptionType.CastException, line_num, f);
-        }
-
-        public String docs() {
-            return "ivar {var, [value]} Subtracts value from var, and stores the new value. Value defaults to 1. Equivalent to --var (or var -= value) in other languages. Expects ivar to be a variable, then"
-                    + " returns the ivar.";
-        }
-        
-        public ExceptionType[] thrown(){
-            return new ExceptionType[]{ExceptionType.CastException};
-        }
-
-        public boolean isRestricted() {
-            return false;
-        }
-
-        public void varList(IVariableList varList) {
-            this.varList = varList;
-        }
-
-        public boolean preResolveVariables() {
-            return false;
-        }
-        public String since() {
-            return "3.0.1";
-        }
-        public Boolean runAsync(){
-            return null;
-        }
-    }
-    
-    @api public static class rand implements Function{
-        
-        Random r = new Random();
-
-        public String getName() {
-            return "rand";
-        }
-
-        public Integer[] numArgs() {
-            return new Integer[]{1, 2};
-        }
-
-        public String docs() {
-            return "int {min/max, [max]} Returns a random number from 0 to max, or min to max, depending on usage. Max is exclusive. Min must"
-                    + " be less than max, and both numbers must be >= 0";
-        }
-        
-        public ExceptionType[] thrown(){
-            return new ExceptionType[]{ExceptionType.RangeException, ExceptionType.CastException};
-        }
-
-        public boolean isRestricted() {
-            return false;
-        }
-
-        public void varList(IVariableList varList) {}
-
-        public boolean preResolveVariables() {
-            return true;
-        }
-
-        public String since() {
-            return "3.0.1";
-        }
-
-        public Construct exec(int line_num, File f, CommandSender p, Construct... args) throws CancelCommandException, ConfigRuntimeException {
-            long min = 0;
-            long max = 0;
-            if(args.length == 1){
-                max = Static.getInt(args[0]);
-            } else {
-                min = Static.getInt(args[0]);
-                max = Static.getInt(args[1]);
-            }
-            if(max > Integer.MAX_VALUE || min > Integer.MAX_VALUE){
-                throw new ConfigRuntimeException("max and min must be below int max, defined as " + Integer.MAX_VALUE, 
-                        ExceptionType.RangeException,
-                        line_num, f);
-            }
-           
-            long range = max - min;
-            if(range <= 0){
-                throw new ConfigRuntimeException("max - min must be greater than 0", 
-                        ExceptionType.RangeException, line_num, f);
-            }
-            long rand = java.lang.Math.abs(r.nextLong());
-            long i = (rand % (range)) + min;
-
-            return new CInt(i, line_num, f);
-        }
-        public Boolean runAsync(){
-            return null;
-        }
-    }
-    
-    @api
-    public static class abs implements Function{
-
-        public String getName() {
-            return "abs";
-        }
-
-        public Integer[] numArgs() {
-            return new Integer[]{1};
-        }
-
-        public String docs() {
-            return "double {arg} Returns the absolute value of the argument.";
-        }
-
-        public ExceptionType[] thrown() {
-            return new ExceptionType[]{ExceptionType.CastException};
-        }
-
-        public boolean isRestricted() {
-            return false;
-        }
-
-        public void varList(IVariableList varList) {}
-
-        public boolean preResolveVariables() {
-            return true;
-        }
-
-        public String since() {
-            return "3.1.2";
-        }
-
-        public Boolean runAsync() {
-            return null;
-        }
-
-        public Construct exec(int line_num, File f, CommandSender p, Construct... args) throws ConfigRuntimeException {
-            double d = Static.getDouble(args[0]);
-            return new CDouble(java.lang.Math.abs(d), line_num, f);
-        }
-        
-    }
-    
-    @api public static class floor implements Function{
-
-        public String getName() {
-            return "floor";
-        }
-
-        public Integer[] numArgs() {
-            return new Integer[]{1};
-        }
-
-        public String docs() {
-            return "int {number} Returns the floor of any given number. For example, floor(3.8) returns 3, and floor(-1.1) returns 2";
-        }
-
-        public ExceptionType[] thrown() {
-            return new ExceptionType[]{ExceptionType.CastException};
-        }
-
-        public boolean isRestricted() {
-            return false;
-        }
-
-        public void varList(IVariableList varList) {}
-
-        public boolean preResolveVariables() {
-            return true;
-        }
-
-        public String since() {
-            return "3.1.3";
-        }
-
-        public Boolean runAsync() {
-            return null;
-        }
-
-        public Construct exec(int line_num, File f, CommandSender p, Construct... args) throws ConfigRuntimeException {
-            return new CInt((long)java.lang.Math.floor(Static.getNumber(args[0])), line_num, f);
-        }
-        
-    }
-    
-    @api public static class ceil implements Function{
-
-        public String getName() {
-            return "ceil";
-        }
-
-        public Integer[] numArgs() {
-            return new Integer[]{1};
-        }
-
-        public String docs() {
-            return "int {number} Returns the ceiling of any given number. For example, ceil(3.2) returns 4, and ceil(-1.1) returns -1";
-        }
-
-        public ExceptionType[] thrown() {
-            return new ExceptionType[]{ExceptionType.CastException};
-        }
-
-        public boolean isRestricted() {
-            return false;
-        }
-
-        public void varList(IVariableList varList) {}
-
-        public boolean preResolveVariables() {
-            return true;
-        }
-
-        public String since() {
-            return "3.1.3";
-        }
-
-        public Boolean runAsync() {
-            return null;
-        }
-
-        public Construct exec(int line_num, File f, CommandSender p, Construct... args) throws ConfigRuntimeException {
-            return new CInt((long)java.lang.Math.ceil(Static.getNumber(args[0])), line_num, f);
-        }
-        
-    }
-    
-    @api public static class sqrt implements Function{
-
-        public String getName() {
-            return "sqrt";
-        }
-
-        public Integer[] numArgs() {
-            return new Integer[]{1};
-        }
-
-        public String docs() {
-            return "number {number} Returns the square root of a number. Note that this is mathematically equivalent to pow(number, .5)."
-                    + " Imaginary numbers are not supported at this time, so number must be positive.";
-        }
-
-        public ExceptionType[] thrown() {
-            return new ExceptionType[]{ExceptionType.RangeException, ExceptionType.CastException};
-        }
-
-        public boolean isRestricted() {
-            return false;
-        }
-
-        public void varList(IVariableList varList) {
-            
-        }
-
-        public boolean preResolveVariables() {
-            return true;
-        }
-
-        public String since() {
-            return "3.2.0";
-        }
-
-        public Boolean runAsync() {
-            return null;
-        }
-
-        public Construct exec(int line_num, File f, CommandSender p, Construct... args) throws ConfigRuntimeException {
-            double d = Static.getNumber(args[0]);
-            if(d < 0){
-               throw new ConfigRuntimeException("sqrt expects a number >= 0", ExceptionType.RangeException, line_num, f); 
-            }
-            double m = java.lang.Math.sqrt(d);
-            if(m == (int)m){
-                return new CInt((long) m, line_num, f);
-            } else {
-                return new CDouble(m, line_num, f);
-            }
-        }
-        
-    }
-    
-    @api public static class min implements Function{
-
-        public String getName() {
-            return "min";
-        }
-
-        public Integer[] numArgs() {
-            return new Integer[]{Integer.MAX_VALUE};
-        }
-
-        public String docs() {
-            return "number {num1, [num2...]} Returns the lowest number in a given list of numbers. If any of the arguments"
-                    + " are arrays, they are expanded into individual numbers, and also compared.";
-        }
-
-        public ExceptionType[] thrown() {
-            return new ExceptionType[]{ExceptionType.CastException, ExceptionType.InsufficientArgumentsException};
-        }
-
-        public boolean isRestricted() {
-            return false;
-        }
-
-        public void varList(IVariableList varList) {}
-
-        public boolean preResolveVariables() {
-            return true;
-        }
-
-        public String since() {
-            return "3.2.0";
-        }
-
-        public Boolean runAsync() {
-            return null;
-        }
-
-        public Construct exec(int line_num, File f, CommandSender p, Construct... args) throws ConfigRuntimeException {
-            if(args.length == 0){
-                throw new ConfigRuntimeException("You must send at least one parameter to min", 
-                        ExceptionType.InsufficientArgumentsException, line_num, f);
-            }
-            double lowest = Double.POSITIVE_INFINITY;
-            List<Construct> list = new ArrayList<Construct>();
-            recList(list, args);
-            for(Construct c : list){
-                double d = Static.getNumber(c);
-                if(d < lowest){
-                    lowest = d;
-                }
-            }
-            if(lowest == (long)lowest){
-                return new CInt((long)lowest, line_num, f);
-            } else {
-                return new CDouble(lowest, line_num, f);
-            }
-        }
-        
-        public List<Construct> recList(List<Construct> list, Construct ... args){
-            for(Construct c : args){
-                if(c instanceof CArray){
-                    for(int i = 0; i < ((CArray)c).size(); i++){
-                        recList(list, ((CArray)c).get(i, 0));
-                    }
-                } else {
-                    list.add(c);
-                }
-            }
-            return list;
-        }
-        
-    }
-    
-    @api public static class max implements Function{
-
-        public String getName() {
-            return "max";
-        }
-
-        public Integer[] numArgs() {
-            return new Integer[]{Integer.MAX_VALUE};
-        }
-
-        public String docs() {
-            return "number {num1, [num2...]} Returns the highest number in a given list of numbers. If any of the arguments"
-                    + " are arrays, they are expanded into individual numbers, and also compared.";
-        }
-
-        public ExceptionType[] thrown() {
-            return new ExceptionType[]{ExceptionType.CastException, ExceptionType.InsufficientArgumentsException};
-        }
-
-        public boolean isRestricted() {
-            return false;
-        }
-
-        public void varList(IVariableList varList) {}
-
-        public boolean preResolveVariables() {
-            return true;
-        }
-
-        public String since() {
-            return "3.2.0";
-        }
-
-        public Boolean runAsync() {
-            return null;
-        }
-
-        public Construct exec(int line_num, File f, CommandSender p, Construct... args) throws ConfigRuntimeException {
-            if(args.length == 0){
-                throw new ConfigRuntimeException("You must send at least one parameter to max", 
-                        ExceptionType.InsufficientArgumentsException, line_num, f);
-            }
-            double highest = Double.NEGATIVE_INFINITY;
-            List<Construct> list = new ArrayList<Construct>();
-            recList(list, args);
-            for(Construct c : list){
-                double d = Static.getNumber(c);
-                if(d > highest){
-                    highest = d;
-                }
-            }
-            if(highest == (long)highest){
-                return new CInt((long)highest, line_num, f);
-            } else {
-                return new CDouble(highest, line_num, f);
-            }
-        }
-        
-        public List<Construct> recList(List<Construct> list, Construct ... args){
-            for(Construct c : args){
-                if(c instanceof CArray){
-                    for(int i = 0; i < ((CArray)c).size(); i++){
-                        recList(list, ((CArray)c).get(i, 0));
-                    }
-                } else {
-                    list.add(c);
-                }
-            }
-            return list;
-        }
-        
-    }
-    
-}
diff --git a/src/main/java/com/laytonsmith/aliasengine/functions/Meta.java b/src/main/java/com/laytonsmith/aliasengine/functions/Meta.java
deleted file mode 100644
index 7790463..0000000
--- a/src/main/java/com/laytonsmith/aliasengine/functions/Meta.java
+++ /dev/null
@@ -1,442 +0,0 @@
-/*
- * To change this template, choose Tools | Templates
- * and open the template in the editor.
- */
-package com.laytonsmith.aliasengine.functions;
-
-import com.laytonsmith.aliasengine.functions.exceptions.CancelCommandException;
-import com.laytonsmith.aliasengine.functions.exceptions.ConfigRuntimeException;
-import com.laytonsmith.aliasengine.Constructs.CArray;
-import com.laytonsmith.aliasengine.Constructs.CString;
-import com.laytonsmith.aliasengine.Constructs.CVoid;
-import com.laytonsmith.aliasengine.Constructs.Construct;
-import com.laytonsmith.aliasengine.Static;
-import com.laytonsmith.aliasengine.functions.Exceptions.ExceptionType;
-import java.io.File;
-import java.lang.reflect.Field;
-import java.lang.reflect.InvocationHandler;
-import java.lang.reflect.Method;
-import java.lang.reflect.Proxy;
-import java.util.Set;
-import java.util.logging.Level;
-import net.minecraft.server.ServerConfigurationManager;
-import org.bukkit.Bukkit;
-import org.bukkit.Server;
-import org.bukkit.command.CommandSender;
-import org.bukkit.entity.Player;
-
-/**
- * I'm So Meta, Even This Acronym
- * @author Layton
- */
-public class Meta {
-
-    public static String docs() {
-        return "These functions provide a way to run other commands";
-    }
-
-    @api
-    public static class runas implements Function {
-
-        public String getName() {
-            return "runas";
-        }
-
-        public Integer[] numArgs() {
-            return new Integer[]{2};
-        }
-
-        public Construct exec(int line_num, File f, final CommandSender p, Construct... args) throws CancelCommandException, ConfigRuntimeException {
-            if (args[1].val() == null || args[1].val().length() <= 0 || args[1].val().charAt(0) != '/') {
-                throw new ConfigRuntimeException("The first character of the command must be a forward slash (i.e. '/give')",
-                        ExceptionType.FormatException, line_num, f);
-            }
-            String cmd = args[1].val().substring(1);
-            if (args[0] instanceof CArray) {
-                CArray u = (CArray) args[0];
-                for (int i = 0; i < u.size(); i++) {
-                    exec(line_num, f, p, new Construct[]{new CString(u.get(i, line_num).val(), line_num, f), args[1]});
-                }
-                return new CVoid(line_num, f);
-            }
-            if (args[0].val().equals("~op")) {
-                Boolean isOp = p.isOp();
-
-                if ((Boolean) Static.getPreferences().getPreference("debug-mode")) {
-                    if (p instanceof Player) {
-                        Static.getLogger().log(Level.INFO, "[CommandHelper]: Executing command on " + ((Player) p).getName() + ": " + args[1].val().trim());
-                    } else {
-                        Static.getLogger().log(Level.INFO, "[CommandHelper]: Executing command from console equivalent: " + args[1].val().trim());
-                    }
-                }
-
-                if (!isOp) {
-                    this.setOp(p, true);
-                }
-
-                try {
-                    Static.getServer().dispatchCommand(this.getOPCommandSender(p), cmd);
-                } finally {
-                    //If they just opped themselves, or deopped themselves in the command
-                    //don't undo what they just did.
-                    if(!cmd.equalsIgnoreCase("op " + p.getName()) && !cmd.equalsIgnoreCase("deop " + p.getName())){
-                        this.setOp(p, isOp);
-                    }
-                }
-            } else {
-                Player m = Static.getServer().getPlayer(args[0].val());
-                if (m != null && m.isOnline()) {
-                    if (p instanceof Player) {
-                        Static.getLogger().log(Level.INFO, "[CommandHelper]: Executing command on " + ((Player) p).getName() + ": " + args[0].val().trim());
-                    } else {
-                        Static.getLogger().log(Level.INFO, "[CommandHelper]: Executing command from console equivalent: " + args[0].val().trim());
-                    }
-                    //m.chat(cmd);
-                    Static.getServer().dispatchCommand(m, cmd);
-                } else {
-                    throw new ConfigRuntimeException("The player " + args[0].val() + " is not online",
-                            ExceptionType.PlayerOfflineException, line_num, f);
-                }
-            }
-            return new CVoid(line_num, f);
-        }
-
-        public ExceptionType[] thrown() {
-            return new ExceptionType[]{ExceptionType.FormatException, ExceptionType.PlayerOfflineException};
-        }
-
-        public String docs() {
-            return "void {player, command} Runs a command as a particular user. The special user '~op' is a user that runs as op. Be careful with this very powerful function."
-                    + " Commands cannot be run as an offline player. Returns void. If the first argument is an array of usernames, the command"
-                    + " will be run in the context of each user in the array.";
-        }
-
-        public boolean isRestricted() {
-            return true;
-        }
-
-        public void varList(IVariableList varList) {
-        }
-
-        public boolean preResolveVariables() {
-            return true;
-        }
-
-        public String since() {
-            return "3.0.1";
-        }
-
-        public Boolean runAsync() {
-            return false;
-        }
-
-        /**
-         * Set OP status for player without saving to ops.txt
-         * 
-         * @param player
-         * @param value 
-         */
-        protected void setOp(CommandSender player, Boolean value) {
-            if (!(player instanceof Player) || player.isOp() == value) {
-                return;
-            }
-
-            try {
-                Server server = Bukkit.getServer();
-
-                Class serverClass = Class.forName("org.bukkit.craftbukkit.CraftServer", true, server.getClass().getClassLoader());
-
-                if (!server.getClass().isAssignableFrom(serverClass)) {
-                    throw new IllegalStateException("Running server isn't CraftBukkit");
-                }
-
-                Field opSetField;
-
-                try {
-                    opSetField = ServerConfigurationManager.class.getDeclaredField("operators");
-                } catch (NoSuchFieldException e){
-                    opSetField = ServerConfigurationManager.class.getDeclaredField("h");
-                }
-
-                opSetField.setAccessible(true); // make field accessible for reflection 
-
-                // Reflection magic
-                Set opSet = (Set) opSetField.get((ServerConfigurationManager) serverClass.getMethod("getHandle").invoke(server));
-
-                // since all Java objects pass by reference, we don't need to set field back to object
-                if (value) {
-                    opSet.add(player.getName().toLowerCase());
-                } else {
-                    opSet.remove(player.getName().toLowerCase());
-                }
-
-                player.recalculatePermissions();
-                
-            } catch (ClassNotFoundException e) {
-            } catch (IllegalStateException e) {
-            } catch (Throwable e) {
-                Static.getLogger().log(Level.WARNING, "[CommandHelper]: Failed to OP player " + player.getName());
-            }
-        }
-
-        protected CommandSender getOPCommandSender(final CommandSender sender) {
-            if (sender.isOp()) {
-                return sender;
-            }
-
-            return (CommandSender) Proxy.newProxyInstance(sender.getClass().getClassLoader(),
-                    new Class[] { (sender instanceof Player) ? Player.class : CommandSender.class },
-                    new InvocationHandler() {
-                        public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
-                            String methodName = method.getName();
-                            if ("isOp".equals(methodName) || "hasPermission".equals(methodName) || "isPermissionSet".equals(methodName)) {
-                                return true;
-                            } else {
-                                return method.invoke(sender, args);
-                            }
-                        }
-                    });            
-        }
-    }
-
-    @api
-    public static class run implements Function {
-
-        public String getName() {
-            return "run";
-        }
-
-        public Integer[] numArgs() {
-            return new Integer[]{1};
-        }
-
-        public Construct exec(int line_num, File f, CommandSender p, Construct... args) throws CancelCommandException, ConfigRuntimeException {
-            if (args[0].val() == null || args[0].val().length() <= 0 || args[0].val().charAt(0) != '/') {
-                throw new ConfigRuntimeException("The first character of the command must be a forward slash (i.e. '/give')",
-                        ExceptionType.FormatException, line_num, f);
-            }
-            String cmd = args[0].val().substring(1);
-            if ((Boolean) Static.getPreferences().getPreference("debug-mode")) {
-                if (p instanceof Player) {
-                    Static.getLogger().log(Level.INFO, "[CommandHelper]: Executing command on " + ((Player) p).getName() + ": " + args[0].val().trim());
-                } else {
-                    Static.getLogger().log(Level.INFO, "[CommandHelper]: Executing command from console equivalent: " + args[0].val().trim());
-                }
-            }
-            //p.chat(cmd);
-            Static.getServer().dispatchCommand(p, cmd);
-            return new CVoid(line_num, f);
-        }
-
-        public String docs() {
-            return "void {var1} Runs a command as the current player. Useful for running commands in a loop. Note that this accepts commands like from the "
-                    + "chat; with a forward slash in front.";
-        }
-
-        public ExceptionType[] thrown() {
-            return new ExceptionType[]{ExceptionType.FormatException};
-        }
-
-        public boolean isRestricted() {
-            return false;
-        }
-
-        public void varList(IVariableList varList) {
-        }
-
-        public boolean preResolveVariables() {
-            return true;
-        }
-
-        public String since() {
-            return "3.0.1";
-        }
-
-        public Boolean runAsync() {
-            return false;
-        }
-    }
-
-    @api
-    public static class g implements Function {
-
-        public String getName() {
-            return "g";
-        }
-
-        public Integer[] numArgs() {
-            return new Integer[]{Integer.MAX_VALUE};
-        }
-
-        public Construct exec(int line_num, File f, CommandSender p, Construct... args) throws CancelCommandException, ConfigRuntimeException {
-            for (int i = 0; i < args.length; i++) {
-                args[i].val();
-            }
-            return new CVoid(line_num, f);
-        }
-
-        public String docs() {
-            return "string {func1, [func2...]} Groups any number of functions together, and returns void. ";
-        }
-
-        public ExceptionType[] thrown() {
-            return new ExceptionType[]{};
-        }
-
-        public boolean isRestricted() {
-            return false;
-        }
-
-        public void varList(IVariableList varList) {
-        }
-
-        public boolean preResolveVariables() {
-            return true;
-        }
-
-        public String since() {
-            return "3.0.1";
-        }
-
-        public Boolean runAsync() {
-            return null;
-        }
-    }
-
-    @api
-    public static class p implements Function {
-
-        public String getName() {
-            return "p";
-        }
-
-        public Integer[] numArgs() {
-            return new Integer[]{1};
-        }
-
-        public String docs() {
-            return "mixed {c} Used internally by the compiler.";
-        }
-
-        public ExceptionType[] thrown() {
-            return null;
-        }
-
-        public boolean isRestricted() {
-            return false;
-        }
-
-        public void varList(IVariableList varList) {
-        }
-
-        public boolean preResolveVariables() {
-            return true;
-        }
-
-        public String since() {
-            return "3.1.2";
-        }
-
-        public Boolean runAsync() {
-            return null;
-        }
-
-        public Construct exec(int line_num, File f, CommandSender p, Construct... args) throws ConfigRuntimeException {
-            return Static.resolveConstruct(args[0].val(), line_num, f);
-        }
-    }
-
-    @api
-    public static class eval implements Function {
-
-        public String getName() {
-            return "eval";
-        }
-
-        public Integer[] numArgs() {
-            return new Integer[]{1};
-        }
-
-        public String docs() {
-            return "string {script_string} Executes arbitrary MScript. Note that this function is very experimental, and is subject to changing or "
-                    + "removal.";
-        }
-
-        public ExceptionType[] thrown() {
-            return new ExceptionType[]{};
-        }
-
-        public boolean isRestricted() {
-            return true;
-        }
-
-        public void varList(IVariableList varList) {
-        }
-
-        public boolean preResolveVariables() {
-            return true;
-        }
-
-        public String since() {
-            return "3.1.0";
-        }
-
-        public Construct exec(int line_num, File f, CommandSender p, Construct... args) throws CancelCommandException, ConfigRuntimeException {
-            return new CVoid(line_num, f);
-        }
-        //Doesn't matter, run out of state anyways
-
-        public Boolean runAsync() {
-            return null;
-        }
-    }
-
-    @api
-    public static class call_alias implements Function {
-
-        public String getName() {
-            return "call_alias";
-        }
-
-        public Integer[] numArgs() {
-            return new Integer[]{1};
-        }
-
-        public String docs() {
-            return "void {cmd} Allows a CommandHelper alias to be called from within another alias. Typically this is not possible, as"
-                    + " a script that runs \"/jail = /jail\" for instance, would simply be calling whatever plugin that actually"
-                    + " provides the jail functionality's /jail command. However, using this function makes the command loop back"
-                    + " to CommandHelper only.";
-        }
-
-        public ExceptionType[] thrown() {
-            return new ExceptionType[]{};
-        }
-
-        public boolean isRestricted() {
-            return false;
-        }
-
-        public void varList(IVariableList varList) {
-        }
-
-        public boolean preResolveVariables() {
-            return true;
-        }
-
-        public String since() {
-            return "3.2.0";
-        }
-
-        public Boolean runAsync() {
-            return null;
-        }
-
-        public Construct exec(int line_num, File f, CommandSender p, Construct... args) throws ConfigRuntimeException {
-            Static.getAliasCore().removePlayerReference(p);
-            Static.getAliasCore().alias(args[0].val(), p, null);
-            Static.getAliasCore().addPlayerReference(p);
-            return new CVoid(line_num, f);
-        }
-    }
-}
diff --git a/src/main/java/com/laytonsmith/aliasengine/functions/Minecraft.java b/src/main/java/com/laytonsmith/aliasengine/functions/Minecraft.java
deleted file mode 100644
index 96f5dd6..0000000
--- a/src/main/java/com/laytonsmith/aliasengine/functions/Minecraft.java
+++ /dev/null
@@ -1,370 +0,0 @@
-/*
- * To change this template, choose Tools | Templates
- * and open the template in the editor.
- */
-package com.laytonsmith.aliasengine.functions;
-
-import com.laytonsmith.aliasengine.functions.exceptions.CancelCommandException;
-import com.laytonsmith.aliasengine.functions.exceptions.ConfigRuntimeException;
-import com.laytonsmith.aliasengine.Constructs.CArray;
-import com.laytonsmith.aliasengine.Constructs.CInt;
-import com.laytonsmith.aliasengine.Constructs.CString;
-import com.laytonsmith.aliasengine.Constructs.CVoid;
-import com.laytonsmith.aliasengine.Constructs.Construct;
-import com.laytonsmith.aliasengine.Static;
-import com.laytonsmith.aliasengine.functions.Exceptions.ExceptionType;
-import java.io.File;
-import java.util.List;
-import org.bukkit.DyeColor;
-import org.bukkit.Effect;
-import org.bukkit.Location;
-import org.bukkit.Material;
-import org.bukkit.World;
-import org.bukkit.command.CommandSender;
-import org.bukkit.entity.CaveSpider;
-import org.bukkit.entity.Chicken;
-import org.bukkit.entity.Cow;
-import org.bukkit.entity.Creeper;
-import org.bukkit.entity.Enderman;
-import org.bukkit.entity.Entity;
-import org.bukkit.entity.Ghast;
-import org.bukkit.entity.Pig;
-import org.bukkit.entity.PigZombie;
-import org.bukkit.entity.Player;
-import org.bukkit.entity.Sheep;
-import org.bukkit.entity.Silverfish;
-import org.bukkit.entity.Skeleton;
-import org.bukkit.entity.Slime;
-import org.bukkit.entity.Spider;
-import org.bukkit.entity.Squid;
-import org.bukkit.entity.Wolf;
-import org.bukkit.entity.Zombie;
-import org.bukkit.material.MaterialData;
-
-/**
- *
- * @author Layton
- */
-public class Minecraft {
-
-    public static String docs() {
-        return "These functions provide a hook into game functionality.";
-    }
-
-    @api
-    public static class data_values implements Function {
-
-        public String getName() {
-            return "data_values";
-        }
-
-        public Integer[] numArgs() {
-            return new Integer[]{1};
-        }
-
-        public Construct exec(int line_num, File f, CommandSender p, Construct... args) throws CancelCommandException, ConfigRuntimeException {
-            if (args[0] instanceof CInt) {
-                return new CInt(Static.getInt(args[0]), line_num, f);
-            } else {
-                String c = args[0].val();
-                return new CInt(new MaterialData(Material.matchMaterial(c)).getItemTypeId(), line_num, f);
-            }
-        }
-
-        public String docs() {
-            return "int {var1} Does a lookup to return the data value of a name. For instance, returns 1 for 'stone'. If an integer is given,"
-                    + " simply returns that number";
-        }
-
-        public ExceptionType[] thrown() {
-            return new ExceptionType[]{ExceptionType.CastException};
-        }
-
-        public boolean isRestricted() {
-            return false;
-        }
-
-        public void varList(IVariableList varList) {
-        }
-
-        public boolean preResolveVariables() {
-            return true;
-        }
-
-        public String since() {
-            return "3.0.1";
-        }
-
-        public Boolean runAsync() {
-            return false;
-        }
-    }
-
-    @api
-    public static class get_worlds implements Function {
-
-        public String getName() {
-            return "get_worlds";
-        }
-
-        public Integer[] numArgs() {
-            return new Integer[]{0};
-        }
-
-        public String docs() {
-            return "array {} Returns the names of the worlds available in this server";
-        }
-
-        public ExceptionType[] thrown() {
-            return new ExceptionType[]{};
-        }
-
-        public boolean isRestricted() {
-            return false;
-        }
-
-        public void varList(IVariableList varList) {
-        }
-
-        public boolean preResolveVariables() {
-            return true;
-        }
-
-        public String since() {
-            return "3.1.0";
-        }
-
-        public Boolean runAsync() {
-            return true;
-        }
-
-        public Construct exec(int line_num, File f, CommandSender p, Construct... args) throws CancelCommandException, ConfigRuntimeException {
-            List<World> worlds = p.getServer().getWorlds();
-            CArray c = new CArray(line_num, f);
-            for (World w : worlds) {
-                c.push(new CString(w.getName(), line_num, f));
-            }
-            return c;
-        }
-    }
-
-    @api
-    public static class spawn_mob implements Function {
-
-        public String getName() {
-            return "spawn_mob";
-        }
-
-        public Integer[] numArgs() {
-            return new Integer[]{1, 2, 3};
-        }
-
-        public String docs() {
-            return "void {mobType, [qty], [location]} Spawns qty mob of one of the following types at location. qty defaults to 1, and location defaults"
-                    + " to the location of the player. mobType can be one of: CHICKEN, COW, CREEPER, GHAST,"
-                    + " PIG, PIGZOMBIE, SHEEP, SKELETON, SLIME, SPIDER, SQUID, WOLF, ZOMBIE, CAVESPIDER,"
-                    + " ENDERMAN, SILVERFISH. Spelling matters, but capitalization doesn't. At this"
-                    + " time, the function is limited to spawning a maximum of 50 at a time. Further, SHEEP can be spawned as any color, by specifying"
-                    + " SHEEP:COLOR, where COLOR is any of the dye colors: BLACK RED GREEN BROWN BLUE PURPLE CYAN SILVER GRAY PINK LIME YELLOW LIGHT_BLUE MAGENTA ORANGE WHITE. COLOR defaults to white if not"
-                    + " specified.";
-        }
-
-        public ExceptionType[] thrown() {
-            return new ExceptionType[]{ExceptionType.CastException, ExceptionType.RangeException, ExceptionType.FormatException};
-        }
-
-        public boolean isRestricted() {
-            return true;
-        }
-
-        public void varList(IVariableList varList) {
-        }
-
-        public boolean preResolveVariables() {
-            return true;
-        }
-
-        public String since() {
-            return "3.1.2";
-        }
-
-        public Boolean runAsync() {
-            return false;
-        }
-
-        enum MOBS {
-
-            CHICKEN, COW, CREEPER, GHAST, PIG, PIGZOMBIE, SHEEP, SKELETON, SLIME, 
-            SPIDER, SQUID, WOLF, ZOMBIE, CAVESPIDER, ENDERMAN, SILVERFISH
-        }
-
-        public Construct exec(int line_num, File f, CommandSender p, Construct... args) throws CancelCommandException, ConfigRuntimeException {
-            String mob = args[0].val();
-            String sheepColor = "WHITE";
-            if (mob.toUpperCase().startsWith("SHEEP:")) {
-                sheepColor = mob.substring(6);
-                mob = "SHEEP";
-            }
-            int qty = 1;
-            if (args.length > 1) {
-                qty = (int) Static.getInt(args[1]);
-            }
-            if (qty > 50) {
-                throw new ConfigRuntimeException("A bit excessive, don't you think? Let's scale that back some, huh?",
-                        ExceptionType.RangeException, line_num, f);
-            }
-            Location l = null;
-            if (p instanceof Player) {
-                l = ((Player) p).getLocation();
-            }
-            if (args.length > 2) {
-                if (args[2] instanceof CArray) {
-                    CArray ca = (CArray) args[2];
-                    if (ca.size() == 3) {
-                        //l = new Location(p.getWorld(), Static.getNumber(ca.get(0, line_num)),
-                        //        Static.getNumber(ca.get(1, line_num)) + 1, Static.getNumber(ca.get(2, line_num)));
-                        l = Static.GetLocation(ca, (l != null?l.getWorld():null), line_num, f);
-                    } else {
-                        throw new ConfigRuntimeException("Expected argument 3 to be an array with 3 items",
-                                ExceptionType.LengthException, line_num, f);
-                    }
-                } else {
-                    throw new ConfigRuntimeException("Expected argument 3 to spawn_mob to be an array",
-                            ExceptionType.CastException, line_num, f);
-                }
-            }
-            Class mobType = null;
-            try {
-                switch (MOBS.valueOf(mob.toUpperCase())) {
-                    case CHICKEN:
-                        mobType = Chicken.class;
-                        break;
-                    case COW:
-                        mobType = Cow.class;
-                        break;
-                    case CREEPER:
-                        mobType = Creeper.class;
-                        break;
-                    case GHAST:
-                        mobType = Ghast.class;
-                        break;
-                    case PIG:
-                        mobType = Pig.class;
-                        break;
-                    case PIGZOMBIE:
-                        mobType = PigZombie.class;
-                        break;
-                    case SHEEP:
-                        mobType = Sheep.class;
-                        break;
-                    case SKELETON:
-                        mobType = Skeleton.class;
-                        break;
-                    case SLIME:
-                        mobType = Slime.class;
-                        break;
-                    case SPIDER:
-                        mobType = Spider.class;
-                        break;
-                    case SQUID:
-                        mobType = Squid.class;
-                        break;
-                    case WOLF:
-                        mobType = Wolf.class;
-                        break;
-                    case ZOMBIE:
-                        mobType = Zombie.class;
-                        break;
-                    case CAVESPIDER:
-                        mobType = CaveSpider.class;
-                        break;
-                    case ENDERMAN:
-                        mobType = Enderman.class;
-                        break;
-                    case SILVERFISH:
-                        mobType = Silverfish.class;
-                }
-            } catch (IllegalArgumentException e) {
-                throw new ConfigRuntimeException("No mob of type " + mob + " exists",
-                        ExceptionType.FormatException, line_num, f);
-            }
-            if (l.getWorld() != null) {
-                for (int i = 0; i < qty; i++) {
-                    Entity e = l.getWorld().spawn(l, mobType);
-                    if (e instanceof Sheep) {
-                        Sheep s = (Sheep) e;
-                        try {
-                            s.setColor(DyeColor.valueOf(sheepColor.toUpperCase()));
-                        } catch (IllegalArgumentException ex) {
-                            throw new ConfigRuntimeException(sheepColor.toUpperCase() + " is not a valid color",
-                                    ExceptionType.FormatException, line_num, f);
-                        }
-                    }
-                }
-            } else {
-                throw new ConfigRuntimeException("World was not specified", ExceptionType.InvalidWorldException, line_num, f);
-            }
-            return new CVoid(line_num, f);
-        }
-    }
-    
-    @api public static class make_effect implements Function{
-
-        public String getName() {
-            return "make_effect";
-        }
-
-        public Integer[] numArgs() {
-            return new Integer[]{2, 3};
-        }
-
-        public String docs() {
-            return "void {xyzArray, effect, [radius]} Plays the specified effect (sound effect) at the given location, for all players within"
-                    + " the radius (or 64 by default). The effect can be one of the following:"
-                    + " BOW_FIRE, CLICK1, CLICK2, DOOR_TOGGLE, EXTINGUISH.";
-        }
-
-        public ExceptionType[] thrown() {
-            return new ExceptionType[]{ExceptionType.CastException, ExceptionType.FormatException};
-        }
-
-        public boolean isRestricted() {
-            return true;
-        }
-
-        public void varList(IVariableList varList) {}
-
-        public boolean preResolveVariables() {
-            return true;
-        }
-
-        public String since() {
-            return "3.1.3";
-        }
-
-        public Boolean runAsync() {
-            return false;
-        }
-
-        public Construct exec(int line_num, File f, CommandSender p, Construct... args) throws ConfigRuntimeException {
-            Location l = Static.GetLocation(args[0], (p instanceof Player?((Player)p).getWorld():null), line_num, f);
-            Effect e = null;
-            try{
-                e = Effect.valueOf(args[1].val().toUpperCase());
-                if(e.equals(Effect.RECORD_PLAY) || e.equals(Effect.SMOKE) || e.equals(Effect.STEP_SOUND)){
-                    throw new IllegalArgumentException();
-                }
-            } catch(IllegalArgumentException ex){
-                throw new ConfigRuntimeException("The effect type " + args[1].val() + " is not valid", ExceptionType.FormatException, line_num, f);
-            }
-            int data = 0;
-            int radius = 64;
-            if(args.length == 3){
-                radius = (int) Static.getInt(args[2]);
-            }
-            l.getWorld().playEffect(l, e, data, radius);
-            return new CVoid(line_num, f);
-        }
-        
-    }
-}
diff --git a/src/main/java/com/laytonsmith/aliasengine/functions/Persistance.java b/src/main/java/com/laytonsmith/aliasengine/functions/Persistance.java
deleted file mode 100644
index 13aa15e..0000000
--- a/src/main/java/com/laytonsmith/aliasengine/functions/Persistance.java
+++ /dev/null
@@ -1,194 +0,0 @@
-/*
- * To change this template, choose Tools | Templates
- * and open the template in the editor.
- */
-package com.laytonsmith.aliasengine.functions;
-
-import com.laytonsmith.aliasengine.functions.exceptions.CancelCommandException;
-import com.laytonsmith.aliasengine.functions.exceptions.ConfigRuntimeException;
-import com.laytonsmith.aliasengine.Constructs.CBoolean;
-import com.laytonsmith.aliasengine.Constructs.CNull;
-import com.laytonsmith.aliasengine.Constructs.CVoid;
-import com.laytonsmith.aliasengine.Constructs.Construct;
-import com.laytonsmith.aliasengine.Static;
-import com.laytonsmith.aliasengine.functions.Exceptions.ExceptionType;
-import com.laytonsmith.aliasengine.functions.exceptions.MarshalException;
-import java.io.File;
-import java.util.logging.Level;
-import java.util.logging.Logger;
-import org.bukkit.command.CommandSender;
-
-/**
- *
- * @author Layton
- */
-public class Persistance {
-    public static String docs(){
-        return "Allows scripts to store data from execution to execution. See the guide on [[CommandHelper/Persistance|persistance]] for more information.";
-    }
-    
-    @api public static class store_value implements Function{
-
-        public String getName() {
-            return "store_value";
-        }
-
-        public Integer[] numArgs() {
-            return new Integer[]{2};
-        }
-
-        public String docs() {
-            return "void {key, value} Allows you to store a value, which can then be retrieved later. key must be a string containing"
-                    + " only letters, numbers, underscores.";
-        }
-        
-        public ExceptionType[] thrown(){
-            return new ExceptionType[]{ExceptionType.FormatException};
-        }
-
-        public boolean isRestricted() {
-            return true;
-        }
-
-        public void varList(IVariableList varList) {}
-
-        public boolean preResolveVariables() {
-            return true;
-        }
-
-        public String since() {
-            return "3.0.2";
-        }
-
-        public Construct exec(int line_num, File f, CommandSender p, Construct... args) throws CancelCommandException, ConfigRuntimeException {
-            String key = args[0].val();
-            String value = null;
-            try{
-                value = Construct.json_encode(args[1]);
-            } catch(MarshalException e){
-                throw new ConfigRuntimeException(e.getMessage(), line_num, f);
-            }
-            for(int i = 0; i < key.length(); i++){
-                Character c = key.charAt(i);
-                if(c != '_' && !Character.isLetterOrDigit(c)){
-                    throw new ConfigRuntimeException("Param 1 in store_value must only contain letters, digits, or underscores.",
-                            ExceptionType.FormatException, line_num, f);
-                }
-            }
-            Static.getPersistance().setValue(new String[]{"commandhelper", "function", "storage", key}, value);
-            Static.getPersistance().setValue(new String[]{}, null);
-            try {
-                com.laytonsmith.aliasengine.Static.getPersistance().save();
-            } catch (Exception ex) {
-                Logger.getLogger(Persistance.class.getName()).log(Level.SEVERE, null, ex);
-            }
-            return new CVoid(line_num, f);
-        }
-        
-        public Boolean runAsync(){
-            //Because we do IO
-            return true;
-        }
-        
-    }
-    
-    @api public static class get_value implements Function{
-
-        public String getName() {
-            return "get_value";
-        }
-
-        public Integer[] numArgs() {
-            return new Integer[]{1};
-        }
-
-        public String docs() {
-            return "Mixed {key} Returns a stored value stored with store_value. If the key doesn't exist in storage, null"
-                    + " is returned. On a more detailed note: If the value stored in the persistance database is not actually a construct,"
-                    + " then null is also returned.";
-        }
-        
-        public ExceptionType[] thrown(){
-            return new ExceptionType[]{};
-        }
-
-        public boolean isRestricted() {
-            return true;
-        }
-
-        public void varList(IVariableList varList) {}
-
-        public boolean preResolveVariables() {
-            return true;
-        }
-
-        public String since() {
-            return "3.0.2";
-        }
-
-        public Construct exec(int line_num, File f, CommandSender p, Construct... args) throws CancelCommandException, ConfigRuntimeException {            
-            Object o;
-            try {
-                Object obj = Static.getPersistance().getValue(new String[]{"commandhelper", "function", "storage", args[0].val()});
-                if(obj == null){
-                    return new CNull(line_num, f);
-                }
-                o = Construct.json_decode(obj.toString());
-            } catch (MarshalException ex) {
-                throw new ConfigRuntimeException(ex.getMessage(), line_num, f);
-            }
-            try{
-                return (Construct)o;
-            } catch(ClassCastException e){
-                return new CNull(line_num, f);
-            }
-        }
-        public Boolean runAsync(){
-            //Because we do IO
-            return true;
-        }
-        
-    }
-    
-    public static class has_value implements Function{
-
-        public String getName() {
-            return "has_value";
-        }
-
-        public Integer[] numArgs() {
-            return new Integer[]{1};
-        }
-
-        public String docs() {
-            return "boolean {key} Returns whether or not there is data stored at the specified key in the Persistance database.";
-        }
-
-        public ExceptionType[] thrown() {
-            return null;
-        }
-
-        public boolean isRestricted() {
-            return true;
-        }
-
-        public void varList(IVariableList varList) {}
-
-        public boolean preResolveVariables() {
-            return true;
-        }
-
-        public String since() {
-            return "3.1.2";
-        }
-
-        public Boolean runAsync() {
-            return true;
-        }
-
-        public Construct exec(int line_num, File f, CommandSender p, Construct... args) throws ConfigRuntimeException {
-            return new CBoolean(Static.getPersistance().isKeySet(new String[]{"commandhelper", "function", "storage", args[0].val()}), line_num, f);
-        }
-        
-    }
-}
diff --git a/src/main/java/com/laytonsmith/aliasengine/functions/PlayerManangement.java b/src/main/java/com/laytonsmith/aliasengine/functions/PlayerManangement.java
deleted file mode 100644
index 826080c..0000000
--- a/src/main/java/com/laytonsmith/aliasengine/functions/PlayerManangement.java
+++ /dev/null
@@ -1,1944 +0,0 @@
-/*
- * To change this template, choose Tools | Templates
- * and open the template in the editor.
- */
-package com.laytonsmith.aliasengine.functions;
-
-import com.laytonsmith.aliasengine.functions.exceptions.CancelCommandException;
-import com.laytonsmith.aliasengine.functions.exceptions.ConfigRuntimeException;
-import com.laytonsmith.aliasengine.Constructs.CArray;
-import com.laytonsmith.aliasengine.Constructs.CBoolean;
-import com.laytonsmith.aliasengine.Constructs.CDouble;
-import com.laytonsmith.aliasengine.Constructs.CInt;
-import com.laytonsmith.aliasengine.Constructs.CNull;
-import com.laytonsmith.aliasengine.Constructs.CString;
-import com.laytonsmith.aliasengine.Constructs.CVoid;
-import com.laytonsmith.aliasengine.Constructs.Construct;
-import com.laytonsmith.aliasengine.Static;
-import com.laytonsmith.aliasengine.functions.Exceptions.ExceptionType;
-import java.io.File;
-import java.lang.reflect.InvocationTargetException;
-import java.lang.reflect.Method;
-import java.util.ArrayList;
-import java.util.logging.Level;
-import java.util.logging.Logger;
-import net.minecraft.server.EntityLiving;
-import net.minecraft.server.EntityPlayer;
-import net.minecraft.server.MobEffect;
-import org.bukkit.GameMode;
-import org.bukkit.Location;
-import org.bukkit.block.Block;
-import org.bukkit.command.CommandSender;
-import org.bukkit.command.ConsoleCommandSender;
-import org.bukkit.craftbukkit.entity.CraftPlayer;
-import org.bukkit.entity.Player;
-import org.bukkit.inventory.ItemStack;
-import org.bukkit.inventory.PlayerInventory;
-
-/**
- *
- * @author Layton
- */
-public class PlayerManangement {
-
-    public static String docs() {
-        return "This class of functions allow a players to be managed";
-    }
-
-    @api
-    public static class player implements Function {
-
-        public String getName() {
-            return "player";
-        }
-
-        public Integer[] numArgs() {
-            return new Integer[]{0};
-        }
-
-        public Construct exec(int line_num, File f, CommandSender p, Construct... args) throws CancelCommandException, ConfigRuntimeException {
-            if(p instanceof Player){
-                return new CString(((Player)p).getName(), line_num, f);            
-            } else if(p instanceof ConsoleCommandSender){
-                return new CString("~console", line_num, f);
-            } else {
-                return new CNull(line_num, f);
-            }
-        }
-
-        public String docs() {
-            return "string {} Returns the name of the player running the command. If the command is being run from the console, then the string '~console'"
-                    + " is returned. If the command is coming from elsewhere, null is returned, and the behavior is undefined. Note that most functions"
-                    + " won't support the user '~console' (they'll throw a PlayerOfflineException), but you can use this to determine where a command is being run from.";
-        }
-
-        public ExceptionType[] thrown() {
-            return new ExceptionType[]{};
-        }
-
-        public boolean isRestricted() {
-            return false;
-        }
-
-        public void varList(IVariableList varList) {
-        }
-
-        public boolean preResolveVariables() {
-            return true;
-        }
-
-        public String since() {
-            return "3.0.1";
-        }
-
-        public Boolean runAsync() {
-            return false;
-        }
-    }
-
-    @api
-    public static class all_players implements Function {
-
-        public String getName() {
-            return "all_players";
-        }
-
-        public Integer[] numArgs() {
-            return new Integer[]{0};
-        }
-
-        public Construct exec(int line_num, File f, CommandSender p, Construct... args) throws CancelCommandException, ConfigRuntimeException {
-            Player[] pa = Static.getServer().getOnlinePlayers();
-            CString[] sa = new CString[pa.length];
-            for (int i = 0; i < pa.length; i++) {
-                sa[i] = new CString(pa[i].getName(), line_num, f);
-            }
-            return new CArray(line_num, f, sa);
-        }
-
-        public String docs() {
-            return "array {} Returns an array of all the player names of all the online players on the server";
-        }
-
-        public ExceptionType[] thrown() {
-            return new ExceptionType[]{};
-        }
-
-        public boolean isRestricted() {
-            return true;
-        }
-
-        public void varList(IVariableList varList) {
-        }
-
-        public boolean preResolveVariables() {
-            return true;
-        }
-
-        public String since() {
-            return "3.0.1";
-        }
-
-        public Boolean runAsync() {
-            return false;
-        }
-    }
-
-    @api
-    public static class ploc implements Function {
-
-        public String getName() {
-            return "ploc";
-        }
-
-        public Integer[] numArgs() {
-            return new Integer[]{0, 1};
-        }
-
-        public Construct exec(int line_num, File f, CommandSender p, Construct... args) throws CancelCommandException, ConfigRuntimeException {
-            Player m = null;
-            if(p instanceof Player){
-                m = (Player)p;
-            }
-            if (args.length == 1) {
-                m = Static.getServer().getPlayer(args[0].val());
-                if (m == null || !m.isOnline()) {
-                    throw new ConfigRuntimeException("The player is not online", 
-                            ExceptionType.PlayerOfflineException, line_num, f);
-                }
-            }
-            if(m == null){
-                throw new ConfigRuntimeException("Player was not specified", ExceptionType.PlayerOfflineException, line_num, f);
-            }
-            Location l = m.getLocation();
-            return new CArray(line_num, f, 
-                    new CDouble(l.getX(), line_num, f),
-                    new CDouble(l.getY() - 1, line_num, f),
-                    new CDouble(l.getZ(), line_num, f));
-        }
-
-        public String docs() {
-            return "array {[playerName]} Returns an array of x, y, z coords of the player specified, or the player running the command otherwise. Note that the y coordinate is"
-                    + " in relation to the player's head, not their feet.";
-        }
-
-        public ExceptionType[] thrown() {
-            return new ExceptionType[]{ExceptionType.PlayerOfflineException};
-        }
-
-        public boolean isRestricted() {
-            return true;
-        }
-
-        public void varList(IVariableList varList) {
-        }
-
-        public boolean preResolveVariables() {
-            return true;
-        }
-
-        public String since() {
-            return "3.0.1";
-        }
-
-        public Boolean runAsync() {
-            return false;
-        }
-    }
-
-    @api
-    public static class set_ploc implements Function {
-
-        public String getName() {
-            return "set_ploc";
-        }
-
-        public Integer[] numArgs() {
-            return new Integer[]{1, 2, 3, 4};
-        }
-
-        public String docs() {
-            return "boolean {[player], xyzArray | [player], x, y, z} Sets the location of the player to the specified coordinates. If the coordinates"
-                    + " are not valid, or the player was otherwise prevented from moving, false is returned, otherwise true. If player is omitted, "
-                    + " the current player is used. Note that 1 is automatically added to the y component, which means that sending a player to"
-                    + " x, y, z coordinates shown with F3 will work as expected, instead of getting them stuck inside the floor. ";
-        }
-
-        public ExceptionType[] thrown() {
-            return new ExceptionType[]{ExceptionType.CastException, ExceptionType.LengthException, ExceptionType.PlayerOfflineException, ExceptionType.FormatException};
-        }
-
-        public boolean isRestricted() {
-            return true;
-        }
-
-        public void varList(IVariableList varList) {
-        }
-
-        public boolean preResolveVariables() {
-            return true;
-        }
-
-        public String since() {
-            return "3.1.0";
-        }
-
-        public Boolean runAsync() {
-            return false;
-        }
-
-        public Construct exec(int line_num, File f, CommandSender p, Construct... args) throws CancelCommandException, ConfigRuntimeException {
-            String player = null;
-            double x;
-            double y;
-            double z;
-            Player m = null;
-            Location l = null;
-            if (args.length == 1) {
-                if (args[0] instanceof CArray) {
-                    CArray ca = (CArray) args[0];
-                    l = Static.GetLocation(ca, (p instanceof Player?((Player)p).getWorld():null), line_num, f);                                       
-                    x = Static.getNumber(ca.get(0, line_num));
-                    y = Static.getNumber(ca.get(1, line_num));
-                    z = Static.getNumber(ca.get(2, line_num));
-                    if(p instanceof Player){
-                        m = ((Player)p);
-                    }
-
-                } else {
-                    throw new ConfigRuntimeException("Expecting an array at parameter 1 of set_ploc", 
-                            ExceptionType.CastException, line_num, f);
-                }
-            } else if (args.length == 2) {
-                if (args[1] instanceof CArray) {
-                    CArray ca = (CArray) args[1];
-                    player = args[0].val();
-                    l = Static.GetLocation(ca, Static.getServer().getPlayer(player).getWorld(), line_num, f);
-                    x = l.getX();
-                    y = l.getY();
-                    z = l.getZ();
-                } else {
-                    throw new ConfigRuntimeException("Expecting parameter 2 to be an array in set_ploc", 
-                            ExceptionType.CastException, line_num, f);
-                }
-            } else if (args.length == 3) {
-                if(p instanceof Player){
-                    m = (Player)p;
-                }
-                x = Static.getNumber(args[0]);
-                y = Static.getNumber(args[1]);
-                z = Static.getNumber(args[2]);
-                l = m.getLocation();
-            } else {
-                player = args[0].val();
-                x = Static.getNumber(args[1]);
-                y = Static.getNumber(args[2]);
-                z = Static.getNumber(args[3]);
-                l = new Location(Static.getServer().getPlayer(player).getWorld(), x, y, z);
-            }
-            if (m == null && player != null) {
-                m = Static.getServer().getPlayer(player);
-            }
-            if (m == null || !m.isOnline()) {
-                throw new ConfigRuntimeException("That player is not online", 
-                        ExceptionType.PlayerOfflineException, line_num, f);
-            }
-            return new CBoolean(m.teleport(new Location(l.getWorld(), x, y + 1, z, m.getLocation().getYaw(), m.getLocation().getPitch())), line_num, f);
-        }
-    }
-
-    @api
-    public static class pcursor implements Function {
-
-        public String getName() {
-            return "pcursor";
-        }
-
-        public Integer[] numArgs() {
-            return new Integer[]{0, 1};
-        }
-
-        public String docs() {
-            return "array {[player]} Returns an array with the x, y, z coordinates of the block the player has highlighted"
-                    + " in their crosshairs. If player is omitted, the current player is used. If the block is too far, a"
-                    + " RangeException is thrown.";
-        }
-
-        public ExceptionType[] thrown() {
-            return new ExceptionType[]{ExceptionType.PlayerOfflineException, ExceptionType.RangeException};
-        }
-
-        public boolean isRestricted() {
-            return true;
-        }
-
-        public void varList(IVariableList varList) {
-        }
-
-        public boolean preResolveVariables() {
-            return true;
-        }
-
-        public String since() {
-            return "3.0.2";
-        }
-
-        public Construct exec(int line_num, File f, CommandSender p, Construct... args) throws CancelCommandException, ConfigRuntimeException {
-            Player m = null;
-            if (args.length == 0) {
-                if(p instanceof Player){
-                    m = (Player)p;
-                }
-            } else {
-                m = Static.getServer().getPlayer(args[0].val());
-                if (m == null || !m.isOnline()) {
-                    throw new ConfigRuntimeException("That player is not online", 
-                            ExceptionType.PlayerOfflineException, line_num, f);
-                }
-            }
-            if(m != null){
-                Block b = m.getTargetBlock(null, 200);
-                if (b == null) {
-                    throw new ConfigRuntimeException("No block in sight, or block too far", 
-                            ExceptionType.RangeException, line_num, f);
-                }
-                return new CArray(line_num, f, new CInt(b.getX(), line_num, f), new CInt(b.getY(), line_num, f), new CInt(b.getZ(), line_num, f));
-            } else {
-                throw new ConfigRuntimeException("Player was not specified", ExceptionType.PlayerOfflineException, line_num, f); 
-            }
-        }
-
-        public Boolean runAsync() {
-            return false;
-        }
-    }
-
-    @api
-    public static class kill implements Function {
-
-        public String getName() {
-            return "kill";
-        }
-
-        public Integer[] numArgs() {
-            return new Integer[]{0, 1};
-        }
-
-        public Construct exec(int line_num, File f, CommandSender p, Construct... args) throws CancelCommandException, ConfigRuntimeException {
-            Player m = null;
-            if (args.length == 1) {
-                m = Static.getServer().getPlayer(args[0].val());
-            } else {
-                if(p instanceof Player){
-                    m = (Player)p;
-                }
-            }
-            if (m == null || !m.isOnline()) {
-                throw new ConfigRuntimeException("The player is not online", 
-                        ExceptionType.PlayerOfflineException, line_num, f);
-            }
-            m.setHealth(0);
-            return new CVoid(line_num, f);
-        }
-
-        public String docs() {
-            return "void {[playerName]} Kills the specified player, or the current player if it is omitted";
-        }
-
-        public ExceptionType[] thrown() {
-            return new ExceptionType[]{ExceptionType.PlayerOfflineException};
-        }
-
-        public boolean isRestricted() {
-            return true;
-        }
-
-        public void varList(IVariableList varList) {
-        }
-
-        public boolean preResolveVariables() {
-            return true;
-        }
-
-        public String since() {
-            return "3.0.1";
-        }
-
-        public Boolean runAsync() {
-            return false;
-        }
-    }
-
-    @api
-    public static class pgroup implements Function {
-
-        public String getName() {
-            return "pgroup";
-        }
-
-        public Integer[] numArgs() {
-            return new Integer[]{0, 1};
-        }
-
-        public Construct exec(int line_num, File f, CommandSender p, Construct... args) throws CancelCommandException, ConfigRuntimeException {
-            Player m = null;
-            if (args.length == 0) {
-                if(p instanceof Player){
-                    m = (Player)p;
-                }
-            } else {
-                m = Static.getServer().getPlayer(args[0].val());
-            }
-            
-            if(m == null){
-                throw new ConfigRuntimeException("Player was not specified, or is offline", ExceptionType.PlayerOfflineException, line_num, f);
-            }
-            if (m == null || !m.isOnline()) {
-                throw new ConfigRuntimeException("That player is not online.", 
-                        ExceptionType.PlayerOfflineException, line_num, f);
-            }
-            String[] sa = Static.getPermissionsResolverManager().getGroups(m.getName());
-            Construct[] ca = new Construct[sa.length];
-            for (int i = 0; i < sa.length; i++) {
-                ca[i] = new CString(sa[i], line_num, f);
-            }
-            CArray a = new CArray(line_num, f, ca);
-            return a;
-        }
-
-        public String docs() {
-            return "array {[playerName]} Returns an array of the groups a player is in. If playerName is omitted, the current player is used.";
-        }
-
-        public ExceptionType[] thrown() {
-            return new ExceptionType[]{ExceptionType.PlayerOfflineException};
-        }
-
-        public boolean isRestricted() {
-            return true;
-        }
-
-        public void varList(IVariableList varList) {
-        }
-
-        public boolean preResolveVariables() {
-            return true;
-        }
-
-        public String since() {
-            return "3.0.1";
-        }
-
-        public Boolean runAsync() {
-            return false;
-        }
-    }
-
-    @api
-    public static class pinfo implements Function {
-
-        public String getName() {
-            return "pinfo";
-        }
-
-        public Integer[] numArgs() {
-            return new Integer[]{0, 1, 2};
-        }
-
-        public String docs() {
-            return "mixed {[pName], [value]} Returns various information about the player specified, or the current player if no argument was given."
-                    + "If value is set, it should be an integer of one of the following indexes, and only that information for that index"
-                    + " will be returned. Otherwise if value is not specified (or is -1), it returns an array of"
-                    + " information with the following pieces of information in the specified index: "
-                    + "<ul><li>0 - Player's name; This will return the player's exact name, "
-                    + " even if called with a partial match.</li><li>1 - Player's location; an array of the player's xyz coordinates</li><li>2 - Player's cursor; an array of the "
-                    + "location of the player's cursor, or null if the block is out of sight.</li><li>3 - Player's IP; Returns the IP address of this player.</li><li>4 - Display name; The name that is used when the"
-                    + " player's name is displayed on screen typically. </li><li>5 - Player's health; Gets the current health of the player, which will be an int"
-                    + " from 0-20.</li><li>6 - Item in hand; The value returned by this will be similar to the value returned by get_block_at()</li><li>7 - "
-                    + "World name; Gets the name of the world this player is in.</li><li>8 - Is Op; true or false if this player is an op.</li><li>9 - Player groups;"
-                    + " An array of the permissions groups the player is in.</li></ul>";
-        }
-
-        public ExceptionType[] thrown() {
-            return new ExceptionType[]{ExceptionType.PlayerOfflineException, ExceptionType.RangeException, ExceptionType.CastException};
-        }
-
-        public boolean isRestricted() {
-            return true;
-        }
-
-        public void varList(IVariableList varList) {
-        }
-
-        public boolean preResolveVariables() {
-            return true;
-        }
-
-        public String since() {
-            return "3.1.0";
-        }
-
-        public Boolean runAsync() {
-            return false;
-        }
-
-        public Construct exec(int line_num, File f, CommandSender m, Construct... args) throws CancelCommandException, ConfigRuntimeException {
-            String player = "";
-            int index = -1;
-            if (args.length == 0) {
-                player = (m instanceof Player?((Player)m).getName():null);
-                index = -1;
-            } else if (args.length == 1) {
-                player = args[0].val();
-                index = -1;
-            } else {
-                player = args[0].val();
-                index = (int) Static.getInt(args[1]);
-            }
-            if(player == null){
-                throw new ConfigRuntimeException("Player was not specified", ExceptionType.PlayerOfflineException, line_num, f);
-            }
-            Player p = Static.getServer().getPlayer(player);
-            if (p == null || !p.isOnline()) {
-                throw new ConfigRuntimeException("The specified player is not online", 
-                        ExceptionType.PlayerOfflineException, line_num, f);
-            }
-            if (index < -1 || index > 9) {
-                throw new ConfigRuntimeException("pinfo expects the index to be between -1 and 8", 
-                        ExceptionType.RangeException, line_num, f);
-            }
-            assert index >= -1 && index <= 9;
-            ArrayList<Construct> retVals = new ArrayList<Construct>();
-            if (index == 0 || index == -1) {
-                //Player name 
-                retVals.add(new CString(p.getName(), line_num, f));
-            }
-            if (index == 1 || index == -1) {
-                //Player location
-                retVals.add(new CArray(line_num, f, new CDouble(p.getLocation().getX(), line_num, f),
-                        new CDouble(p.getLocation().getY() - 1, line_num, f), new CDouble(p.getLocation().getZ(), line_num, f)));
-            }
-            if (index == 2 || index == -1) {
-                //Player cursor
-                Block b = p.getTargetBlock(null, 200);
-                if (b == null) {
-                    retVals.add(new CNull(line_num, f));
-                } else {
-                    retVals.add(new CArray(line_num, f, new CInt(b.getX(), line_num, f), new CInt(b.getY(), line_num, f), new CInt(b.getZ(), line_num, f)));
-                }
-            }
-            if (index == 3 || index == -1) {
-                //Player IP
-                retVals.add(new CString(p.getAddress().getHostName(), line_num, f));
-            }
-            if (index == 4 || index == -1) {
-                //Display name
-                retVals.add(new CString(p.getDisplayName(), line_num, f));
-            }
-            if (index == 5 || index == -1) {
-                //Player health
-                retVals.add(new CInt((long) p.getHealth(), line_num, f));
-            }
-            if (index == 6 || index == -1) {
-                //Item in hand
-                ItemStack is = p.getItemInHand();
-                byte data = 0;
-                if (is.getData() != null) {
-                    data = is.getData().getData();
-                }
-                retVals.add(new CString(is.getTypeId() + ":" + data, line_num, f));
-            }
-            if (index == 7 || index == -1) {
-                //World name
-                retVals.add(new CString(p.getWorld().getName(), line_num, f));
-            }
-            if (index == 8 || index == -1) {
-                //Is op
-                retVals.add(new CBoolean(p.isOp(), line_num, f));
-            }
-            if (index == 9 || index == -1) {
-                //Player groups
-                String[] sa = Static.getPermissionsResolverManager().getGroups(p.getName());
-                Construct[] ca = new Construct[sa.length];
-                for (int i = 0; i < sa.length; i++) {
-                    ca[i] = new CString(sa[i], line_num, f);
-                }
-                CArray a = new CArray(line_num, f, ca);
-                retVals.add(a);
-            }
-            if (retVals.size() == 1) {
-                return retVals.get(0);
-            } else {
-                CArray ca = new CArray(line_num, f);
-                for (Construct c : retVals) {
-                    ca.push(c);
-                }
-                return ca;
-            }
-        }
-    }
-
-    @api
-    public static class pworld implements Function {
-
-        public String getName() {
-            return "pworld";
-        }
-
-        public Integer[] numArgs() {
-            return new Integer[]{0, 1};
-        }
-
-        public String docs() {
-            return "string {[playerName]} Gets the world of the player specified, or the current player, if playerName isn't specified.";
-        }
-
-        public ExceptionType[] thrown() {
-            return new ExceptionType[]{ExceptionType.PlayerOfflineException};
-        }
-
-        public boolean isRestricted() {
-            return true;
-        }
-
-        public void varList(IVariableList varList) {
-        }
-
-        public boolean preResolveVariables() {
-            return true;
-        }
-
-        public String since() {
-            return "3.1.0";
-        }
-
-        public Boolean runAsync() {
-            return true;
-        }
-
-        public Construct exec(int line_num, File f, CommandSender p, Construct... args) throws CancelCommandException, ConfigRuntimeException {
-            Player m = null;
-            if (args.length == 0) {
-                if(p instanceof Player){
-                    m = (Player)p;
-                }
-            } else {
-                m = Static.getServer().getPlayer(args[0].val());
-                if (m == null || !m.isOnline()) {
-                    throw new ConfigRuntimeException("That player is not online", 
-                            ExceptionType.PlayerOfflineException, line_num, f);
-                }
-            }
-            return new CString(m.getWorld().getName(), line_num, f);
-        }
-    }
-
-    @api
-    public static class kick implements Function {
-
-        public String getName() {
-            return "kick";
-        }
-
-        public Integer[] numArgs() {
-            return new Integer[]{0, 1, 2};
-        }
-
-        public String docs() {
-            return "void {[playerName], [message]} Kicks the specified player, with an optional message. If no message is specified, "
-                    + "\"You have been kicked\" is used. If no player is specified, the current player is used, with the default message.";
-        }
-
-        public ExceptionType[] thrown() {
-            return new ExceptionType[]{ExceptionType.PlayerOfflineException};
-        }
-
-        public boolean isRestricted() {
-            return true;
-        }
-
-        public void varList(IVariableList varList) {
-        }
-
-        public boolean preResolveVariables() {
-            return true;
-        }
-
-        public String since() {
-            return "3.1.0";
-        }
-
-        public Boolean runAsync() {
-            return false;
-        }
-
-        public Construct exec(int line_num, File f, CommandSender p, Construct... args) throws CancelCommandException, ConfigRuntimeException {
-            String message = "You have been kicked";
-            Player m = null;
-            if (args.length == 0) {
-                if(p instanceof Player){
-                    m = (Player)p;
-                }
-            }
-            if (args.length >= 1) {
-                m = Static.getServer().getPlayer(args[0].val());
-            }
-            if (args.length >= 2) {
-                message = args[1].val();
-            }
-            Player ptok = m;
-            if (ptok != null && ptok.isOnline()) {
-                ptok.kickPlayer(message);
-                return new CVoid(line_num, f);
-            } else {
-                throw new ConfigRuntimeException("The specified player does not seem to be online", 
-                        ExceptionType.PlayerOfflineException, line_num, f);
-            }
-        }
-    }
-
-    @api
-    public static class set_display_name implements Function {
-
-        public String getName() {
-            return "set_display_name";
-        }
-
-        public Integer[] numArgs() {
-            return new Integer[]{1, 2};
-        }
-
-        public String docs() {
-            return "void {playerName, newDisplayName | newDisplayName} Sets a player's display name. If the second usage is used,"
-                    + " it sets the display name of the player running the command. See reset_display_name also. playerName, as well"
-                    + " as all CommandHelper commands expect the player's real name, not their display name.";
-        }
-
-        public ExceptionType[] thrown() {
-            return new ExceptionType[]{ExceptionType.PlayerOfflineException};
-        }
-
-        public boolean isRestricted() {
-            return true;
-        }
-
-        public void varList(IVariableList varList) {
-        }
-
-        public boolean preResolveVariables() {
-            return true;
-        }
-
-        public String since() {
-            return "3.1.2";
-        }
-
-        public Boolean runAsync() {
-            return false;
-        }
-
-        public Construct exec(int line_num, File f, CommandSender p, Construct... args) throws CancelCommandException, ConfigRuntimeException {
-            Player player = null;
-            String name;
-            if (args.length == 1) {
-                if(p instanceof Player){
-                    player = (Player)p;
-                }
-                name = args[0].val();
-            } else {
-                player = p.getServer().getPlayer(args[0].val());
-                name = args[1].val();
-            }
-            if (player == null || !player.isOnline()) {
-                throw new ConfigRuntimeException("That player is not online", 
-                        ExceptionType.PlayerOfflineException, line_num, f);
-            }
-            player.setDisplayName(name);
-            return new CVoid(line_num, f);
-        }
-    }
-
-    @api
-    public static class reset_display_name implements Function {
-
-        public String getName() {
-            return "reset_display_name";
-        }
-
-        public Integer[] numArgs() {
-            return new Integer[]{0, 1};
-        }
-
-        public String docs() {
-            return "void {[playerName]} Resets a player's display name to their real name. If playerName isn't specified, defaults to the"
-                    + " player running the command.";
-        }
-
-        public ExceptionType[] thrown() {
-            return new ExceptionType[]{ExceptionType.PlayerOfflineException};
-        }
-
-        public boolean isRestricted() {
-            return true;
-        }
-
-        public void varList(IVariableList varList) {
-        }
-
-        public boolean preResolveVariables() {
-            return true;
-        }
-
-        public String since() {
-            return "3.1.2";
-        }
-
-        public Boolean runAsync() {
-            return false;
-        }
-
-        public Construct exec(int line_num, File f, CommandSender p, Construct... args) throws CancelCommandException, ConfigRuntimeException {
-            Player player = null;
-            if (args.length == 0) {
-                if(p instanceof Player){
-                    player = (Player)p;
-                }
-            } else {
-                player = p.getServer().getPlayer(args[0].val());
-            }
-            if (player == null || !player.isOnline()) {
-                throw new ConfigRuntimeException("That player is not online", 
-                        ExceptionType.PlayerOfflineException, line_num, f);
-            }
-            player.setDisplayName(player.getName());
-            return new CVoid(line_num, f);
-        }
-    }
-
-    @api
-    public static class pfacing implements Function {
-
-        public String getName() {
-            return "pfacing";
-        }
-
-        public Integer[] numArgs() {
-            return new Integer[]{0, 1, 2, 3};
-        }
-
-        public String docs() {
-            return "mixed {F | yaw, pitch | player, F | player, yaw, pitch | player | &lt;none&gt;} Sets the direction the player is facing. When using the first variation, expects an integer 0-3, which will"
-                    + " set the direction the player faces using their existing pitch (up and down) but sets their yaw (left and right) to one of the"
-                    + " cardinal directions, as follows: 0 - West, 1 - South, 2 - East, 3 - North, which corresponds to the directions given by F when"
-                    + " viewed with F3. In the second variation, specific yaw and pitches can be provided. If the player is not specified, the current player"
-                    + " is used. If just the player is specified, that player's yaw and pitch are returned as an array, or if no arguments are given, the"
-                    + " player running the command's yaw and pitch are returned as an array. The function returns void when setting the values. (Note that while this"
-                    + " function looks like it has ambiguous arguments, players cannot be named numbers.) A note on numbers: The values returned by the getter will always be"
-                    + " as such: pitch will always be a number between 90 and -90, with -90 being the player looking up, and 90 being the player looking down. Yaw will"
-                    + " always be a number between 0 and 359.9~. When using it as a setter, pitch must be a number between -90 and 90, and yaw may be any number."
-                    + " If the number given is not between 0 and 359.9~, it will be normalized first. 0 is dead west, 90 is north, etc.";
-        }
-
-        public ExceptionType[] thrown() {
-            return new ExceptionType[]{ExceptionType.PlayerOfflineException, ExceptionType.RangeException, ExceptionType.CastException};
-        }
-
-        public boolean isRestricted() {
-            return true;
-        }
-
-        public void varList(IVariableList varList) {
-        }
-
-        public boolean preResolveVariables() {
-            return true;
-        }
-
-        public String since() {
-            return "3.1.3";
-        }
-
-        public Boolean runAsync() {
-            return false;
-        }
-
-        public Construct exec(int line_num, File f, CommandSender p, Construct... args) throws ConfigRuntimeException {
-            //Getter
-            if (args.length == 0 || args.length == 1) {
-                Location l = null;
-                if (args.length == 0) {
-                    if(p instanceof Player){
-                        l = ((Player)p).getLocation();
-                    }
-                } else if (args.length == 1) {
-                    //if it's a number, we are setting F. Otherwise, it's a getter for the player specified.
-                    try {
-                        Integer.parseInt(args[0].val());
-                    } catch (NumberFormatException e) {
-                        Player p2 = p.getServer().getPlayer(args[0].val());
-                        if (p2 == null || !p2.isOnline()) {
-                            throw new ConfigRuntimeException("The specified player is offline", 
-                                    ExceptionType.PlayerOfflineException, line_num, f);
-                        } else {
-                            l = p2.getLocation();
-                        }
-                    }
-                }
-                if (l != null) {
-                    float yaw = l.getYaw();
-                    float pitch = l.getPitch();
-                    //normalize yaw
-                    if (yaw < 0) {
-                        yaw = (((yaw) % 360) + 360);
-                    }
-                    return new CArray(line_num, f, new CDouble(yaw, line_num, f), new CDouble(pitch, line_num, f));
-                }
-            }
-            //Setter
-            Player toSet = null;
-            float yaw = 0;
-            float pitch = 0;
-            if (args.length == 1) {
-                //We are setting F for this player
-                if(p instanceof Player){
-                    toSet = (Player)p;
-                    pitch = toSet.getLocation().getPitch();
-                }
-                int g = (int) Static.getInt(args[0]);
-                if (g < 0 || g > 3) {
-                    throw new ConfigRuntimeException("The F specifed must be from 0 to 3", 
-                            ExceptionType.RangeException, line_num, f);
-                }
-                yaw = g * 90;
-            } else if (args.length == 2) {
-                //Either we are setting this player's pitch and yaw, or we are setting the specified player's F.
-                //Check to see if args[0] is a number
-                try {
-                    Float.parseFloat(args[0].val());
-                    //It's the yaw, pitch variation
-                    if(p instanceof Player){
-                        toSet = (Player)p;
-                    }
-                    yaw = (float) Static.getNumber(args[0]);
-                    pitch = (float) Static.getNumber(args[1]);
-                } catch (NumberFormatException e) {
-                    //It's the player, F variation
-                    toSet = p.getServer().getPlayer(args[0].val());
-                    pitch = toSet.getLocation().getPitch();
-                    int g = (int) Static.getInt(args[1]);
-                    if (g < 0 || g > 3) {
-                        throw new ConfigRuntimeException("The F specifed must be from 0 to 3", 
-                                ExceptionType.RangeException, line_num, f);
-                    }
-                    yaw = g * 90;
-                }
-            } else if (args.length == 3) {
-                //It's the player, yaw, pitch variation
-                toSet = p.getServer().getPlayer(args[0].val());
-                yaw = (float) Static.getNumber(args[1]);
-                pitch = (float) Static.getNumber(args[2]);
-            }
-
-            //Error check our data
-            if (toSet == null || !toSet.isOnline()) {
-                throw new ConfigRuntimeException("The specified player is not online", 
-                        ExceptionType.PlayerOfflineException, line_num, f);
-            }
-            if (pitch > 90 || pitch < -90) {
-                throw new ConfigRuntimeException("pitch must be between -90 and 90", 
-                        ExceptionType.RangeException, line_num, f);
-            }
-            Location l = toSet.getLocation().clone();
-            l.setPitch(pitch);
-            l.setYaw(yaw);
-            toSet.teleport(l);
-            return new CVoid(line_num, f);
-        }
-    }
-
-    @api
-    public static class pinv implements Function {
-
-        public String getName() {
-            return "pinv";
-        }
-
-        public Integer[] numArgs() {
-            return new Integer[]{0, 1, 2};
-        }
-
-        public String docs() {
-            return "mixed {[player], [index]} Gets the inventory information for the specified player, or the current player if none specified. If the index is specified, only the slot "
-                    + " given will be returned, but in general, the return format is: array(array(data, qty), array(data, qty), ...) where data is the x:y value of the block (or just the"
-                    + " value if it's an item), and"
-                    + " qty is the number of items. The index of the array in the array is 0 - 35, which corresponds to the slot in the players inventory. To access armor"
-                    + " slots, you must specify the index. (100 - 103). The quick bar is 0 - 8. If index is null, the item in the player's hand is returned, regardless"
-                    + " of what slot is selected. If there is no item at the slot specified, null is returned.";
-        }
-
-        public ExceptionType[] thrown() {
-            return new ExceptionType[]{ExceptionType.PlayerOfflineException, ExceptionType.CastException, ExceptionType.RangeException};
-        }
-
-        public boolean isRestricted() {
-            return true;
-        }
-
-        public void varList(IVariableList varList) {
-        }
-
-        public boolean preResolveVariables() {
-            return true;
-        }
-
-        public String since() {
-            return "3.1.3";
-        }
-
-        public Boolean runAsync() {
-            return false;
-        }
-
-        public Construct exec(int line_num, File f, CommandSender p, Construct... args) throws ConfigRuntimeException {
-            int index = -1;
-            boolean all = false;
-            Player m = null;
-            if (args.length == 0) {
-                all = true;
-                if(p instanceof Player){
-                    m = (Player)p;
-                }
-            } else if (args.length == 1) {
-                all = true;
-                m = p.getServer().getPlayer(args[0].val());
-            } else if (args.length == 2) {
-                if (args[1] instanceof CNull) {
-                    index = -1;
-                } else {
-                    index = (int) Static.getInt(args[1]);
-                }
-                all = false;
-                m = p.getServer().getPlayer(args[0].val());
-            }
-            if (m == null || !m.isOnline()) {
-                throw new ConfigRuntimeException("The specified player is not online", 
-                        ExceptionType.PlayerOfflineException, line_num, f);
-            }
-            if (!all) {
-                if ((index < 0 || index > 35) && (index < 100 || index > 103) && index != -1) {
-                    throw new ConfigRuntimeException("The index specified must be between 0-35, or 100-103", 
-                            ExceptionType.RangeException, line_num, f);
-                }
-            }
-            PlayerInventory inv = m.getInventory();
-            if (!all) {
-                String value = "";
-                int qty = 0;
-                if (index == -1) {
-                    ItemStack is = m.getItemInHand();
-                    if (is.getTypeId() != 0) {
-                        return new CArray(line_num, f,
-                                new CString(is.getTypeId() + (is.getData() == null ? "" : ":" + is.getData().getData()), line_num, f),
-                                new CInt(is.getAmount(), line_num, f));
-                    } else {
-                        return new CNull(line_num, f);
-                    }
-                }
-                if (index >= 100 && index <= 103) {
-                    qty = 1;
-                    switch (index) {
-                        case 100:
-                            value = Integer.toString(inv.getBoots().getTypeId());
-                            break;
-                        case 101:
-                            value = Integer.toString(inv.getLeggings().getTypeId());
-                            break;
-                        case 102:
-                            value = Integer.toString(inv.getChestplate().getTypeId());
-                            break;
-                        case 103:
-                            value = Integer.toString(inv.getHelmet().getTypeId());
-                            break;
-                    }
-                    if (value.equals("0")) {
-                        value = null;
-                        qty = 0;
-                    }
-                } else {
-                    if (inv.getItem(index).getTypeId() == 0) {
-                        value = null;
-                    } else {
-                        value = inv.getItem(index).getTypeId() + (inv.getItem(index).getData() == null ? "" : ":" + inv.getItem(index).getData().getData());
-                    }
-                    qty = inv.getItem(index).getAmount();
-                }
-                if (value == null) {
-                    return new CNull(line_num, f);
-                } else {
-                    Construct cvalue = null;
-                    cvalue = new CString(value, line_num, f);
-                    return new CArray(line_num, f, cvalue, new CInt(qty, line_num, f));
-                }
-            } else {
-                CArray ca = new CArray(line_num, f);
-                for (int i = 0; i < 36; i++) {
-                    ItemStack is = inv.getItem(i);
-                    if (is != null && is.getTypeId() != 0) {
-                        ca.push(new CArray(line_num, f,
-                                new CString(is.getTypeId() + (is.getData() == null ? "" : ":" + is.getData().getData()), line_num, f),
-                                new CInt(is.getAmount(), line_num, f)));
-                    } else {
-                        ca.push(new CNull(line_num, f));
-                    }
-                }
-                return ca;
-            }
-        }
-    }
-
-    @api public static class set_pinv implements Function {
-
-        public String getName() {
-            return "set_pinv";
-        }
-
-        public Integer[] numArgs() {
-            return new Integer[]{2, 3, 4, 5};
-        }
-
-        public String docs() {
-            return "void {[player], slot, item_id, [qty], [damage]} Sets the index of the slot to the specified item_id, with the specified qty,"
-                    + " or 1 by default. If the qty of armor indexes is greater than 1, it is silently ignored, and only 1 is added."
-                    + " item_id follows the same notation for items used elsewhere. Damage defaults to 0, and is a percentage from 0-100, of"
-                    + " how damaged an item is. If slot is null, it defaults to the item in hand. The item_id notation gives a shortcut"
-                    + " to setting damage values, for instance, set_pinv(null, '35:15') will give the player black wool. The \"15\""
-                    + " here is an unscaled damage value. This is the same thing as set_pinv(null, 35, 1, 100). 100 is a scaled damage"
-                    + " value.";
-                    
-        }
-
-        public ExceptionType[] thrown() {
-            return new ExceptionType[]{ExceptionType.PlayerOfflineException};
-        }
-
-        public boolean isRestricted() {
-            return true;
-        }
-
-        public void varList(IVariableList varList) {}
-
-        public boolean preResolveVariables() {
-            return true;
-        }
-
-        public String since() {
-            return "3.2.0";
-        }
-
-        public Boolean runAsync() {
-            return false;
-        }
-
-        public Construct exec(int line_num, File f, CommandSender p, Construct... args) throws ConfigRuntimeException {
-            Player m = null;
-            if(p instanceof Player){
-                m = (Player)p;
-            }
-            int slot = 0;
-            int offset = 0;
-            int qty = 1;
-            short damage = -1;
-            if(args[0].val().matches("\\d*(:\\d*)?") || Static.isNull(args[0])){
-                //We're using the slot as arg 1
-                if(Static.isNull(args[0])){
-                    slot = -1;
-                } else {
-                    slot = (int)Static.getInt(args[0]);
-                }
-            } else {
-                m = Static.GetPlayer(args[0].val(), line_num, f);
-                if(Static.isNull(args[1])){
-                    slot = -1;
-                } else {
-                    slot = (int)Static.getInt(args[1]);
-                }
-                offset = 1;
-            }
-            if(slot < -1 || slot > 35 && slot < 100 || slot > 103){
-                throw new ConfigRuntimeException("Slot number must be from 0-35 or 100-103", ExceptionType.RangeException, line_num, f);
-            }
-            if(args.length > 2 + offset){
-                qty = (int)Static.getInt(args[2 + offset]);
-            }            
-            qty = Static.Normalize(qty, 0, Integer.MAX_VALUE);
-            ItemStack is = Static.ParseItemNotation(this.getName(), args[1 + offset].val(), qty, line_num, f);
-            if(args.length > 3 + offset){
-                damage = (short)Static.getInt(args[3 + offset]);
-            }
-            if(damage != -1){
-                damage = (short)java.lang.Math.max(0, java.lang.Math.min(100, damage));
-                short max = is.getType().getMaxDurability();
-                is.setDurability((short)((max * damage) / 100));            
-            }
-            
-            if(is.getTypeId() == 0){
-                qty = 0; //Giving the player air crashes their client, so just remove the item
-                is.setTypeId(1);
-            }
-            
-            if(qty == 0){
-                is = null;
-            }
-            if(slot == -1){
-                m.setItemInHand(is);
-            } else {
-                if(slot == 103){
-                    m.getInventory().setHelmet(is);
-                } else if(slot == 102){
-                    m.getInventory().setChestplate(is);
-                } else if(slot == 101){
-                    m.getInventory().setLeggings(is);
-                } else if(slot == 100){
-                    m.getInventory().setBoots(is);
-                } else {
-                    m.getInventory().setItem(slot, is);
-                }
-            }
-            return new CVoid(line_num, f);
-        }
-    }
-    
-    @api public static class pmode implements Function{
-
-        public String getName() {
-            return "pmode";
-        }
-
-        public Integer[] numArgs() {
-            return new Integer[]{0, 1};
-        }
-
-        public String docs() {
-            return "string {[player]} Returns the player's game mode. It will be one of \"CREATIVE\" or \"SURVIVAL\".";
-        }
-
-        public ExceptionType[] thrown() {
-            return new ExceptionType[]{ExceptionType.PlayerOfflineException};
-        }
-
-        public boolean isRestricted() {
-            return true;
-        }
-
-        public void varList(IVariableList varList) {}
-
-        public boolean preResolveVariables() {
-            return true;
-        }
-
-        public String since() {
-            return "3.1.3";
-        }
-
-        public Boolean runAsync() {
-            return false;
-        }
-
-        public Construct exec(int line_num, File f, CommandSender p, Construct... args) throws ConfigRuntimeException {
-            Player m = null;
-            if(p instanceof Player){
-                m = (Player)p;
-            }
-            if(args.length == 1){
-                m = Static.getServer().getPlayer(args[0].val());
-            }
-            if(m == null || !m.isOnline()){
-                throw new ConfigRuntimeException("The specified player is offline", ExceptionType.PlayerOfflineException, line_num, f);
-            }
-            String mode = m.getGameMode().name();            
-            return new CString(mode, line_num, f);
-        }
-        
-    }
-    
-    @api public static class set_pmode implements Function {
-
-        public String getName() {
-            return "set_pmode";
-        }
-
-        public Integer[] numArgs() {
-            return new Integer[]{1, 2};
-        }
-
-        public String docs() {
-            return "void {[player], mode} Sets the player's game mode. mode must be either \"CREATIVE\" or \"SURVIVAL\""
-                    + " (case doesn't matter)";
-        }
-
-        public ExceptionType[] thrown() {
-            return new ExceptionType[]{ExceptionType.PlayerOfflineException};
-        }
-
-        public boolean isRestricted() {
-            return true;
-        }
-
-        public void varList(IVariableList varList) {}
-
-        public boolean preResolveVariables() {
-            return true;
-        }
-
-        public String since() {
-            return "3.1.3";
-        }
-
-        public Boolean runAsync() {
-            return false;
-        }
-
-        public Construct exec(int line_num, File f, CommandSender p, Construct... args) throws ConfigRuntimeException {
-            Player m = null;
-            String mode = "";
-            GameMode gm;
-            if(p instanceof Player){
-                m = (Player)p;
-            }
-            if(args.length == 2){
-                m = Static.getServer().getPlayer(args[0].val());
-                mode = args[1].val();
-            } else {
-                mode = args[0].val();
-            }
-            if(m == null || !m.isOnline()){
-                throw new ConfigRuntimeException("That player is not online", ExceptionType.PlayerOfflineException, line_num, f);
-            }
-            
-            try{
-                gm = GameMode.valueOf(mode.toUpperCase());
-            } catch(IllegalArgumentException e){
-                throw new ConfigRuntimeException("Mode must be either 'CREATIVE' or 'SURVIVAL'", ExceptionType.FormatException, line_num, f);
-            }
-            m.setGameMode(gm);
-            return new CVoid(line_num, f);
-        }
-        
-    }
-    
-    @api public static class pexp implements Function{
-        public String getName() {
-            return "pexp";
-        }
-
-        public Integer[] numArgs() {
-            return new Integer[]{0, 1};
-        }
-
-        public String docs() {
-            return "void {[player]} Gets the experience of a player within this level.";
-        }
-
-        public ExceptionType[] thrown() {
-            return new ExceptionType[]{ExceptionType.CastException, ExceptionType.PlayerOfflineException};
-        }
-
-        public boolean isRestricted() {
-            return true;
-        }
-
-        public void varList(IVariableList varList) {}
-
-        public boolean preResolveVariables() {
-            return true;
-        }
-
-        public String since() {
-            return "3.1.3";
-        }
-
-        public Boolean runAsync() {
-            return false;
-        }
-
-        public Construct exec(int line_num, File f, CommandSender p, Construct... args) throws ConfigRuntimeException {
-            Player m = null;
-            if(p instanceof Player){
-                m = (Player)p;
-            }
-            if(args.length == 1){
-                m = Static.GetPlayer(args[0].val(), line_num, f);
-            }
-            if(m == null || !m.isOnline()){
-                throw new ConfigRuntimeException("The specified player is not online", ExceptionType.PlayerOfflineException, line_num, f);
-            }
-            return new CInt(m.getExperience(), line_num, f);
-        }
-    }
-    
-    @api public static class set_pexp implements Function{
-        public String getName() {
-            return "set_pexp";
-        }
-
-        public Integer[] numArgs() {
-            return new Integer[]{1, 2};
-        }
-
-        public String docs() {
-            return "void {[player], xp} Sets the experience of a player within the current level.";
-        }
-
-        public ExceptionType[] thrown() {
-            return new ExceptionType[]{ExceptionType.CastException, ExceptionType.PlayerOfflineException};
-        }
-
-        public boolean isRestricted() {
-            return true;
-        }
-
-        public void varList(IVariableList varList) {}
-
-        public boolean preResolveVariables() {
-            return true;
-        }
-
-        public String since() {
-            return "3.1.3";
-        }
-
-        public Boolean runAsync() {
-            return false;
-        }
-
-        public Construct exec(int line_num, File f, CommandSender p, Construct... args) throws ConfigRuntimeException {
-            Player m = null;
-            int xp = 0;
-            if(p instanceof Player){
-                m = (Player)p;
-            }
-            if(args.length == 2){
-                m = Static.GetPlayer(args[0].val(), line_num, f);
-                xp = (int)Static.getInt(args[1]);
-            } else {
-                xp = (int)Static.getInt(args[0]);
-            }
-            if(m == null || !m.isOnline()){
-                throw new ConfigRuntimeException("The specified player is not online", ExceptionType.PlayerOfflineException, line_num, f);
-            }
-            m.setExperience(xp);
-            return new CVoid(line_num, f);
-        }
-    }
-        
-    @api public static class plevel implements Function{
-        public String getName() {
-            return "plevel";
-        }
-
-        public Integer[] numArgs() {
-            return new Integer[]{0, 1};
-        }
-
-        public String docs() {
-            return "void {[player]} Gets the experience of a player within this level.";
-        }
-
-        public ExceptionType[] thrown() {
-            return new ExceptionType[]{ExceptionType.CastException, ExceptionType.PlayerOfflineException};
-        }
-
-        public boolean isRestricted() {
-            return true;
-        }
-
-        public void varList(IVariableList varList) {}
-
-        public boolean preResolveVariables() {
-            return true;
-        }
-
-        public String since() {
-            return "3.1.3";
-        }
-
-        public Boolean runAsync() {
-            return false;
-        }
-
-        public Construct exec(int line_num, File f, CommandSender p, Construct... args) throws ConfigRuntimeException {
-            Player m = null;
-            if(p instanceof Player){
-                m = (Player)p;
-            }
-            if(args.length == 1){
-                m = Static.GetPlayer(args[0].val(), line_num, f);
-            }
-            if(m == null || !m.isOnline()){
-                throw new ConfigRuntimeException("The specified player is not online", ExceptionType.PlayerOfflineException, line_num, f);
-            }
-            return new CInt(m.getLevel(), line_num, f);
-        }
-    }
-    
-    @api public static class set_plevel implements Function{
-        public String getName() {
-            return "set_plevel";
-        }
-
-        public Integer[] numArgs() {
-            return new Integer[]{1, 2};
-        }
-
-        public String docs() {
-            return "void {[player], level} Sets the level of a player.";
-        }
-
-        public ExceptionType[] thrown() {
-            return new ExceptionType[]{ExceptionType.CastException, ExceptionType.PlayerOfflineException};
-        }
-
-        public boolean isRestricted() {
-            return true;
-        }
-
-        public void varList(IVariableList varList) {}
-
-        public boolean preResolveVariables() {
-            return true;
-        }
-
-        public String since() {
-            return "3.1.3";
-        }
-
-        public Boolean runAsync() {
-            return false;
-        }
-
-        public Construct exec(int line_num, File f, CommandSender p, Construct... args) throws ConfigRuntimeException {
-            Player m = null;
-            int xp = 0;
-            if(p instanceof Player){
-                m = (Player)p;
-            }
-            if(args.length == 2){
-                m = Static.GetPlayer(args[0].val(), line_num, f);
-                xp = (int)Static.getInt(args[1]);
-            } else {
-                xp = (int)Static.getInt(args[0]);
-            }
-            if(m == null || !m.isOnline()){
-                throw new ConfigRuntimeException("The specified player is not online", ExceptionType.PlayerOfflineException, line_num, f);
-            }
-            m.setLevel(xp);
-            return new CVoid(line_num, f);
-        }
-    }
-    
-    @api public static class ptexp implements Function{
-        public String getName() {
-            return "ptexp";
-        }
-
-        public Integer[] numArgs() {
-            return new Integer[]{0, 1};
-        }
-
-        public String docs() {
-            return "void {[player]} Gets the total experience of a player.";
-        }
-
-        public ExceptionType[] thrown() {
-            return new ExceptionType[]{ExceptionType.CastException, ExceptionType.PlayerOfflineException};
-        }
-
-        public boolean isRestricted() {
-            return true;
-        }
-
-        public void varList(IVariableList varList) {}
-
-        public boolean preResolveVariables() {
-            return true;
-        }
-
-        public String since() {
-            return "3.1.3";
-        }
-
-        public Boolean runAsync() {
-            return false;
-        }
-
-        public Construct exec(int line_num, File f, CommandSender p, Construct... args) throws ConfigRuntimeException {
-            Player m = null;
-            if(p instanceof Player){
-                m = (Player)p;
-            }
-            if(args.length == 1){
-                m = Static.GetPlayer(args[0].val(), line_num, f);
-            }
-            if(m == null || !m.isOnline()){
-                throw new ConfigRuntimeException("The specified player is not online", ExceptionType.PlayerOfflineException, line_num, f);
-            }
-            return new CInt(m.getTotalExperience(), line_num, f);
-        }
-    }
-    
-    @api public static class set_ptexp implements Function{
-
-        public String getName() {
-            return "set_ptexp";
-        }
-
-        public Integer[] numArgs() {
-            return new Integer[]{1, 2};
-        }
-
-        public String docs() {
-            return "void {[player], xp} Sets the total experience of a player.";
-        }
-
-        public ExceptionType[] thrown() {
-            return new ExceptionType[]{ExceptionType.CastException, ExceptionType.PlayerOfflineException};
-        }
-
-        public boolean isRestricted() {
-            return true;
-        }
-
-        public void varList(IVariableList varList) {}
-
-        public boolean preResolveVariables() {
-            return true;
-        }
-
-        public String since() {
-            return "3.1.3";
-        }
-
-        public Boolean runAsync() {
-            return false;
-        }
-
-        public Construct exec(int line_num, File f, CommandSender p, Construct... args) throws ConfigRuntimeException {
-            Player m = null;
-            int xp = 0;
-            if(p instanceof Player){
-                m = (Player)p;
-            }
-            if(args.length == 2){
-                m = Static.GetPlayer(args[0].val(), line_num, f);
-                xp = (int)Static.getInt(args[1]);
-            } else {
-                xp = (int)Static.getInt(args[0]);
-            }
-            if(m == null || !m.isOnline()){
-                throw new ConfigRuntimeException("The specified player is not online", ExceptionType.PlayerOfflineException, line_num, f);
-            }
-            m.setTotalExperience(xp);
-            return new CVoid(line_num, f);
-        }
-        
-    }
-    
-    @api public static class pfood implements Function{
-
-        public String getName() {
-            return "pfood";
-        }
-
-        public Integer[] numArgs() {
-            return new Integer[]{0, 1};
-        }
-
-        public String docs() {
-            return "int {[player]} Returns the player's current food level.";
-        }
-
-        public ExceptionType[] thrown() {
-            return new ExceptionType[]{ExceptionType.PlayerOfflineException};
-        }
-
-        public boolean isRestricted() {
-            return true;
-        }
-
-        public void varList(IVariableList varList) {}
-
-        public boolean preResolveVariables() {
-            return true;
-        }
-
-        public String since() {
-            return "3.1.3";
-        }
-
-        public Boolean runAsync() {
-            return false;
-        }
-
-        public Construct exec(int line_num, File f, CommandSender p, Construct... args) throws ConfigRuntimeException {
-            Player m = null;
-            if(p instanceof Player){
-                m = (Player)p;
-            }
-            if(args.length == 1){
-                m = Static.GetPlayer(args[0].val(), line_num, f);
-            }
-            if(m == null || !m.isOnline()){
-                throw new ConfigRuntimeException("The specified player is not online", ExceptionType.PlayerOfflineException, line_num, f);
-            }
-            return new CInt(m.getFoodLevel(), line_num, f);
-        }
-        
-    }
-    
-    @api public static class set_pfood implements Function{
-
-        public String getName() {
-            return "set_pfood";
-        }
-
-        public Integer[] numArgs() {
-            return new Integer[]{1, 2};
-        }
-
-        public String docs() {
-            return "void {[player], level} Sets the player's food level. This is an integer from 0-?";
-        }
-
-        public ExceptionType[] thrown() {
-            return new ExceptionType[]{ExceptionType.PlayerOfflineException, ExceptionType.CastException};
-        }
-
-        public boolean isRestricted() {
-            return true;
-        }
-
-        public void varList(IVariableList varList) {
-            
-        }
-
-        public boolean preResolveVariables() {
-            return true;
-        }
-
-        public String since() {
-            return "3.1.3";
-        }
-
-        public Boolean runAsync() {
-            return false;
-        }
-
-        public Construct exec(int line_num, File f, CommandSender p, Construct... args) throws ConfigRuntimeException {
-            Player m = null;
-            int level = 0;
-            if(p instanceof Player){
-                m = (Player)p;
-            }
-            if(args.length == 2){
-                m = Static.GetPlayer(args[0].val(), line_num, f);
-                level = (int)Static.getInt(args[1]);
-            } else {
-                level = (int)Static.getInt(args[0]);
-            }
-            if(m == null || !m.isOnline()){
-                throw new ConfigRuntimeException("The specified player is not online", ExceptionType.PlayerOfflineException, line_num, f);
-            }
-            m.setFoodLevel(level);
-            return new CVoid(line_num, f);
-        }
-        
-    }
-    
-    @api public static class set_peffect implements Function{
-
-        public String getName() {
-            return "set_peffect";
-        }
-
-        public Integer[] numArgs() {
-            return new Integer[]{3, 4};
-        }
-
-        public String docs() {
-            return "void {player, potionID, strength, [seconds]} Not all potions work of course, but effect is 1-19. Seconds defaults to 30.";
-        }
-
-        public ExceptionType[] thrown() {
-            return new ExceptionType[]{ExceptionType.PlayerOfflineException, ExceptionType.CastException};
-        }
-
-        public boolean isRestricted() {
-            return true;
-        }
-
-        public void varList(IVariableList varList) {}
-
-        public boolean preResolveVariables() {
-            return true;
-        }
-
-        public String since() {
-            return "0.0.0";
-        }
-
-        public Boolean runAsync() {
-            return false;
-        }
-
-        public Construct exec(int line_num, File f, CommandSender p, Construct... args) throws ConfigRuntimeException {
-            Player m = Static.GetPlayer(args[0].val(), line_num, f);
-            if(m == null || !m.isOnline()){
-                throw new ConfigRuntimeException("That player is not online", ExceptionType.PlayerOfflineException, line_num, f);
-            }
-            int effect = (int)Static.getInt(args[1]);
-            int strength = (int)Static.getInt(args[2]);
-            int seconds = 30;
-            if(args.length == 4){
-                seconds = (int)Static.getInt(args[3]);
-            }
-            EntityPlayer ep = ((CraftPlayer)m).getHandle();
-            Class epc = EntityLiving.class;
-            MobEffect me = new MobEffect(effect, seconds * 20, strength);
-            try{
-                Method meth = epc.getDeclaredMethod("d", net.minecraft.server.MobEffect.class);
-                //ep.d(new MobEffect(effect, seconds * 20, strength));
-                //Call it reflectively, because it's deobfuscated in newer versions of CB
-                meth.invoke(ep, me);
-            } catch(Exception e){
-                try {
-                    //Look for the addEffect version                
-                    Method meth = epc.getDeclaredMethod("addEffect", MobEffect.class);
-                    //ep.addEffect(me);
-                    meth.invoke(ep, me);
-                } catch (Exception ex) {
-                    Logger.getLogger(PlayerManangement.class.getName()).log(Level.SEVERE, null, ex);
-                }
-            }
-            return new CVoid(line_num, f);
-        }
-        
-    }
-    
-    @api public static class set_phealth implements Function{
-
-        public String getName() {
-            return "set_phealth";
-        }
-
-        public Integer[] numArgs() {
-            return new Integer[]{1, 2};
-        }
-
-        public String docs() {
-            return "void {[player], health} Sets the player's health. health should be an integer from 0-20.";
-        }
-
-        public ExceptionType[] thrown() {
-            return new ExceptionType[]{ExceptionType.CastException, ExceptionType.RangeException};
-        }
-
-        public boolean isRestricted() {
-            return true;
-        }
-
-        public void varList(IVariableList varList) {}
-
-        public boolean preResolveVariables() {
-            return true;
-        }
-
-        public String since() {
-            return "3.2.0";
-        }
-
-        public Boolean runAsync() {
-            return false;
-        }
-
-        public Construct exec(int line_num, File f, CommandSender p, Construct... args) throws ConfigRuntimeException {
-            Player m = null;
-            if(p instanceof Player){
-                m = (Player)p;
-            }
-            int health = 0;
-            if(args.length == 2){
-                m = Static.GetPlayer(args[0].val(), line_num, f);
-                health = (int)Static.getInt(args[1]);
-            } else {
-                health = (int)Static.getInt(args[0]);
-            }
-            if(health < 0 || health > 20){
-                throw new ConfigRuntimeException("Health must be between 0 and 20", ExceptionType.RangeException, line_num, f);
-            }
-            m.setHealth(health);
-            return new CVoid(line_num, f);
-        }
-        
-    }
-    
-}
diff --git a/src/main/java/com/laytonsmith/aliasengine/functions/PluginLoader.java b/src/main/java/com/laytonsmith/aliasengine/functions/PluginLoader.java
deleted file mode 100644
index cbbbfb0..0000000
--- a/src/main/java/com/laytonsmith/aliasengine/functions/PluginLoader.java
+++ /dev/null
@@ -1,69 +0,0 @@
-package com.laytonsmith.aliasengine.functions;
-import java.net.*;
-import java.io.*;
-
-/**
- * This class handles loading the modules classes. Most of this code was copy-pasted,
- * so I can't comment too much on it, because I'm still fairly new to what's happening here,
- * however, I will try to offer some insight. The jar file in which the classes are located
- * must first be added to the classpath with <code>loadJars</code>. The classes are then
- * loaded into the classloader, and then when they need to be instantiated, the URLCLassLoader
- * that is static in this class is used to instatiate them. (Over in frame.java)
- * @author Layton
- */
-class PluginLoader {
-//    private static URLClassLoader loader;
-//    private static String baseClassPath;
-//
-//    public static ClassLoader getLoader(){
-//        return loader;
-//    }
-//    private static String parseFile(String dir) {
-//        String tempJars = "";
-//        File file = new File(dir);
-//        File[] tempFiles = file.listFiles();
-//        String tempString = "";
-//        for (int a = 0; a < tempFiles.length; a++) {
-//            tempString = tempFiles[a].toString();
-//            if (tempString.length() > 4) {
-//                if (tempString.substring(tempString.length() - 4, tempString.length()).equals(".jar")) {
-//                    tempJars = tempJars + tempString + ";";
-//                    try {
-//                        if(loader != null){
-//                            URL [] ans = new URL[loader.getURLs().length + 1];
-//                            System.arraycopy(loader.getURLs(), 0, ans, 0, loader.getURLs().length);
-//                            ans[ans.length - 1] = tempFiles[a].toURI().toURL();
-//                            loader = new URLClassLoader(ans);
-//                        }
-//                        else{
-//                            loader = new URLClassLoader(new URL[]{tempFiles[a].toURI().toURL()});
-//                        }
-//                    } catch (MalformedURLException e) {
-//                        e.printStackTrace();
-//                    } catch (Exception e){
-//                        e.printStackTrace();
-//                    }
-//                }
-//            }
-//        }
-//        if(tempJars.length() > 0){
-//            if (tempJars.substring(tempJars.length() - 1, tempJars.length()).equals(";")) {
-//                tempJars = tempJars.substring(0, tempJars.length() - 1);
-//            }
-//        }
-//        else{
-//            return null;
-//        }
-//        return tempJars;
-//    }
-//
-//    public static void loadJars(String dir) {
-//        String jars = parseFile(dir);
-//        if(jars == null){
-//            return;
-//        }
-//        String classPath = baseClassPath + System.getProperty("path.separator") + jars;
-//
-//        System.setProperty("java.class.path", classPath);
-//    }
-}
diff --git a/src/main/java/com/laytonsmith/aliasengine/functions/Regex.java b/src/main/java/com/laytonsmith/aliasengine/functions/Regex.java
deleted file mode 100644
index 733e2a6..0000000
--- a/src/main/java/com/laytonsmith/aliasengine/functions/Regex.java
+++ /dev/null
@@ -1,315 +0,0 @@
-/*
- * To change this template, choose Tools | Templates
- * and open the template in the editor.
- */
-package com.laytonsmith.aliasengine.functions;
-
-import com.laytonsmith.aliasengine.Constructs.CArray;
-import com.laytonsmith.aliasengine.Constructs.CInt;
-import com.laytonsmith.aliasengine.Constructs.CString;
-import com.laytonsmith.aliasengine.Constructs.Construct;
-import com.laytonsmith.aliasengine.functions.Exceptions.ExceptionType;
-import com.laytonsmith.aliasengine.functions.exceptions.ConfigRuntimeException;
-import java.io.File;
-import java.util.regex.Matcher;
-import java.util.regex.Pattern;
-import org.bukkit.command.CommandSender;
-
-/**
- *
- * @author Layton
- */
-public class Regex {
-    
-    public static String docs(){
-        return "This class provides regular expression functions. For more details, please see the page on "
-                + "[[CommandHelper/Regex|regular expressions]]";
-    }
-    
-    @api public static class reg_match implements Function{
-
-        public String getName() {
-            return "reg_match";
-        }
-
-        public Integer[] numArgs() {
-            return new Integer[]{2};
-        }
-
-        public String docs() {
-            return "array {pattern, subject} Searches for the given pattern, and returns an array with the results. Captures are supported."
-                    + " If the pattern is not found anywhere in the subject, an empty array is returned. The indexes of the array"
-                    + " follow typical regex fashion; the 0th element is the whole match, and 1-n are the captures specified in"
-                    + " the regex.";
-        }
-
-        public ExceptionType[] thrown() {
-            return new ExceptionType[]{};
-        }
-
-        public boolean isRestricted() {
-            return false;
-        }
-
-        public void varList(IVariableList varList) {}
-
-        public boolean preResolveVariables() {
-            return true;
-        }
-
-        public String since() {
-            return "3.2.0";
-        }
-
-        public Boolean runAsync() {
-            return null;
-        }
-
-        public Construct exec(int line_num, File f, CommandSender p, Construct... args) throws ConfigRuntimeException {
-            Pattern pattern = getPattern(args[0], line_num, f);
-            String subject = args[1].val();
-            CArray ret = new CArray(line_num, f);
-            Matcher m = pattern.matcher(subject);
-            if(m.find()){
-                ret.push(new CString(m.group(0), line_num, f));
-
-                for(int i = 1; i <= m.groupCount(); i++){
-                    ret.push(new CString(m.group(i), line_num, f));
-                }
-            }
-            return ret;
-        }
-        
-    }
-    
-    @api public static class reg_match_all implements Function{
-
-        public String getName() {
-            return "reg_match_all";
-        }
-
-        public Integer[] numArgs() {
-            return new Integer[]{2};
-        }
-
-        public String docs() {
-            return "array {pattern, subject} Searches subject for all matches to the regular expression given in pattern, unlike reg_match,"
-                    + " which just returns the first match.";
-        }
-
-        public ExceptionType[] thrown() {
-            return new ExceptionType[]{};
-        }
-
-        public boolean isRestricted() {
-            return false;
-        }
-
-        public void varList(IVariableList varList) {}
-
-        public boolean preResolveVariables() {
-            return true;
-        }
-
-        public String since() {
-            return "3.2.0";
-        }
-
-        public Boolean runAsync() {
-            return null;
-        }
-
-        public Construct exec(int line_num, File f, CommandSender p, Construct... args) throws ConfigRuntimeException {
-            Pattern pattern = getPattern(args[0], line_num, f);
-            String subject = args[1].val();
-            CArray fret = new CArray(line_num, f);
-            Matcher m = pattern.matcher(subject);
-            while(m.find()){
-                CArray ret = new CArray(line_num, f);
-                ret.push(new CString(m.group(0), line_num, f));
-
-                for(int i = 1; i <= m.groupCount(); i++){
-                    ret.push(new CString(m.group(i), line_num, f));
-                }
-                fret.push(ret);
-            }
-            return fret;
-        }
-        
-    }
-    
-    @api public static class reg_replace implements Function{
-
-        public String getName() {
-            return "reg_replace";
-        }
-
-        public Integer[] numArgs() {
-            return new Integer[]{3};
-        }
-
-        public String docs() {
-            return "string {pattern, replacement, subject} Replaces any occurances of pattern with the replacement in subject."
-                    + " Back references are allowed.";
-        }
-
-        public ExceptionType[] thrown() {
-            return new ExceptionType[]{};
-        }
-
-        public boolean isRestricted() {
-            return false;
-        }
-
-        public void varList(IVariableList varList) {}
-
-        public boolean preResolveVariables() {
-            return true;
-        }
-
-        public String since() {
-            return "3.2.0";
-        }
-
-        public Boolean runAsync() {
-            return null;
-        }
-
-        public Construct exec(int line_num, File f, CommandSender p, Construct... args) throws ConfigRuntimeException {
-            Pattern pattern = getPattern(args[0], line_num, f);
-            String replacement = args[1].val();
-            String subject = args[2].val();
-            String ret = "";
-            
-            ret = pattern.matcher(subject).replaceAll(replacement);
-            
-            return new CString(ret, line_num, f);
-        }
-        
-    }
-    
-    @api public static class reg_split implements Function{
-
-        public String getName() {
-            return "reg_split";
-        }
-
-        public Integer[] numArgs() {
-            return new Integer[]{2};
-        }
-
-        public String docs() {
-            return "array {pattern, subject} Splits a string on the given regex, and returns an array of the parts. If"
-                    + " nothing matched, an array with one element, namely the original subject, is returned.";
-        }
-
-        public ExceptionType[] thrown() {
-            return new ExceptionType[]{};
-        }
-
-        public boolean isRestricted() {
-            return false;
-        }
-
-        public void varList(IVariableList varList) {}
-
-        public boolean preResolveVariables() {
-            return true;
-        }
-
-        public String since() {
-            return "3.2.0";
-        }
-
-        public Boolean runAsync() {
-            return null;
-        }
-
-        public Construct exec(int line_num, File f, CommandSender p, Construct... args) throws ConfigRuntimeException {
-            Pattern pattern = getPattern(args[0], line_num, f);
-            String subject = args[1].val();
-            String [] rsplit = pattern.split(subject);
-            CArray ret = new CArray(line_num, f);
-            for(String split : rsplit){
-                ret.push(new CString(split, line_num, f));
-            }
-            return ret;
-        }
-        
-        
-    }  
-    
-    @api public static class reg_count implements Function{
-
-        public String getName() {
-            return "reg_count";
-        }
-
-        public Integer[] numArgs() {
-            return new Integer[]{2};
-        }
-
-        public String docs() {
-            return "int {pattern, subject} Counts the number of occurances in the subject.";
-        }
-
-        public ExceptionType[] thrown() {
-            return new ExceptionType[]{};
-        }
-
-        public boolean isRestricted() {
-            return false;
-        }
-
-        public void varList(IVariableList varList) {}
-
-        public boolean preResolveVariables() {
-            return true;
-        }
-
-        public String since() {
-            return "3.2.0";
-        }
-
-        public Boolean runAsync() {
-            return null;
-        }
-
-        public Construct exec(int line_num, File f, CommandSender p, Construct... args) throws ConfigRuntimeException {
-            Pattern pattern = getPattern(args[0], line_num, f);
-            String subject = args[1].val();
-            long ret = 0;
-            Matcher m = pattern.matcher(subject);
-            while(m.find()){
-                ret++;
-            }
-            return new CInt(ret, line_num, f);
-        }
-        
-    }
-    
-    private static Pattern getPattern(Construct c, int line_num, File f){
-        String regex = "";
-        int flags = 0;
-        String sflags = "";
-        if(c instanceof CArray){
-            CArray ca = (CArray)c;
-            regex = ca.get(0, line_num).val();
-            sflags = ca.get(1, line_num).val();
-            for(int i = 0; i < sflags.length(); i++){
-                if(sflags.toLowerCase().charAt(i) == 'i'){
-                    flags |= Pattern.CASE_INSENSITIVE;
-                } else if(sflags.toLowerCase().charAt(i) == 'm'){
-                    flags |= Pattern.MULTILINE;
-                } else if(sflags.toLowerCase().charAt(i) == 's'){
-                    flags |= Pattern.DOTALL;
-                } else {
-                    throw new ConfigRuntimeException("Unrecognized flag: " + sflags.toLowerCase().charAt(i), ExceptionType.FormatException, line_num, f);
-                }
-            }
-        } else {
-            regex = c.val();
-        }
-        return Pattern.compile(regex, flags);
-    }
-}
diff --git a/src/main/java/com/laytonsmith/aliasengine/functions/Sandbox.java b/src/main/java/com/laytonsmith/aliasengine/functions/Sandbox.java
deleted file mode 100644
index a7001b1..0000000
--- a/src/main/java/com/laytonsmith/aliasengine/functions/Sandbox.java
+++ /dev/null
@@ -1,264 +0,0 @@
-/*
- * To change this template, choose Tools | Templates
- * and open the template in the editor.
- */
-package com.laytonsmith.aliasengine.functions;
-
-import com.laytonsmith.aliasengine.Constructs.CArray;
-import com.laytonsmith.aliasengine.functions.exceptions.ConfigRuntimeException;
-import com.laytonsmith.aliasengine.Constructs.CVoid;
-import com.laytonsmith.aliasengine.Constructs.Construct;
-import com.laytonsmith.aliasengine.Static;
-import com.laytonsmith.aliasengine.functions.Exceptions.ExceptionType;
-import java.io.File;
-import java.lang.reflect.Constructor;
-import java.lang.reflect.InvocationTargetException;
-import java.lang.reflect.Method;
-import java.util.Arrays;
-import java.util.List;
-import java.util.SortedSet;
-import java.util.logging.Level;
-import java.util.logging.Logger;
-import net.minecraft.server.EntityPlayer;
-import org.bukkit.Location;
-import org.bukkit.command.Command;
-import org.bukkit.command.CommandSender;
-import org.bukkit.command.PluginCommand;
-import org.bukkit.craftbukkit.entity.CraftPlayer;
-import org.bukkit.entity.Player;
-import org.bukkit.event.Event;
-import org.bukkit.inventory.ItemStack;
-import org.bukkit.plugin.Plugin;
-import org.bukkit.plugin.RegisteredListener;
-import org.bukkit.plugin.SimplePluginManager;
-
-/**
- * @author Layton
- */
-public class Sandbox {
-    public static String docs(){
-        return "This class is for functions that are experimental. They don't actually get added"
-                + " to the documentation, and are subject to removal at any point in time, nor are they"
-                + " likely to have good documentation.";
-    }
-    @api public static class plugin_cmd implements Function{
-
-        public String getName() {
-            return "__plugin_cmd__";
-        }
-
-        public Integer[] numArgs() {
-            return new Integer[]{2};
-        }
-
-        public String docs() {
-            return "void {plugin, cmd} ";
-        }
-
-        public ExceptionType[] thrown() {
-            return null;
-        }
-
-        public boolean isRestricted() {
-            return true;
-        }
-
-        public void varList(IVariableList varList) {}
-
-        public boolean preResolveVariables() {
-            return true;
-        }
-
-        public String since() {
-            return "0.0.0";
-        }
-
-        public Boolean runAsync() {
-            return false;
-        }
-
-        public Construct exec(int line_num, File f, CommandSender p, Construct... args) throws ConfigRuntimeException {
-            Object o = Static.getAliasCore().parent.getServer().getPluginManager();
-            if(o instanceof SimplePluginManager){
-                SimplePluginManager spm = (SimplePluginManager)o;
-                try {
-                    Method m = spm.getClass().getDeclaredMethod("getEventListeners", Event.Type.class);
-                    m.setAccessible(true);
-                    SortedSet<RegisteredListener> ss = (SortedSet<RegisteredListener>) m.invoke(spm, Event.Type.PLAYER_COMMAND_PREPROCESS);
-                    for(RegisteredListener l : ss){
-                        if(l.getPlugin().getDescription().getName().equals(args[0].val())){
-                            PluginCommand.class.getDeclaredMethods();
-                            Constructor c = PluginCommand.class.getDeclaredConstructor(String.class, Plugin.class);
-                            c.setAccessible(true);
-                            Command com = (Command)c.newInstance(l.getPlugin().getDescription().getName(), l.getPlugin()); 
-                            List<String> argList = Arrays.asList(args[1].val().split(" "));
-//                            com.execute(p, argList.get(0).substring(1), argList.subList(1, argList.size()).toArray(new String[]{}));
-//                            l.callEvent(new Event() {});
-//                            break;
-                            l.getPlugin().onCommand(p, com, argList.get(0).substring(1), argList.subList(1, argList.size()).toArray(new String[]{}));
-                        }
-                    }
-                } catch (InstantiationException ex) {
-                    Logger.getLogger(Sandbox.class.getName()).log(Level.SEVERE, null, ex);
-                } catch (IllegalAccessException ex) {
-                    Logger.getLogger(Sandbox.class.getName()).log(Level.SEVERE, null, ex);
-                } catch (IllegalArgumentException ex) {
-                    Logger.getLogger(Sandbox.class.getName()).log(Level.SEVERE, null, ex);
-                } catch (InvocationTargetException ex) {
-                    Logger.getLogger(Sandbox.class.getName()).log(Level.SEVERE, null, ex);
-                } catch (NoSuchMethodException ex) {
-                    Logger.getLogger(Sandbox.class.getName()).log(Level.SEVERE, null, ex);
-                } catch (SecurityException ex) {
-                    Logger.getLogger(Sandbox.class.getName()).log(Level.SEVERE, null, ex);
-                }
-            }
-            
-            return new CVoid(line_num, f);
-        }
-        
-    }
-    
-    @api public static class pdrop implements Function{
-
-        public String getName() {
-            return "item_drop";
-        }
-
-        public Integer[] numArgs() {
-            return new Integer[]{1, 2, 3};
-        }
-
-        public String docs() {
-            return "void {[player/LocationArray], item, [qty]} Drops the specified item at the specified quantity at the specified player's feet (or "
-                    + " at an arbitrary Location, if an array is given),"
-                    + " like the vanilla /give command. player defaults to the current player, and qty defaults to 1. item follows the"
-                    + " same type[:data] format used elsewhere.";
-        }
-
-        public ExceptionType[] thrown() {
-            return new ExceptionType[]{ExceptionType.CastException, ExceptionType.FormatException, ExceptionType.PlayerOfflineException};
-        }
-
-        public boolean isRestricted() {
-            return true;
-        }
-
-        public void varList(IVariableList varList) {}
-
-        public boolean preResolveVariables() {
-            return true;
-        }
-
-        public String since() {
-            return "3.2.0";
-        }
-
-        public Boolean runAsync() {
-            return false;
-        }
-
-        public Construct exec(int line_num, File f, CommandSender p, Construct... args) throws ConfigRuntimeException {
-
-            Location l = null;
-            int qty = 1;
-            ItemStack is = null;
-            boolean natural = false;
-            if(p instanceof Player){
-                l = ((Player)p).getLocation();
-            }
-            if(args.length == 1){
-                //It is just the item
-                is = Static.ParseItemNotation(this.getName(), args[0].val(), qty, line_num, f);
-                natural = true;
-            } else if(args.length == 2){
-                //If args[0] starts with a number, it's the (item, qty) version, otherwise it's
-                //(player, item)
-                if(args[0].val().matches("\\d.*")){
-                    qty = (int)Static.getInt(args[1]);
-                    is = Static.ParseItemNotation(this.getName(), args[0].val(), qty, line_num, f);
-                    natural = true;
-                } else {
-                    if(args[0] instanceof CArray){
-                        l = Static.GetLocation(args[0], (l != null?l.getWorld():null), line_num, f);
-                        natural = false;
-                    } else {
-                        l = Static.GetPlayer(args[0].val(), line_num, f).getLocation();
-                        natural = true;
-                    }
-                    is = Static.ParseItemNotation(this.getName(), args[1].val(), qty, line_num, f);
-                    
-                }
-            } else if(args.length == 3){
-                //We are specifying all 3
-                if(args[0] instanceof CArray){
-                    l = Static.GetLocation(args[0], (l != null?l.getWorld():null), line_num, f);
-                    natural = false;
-                } else {
-                    l = Static.GetPlayer(args[0].val(), line_num, f).getLocation();
-                    natural = true;
-                }
-                qty = (int)Static.getInt(args[2]);
-                is = Static.ParseItemNotation(this.getName(), args[1].val(), qty, line_num, f);
-            }      
-            if(l.getWorld() != null){
-                if(natural){
-                    l.getWorld().dropItemNaturally(l, is);
-                } else {
-                    l.getWorld().dropItem(l, is);
-                }
-            } else {
-                throw new ConfigRuntimeException("World was not specified", ExceptionType.InvalidWorldException, line_num, f);
-            }
-
-            return new CVoid(line_num, f);
-        }
-        
-    }
-    
-    @api public static class npe implements Function{
-
-        public String getName() {
-            return "npe";
-        }
-
-        public Integer[] numArgs() {
-            return new Integer[]{0};
-        }
-
-        public String docs() {
-            return "void {}";
-        }
-
-        public ExceptionType[] thrown() {
-            return null;
-        }
-
-        public boolean isRestricted() {
-            return true;
-        }
-
-        public void varList(IVariableList varList) {}
-
-        public boolean preResolveVariables() {
-            return true;
-        }
-
-        public String since() {
-            return "0.0.0";
-        }
-
-        public Boolean runAsync() {
-            return null;
-        }
-
-        public Construct exec(int line_num, File f, CommandSender p, Construct... args) throws ConfigRuntimeException {
-            Object o = null;
-            o.toString();
-            return new CVoid(line_num, f);
-        }
-        
-    }
-    
-    
-        
-}
diff --git a/src/main/java/com/laytonsmith/aliasengine/functions/Scheduling.java b/src/main/java/com/laytonsmith/aliasengine/functions/Scheduling.java
deleted file mode 100644
index a7c5613..0000000
--- a/src/main/java/com/laytonsmith/aliasengine/functions/Scheduling.java
+++ /dev/null
@@ -1,171 +0,0 @@
-/*
- * To change this template, choose Tools | Templates
- * and open the template in the editor.
- */
-package com.laytonsmith.aliasengine.functions;
-
-import com.laytonsmith.aliasengine.functions.exceptions.CancelCommandException;
-import com.laytonsmith.aliasengine.functions.exceptions.ConfigRuntimeException;
-import com.laytonsmith.aliasengine.Constructs.CInt;
-import com.laytonsmith.aliasengine.Constructs.CVoid;
-import com.laytonsmith.aliasengine.Constructs.Construct;
-import com.laytonsmith.aliasengine.Static;
-import com.laytonsmith.aliasengine.functions.Exceptions.ExceptionType;
-import java.io.File;
-import org.bukkit.command.CommandSender;
-
-/**
- *
- * @author Layton
- */
-public class Scheduling {
-    public static String docs(){
-        return "This class contains methods for dealing with time and bukkit scheduling.";
-    }
-    @api public static class time implements Function{
-
-        public String getName() {
-            return "time";
-        }
-
-        public Integer[] numArgs() {
-            return new Integer[]{0};
-        }
-
-        public String docs() {
-            return "int {} Returns the current unix time stamp, in milliseconds. The resolution of this is not guaranteed to be extremely accurate. If "
-                    + "you need extreme accuracy, use nano_time()";
-        }
-        
-        public ExceptionType[] thrown() {
-            return new ExceptionType[]{};
-        }
-
-        public boolean isRestricted() {
-            return false;
-        }
-
-        public void varList(IVariableList varList) {}
-
-        public boolean preResolveVariables() {
-            return true;
-        }
-
-        public String since() {
-            return "3.1.0";
-        }
-
-        public Boolean runAsync() {
-            return null;
-        }
-
-        public Construct exec(int line_num, File f, CommandSender p, Construct... args) throws CancelCommandException, ConfigRuntimeException {
-            return new CInt(System.currentTimeMillis(), line_num, f);
-        }
-        
-    }
-    
-    @api public static class nano_time implements Function{
-
-        public String getName() {
-            return "nano_time";
-        }
-
-        public Integer[] numArgs() {
-            return new Integer[]{0};
-        }
-
-        public String docs() {
-            return "int {} Returns an arbitrary number based on the most accurate clock available on this system. Only useful when compared to other calls"
-                    + " to nano_time(). The return is in nano seconds. See the Java API on System.nanoTime() for more information on the usage of this function.";
-        }
-        
-        public ExceptionType[] thrown() {
-            return new ExceptionType[]{};
-        }
-
-        public boolean isRestricted() {
-            return false;
-        }
-
-        public void varList(IVariableList varList) {}
-
-        public boolean preResolveVariables() {
-            return true;
-        }
-
-        public String since() {
-            return "3.1.0";
-        }
-
-        public Boolean runAsync() {
-            return null;
-        }
-
-        public Construct exec(int line_num, File f, CommandSender p, Construct... args) throws CancelCommandException, ConfigRuntimeException {
-            return new CInt(System.nanoTime(), line_num, f);
-        }
-        
-    }
-    
-    public static class sleep implements Function {
-
-        public String getName() {
-            return "sleep";
-        }
-
-        public Integer[] numArgs() {
-            return new Integer[]{1};
-        }
-
-        public String docs() {
-            return "void {seconds} Sleeps the script for the specified number of seconds, up to the maximum time limit defined in the preferences file."
-                    + " Seconds may be a double value, so 0.5 would be half a second."
-                    + " PLEASE NOTE: Sleep times are NOT very accurate, and should not be relied on for preciseness.";
-        }
-        
-        public ExceptionType[] thrown() {
-            return new ExceptionType[]{ExceptionType.CastException};
-        }
-
-        public boolean isRestricted() {
-            return true;
-        }
-
-        public void varList(IVariableList varList) {
-        }
-
-        public boolean preResolveVariables() {
-            return true;
-        }
-
-        public String since() {
-            return "3.1.0";
-        }
-
-        public Construct exec(int line_num, File f, CommandSender p, Construct... args) throws CancelCommandException, ConfigRuntimeException {
-            if (Thread.currentThread().getName().equals("Server thread")) {
-                throw new ConfigRuntimeException("sleep() cannot be run in the main server thread", 
-                        null, line_num, f);
-            }
-            Construct x = args[0];
-            double time = Static.getNumber(x);
-            Integer i = (Integer) (Static.getPreferences().getPreference("max-sleep-time"));
-            if (i > time || i <= 0) {
-                try {
-                    Thread.sleep((int)(time * 1000));
-                } catch (InterruptedException ex) {
-                }
-            } else {
-                throw new ConfigRuntimeException("The value passed to sleep must be less than the server defined value of " + i + " seconds or less.", 
-                        ExceptionType.RangeException, line_num, f);
-            }
-            return new CVoid(line_num, f);
-        }
-
-        public Boolean runAsync() {
-            //Because we stop the thread
-            return true;
-        }
-    }
-}
diff --git a/src/main/java/com/laytonsmith/aliasengine/functions/StringHandling.java b/src/main/java/com/laytonsmith/aliasengine/functions/StringHandling.java
deleted file mode 100644
index 2923554..0000000
--- a/src/main/java/com/laytonsmith/aliasengine/functions/StringHandling.java
+++ /dev/null
@@ -1,522 +0,0 @@
-/*
- * To change this template, choose Tools | Templates
- * and open the template in the editor.
- */
-package com.laytonsmith.aliasengine.functions;
-
-import com.laytonsmith.aliasengine.functions.exceptions.CancelCommandException;
-import com.laytonsmith.aliasengine.functions.exceptions.ConfigRuntimeException;
-import com.laytonsmith.aliasengine.Constructs.CArray;
-import com.laytonsmith.aliasengine.Constructs.CInt;
-import com.laytonsmith.aliasengine.Constructs.CString;
-import com.laytonsmith.aliasengine.Constructs.Construct;
-import com.laytonsmith.aliasengine.Static;
-import com.laytonsmith.aliasengine.functions.Exceptions.ExceptionType;
-import java.io.BufferedReader;
-import java.io.File;
-import java.io.FileReader;
-import java.util.ArrayList;
-import java.util.logging.Level;
-import org.bukkit.command.CommandSender;
-
-/**
- *
- * @author Layton
- */
-public class StringHandling {
-
-    public static String docs() {
-        return "These class provides functions that allow strings to be manipulated";
-    }
-
-    @api
-    public static class concat implements Function {
-
-        public String getName() {
-            return "concat";
-        }
-
-        public Integer[] numArgs() {
-            return new Integer[]{Integer.MAX_VALUE};
-        }
-        
-        public ExceptionType[] thrown() {
-            return new ExceptionType[]{};
-        }
-
-        public Construct exec(int line_num, File f, CommandSender p, Construct... args) throws CancelCommandException, ConfigRuntimeException {
-            StringBuilder b = new StringBuilder();
-            for (int i = 0; i < args.length; i++) {
-                b.append(args[i].val());
-            }
-            return new CString(b.toString(), line_num, f);
-        }
-
-        public String docs() {
-            return "string {var1, [var2...]} Concatenates any number of arguments together, and returns a string";
-        }
-
-        public boolean isRestricted() {
-            return false;
-        }
-
-        public void varList(IVariableList varList) {
-        }
-
-        public boolean preResolveVariables() {
-            return true;
-        }
-        public String since() {
-            return "3.0.1";
-        }
-        public Boolean runAsync(){
-            return null;
-        }
-    }
-
-    @api
-    public static class sconcat implements Function {
-
-        public String getName() {
-            return "sconcat";
-        }
-
-        public Integer[] numArgs() {
-            return new Integer[]{Integer.MAX_VALUE};
-        }
-
-        public Construct exec(int line_num, File f, CommandSender p, Construct... args) throws CancelCommandException, ConfigRuntimeException {
-            StringBuilder b = new StringBuilder();
-            for (int i = 0; i < args.length; i++) {
-                if (i > 0) {
-                    b.append(" ");
-                }
-                b.append(args[i].val());
-            }
-            return new CString(b.toString(), line_num, f);
-        }
-
-        public String docs() {
-            return "string {var1, [var2...]} Concatenates any number of arguments together, but puts a space between elements";
-        }
-        
-        public ExceptionType[] thrown() {
-            return new ExceptionType[]{};
-        }
-
-        public boolean isRestricted() {
-            return false;
-        }
-
-        public void varList(IVariableList varList) {
-        }
-
-        public boolean preResolveVariables() {
-            return true;
-        }
-        public String since() {
-            return "3.0.1";
-        }
-        public Boolean runAsync(){
-            return null;
-        }
-    }
-
-    @api
-    public static class read implements Function {
-
-        public static String file_get_contents(String file_location) throws Exception {
-            BufferedReader in = new BufferedReader(new FileReader(file_location));
-            StringBuilder ret = new StringBuilder();
-            String str;
-            while ((str = in.readLine()) != null) {
-                ret.append(str).append("\n");
-            }
-            in.close();
-            return ret.toString();
-        }
-
-        public String getName() {
-            return "read";
-        }
-
-        public Integer[] numArgs() {
-            return new Integer[]{1};
-        }
-
-        public Construct exec(int line_num, File f, CommandSender p, Construct... args) throws CancelCommandException, ConfigRuntimeException {
-            String location = args[0].val();
-            //Verify this file is not above the craftbukkit directory (or whatever directory the user specified
-            if(!Static.CheckSecurity(location)){
-                throw new ConfigRuntimeException("You do not have permission to access the file '" + location + "'", 
-                        ExceptionType.SecurityException, line_num, f);
-            }
-            try {
-                String s = file_get_contents(location);
-                s = s.replaceAll("\n|\r\n", "\n");
-                return new CString(s, line_num, f);
-            } catch (Exception ex) {
-                Static.getLogger().log(Level.SEVERE, "Could not read in file while attempting to find " + new File(location).getAbsolutePath()
-                        + "\nFile " + (new File(location).exists()?"exists":"does not exist"));
-                ex.printStackTrace();
-                throw new ConfigRuntimeException("File could not be read in.", 
-                        ExceptionType.IOException, line_num, f);
-            }
-        }
-
-        public String docs() {
-            return "string {file} Reads in a file from the file system at location var1 and returns it as a string. The path is relative to"
-                    + " CraftBukkit, not CommandHelper. If the file is not found, or otherwise can't be read in, an IOException is thrown."
-                    + " If the file specified is not within base-dir (as specified in the preferences file), a SecurityException is thrown."
-                    + " The line endings for the string returned will always be \\n, even if they originally were \\r\\n.";
-        }
-        
-        public ExceptionType[] thrown() {
-            return new ExceptionType[]{ExceptionType.IOException, ExceptionType.SecurityException};
-        }
-
-        public boolean isRestricted() {
-            return true;
-        }
-
-        public void varList(IVariableList varList) {
-        }
-
-        public boolean preResolveVariables() {
-            return true;
-        }
-        public String since() {
-            return "3.0.1";
-        }
-        public Boolean runAsync(){
-            //Because we do disk IO
-            return true;
-        }
-    }
-
-    @api
-    public static class replace implements Function {
-
-        public String getName() {
-            return "replace";
-        }
-
-        public Integer[] numArgs() {
-            return new Integer[]{3};
-        }
-
-        public Construct exec(int line_num, File f, CommandSender p, Construct... args) throws CancelCommandException, ConfigRuntimeException {
-            String thing = args[0].val();
-            String what = args[1].val();
-            String that = args[2].val();
-            return new CString(thing.replace(what, that), line_num, f);
-        }
-
-        public String docs() {
-            return "string {main, what, that} Replaces all instances of 'what' with 'that' in 'main'";
-        }
-        
-        public ExceptionType[] thrown() {
-            return new ExceptionType[]{};
-        }
-
-        public boolean isRestricted() {
-            return false;
-        }
-
-        public void varList(IVariableList varList) {
-        }
-
-        public boolean preResolveVariables() {
-            return true;
-        }
-        public String since() {
-            return "3.0.1";
-        }
-        public Boolean runAsync(){
-            return null;
-        }
-    }
-
-    @api
-    public static class parse_args implements Function {
-
-        public String getName() {
-            return "parse_args";
-        }
-
-        public Integer[] numArgs() {
-            return new Integer[]{1};
-        }
-
-        public Construct exec(int line_num, File f, CommandSender p, Construct... args) throws CancelCommandException, ConfigRuntimeException {
-            String[] sa = args[0].val().split(" ");
-            ArrayList<Construct> a = new ArrayList<Construct>();
-            for (String s : sa) {
-                if (!s.trim().equals("")) {
-                    a.add(new CString(s.trim(), line_num, f));
-                }
-            }
-            Construct[] csa = new Construct[a.size()];
-            for (int i = 0; i < a.size(); i++) {
-                csa[i] = a.get(i);
-            }
-            return new CArray(line_num, f, csa);
-        }
-
-        public String docs() {
-            return "array {string} Parses string into an array, where string is a space seperated list of arguments. Handy for turning"
-                    + " $ into a usable array of items with which to script against. Extra spaces are ignored, so you would never get an empty"
-                    + " string as an input.";
-        }
-        
-        public ExceptionType[] thrown() {
-            return new ExceptionType[]{};
-        }
-
-        public boolean isRestricted() {
-            return false;
-        }
-
-        public void varList(IVariableList varList) {
-        }
-
-        public boolean preResolveVariables() {
-            return true;
-        }
-        public String since() {
-            return "3.0.1";
-        }
-        public Boolean runAsync(){
-            return null;
-        }
-    }
-    
-    @api public static class trim implements Function{
-
-        public String getName() {
-            return "trim";
-        }
-
-        public Integer[] numArgs() {
-            return new Integer[]{1};
-        }
-
-        public String docs() {
-            return "string {s} Returns the string s with leading and trailing whitespace cut off";
-        }
-        
-        public ExceptionType[] thrown() {
-            return new ExceptionType[]{};
-        }
-
-        public boolean isRestricted() {
-            return false;
-        }
-
-        public void varList(IVariableList varList) {}
-
-        public boolean preResolveVariables() {
-            return true;
-        }
-
-        public String since() {
-            return "3.0.1";
-        }
-
-        public Construct exec(int line_num, File f, CommandSender p, Construct... args) throws CancelCommandException, ConfigRuntimeException {
-            return new CString(args[0].val().trim(), args[0].getLineNum(), args[0].getFile());
-        }
-        public Boolean runAsync(){
-            return null;
-        }
-        
-    }
-    
-    @api public static class length implements Function{
-
-        public String getName() {
-            return "length";
-        }
-
-        public Integer[] numArgs() {
-            return new Integer[]{1};
-        }
-
-        public String docs() {
-            return "int {str | array} Returns the character length of str, if the value is castable to a string, or the length of the array, if an array is given";
-        }
-        
-        public ExceptionType[] thrown() {
-            return new ExceptionType[]{};
-        }
-
-        public boolean isRestricted() {
-            return false;
-        }
-
-        public void varList(IVariableList varList) {}
-
-        public boolean preResolveVariables() {
-            return true;
-        }
-
-        public String since() {
-            return "3.1.2";
-        }
-
-        public Boolean runAsync() {
-            return null;
-        }
-
-        public Construct exec(int line_num, File f, CommandSender p, Construct... args) throws CancelCommandException, ConfigRuntimeException {
-            if(args[0] instanceof CArray){
-                return new CInt(((CArray)args[0]).size(), line_num, f);
-            } else {
-                return new CInt(args[0].val().length(), line_num, f);
-            }
-        }
-        
-    }
-    
-    @api public static class to_upper implements Function{
-
-        public String getName() {
-            return "to_upper";
-        }
-
-        public Integer[] numArgs() {
-            return new Integer[]{1};
-        }
-
-        public String docs() {
-            return "string {str} Returns an all caps version of str";
-        }
-        
-        public ExceptionType[] thrown() {
-            return new ExceptionType[]{};
-        }
-
-        public boolean isRestricted() {
-            return false;
-        }
-
-        public void varList(IVariableList varList) {}
-
-        public boolean preResolveVariables() {
-            return true;
-        }
-
-        public String since() {
-            return "3.1.2";
-        }
-
-        public Boolean runAsync() {
-            return null;
-        }
-
-        public Construct exec(int line_num, File f, CommandSender p, Construct... args) throws CancelCommandException, ConfigRuntimeException {
-            return new CString(args[0].val().toUpperCase(), line_num, f);
-        }
-        
-    }
-    
-    @api public static class to_lower implements Function{
-
-        public String getName() {
-            return "to_lower";
-        }
-
-        public Integer[] numArgs() {
-            return new Integer[]{1};
-        }
-
-        public String docs() {
-            return "string {str} Returns an all lower case version of str";
-        }
-        
-        public ExceptionType[] thrown() {
-            return new ExceptionType[]{};
-        }
-
-        public boolean isRestricted() {
-            return false;
-        }
-
-        public void varList(IVariableList varList) {}
-
-        public boolean preResolveVariables() {
-            return true;
-        }
-
-        public String since() {
-            return "3.1.2";
-        }
-
-        public Boolean runAsync() {
-            return null;
-        }
-
-        public Construct exec(int line_num, File f, CommandSender p, Construct... args) throws CancelCommandException, ConfigRuntimeException {
-            return new CString(args[0].val().toLowerCase(), line_num, f);
-        }        
-    }
-    
-    @api public static class substr implements Function{
-
-        public String getName() {
-            return "substr";
-        }
-
-        public Integer[] numArgs() {
-            return new Integer[]{2,3};
-        }
-
-        public String docs() {
-            return "string {str, begin, [end]} Returns a substring of the given string str, starting from index begin, to index end, or the"
-                    + " end of the string, if no index is given. If either begin or end are out of bounds of the string, an exception is thrown."
-                    + " substr('hamburger', 4, 8) returns \"urge\", substr('smiles', 1, 5) returns \"mile\", and substr('lightning', 5) returns \"ning\"."
-                    + " See also length().";
-        }
-        
-        public ExceptionType[] thrown() {
-            return new ExceptionType[]{ExceptionType.RangeException, ExceptionType.CastException};
-        }
-
-        public boolean isRestricted() {
-            return false;
-        }
-
-        public void varList(IVariableList varList) {}
-
-        public boolean preResolveVariables() {
-            return true;
-        }
-
-        public String since() {
-            return "3.1.2";
-        }
-
-        public Boolean runAsync() {
-            return null;
-        }
-
-        public Construct exec(int line_num, File f, CommandSender p, Construct... args) throws CancelCommandException, ConfigRuntimeException {
-            try{
-                String s = args[0].val();
-                int begin = (int)Static.getInt(args[1]);
-                int end;
-                if(args.length == 3){
-                    end = (int)Static.getInt(args[2]);
-                } else {
-                    end = s.length();
-                }
-                return new CString(s.substring(begin, end), line_num, f);
-            } catch(IndexOutOfBoundsException e){
-                throw new ConfigRuntimeException("The indices given are not valid for string '" + args[0].val() + "'",
-                        ExceptionType.RangeException, line_num, f);
-            }
-        }
-        
-    }     
-}
diff --git a/src/main/java/com/laytonsmith/aliasengine/functions/Weather.java b/src/main/java/com/laytonsmith/aliasengine/functions/Weather.java
deleted file mode 100644
index bce2c54..0000000
--- a/src/main/java/com/laytonsmith/aliasengine/functions/Weather.java
+++ /dev/null
@@ -1,155 +0,0 @@
-/*
- * To change this template, choose Tools | Templates
- * and open the template in the editor.
- */
-package com.laytonsmith.aliasengine.functions;
-
-import com.laytonsmith.aliasengine.functions.exceptions.CancelCommandException;
-import com.laytonsmith.aliasengine.functions.exceptions.ConfigRuntimeException;
-import com.laytonsmith.aliasengine.Constructs.CArray;
-import com.laytonsmith.aliasengine.Constructs.CVoid;
-import com.laytonsmith.aliasengine.Constructs.Construct;
-import com.laytonsmith.aliasengine.Static;
-import com.laytonsmith.aliasengine.functions.Exceptions.ExceptionType;
-import java.io.File;
-import org.bukkit.Location;
-import org.bukkit.World;
-import org.bukkit.command.CommandSender;
-import org.bukkit.entity.Player;
-
-/**
- *
- * @author Layton
- */
-public class Weather {
-    public static String docs(){
-        return "Provides functions to control the weather";
-    }
-    
-    @api public static class lightning implements Function{
-
-        public String getName() {
-            return "lightning";
-        }
-
-        public Integer[] numArgs() {
-            return new Integer[]{1, 3};
-        }
-        
-        public ExceptionType[] thrown() {
-            return new ExceptionType[]{ExceptionType.CastException, ExceptionType.LengthException, ExceptionType.InvalidWorldException};
-        }
-
-        public Construct exec(int line_num, File f, CommandSender p, Construct... args) throws CancelCommandException, ConfigRuntimeException {
-            int x;
-            int y;
-            int z;
-            World w = null;
-            if(args.length == 1){
-                if(args[0] instanceof CArray){
-                    CArray a = (CArray)args[0];
-                    if(a.size() != 3){
-                        throw new ConfigRuntimeException("lightning expects the array to be a location array", 
-                                ExceptionType.LengthException, line_num, f);
-                    }
-                    Location l = Static.GetLocation(a, (p instanceof Player?((Player)p).getWorld():null), line_num, f);
-                    x = (int)java.lang.Math.floor(l.getX());
-                    y = (int)java.lang.Math.floor(l.getY());
-                    z = (int)java.lang.Math.floor(l.getZ());
-                    w = l.getWorld();
-                } else {
-                    throw new ConfigRuntimeException("lightning expects an array as the one argument", 
-                            ExceptionType.CastException, line_num, f);
-                }
-            } else {
-                x = (int)java.lang.Math.floor(Static.getNumber(args[0]));
-                y = (int)java.lang.Math.floor(Static.getNumber(args[1]));
-                z = (int)java.lang.Math.floor(Static.getNumber(args[2]));
-            }
-            if(w != null){
-                w.strikeLightning(new Location(w, x, y + 1, z)); 
-            } else {
-                throw new ConfigRuntimeException("World was not specified", ExceptionType.InvalidWorldException, line_num, f);
-            }
-//            World w = ((CraftWorld)p.getWorld()).getHandle();
-//            EntityWeatherStorm e = new EntityWeatherStorm(w, x, y, z);
-//            w.a(e);
-            
-            return new CVoid(line_num, f);
-        }
-
-        public String docs() {
-            return "void {strikeLocArray | x, y, z} Makes lightning strike at the x y z coordinates specified in the array(x, y, z).";
-        }
-
-        public boolean isRestricted() {
-            return true;
-        }
-
-        public void varList(IVariableList varList) {}
-
-        public boolean preResolveVariables() {
-            return true;
-        }
-        public String since() {
-            return "3.0.1";
-        }
-        public Boolean runAsync(){
-            return false;
-        }
-    }
-    
-    @api public static class storm implements Function{
-
-        public String getName() {
-            return "storm";
-        }
-
-        public Integer[] numArgs() {
-            return new Integer[]{1, 2};
-        }
-
-        public Construct exec(int line_num, File f, CommandSender p, Construct... args) throws CancelCommandException, ConfigRuntimeException {
-            boolean b = Static.getBoolean(args[0]);
-            World w = null;
-            if(p instanceof Player){
-                w = ((Player)p).getWorld();
-            }
-            if(args.length == 2){
-                w = Static.getServer().getWorld(args[1].val());
-            }
-            if(w != null){
-                w.setStorm(b);
-            } else {
-                throw new ConfigRuntimeException("World was not specified", ExceptionType.InvalidWorldException, line_num, f);
-            }
-            return new CVoid(line_num, f);
-        }
-
-        public String docs() {
-            return "void {isStorming, [world]} Creates a storm if isStorming is true, stops a storm if isStorming is false";
-        }
-        
-        public ExceptionType[] thrown() {
-            return new ExceptionType[]{ExceptionType.CastException, ExceptionType.InvalidWorldException};
-        }
-
-        public boolean isRestricted() {
-            return true;
-        }
-
-        public void varList(IVariableList varList) {}
-
-        public boolean preResolveVariables() {
-            return true;
-        }
-        public String since() {
-            return "3.0.1";
-        }
-        public Boolean runAsync(){
-            return false;
-        }
-        
-    }
-    
-}
diff --git a/src/main/java/com/laytonsmith/aliasengine/functions/WorldEdit.java b/src/main/java/com/laytonsmith/aliasengine/functions/WorldEdit.java
deleted file mode 100644
index ce7dfd7..0000000
--- a/src/main/java/com/laytonsmith/aliasengine/functions/WorldEdit.java
+++ /dev/null
@@ -1,410 +0,0 @@
-/*
- * To change this template, choose Tools | Templates
- * and open the template in the editor.
- */
-package com.laytonsmith.aliasengine.functions;
-
-import com.laytonsmith.aliasengine.Constructs.*;
-import com.laytonsmith.aliasengine.functions.exceptions.CancelCommandException;
-import com.laytonsmith.aliasengine.functions.exceptions.ConfigRuntimeException;
-import com.laytonsmith.aliasengine.Static;
-import com.laytonsmith.aliasengine.functions.Exceptions.ExceptionType;
-import java.io.File;
-
-import com.sk89q.worldedit.BlockVector2D;
-import com.sk89q.worldedit.bukkit.BukkitUtil;
-import com.sk89q.worldedit.Vector;
-import com.sk89q.worldedit.regions.CuboidRegion;
-import com.sk89q.worldedit.regions.CuboidRegionSelector;
-import com.sk89q.worldedit.regions.RegionSelector;
-
-import java.util.*;
-
-import com.sk89q.worldguard.protection.GlobalRegionManager;
-import com.sk89q.worldguard.protection.UnsupportedIntersectionException;
-import com.sk89q.worldguard.protection.flags.Flag;
-import com.sk89q.worldguard.protection.managers.RegionManager;
-import com.sk89q.worldguard.protection.regions.ProtectedCuboidRegion;
-import com.sk89q.worldguard.protection.regions.ProtectedPolygonalRegion;
-import com.sk89q.worldguard.protection.regions.ProtectedRegion;
-import org.bukkit.Bukkit;
-import org.bukkit.Location;
-import org.bukkit.World;
-import org.bukkit.command.CommandSender;
-import org.bukkit.entity.Player;
-
-/**
- *
- * @author Layton
- */
-public class WorldEdit {
-
-    public static String docs() {
-        return "Provides various methods for programmatically hooking into WorldEdit";
-    }
-
-    @api public static class sk_pos1 extends SKFunction {
-
-        public String getName() {
-            return "sk_pos1";
-        }
-
-        public Integer[] numArgs() {
-            return new Integer[]{0, 1, 2};
-        }
-
-        public ExceptionType[] thrown() {
-            return new ExceptionType[]{ExceptionType.PlayerOfflineException, ExceptionType.CastException};
-        }
-
-        public String docs() {
-            return "mixed {[player], locationArray | [player]} Sets the player's point 1, or returns it if the array to set isn't specified. If"
-                    + " the location is returned, it is returned as a 4 index array:(x, y, z, world)";
-        }
-
-        public Construct exec(int line_num, File f, CommandSender p, Construct... args) throws CancelCommandException, ConfigRuntimeException {
-            Player m = null;
-            Location l = null;
-            boolean setter = false;
-            Static.checkPlugin("WorldEdit", line_num, f);
-            
-            if(p instanceof Player){
-                m = (Player)p;
-            }
-            if(args.length == 2){
-                m = Static.GetPlayer(args[0].val(), line_num, f);
-                l = Static.GetLocation(args[1], m.getWorld(), line_num, f);
-                setter = true;
-            } else if(args.length == 1){
-                if(args[0] instanceof CArray){
-                    l = Static.GetLocation(args[0], (m==null?null:m.getWorld()), line_num, f);
-                    setter = true;
-                } else {
-                    m = Static.GetPlayer(args[0].val(), line_num, f);
-                }
-            }
-
-            if (m == null) {
-                throw new ConfigRuntimeException(this.getName() + " needs a player", ExceptionType.PlayerOfflineException, line_num, f);
-            }
-
-            RegionSelector sel = Static.getWorldEditPlugin().getSession(m).getRegionSelector(BukkitUtil.getLocalWorld(m.getWorld()));
-            if (!(sel instanceof CuboidRegionSelector)) {
-                throw new ConfigRuntimeException("Only cuboid regions are supported with " + this.getName(), ExceptionType.PluginInternalException, line_num, f);
-            }
-            if(setter){
-                sel.selectPrimary(BukkitUtil.toVector(l));
-                return new CVoid(line_num, f);
-            } else {
-                Vector pt = ((CuboidRegion) sel.getIncompleteRegion()).getPos1();
-                if (pt == null) throw new ConfigRuntimeException("Point in " + this.getName() +  "undefined", line_num, f);
-                return new CArray(line_num, f,
-                        new CInt(pt.getBlockX(), line_num, f),
-                        new CInt(pt.getBlockY(), line_num, f),
-                        new CInt(pt.getBlockZ(), line_num, f),
-                        new CString(m.getWorld().getName(), line_num, f));
-            }
-        }
-    }
-
-    @api public static class sk_pos2 extends SKFunction {
-
-        public String getName() {
-            return "sk_pos2";
-        }
-
-        public Integer[] numArgs() {
-            return new Integer[]{0, 1, 2};
-        }
-
-        public String docs() {
-            return "mixed {[player], array | [player]} Sets the player's point 2, or returns it if the array to set isn't specified";
-        }
-
-        public ExceptionType[] thrown() {
-            return new ExceptionType[]{ExceptionType.PlayerOfflineException, ExceptionType.CastException};
-        }
-
-        public Construct exec(int line_num, File f, CommandSender p, Construct... args) throws CancelCommandException, ConfigRuntimeException {
-            Player m = null;
-            Location l = null;
-            boolean setter = false;
-            Static.checkPlugin("WorldEdit", line_num, f);
-
-            if (p instanceof Player) {
-                m = (Player)p;
-            }
-            if (args.length == 2){
-                m = Static.GetPlayer(args[0].val(), line_num, f);
-                l = Static.GetLocation(args[1], m.getWorld(), line_num, f);
-                setter = true;
-            } else if (args.length == 1){
-                if (args[0] instanceof CArray) {
-                    l = Static.GetLocation(args[0], (m==null?null:m.getWorld()), line_num, f);
-                    setter = true;
-                } else {
-                    m = Static.GetPlayer(args[0].val(), line_num, f);
-                }
-            }
-
-            if (m == null) {
-                throw new ConfigRuntimeException(this.getName() + " needs a player", ExceptionType.PlayerOfflineException, line_num, f);
-            }
-
-            RegionSelector sel = Static.getWorldEditPlugin().getSession(m).getRegionSelector(BukkitUtil.getLocalWorld(m.getWorld()));
-            if (!(sel instanceof CuboidRegionSelector)) {
-                throw new ConfigRuntimeException("Only cuboid regions are supported with " + this.getName(), ExceptionType.PluginInternalException, line_num, f);
-            }
-
-            if(setter){
-                sel.selectSecondary(BukkitUtil.toVector(l));
-                return new CVoid(line_num, f);
-            } else {
-                Vector pt = ((CuboidRegion)sel.getIncompleteRegion()).getPos2();
-                if (pt == null) throw new ConfigRuntimeException("Point in " + this.getName() +  "undefined", line_num, f);
-                return new CArray(line_num, f,
-                        new CInt(pt.getBlockX(), line_num, f),
-                        new CInt(pt.getBlockY(), line_num, f),
-                        new CInt(pt.getBlockZ(), line_num, f),
-                        new CString(m.getWorld().getName(), line_num, f));
-            }
-        }
-    }
-
-//    public static class sk_points extends SKFunction {
-//
-//        public String getName() {
-//            return "sk_points";
-//        }
-//
-//        public Integer[] numArgs() {
-//            return new Integer[]{0, 1, 2};
-//        }
-//
-//        public String docs() {
-//            return "mixed {[player], arrayOfArrays | [player]} Sets a series of points, or returns the poly selection for this player, if one is specified."
-//                    + " The array should be an array of arrays, and the arrays should be array(x, y, z)";
-//        }
-//
-//        public ExceptionType[] thrown() {
-//            return new ExceptionType[]{ExceptionType.PlayerOfflineException, ExceptionType.CastException};
-//        }
-//
-//        public Construct exec(int line_num, File f, CommandSender p, Construct... args) throws CancelCommandException, ConfigRuntimeException {
-//            Static.checkPlugin("WorldEdit", line_num, f);
-//            return new CVoid(line_num, f);
-//        }
-//    }
-
-    @api public static class sk_region_info extends SKFunction {
-
-        public String getName() {
-            return "sk_region_info";
-        }
-
-        public Integer[] numArgs() {
-            return new Integer[]{2};
-        }
-
-        public String docs() {
-            return "array {region, world} Given a region name, returns an array of information about that region, as follows:<ul>"
-                    + " <li>0 - An array of points that define this region</li>"
-                    + " <li>1 - An array of owners of this region</li>"
-                    + " <li>2 - An array of members of this region</li>"
-                    + " <li>3 - An array of arrays of this region's flags, where each array is: array(flag_name, value)</li>"
-                    + " <li>4 - This region's priority</li>"
-                    + " <li>5 - The volume of this region (in meters cubed)</li>"
-                    + "</ul>"
-                    + "If the region cannot be found, a PluginInternalException is thrown.";
-        }
-
-        public ExceptionType[] thrown() {
-            return new ExceptionType[]{ExceptionType.PluginInternalException};
-        }
-
-        public Construct exec(int line_num, File f, CommandSender p, Construct... args) throws CancelCommandException, ConfigRuntimeException {
-            try {
-                String regionName = args[0].val();
-                String worldName = args[1].val();
-                //Fill these data structures in with the information we need
-                List<Location> points = new ArrayList<Location>();
-                List<String> owners = new ArrayList<String>();
-                List<String> members = new ArrayList<String>();
-                Map<String, String> flags = new HashMap<String, String>();
-                int priority = -1;
-                float volume = -1;
-                World world = Bukkit.getServer().getWorld(worldName);
-                if (world == null) throw new ConfigRuntimeException("Unknown world specified", ExceptionType.PluginInternalException, line_num, f);
-                RegionManager mgr = Static.getWorldGuardPlugin().getGlobalRegionManager().get(world);
-                ProtectedRegion region = mgr.getRegion(regionName);
-                if (region == null) throw new ConfigRuntimeException("Region could not be found!", ExceptionType.PluginInternalException, line_num, f);
-                
-                owners.addAll(region.getOwners().getPlayers());
-                members.addAll(region.getMembers().getPlayers());
-                for (Map.Entry<Flag<?>, Object> ent: region.getFlags().entrySet()) {
-                    flags.put(ent.getKey().getName(), String.valueOf(ent.getValue()));
-                }
-                priority = region.getPriority();
-                volume = region.volume();
-                boolean first = true;
-                if (region instanceof ProtectedPolygonalRegion) {
-                    for (BlockVector2D pt : ((ProtectedPolygonalRegion) region).getPoints()) {
-                        points.add(new Location(world, pt.getX(), first ? region.getMaximumPoint().getY() 
-                                    : region.getMinimumPoint().getY(), pt.getZ()));
-                        first = false;
-                    }
-                } else {
-                    points.add(com.sk89q.worldguard.bukkit.BukkitUtil.toLocation(world, region.getMaximumPoint()));
-                    points.add(com.sk89q.worldguard.bukkit.BukkitUtil.toLocation(world, region.getMinimumPoint()));
-                }
-                
-                
-                CArray ret = new CArray(line_num, f);
-                
-                CArray pointSet = new CArray(line_num, f);
-                for(Location l : points){
-                    CArray point = new CArray(line_num, f);
-                    point.push(new CInt(l.getBlockX(), line_num, f));
-                    point.push(new CInt(l.getBlockY(), line_num, f));
-                    point.push(new CInt(l.getBlockZ(), line_num, f));
-                    point.push(new CString(l.getWorld().getName(), line_num, f));
-                    pointSet.push(point);
-                }
-                CArray ownerSet = new CArray(line_num, f);
-                for(String owner : owners){
-                    ownerSet.push(new CString(owner, line_num, f));
-                }
-                CArray memberSet = new CArray(line_num, f);
-                for(String member : members){
-                    memberSet.push(new CString(member, line_num, f));
-                }
-                CArray flagSet = new CArray(line_num, f);
-                for(Map.Entry<String, String> flag : flags.entrySet()){
-                    CArray fl = new CArray(line_num, f, 
-                            new CString(flag.getKey(), line_num, f), 
-                            new CString(flag.getValue(), line_num, f)
-                    );
-                    flagSet.push(fl);
-                }
-                ret.push(pointSet);
-                ret.push(ownerSet);
-                ret.push(memberSet);
-                ret.push(flagSet);
-                ret.push(new CInt(priority, line_num, f));
-                ret.push(new CDouble(volume, line_num, f));
-                return ret;
-                
-            } catch (NoClassDefFoundError e) {
-                throw new ConfigRuntimeException("It does not appear as though the WorldEdit or WorldGuard plugin is loaded properly. Execution of " + this.getName() + " cannot continue.", ExceptionType.InvalidPluginException, line_num, f);
-            }
-        }
-    }
-
-    @api public static class sk_region_overlaps extends SKFunction {
-
-        public String getName() {
-            return "sk_region_overlaps";
-        }
-
-        public Integer[] numArgs() {
-            return new Integer[]{Integer.MAX_VALUE}; //@wraithguard01
-        }
-
-        public String docs() {
-            return "boolean {world, region1, array(region2, [regionN...])} Returns true or false whether or not the specified regions overlap.";
-        }
-
-        public ExceptionType[] thrown() {
-            return new ExceptionType[]{ExceptionType.PluginInternalException};
-        }
-
-        public Construct exec(int line_num, File f, CommandSender p, Construct... args) throws CancelCommandException, ConfigRuntimeException {
-            String region1 = args[1].val();
-            List<ProtectedRegion> checkRegions = new ArrayList<ProtectedRegion>();
-            Static.checkPlugin("WorldGuard", line_num, f);
-            World world = Bukkit.getServer().getWorld(args[0].val());
-            if (world == null) throw new ConfigRuntimeException("Unknown world specified", ExceptionType.PluginInternalException, line_num, f);
-            RegionManager mgr = Static.getWorldGuardPlugin().getGlobalRegionManager().get(world);
-            if (args[2] instanceof CArray) {
-                CArray arg = (CArray)args[2];
-                for (int i = 0; i < arg.size(); i++) {
-                    ProtectedRegion region = mgr.getRegion(arg.get(i, line_num).val());
-                    if (region == null) throw new ConfigRuntimeException("Region " + arg.get(i, line_num).val() + " could not be found!", ExceptionType.PluginInternalException, line_num, f);
-                    checkRegions.add(region);
-                }
-            } else {
-                ProtectedRegion region = mgr.getRegion(args[2].val());
-                    if (region == null) throw new ConfigRuntimeException("Region " + args[2] + " could not be found!", ExceptionType.PluginInternalException, line_num, f);
-                    checkRegions.add(region);
-            }
-            
-            ProtectedRegion region = mgr.getRegion(region1);
-            if (region == null) throw new ConfigRuntimeException("Region could not be found!", ExceptionType.PluginInternalException, line_num, f);
-            
-            try {
-                if (!region.getIntersectingRegions(checkRegions).isEmpty()) return new CBoolean(true, line_num, f);
-            } catch (UnsupportedIntersectionException e) {}
-            return new CBoolean(false, line_num, f);
-        }
-    }
-
-    @api public static class sk_all_regions extends SKFunction {
-
-        public String getName() {
-            return "sk_all_regions";
-        }
-
-        public Integer[] numArgs() {
-            return new Integer[]{0, 1};
-        }
-
-        public String docs() {
-            return "array {[world]} Returns all the regions in all worlds, or just the one world, if specified.";
-        }
-
-        public ExceptionType[] thrown() {
-            return new ExceptionType[]{};
-        }
-
-        public Construct exec(int line_num, File f, CommandSender p, Construct... args) throws CancelCommandException, ConfigRuntimeException {
-            Static.checkPlugin("WorldGuard", line_num, f);
-            List<World> checkWorlds = null;
-            CArray arr = new CArray(line_num, f);
-            if (args.length == 1) {
-                World world = Bukkit.getServer().getWorld(args[0].val());
-                if (world != null) checkWorlds = Arrays.asList(world);
-            }
-            if (checkWorlds == null) {
-                checkWorlds = Bukkit.getServer().getWorlds();
-            }
-            GlobalRegionManager mgr = Static.getWorldGuardPlugin().getGlobalRegionManager();
-            for (World world : checkWorlds) {
-                for (String region : mgr.get(world).getRegions().keySet()) arr.push(new CString(region, line_num, f));
-            }
-            return arr;
-            
-        }
-    }
-
-    public static abstract class SKFunction implements Function {
-
-        public boolean isRestricted() {
-            return true;
-        }
-
-        public void varList(IVariableList varList) {
-        }
-
-        public boolean preResolveVariables() {
-            return true;
-        }
-
-        public String since() {
-            return "3.2.0";
-        }
-
-        public Boolean runAsync() {
-            return false;
-        }
-    }
-}
diff --git a/src/main/java/com/laytonsmith/aliasengine/functions/api.java b/src/main/java/com/laytonsmith/aliasengine/functions/api.java
deleted file mode 100644
index 7e074f8..0000000
--- a/src/main/java/com/laytonsmith/aliasengine/functions/api.java
+++ /dev/null
@@ -1,18 +0,0 @@
-/*
- * To change this template, choose Tools | Templates
- * and open the template in the editor.
- */
-package com.laytonsmith.aliasengine.functions;
-
-import java.lang.annotation.ElementType;
-import java.lang.annotation.Retention;
-import java.lang.annotation.RetentionPolicy;
-import java.lang.annotation.Target;
-
-/**
- * Marks a function as an API function, which will eventually allow easier 
- * @author Layton
- */
-@Retention(RetentionPolicy.RUNTIME)
-@Target(ElementType.TYPE)
-public @interface api {}
diff --git a/src/main/java/com/laytonsmith/aliasengine/functions/exceptions/CancelCommandException.java b/src/main/java/com/laytonsmith/aliasengine/functions/exceptions/CancelCommandException.java
deleted file mode 100644
index 73bcb20..0000000
--- a/src/main/java/com/laytonsmith/aliasengine/functions/exceptions/CancelCommandException.java
+++ /dev/null
@@ -1,23 +0,0 @@
-/*
- * To change this template, choose Tools | Templates
- * and open the template in the editor.
- */
-
-package com.laytonsmith.aliasengine.functions.exceptions;
-
-/**
- *
- * @author Layton
- */
-public class CancelCommandException extends RuntimeException{
-    String message;
-    public CancelCommandException(String message){
-        this.message = message;
-    }
-
-    @Override
-    public String getMessage() {
-        return message;
-    }
-
-}
diff --git a/src/main/java/com/laytonsmith/aliasengine/functions/exceptions/ConfigCompileException.java b/src/main/java/com/laytonsmith/aliasengine/functions/exceptions/ConfigCompileException.java
deleted file mode 100644
index 1d5d4fb..0000000
--- a/src/main/java/com/laytonsmith/aliasengine/functions/exceptions/ConfigCompileException.java
+++ /dev/null
@@ -1,46 +0,0 @@
-/*
- * To change this template, choose Tools | Templates
- * and open the template in the editor.
- */
-
-package com.laytonsmith.aliasengine.functions.exceptions;
-
-/**
- *
- * @author Layton
- */
-public class ConfigCompileException extends Exception{
-
-    int line_num;
-    String message;
-
-    public ConfigCompileException(String message, int line_num) {
-        this.message = message;
-        this.line_num = line_num;
-    }
-
-    public ConfigCompileException(String string) {
-        message = string;
-        line_num = 0;
-    }
-    
-    @Override
-    public String getMessage() {
-        return message;
-    }
-
-    public String getLineNum(){
-        return Integer.toString(line_num);
-    }
-
-
-    @Override
-    public String toString(){
-        if(line_num != 0){
-            return "Configuration Compile Exception: " + message + " near line " + line_num + " of configuration file. Please "
-                    + "check your config file and try again.";
-        } else{
-            return "Configuration Compile Exception: " + message + ". Please check your config file and try again.";
-        }
-    }
-}
diff --git a/src/main/java/com/laytonsmith/aliasengine/functions/exceptions/ConfigRuntimeException.java b/src/main/java/com/laytonsmith/aliasengine/functions/exceptions/ConfigRuntimeException.java
deleted file mode 100644
index c82ee10..0000000
--- a/src/main/java/com/laytonsmith/aliasengine/functions/exceptions/ConfigRuntimeException.java
+++ /dev/null
@@ -1,86 +0,0 @@
-/*
- * To change this template, choose Tools | Templates
- * and open the template in the editor.
- */
-
-package com.laytonsmith.aliasengine.functions.exceptions;
-
-import com.laytonsmith.aliasengine.functions.Exceptions.ExceptionType;
-import java.io.File;
-
-
-/**
- *
- * @author layton
- */
-public class ConfigRuntimeException extends RuntimeException {
-
-    /**
-     * Creates a new instance of <code>ConfigRuntimeException</code> without detail message.
-     */
-    protected ConfigRuntimeException() {
-    }
-    
-    private ExceptionType ex;
-    private int line_num;
-    private File file;
-    /**
-     * Creates a new ConfigRuntimeException. If ex is not null, this exception can be caught
-     * by user level code. Otherwise, it will be ignored by the try() function.
-     * @param msg The message to be displayed
-     * @param ex The type of exception this is, as seen by user level code
-     * @param line_num The line this exception is being thrown from
-     * @param file The file this code resides in
-     */
-    public ConfigRuntimeException(String msg, ExceptionType ex, int line_num, File file){
-        super(msg);
-        this.ex = ex;
-        this.line_num = line_num;
-        this.file = file;
-    }
-    
-//    public ConfigRuntimeException(String msg, ExceptionType ex, int line_num){
-//        this(msg, ex, line_num, null);
-//    }
-//    public ConfigRuntimeException(String msg, int line_num){
-//        this(msg, null, line_num, null);
-//    }
-    
-    /**
-     * Creates an uncatchable exception (by user level code)
-     * @param msg
-     * @param line_num
-     * @param file 
-     */
-    public ConfigRuntimeException(String msg, int line_num, File file){
-        this(msg, null, line_num, file);
-    }
-
-    /**
-     * Constructs an instance of <code>ConfigRuntimeException</code> with the specified detail message.
-     * @param msg the detail message.
-     */
-    private ConfigRuntimeException(String msg) {
-        super(msg);
-    }
-    
-    public ExceptionType getExceptionType(){
-        return this.ex;
-    }
-    
-    public int getLineNum(){
-        return this.line_num;
-    }
-    
-    public File getFile(){
-        return this.file;
-    }
-    
-    public String getSimpleFile(){
-        if(this.file != null){
-            return this.file.getName();
-        } else {
-            return null;
-        }
-    }
-}
diff --git a/src/main/java/com/laytonsmith/aliasengine/functions/exceptions/FunctionReturnException.java b/src/main/java/com/laytonsmith/aliasengine/functions/exceptions/FunctionReturnException.java
deleted file mode 100644
index f872e3b..0000000
--- a/src/main/java/com/laytonsmith/aliasengine/functions/exceptions/FunctionReturnException.java
+++ /dev/null
@@ -1,21 +0,0 @@
-/*
- * To change this template, choose Tools | Templates
- * and open the template in the editor.
- */
-package com.laytonsmith.aliasengine.functions.exceptions;
-
-import com.laytonsmith.aliasengine.Constructs.Construct;
-
-/**
- *
- * @author Layton
- */
-public class FunctionReturnException extends RuntimeException{
-    Construct ret;
-    public FunctionReturnException(Construct ret){
-        this.ret = ret;
-    }
-    public Construct getReturn(){
-        return ret;
-    }
-}
diff --git a/src/main/java/com/laytonsmith/aliasengine/functions/exceptions/LoopBreakException.java b/src/main/java/com/laytonsmith/aliasengine/functions/exceptions/LoopBreakException.java
deleted file mode 100644
index f069dc5..0000000
--- a/src/main/java/com/laytonsmith/aliasengine/functions/exceptions/LoopBreakException.java
+++ /dev/null
@@ -1,22 +0,0 @@
-/*
- * To change this template, choose Tools | Templates
- * and open the template in the editor.
- */
-package com.laytonsmith.aliasengine.functions.exceptions;
-
-/**
- *
- * @author Layton
- */
-public class LoopBreakException extends RuntimeException{
-    int number;
-    public LoopBreakException(int times){
-        number = times;
-    }
-    public int getTimes(){
-        return number;
-    }    
-    public void setTimes(int number){
-        this.number = number;
-    }
-}
diff --git a/src/main/java/com/laytonsmith/aliasengine/functions/exceptions/LoopContinueException.java b/src/main/java/com/laytonsmith/aliasengine/functions/exceptions/LoopContinueException.java
deleted file mode 100644
index 6c54c76..0000000
--- a/src/main/java/com/laytonsmith/aliasengine/functions/exceptions/LoopContinueException.java
+++ /dev/null
@@ -1,22 +0,0 @@
-/*
- * To change this template, choose Tools | Templates
- * and open the template in the editor.
- */
-package com.laytonsmith.aliasengine.functions.exceptions;
-
-/**
- *
- * @author Layton
- */
-public class LoopContinueException extends RuntimeException{
-    int number;
-    public LoopContinueException(int times){
-        number = times;
-    }
-    public int getTimes(){
-        return number;
-    }    
-    public void setTimes(int number){
-        this.number = number;
-    }
-}
diff --git a/src/main/java/com/laytonsmith/aliasengine/functions/exceptions/MarshalException.java b/src/main/java/com/laytonsmith/aliasengine/functions/exceptions/MarshalException.java
deleted file mode 100644
index 955ecd9..0000000
--- a/src/main/java/com/laytonsmith/aliasengine/functions/exceptions/MarshalException.java
+++ /dev/null
@@ -1,37 +0,0 @@
-/*
- * To change this template, choose Tools | Templates
- * and open the template in the editor.
- */
-package com.laytonsmith.aliasengine.functions.exceptions;
-
-import com.laytonsmith.aliasengine.Constructs.Construct;
-
-/**
- *
- * @author Layton
- */
-public class MarshalException extends Exception {
-
-    /**
-     * Creates a new instance of <code>MarshalException</code> without detail message.
-     */
-    public MarshalException() {
-    }
-
-    /**
-     * Constructs an instance of <code>MarshalException</code> with the specified detail message.
-     * @param msg the detail message.
-     */
-    public MarshalException(String msg) {
-        super(msg);
-    }
-    
-    /**
-     * This is caused when a particular Construct was given that is incompatible.
-     * @param msg
-     * @param c 
-     */
-    public MarshalException(String msg, Construct c){
-        super(msg + ": " + c.toString());
-    }
-}
diff --git a/src/main/java/com/laytonsmith/commandhelper/CommandHelperInterpreterListener.java b/src/main/java/com/laytonsmith/commandhelper/CommandHelperInterpreterListener.java
new file mode 100644
index 0000000..548d6c0
--- /dev/null
+++ b/src/main/java/com/laytonsmith/commandhelper/CommandHelperInterpreterListener.java
@@ -0,0 +1,136 @@
+/*
+ * To change this template, choose Tools | Templates
+ * and open the template in the editor.
+ */
+package com.laytonsmith.commandhelper;
+
+import com.laytonsmith.abstraction.MCChatColor;
+import com.laytonsmith.abstraction.MCPlayer;
+import com.laytonsmith.abstraction.bukkit.BukkitMCPlayer;
+import com.laytonsmith.core.*;
+import com.laytonsmith.core.constructs.Token;
+import com.laytonsmith.core.exceptions.CancelCommandException;
+import com.laytonsmith.core.exceptions.ConfigCompileException;
+import java.io.File;
+import java.util.*;
+import org.bukkit.event.player.PlayerChatEvent;
+import org.bukkit.event.player.PlayerCommandPreprocessEvent;
+import org.bukkit.event.player.PlayerListener;
+import org.bukkit.event.player.PlayerQuitEvent;
+
+/**
+ *
+ * @author Layton
+ */
+public class CommandHelperInterpreterListener extends PlayerListener {
+
+    Set<String> interpreterMode = new HashSet<String>();
+    Map<String, String> multilineMode = new HashMap<String, String>();
+
+    @Override
+    public void onPlayerChat(PlayerChatEvent event) {
+        if (interpreterMode.contains(event.getPlayer().getName())) {
+            MCPlayer p = new BukkitMCPlayer(event.getPlayer());
+            textLine(p, event.getMessage());
+            event.setCancelled(true);
+        }
+
+    }
+
+    @Override
+    public void onPlayerQuit(PlayerQuitEvent event) {
+        interpreterMode.remove(event.getPlayer().getName());
+        multilineMode.remove(event.getPlayer().getName());
+    }
+
+    @Override
+    public void onPlayerCommandPreprocess(PlayerCommandPreprocessEvent event) {
+        if (interpreterMode.contains(event.getPlayer().getName())) {
+            MCPlayer p = new BukkitMCPlayer(event.getPlayer());
+            textLine(p, event.getMessage());
+            event.setCancelled(true);
+        }
+    }
+
+    public void textLine(MCPlayer p, String line) {
+        if (line.equals("-")) {
+            //Exit interpreter mode
+            interpreterMode.remove(p.getName());
+            Static.SendMessage(p, MCChatColor.YELLOW + "Now exiting interpreter mode");
+        } else if (line.equals(">>>")) {
+            //Start multiline mode
+            if (multilineMode.containsKey(p.getName())) {
+                Static.SendMessage(p, MCChatColor.RED + "You are already in multiline mode!");
+            } else {
+                multilineMode.put(p.getName(), "");
+                Static.SendMessage(p, MCChatColor.YELLOW + "You are now in multiline mode. Type <<< on a line by itself to execute.");
+                Static.SendMessage(p, ":" + MCChatColor.GRAY + ">>>");
+            }
+        } else if (line.equals("<<<")) {
+            //Execute multiline
+            Static.SendMessage(p, ":" + MCChatColor.GRAY + "<<<");
+            String script = multilineMode.get(p.getName());
+            multilineMode.remove(p.getName());
+            try {
+                execute(script, p);
+            } catch (ConfigCompileException e) {
+                Static.SendMessage(p, MCChatColor.RED + e.getMessage() + ":" + e.getLineNum());
+            }
+        } else {
+            if (multilineMode.containsKey(p.getName())) {
+                //Queue multiline
+                multilineMode.put(p.getName(), multilineMode.get(p.getName()) + line + "\n");
+                Static.SendMessage(p, ":" + MCChatColor.GRAY + line);
+            } else {
+                try {
+                    //Execute single line
+                    execute(line, p);
+                } catch (ConfigCompileException ex) {
+                    Static.SendMessage(p, MCChatColor.RED + ex.getMessage());
+                }
+            }
+        }
+    }
+
+    public void reload() {
+    }
+
+    public void execute(String script, final MCPlayer p) throws ConfigCompileException {
+        List<Token> stream = MScriptCompiler.lex("include('plugins/CommandHelper/auto_include.ms')\n" + script, new File("Interpreter"));
+        GenericTreeNode tree = MScriptCompiler.compile(stream);
+        interpreterMode.remove(p.getName());
+        Env env = new Env();
+        env.SetPlayer(p);
+        try {
+            MScriptCompiler.execute(tree, env, new MScriptComplete() {
+
+                public void done(String output) {
+                    output = output.trim();
+                    if (output.equals("")) {
+                        Static.SendMessage(p, ":");
+                    } else {
+                        if (output.startsWith("/")) {
+                            //Run the command
+                            Static.SendMessage(p, ":" + MCChatColor.YELLOW + output);
+                            p.chat(output);
+                        } else {
+                            //output the results
+                            Static.SendMessage(p, ":" + MCChatColor.GREEN + output);
+                        }
+                    }
+                    interpreterMode.add(p.getName());
+                }
+            }, null);
+        } catch (CancelCommandException e) {
+            interpreterMode.add(p.getName());
+        } catch(Exception e){
+            Static.SendMessage(p, MCChatColor.RED + e.toString());
+            e.printStackTrace();
+            interpreterMode.add(p.getName());
+        }
+    }
+
+    public void startInterpret(String playername) {
+        interpreterMode.add(playername);
+    }
+}
diff --git a/src/main/java/com/laytonsmith/commandhelper/CommandHelperListener.java b/src/main/java/com/laytonsmith/commandhelper/CommandHelperListener.java
new file mode 100644
index 0000000..b7a4655
--- /dev/null
+++ b/src/main/java/com/laytonsmith/commandhelper/CommandHelperListener.java
@@ -0,0 +1,150 @@
+// $Id$
+/*
+ * CommandHelper
+ * Copyright (C) 2010 sk89q <http://www.sk89q.com>
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program. If not, see <http://www.gnu.org/licenses/>.
+ */
+package com.laytonsmith.commandhelper;
+
+import com.laytonsmith.abstraction.Implementation;
+import com.laytonsmith.abstraction.MCChatColor;
+import com.laytonsmith.abstraction.MCPlayer;
+import com.laytonsmith.abstraction.bukkit.BukkitMCPlayer;
+import com.laytonsmith.core.*;
+import com.laytonsmith.core.exceptions.ConfigRuntimeException;
+import com.sk89q.worldguard.bukkit.WorldGuardPlayerListener;
+import com.sk89q.worldguard.bukkit.WorldGuardPlugin;
+import java.util.List;
+import java.util.logging.Level;
+import java.util.logging.Logger;
+import org.bukkit.entity.Player;
+import org.bukkit.event.player.PlayerCommandPreprocessEvent;
+import org.bukkit.event.player.PlayerListener;
+import org.bukkit.event.player.PlayerQuitEvent;
+
+/**
+ * Event listener for Hey0's server mod.
+ *
+ * @author sk89q
+ */
+public class CommandHelperListener extends PlayerListener {
+
+    /**
+     * Logger.
+     */
+    private static final Logger logger = Logger.getLogger("Minecraft");
+
+    /**
+     * List of global aliases.
+     */
+    private AliasCore ac;
+    private CommandHelperPlugin plugin;
+
+    public CommandHelperListener(CommandHelperPlugin plugin) {
+        this.plugin = plugin;
+    }
+
+    /**
+     * Load global aliases.
+     */
+    public void loadGlobalAliases() {
+        ac = CommandHelperPlugin.getCore();
+    }
+
+    /**
+     * Find and run aliases for a player for a given command.
+     *
+     * @param command
+     * @return
+     */
+    public boolean runAlias(String command, MCPlayer player) {
+        UserManager um = UserManager.GetUserManager(player.getName());
+        List<Script> scripts = um.getAllScripts();
+
+        return CommandHelperPlugin.getCore().alias(command, player, scripts);
+    }
+
+        
+
+    /**
+     * Called when a player attempts to use a command
+     *
+     * @param event Relevant event details
+     */
+    @Override
+    public void onPlayerCommandPreprocess(PlayerCommandPreprocessEvent event) {     
+//        if((Boolean)Static.getPreferences().getPreference("debug-mode")){
+//            System.out.println("CommandHelper: (>'.')> Received event-> " + event.getMessage() + " Is Cancelled? " + (event.isCancelled()?"Y":"N"));
+//        }
+        
+        if (Implementation.GetServerType() == Implementation.Type.BUKKIT) {
+            WorldGuardPlugin wgp = Static.getWorldGuardPlugin(0, null);
+            //This will cancel the command if the player isn't supposed to run it in this region
+            if(wgp != null){
+                WorldGuardPlayerListener wgpl = new WorldGuardPlayerListener(wgp);
+                wgpl.onPlayerCommandPreprocess(event);
+            }
+        }
+        String cmd = event.getMessage();        
+        MCPlayer player = new BukkitMCPlayer(event.getPlayer());
+        Static.PlayDirty();
+        if (cmd.equals("/.") || cmd.equals("/repeat")) {
+            return;
+        }
+        
+        UserManager.GetUserManager(player.getName()).setLastCommand(cmd);
+
+        if (!(Boolean) Static.getPreferences().getPreference("play-dirty")) {
+            if (event.isCancelled()) {
+                return;
+            }
+        } //If we are playing dirty, ignore the cancelled flag
+
+        try {
+            if (runAlias(event.getMessage(), player)) {
+                event.setCancelled(true);
+                if((Boolean) Static.getPreferences().getPreference("play-dirty")){
+                    //Super cancel the event
+                    BukkitDirtyRegisteredListener.setCancelled(event);
+                }
+                //System.out.println("Command Cancelled: " + cmd);
+                return;
+            }
+        } catch (InternalException e) {
+            logger.log(Level.SEVERE, e.getMessage());
+        } catch (ConfigRuntimeException e) {
+            logger.log(Level.WARNING, e.getMessage());
+        } catch (Throwable e) {
+            player.sendMessage(MCChatColor.RED + "Command failed with following reason: " + e.getMessage());
+            //Obviously the command is registered, but it somehow failed. Cancel the event.
+            event.setCancelled(true);
+            e.printStackTrace();
+            return;
+        }
+    }
+
+    /**
+     * Called when a player leaves a server
+     *
+     * @param event Relevant event details
+     */
+    @Override
+    public void onPlayerQuit(PlayerQuitEvent event) {
+        Player player = event.getPlayer();
+        UserManager.ClearUser(player.getName());
+    }
+    
+
+}
\ No newline at end of file
diff --git a/src/main/java/com/laytonsmith/commandhelper/CommandHelperPlugin.java b/src/main/java/com/laytonsmith/commandhelper/CommandHelperPlugin.java
new file mode 100644
index 0000000..4c2de76
--- /dev/null
+++ b/src/main/java/com/laytonsmith/commandhelper/CommandHelperPlugin.java
@@ -0,0 +1,370 @@
+// $Id$
+/*
+ * CommandHelper
+ * Copyright (C) 2010 sk89q <http://www.sk89q.com>
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program. If not, see <http://www.gnu.org/licenses/>.
+*/
+
+package com.laytonsmith.commandhelper;
+
+import com.laytonsmith.PureUtilities.Preferences;
+import com.laytonsmith.PureUtilities.SerializedPersistance;
+import com.laytonsmith.PureUtilities.TermColors;
+import com.laytonsmith.abstraction.MCChatColor;
+import com.laytonsmith.abstraction.MCPlayer;
+import com.laytonsmith.abstraction.MCServer;
+import com.laytonsmith.abstraction.StaticLayer;
+import com.laytonsmith.abstraction.bukkit.BukkitMCPlayer;
+import com.laytonsmith.core.*;
+import com.laytonsmith.core.events.EventList;
+import com.laytonsmith.core.exceptions.ConfigCompileException;
+import com.sk89q.bukkit.migration.PermissionsResolverManager;
+import com.sk89q.bukkit.migration.PermissionsResolverServerListener;
+import com.sk89q.worldedit.bukkit.WorldEditPlugin;
+import java.io.File;
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.HashSet;
+import java.util.Set;
+import java.util.logging.Level;
+import java.util.logging.Logger;
+import org.bukkit.command.Command;
+import org.bukkit.command.CommandSender;
+import org.bukkit.command.ConsoleCommandSender;
+import org.bukkit.entity.Player;
+import org.bukkit.event.Event;
+import org.bukkit.event.Event.Priority;
+import org.bukkit.event.Listener;
+import org.bukkit.event.player.PlayerCommandPreprocessEvent;
+import org.bukkit.event.server.ServerCommandEvent;
+import org.bukkit.plugin.Plugin;
+import org.bukkit.plugin.java.JavaPlugin;
+
+/**
+ * Entry point for the plugin.
+ *
+ * @author sk89q
+ */
+public class CommandHelperPlugin extends JavaPlugin {
+    public static final Logger logger = Logger.getLogger("Minecraft.CommandHelper");
+    private static AliasCore ac;
+    public static MCServer myServer;
+    public static SerializedPersistance persist;
+    public static PermissionsResolverManager perms;
+    public static Version version;
+    public static Preferences prefs;
+    public static CommandHelperPlugin self;
+    public static WorldEditPlugin wep;
+    /**
+     * Listener for the plugin system.
+     */
+    final CommandHelperListener playerListener =
+            new CommandHelperListener(this);
+    
+    /**
+     * Interpreter listener
+     */
+    final CommandHelperInterpreterListener interpreterListener = 
+            new CommandHelperInterpreterListener();
+    /**
+     * Server Command Listener, for console commands
+     */
+    final CommandHelperServerListener serverListener =
+            new CommandHelperServerListener();
+
+    final Set<MCPlayer> commandRunning = new HashSet<MCPlayer>();
+    
+    
+    @Override
+    public void onLoad(){
+        Installer.Install();
+    }
+    /**
+     * Called on plugin enable.
+     */
+    public void onEnable() {
+        self = this;
+        myServer = StaticLayer.GetServer();
+        persist = new SerializedPersistance(new File("plugins/CommandHelper/persistance.ser"), this);
+        logger.info("CommandHelper/CommandHelper " + getDescription().getVersion() + " enabled");
+        version = new Version(getDescription().getVersion());
+        perms = new PermissionsResolverManager(getConfiguration(), getServer(),
+                getDescription().getName(), logger);
+        Plugin pwep = getServer().getPluginManager().getPlugin("WorldEdit");
+        if(pwep != null && pwep.isEnabled() && pwep instanceof WorldEditPlugin){
+            wep = (WorldEditPlugin)pwep;
+        }
+        try {
+            File prefsFile = new File("plugins/CommandHelper/preferences.txt");
+            Static.getPreferences().init(prefsFile);
+            String script_name = (String) Static.getPreferences().getPreference("script-name");
+            String main_file = (String) Static.getPreferences().getPreference("main-file");
+            boolean showSplashScreen = ((Boolean)Static.getPreferences().getPreference("show-splash-screen")).booleanValue();
+            if(showSplashScreen){
+                System.out.println(TermColors.reset());
+                //System.out.flush();
+                System.out.println("\n\n\n" + Static.Logo());
+            }
+            ac = new AliasCore(new File("plugins/CommandHelper/" + script_name), prefsFile, new File("plugins/CommandHelper/" + main_file), perms, this);
+        } catch (IOException ex) {
+            logger.log(Level.SEVERE, null, ex);
+        } catch (ConfigCompileException ex) {
+            logger.log(Level.SEVERE, null, ex);
+        }
+        Static.PlayDirty();
+        registerEvent(Event.Type.PLAYER_COMMAND_PREPROCESS, playerListener, Priority.Lowest);
+        registerEvent(Event.Type.PLAYER_QUIT, playerListener, Priority.Normal);
+        
+        //interpreter events
+        registerEvent(Event.Type.PLAYER_CHAT, interpreterListener, Priority.Lowest);
+        registerEvent(Event.Type.PLAYER_COMMAND_PREPROCESS, interpreterListener, Priority.Lowest);
+        registerEvent(Event.Type.PLAYER_QUIT, interpreterListener, Priority.Normal);
+        registerEvent(Event.Type.SERVER_COMMAND, serverListener, Priority.Lowest);
+        
+        //Script events
+        EventList.Startup(this);
+        
+        (new PermissionsResolverServerListener(perms, this)).register(this);
+        
+        playerListener.loadGlobalAliases();
+        interpreterListener.reload();
+    }
+
+    public static AliasCore getCore(){
+        return ac;
+    }
+
+    /**
+     * Disables the plugin.
+     */
+    @Override
+    public void onDisable() {
+        //free up some memory
+        ac = null;
+        wep = null;
+    }
+    
+    /**
+     * Register an event.
+     * 
+     * @param type
+     * @param listener
+     * @param priority
+     */
+    public void registerEvent(Event.Type type, Listener listener, Priority priority) {
+        getServer().getPluginManager().registerEvent(type, listener, priority, this);
+    }
+
+    /**
+     * Called when a command registered by this plugin is received.
+     */
+    @Override
+    public boolean onCommand(CommandSender sender, Command cmd, String commandLabel, String[] args) {
+        if((sender.isOp() || (sender instanceof Player && (perms.hasPermission(((Player)sender).getName(), "commandhelper.reloadaliases") 
+                || perms.hasPermission(((Player)sender).getName(), "ch.reloadaliases"))))
+                && (cmd.getName().equals("reloadaliases") || cmd.getName().equals("reloadalias"))){
+            MCPlayer player = null;
+            if(sender instanceof Player){
+                player = new BukkitMCPlayer((Player)sender);
+            }
+            if(ac.reload(player)){
+                if(sender instanceof Player){
+                    Static.SendMessage(player, MCChatColor.GOLD + "Command Helper scripts sucessfully recompiled.");
+                }
+                System.out.println(TermColors.YELLOW + "Command Helper scripts sucessfully recompiled." + TermColors.reset());
+            } else{
+                if(sender instanceof Player){
+                    Static.SendMessage(player, MCChatColor.RED + "An error occured when trying to compile the script. Check the console for more information.");
+                }
+                System.out.println(TermColors.RED + "An error occured when trying to compile the script. Check the console for more information." + TermColors.reset());
+            }
+            return true;
+        } else if(cmd.getName().equals("commandhelper") && args.length >= 1 && args[0].equalsIgnoreCase("null")){
+            return true;
+        } else if(cmd.getName().equals("runalias")){
+            //Hardcoded alias rebroadcast
+            if(sender instanceof Player){
+                PlayerCommandPreprocessEvent pcpe = new PlayerCommandPreprocessEvent((Player)sender, Static.strJoin(args, " "));
+                playerListener.onPlayerCommandPreprocess(pcpe);
+            } else if(sender instanceof ConsoleCommandSender){
+                String cmd2 = Static.strJoin(args, " ");
+                if(cmd2.startsWith("/")){
+                    cmd2 = cmd2.substring(1);
+                }
+                ServerCommandEvent sce = new ServerCommandEvent((ConsoleCommandSender)sender, cmd2);
+                serverListener.onServerCommand(sce);                
+            }
+            return true;
+        } else if (sender instanceof Player) {
+                return runCommand(new BukkitMCPlayer((Player)sender), cmd.getName(), args);
+        } else {
+            return false;
+        }
+    }
+    
+    /**
+     * Runs commands.
+     *
+     * @param player
+     * @param split
+     * @return
+     */
+    private boolean runCommand(final MCPlayer player, String cmd, String[] args) {
+        if(commandRunning.contains(player)){
+            return true;
+        }
+
+        commandRunning.add(player);
+        UserManager um = UserManager.GetUserManager(player.getName());
+        // Repeat command
+        if (cmd.equals("repeat")) {
+            if(perms.hasPermission(player.getName(), "commandhelper.repeat") ||
+                    perms.hasPermission(player.getName(), "ch.repeat")){
+                //Go ahead and remove them, so that they can repeat aliases. They can't get stuck in
+                //an infinite loop though, because the preprocessor won't try to fire off a repeat command
+                commandRunning.remove(player);
+                if (um.getLastCommand() != null) {
+                    Static.SendMessage(player, MCChatColor.GRAY + um.getLastCommand());
+                    execCommand(player, um.getLastCommand());
+                } else {
+                    Static.SendMessage(player, MCChatColor.RED + "No previous command.");
+                }
+                return true;
+            } else {
+                Static.SendMessage(player, MCChatColor.RED + "You do not have permission to access the repeat command");
+                commandRunning.remove(player);
+                return true;
+            }
+    
+        // Save alias
+        } else if (cmd.equalsIgnoreCase("alias") || cmd.equalsIgnoreCase("commandhelper")
+                /*&& player.canUseCommand("/alias")*/) {
+            if(!perms.hasPermission(player.getName(), "commandhelper.useralias") && !perms.hasPermission(player.getName(), "ch.useralias")){
+                Static.SendMessage(player, MCChatColor.RED + "You do not have permission to access the alias command");
+                commandRunning.remove(player);
+                return true;
+            }
+            if(args.length > 0){
+
+                String alias = CommandHelperPlugin.joinString(args, " ");
+                try {
+                    int id = um.addAlias(alias);
+                    if(id > -1){
+                        Static.SendMessage(player, MCChatColor.YELLOW + "Alias added with id '" + id + "'");
+                    }
+                } catch (ConfigCompileException ex) {
+                    Static.SendMessage(player, "Your alias could not be added due to a compile error:\n" + MCChatColor.RED + ex.getMessage());
+                }
+            } else{
+                //Display a help message
+                Static.SendMessage(player, MCChatColor.GREEN + "Command usage: \n"
+                        + MCChatColor.GREEN + "/alias <alias> - adds an alias to your user defined list\n"
+                        + MCChatColor.GREEN + "/delalias <id> - deletes alias with id <id> from your user defined list\n"
+                        + MCChatColor.GREEN + "/viewalias - shows you all of your aliases");
+            }
+
+            commandRunning.remove(player);
+            return true;
+        //View all aliases for this user
+        } else if(cmd.equalsIgnoreCase("viewalias")){
+            if(!perms.hasPermission(player.getName(), "commandhelper.useralias") && !perms.hasPermission(player.getName(), "ch.useralias")){
+                Static.SendMessage(player, MCChatColor.RED + "You do not have permission to access the viewalias command");
+                commandRunning.remove(player);
+                return true;
+            }
+            int page = 0;
+            try{
+                page = Integer.parseInt(args[0]);
+            } catch(Exception e){
+                //Meh. Index out of bounds, or number format exception. Whatever, show page 1
+            }
+            Static.SendMessage(player, um.getAllAliases(page));
+            commandRunning.remove(player);
+            return true;
+        // Delete alias
+        } else if (cmd.equalsIgnoreCase("delalias")) {
+            if(!perms.hasPermission(player.getName(), "commandhelper.useralias") && !perms.hasPermission(player.getName(), "ch.useralias")){
+                Static.SendMessage(player, MCChatColor.RED + "You do not have permission to access the delalias command");
+                commandRunning.remove(player);
+                return true;
+            }
+            try{
+                ArrayList<String> deleted = new ArrayList<String>();
+                for(int i = 0; i < args.length; i++){
+                    um.delAlias(Integer.parseInt(args[i]));
+                    deleted.add("#" + args[i]);
+                }
+                if(args.length > 1){
+                    String s = MCChatColor.YELLOW + "Aliases " + deleted.toString() + " were deleted";
+                    Static.SendMessage(player, s);
+
+                } else{
+                    Static.SendMessage(player, MCChatColor.YELLOW + "Alias #" + args[0] + " was deleted");
+                }
+            } catch(NumberFormatException e){
+                Static.SendMessage(player, MCChatColor.RED + "The id must be a number");
+            } catch(ArrayIndexOutOfBoundsException e){
+                Static.SendMessage(player, MCChatColor.RED + "Usage: /delalias <id> <id> ...");
+            }
+            commandRunning.remove(player);
+            return true;
+    
+        } else if(cmd.equalsIgnoreCase("interpreter")){
+            if(perms.hasPermission(player.getName(), "commandhelper.interpreter")){
+                if((Boolean)Static.getPreferences().getPreference("enable-interpreter")){
+                    interpreterListener.startInterpret(player.getName());
+                    Static.SendMessage(player, MCChatColor.YELLOW + "You are now in interpreter mode. Type a dash (-) on a line by itself to exit, and >>> to enter"
+                            + " multiline mode.");
+                } else {
+                    Static.SendMessage(player, MCChatColor.RED + "The interpreter is currently disabled. Check your preferences file.");
+                }
+            } else {
+                Static.SendMessage(player, MCChatColor.RED + "You do not have permission to run that command");
+            }
+            commandRunning.remove(player);
+            return true;
+        }
+        commandRunning.remove(player);
+        return false;
+    }
+
+    /**
+     * Joins a string from an array of strings.
+     *
+     * @param str
+     * @param delimiter
+     * @return
+     */
+    public static String joinString(String[] str, String delimiter) {
+        if (str.length == 0) {
+            return "";
+        }
+        StringBuilder buffer = new StringBuilder(str[0]);
+        for (int i = 1; i < str.length; i++) {
+            buffer.append(delimiter).append(str[i]);
+        }
+        return buffer.toString();
+    }
+    
+    /**
+     * Execute a command.
+     * @param player 
+     *
+     * @param cmd
+     */
+    public static void execCommand(MCPlayer player, String cmd) {
+        player.chat(cmd);
+    }
+}
diff --git a/src/main/java/com/laytonsmith/commandhelper/CommandHelperServerListener.java b/src/main/java/com/laytonsmith/commandhelper/CommandHelperServerListener.java
new file mode 100644
index 0000000..4c8b89b
--- /dev/null
+++ b/src/main/java/com/laytonsmith/commandhelper/CommandHelperServerListener.java
@@ -0,0 +1,48 @@
+/*
+ * To change this template, choose Tools | Templates
+ * and open the template in the editor.
+ */
+package com.laytonsmith.commandhelper;
+
+import com.laytonsmith.abstraction.MCChatColor;
+import com.laytonsmith.abstraction.MCCommandSender;
+import com.laytonsmith.abstraction.bukkit.BukkitMCCommandSender;
+import com.laytonsmith.core.InternalException;
+import com.laytonsmith.core.Script;
+import com.laytonsmith.core.Static;
+import com.laytonsmith.core.exceptions.ConfigRuntimeException;
+import java.util.ArrayList;
+import java.util.logging.Level;
+import org.bukkit.event.server.ServerCommandEvent;
+import org.bukkit.event.server.ServerListener;
+
+/**
+ *
+ * @author Layton
+ */
+public class CommandHelperServerListener extends ServerListener{
+    
+    @Override
+    public void onServerCommand(ServerCommandEvent event){
+        MCCommandSender player = new BukkitMCCommandSender(event.getSender());
+        boolean match = false;
+        try {
+            match = Static.getAliasCore().alias("/" + event.getCommand(), player, new ArrayList<Script>());
+        } catch (InternalException e) {
+            Static.getLogger().log(Level.SEVERE, e.getMessage());
+        } catch (ConfigRuntimeException e) {
+            Static.getLogger().log(Level.WARNING, e.getMessage());
+        } catch (Throwable e) {
+            player.sendMessage(MCChatColor.RED + "Command failed with following reason: " + e.getMessage());
+            //Obviously the command is registered, but it somehow failed. Cancel the event.
+            e.printStackTrace();
+            return;
+        }
+        //To prevent "unknown console command" error, set the command to the meta command
+        //commandhelper null, which just returns true.
+        if(match){
+            event.setCommand("commandhelper null");
+        }
+    }
+    
+}
diff --git a/src/main/java/com/laytonsmith/core/AliasCore.java b/src/main/java/com/laytonsmith/core/AliasCore.java
new file mode 100644
index 0000000..b8f9cf7
--- /dev/null
+++ b/src/main/java/com/laytonsmith/core/AliasCore.java
@@ -0,0 +1,407 @@
+/*
+ * To change this template, choose Tools | Templates
+ * and open the template in the editor.
+ */
+package com.laytonsmith.core;
+
+import com.laytonsmith.PureUtilities.Preferences;
+import com.laytonsmith.PureUtilities.TermColors;
+import com.laytonsmith.abstraction.MCChatColor;
+import com.laytonsmith.abstraction.MCCommandSender;
+import com.laytonsmith.abstraction.MCPlayer;
+import com.laytonsmith.commandhelper.CommandHelperPlugin;
+import com.laytonsmith.core.events.EventUtils;
+import com.laytonsmith.core.exceptions.ConfigCompileException;
+import com.laytonsmith.core.exceptions.ConfigRuntimeException;
+import com.laytonsmith.core.functions.IncludeCache;
+import com.sk89q.bukkit.migration.PermissionsResolverManager;
+import java.io.*;
+import java.util.*;
+import java.util.logging.Level;
+import java.util.logging.Logger;
+
+/**
+ * This class contains all the handling code. It only deals with built-in Java Objects,
+ * so that if the Minecraft API Hook changes, porting the code will only require changing
+ * the API specific portions, not this core file.
+ * @author Layton
+ */
+public class AliasCore {
+
+    private File aliasConfig;
+    private File prefFile;
+    private File mainFile;
+    //AliasConfig config;
+    List<Script> scripts;
+    static final Logger logger = Logger.getLogger("Minecraft");
+    private Set<String> echoCommand = new HashSet<String>();
+    private PermissionsResolverManager perms;
+    public static CommandHelperPlugin parent;
+
+    /**
+     * This constructor accepts the configuration settings for the plugin, and ensures
+     * that the manager uses these settings.
+     * @param allowCustomAliases Whether or not to allow users to add their own personal aliases
+     * @param maxCustomAliases How many aliases a player is allowed to have. -1 is unlimited.
+     * @param maxCommands How many commands an alias may contain. Since aliases can be used like a
+     * macro, this can help prevent command spamming.
+     */
+    public AliasCore(File aliasConfig, File prefFile, File mainFile, PermissionsResolverManager perms, CommandHelperPlugin parent) throws ConfigCompileException {
+        this.aliasConfig = aliasConfig;
+        this.prefFile = prefFile;
+        this.perms = perms;
+        this.parent = parent;
+        this.mainFile = mainFile;
+        reload(null);
+    }
+
+    /**
+     * This is the workhorse function. It takes a given command, then converts it
+     * into the actual command(s). If the command maps to a defined alias, it will
+     * run the specified alias. It will search through the
+     * global list of aliases, as well as the aliases defined for that specific player.
+     * This function doesn't handle the /alias command however.
+     * @param command
+     * @return
+     */
+    public boolean alias(String command, final MCCommandSender player, List<Script> playerCommands) {
+        
+        Env env = new Env();
+        env.SetCommandSender(player);
+
+        if (scripts == null) {
+            throw new ConfigRuntimeException("Cannot run alias commands, no config file is loaded", 0, null);
+        }
+
+        boolean match = false;
+        try { //catch RuntimeException
+            //If player is null, we are running the test harness, so don't
+            //actually add the player to the array.
+            if (player != null && player instanceof MCPlayer && echoCommand.contains(((MCPlayer) player).getName())) {
+                //we are running one of the expanded commands, so exit with false
+                return false;
+            }
+
+            //Global aliases override personal ones, so check the list first
+            //a = config.getRunnableAliases(command, player);
+            for (Script s : scripts) {
+                try {
+                    if (s.match(command)) {
+                        this.addPlayerReference(player);
+                        if ((Boolean) Static.getPreferences().getPreference("console-log-commands")) {
+                            StringBuilder b = new StringBuilder("CH: Running original command ");
+                            if (player instanceof MCPlayer) {
+                                b.append("on player ").append(((MCPlayer) player).getName());
+                            } else {
+                                b.append("from a MCCommandSender");
+                            }
+                            b.append(" ----> ").append(command);
+                            Static.getLogger().log(Level.INFO, b.toString());
+                        }
+                        try {
+                            env.SetCommand(command);
+                            s.run(s.getVariables(command), env, new MScriptComplete() {
+
+                                public void done(String output) {
+                                    try {
+                                        if (output != null) {
+                                            if (!output.trim().equals("") && output.trim().startsWith("/")) {
+                                                if ((Boolean) Static.getPreferences().getPreference("debug-mode")) {
+                                                    if (player instanceof MCPlayer) {
+                                                        Static.getLogger().log(Level.INFO, "[CommandHelper]: Executing command on " + ((MCPlayer) player).getName() + ": " + output.trim());
+                                                    } else {
+                                                        Static.getLogger().log(Level.INFO, "[CommandHelper]: Executing command from console equivalent: " + output.trim());
+                                                    }
+                                                }
+                                                
+                                                if (player instanceof MCPlayer) {
+                                                    ((MCPlayer) player).chat(output.trim());
+                                                } else {
+                                                    Static.getServer().dispatchCommand(player, output.trim().substring(1));
+                                                }
+                                            }
+                                        }
+                                    } catch (Throwable e) {
+                                        System.err.println(e.getMessage());
+                                        player.sendMessage(MCChatColor.RED + e.getMessage());
+                                    } finally {
+                                        Static.getAliasCore().removePlayerReference(player);
+                                    }
+                                }
+                            });
+                        } catch(ConfigRuntimeException ex){
+                            ex.setEnv(env);
+                            switch(ConfigRuntimeException.HandleUncaughtException(ex)){
+                                case REPORT:
+                                    ConfigRuntimeException.DoReport(ex);
+                                    break;
+                                case IGNORE:
+                                    break;
+                                case FATAL:
+                                    throw ex;
+                                default:
+                                    break;
+                            }
+                        } catch (Throwable e) {
+                            //This is not a simple user script error, this is a deeper problem, so we always handle this.
+                            System.err.println("An unexpected exception occured: " + e.getClass().getSimpleName());
+                            player.sendMessage("An unexpected exception occured: " + MCChatColor.RED + e.getClass().getSimpleName());
+                            e.printStackTrace();
+                        } finally {
+                            Static.getAliasCore().removePlayerReference(player);
+                        }
+                        match = true;
+                        break;
+                    }
+                } catch (Exception e) {
+                    System.err.println("An unexpected exception occured inside the command " + s.toString());
+                    e.printStackTrace();
+                }
+            }
+
+            if (player instanceof MCPlayer) {
+                if (match == false && playerCommands != null) {
+                    //if we are still looking, look in the aliases for this player
+                    for (Script ac : playerCommands) {
+                        //RunnableAlias b = ac.getRunnableAliases(command, player);
+                        try {
+                            
+                            ac.compile();
+                            
+                            if (ac.match(command)) {
+                                Static.getAliasCore().addPlayerReference(player);
+                                ac.run(ac.getVariables(command), env, new MScriptComplete() {
+
+                                    public void done(String output) {
+                                        if (output != null) {
+                                            if (!output.trim().equals("") && output.trim().startsWith("/")) {
+                                                if ((Boolean) Static.getPreferences().getPreference("debug-mode")) {
+                                                    Static.getLogger().log(Level.INFO, "[CommandHelper]: Executing command on " + ((MCPlayer)player).getName() + ": " + output.trim());
+                                                }
+                                                ((MCPlayer)player).chat(output.trim());
+                                            }
+                                        }
+                                        Static.getAliasCore().removePlayerReference(player);
+                                    }
+                                });
+                                match = true;
+                                break;
+                            }
+                        } catch (ConfigRuntimeException e) {
+                            //Unlike system scripts, this should just report the problem to the player
+                            ConfigRuntimeException.DoReport(e);
+                            Static.getAliasCore().removePlayerReference(player);
+                        } catch(ConfigCompileException e){
+                            //Something strange happened, and a bad alias was added
+                            //to the database. Our best course of action is to just
+                            //skip it.
+                        }
+                    }
+
+                }
+            }
+        } catch (Throwable e) {
+            throw new InternalException("An error occured in the CommandHelper plugin: " + e.getMessage() + Arrays.asList(e.getStackTrace()));
+        }
+        return match;
+    }
+
+    /**
+     * Loads the global alias file in from the file system. If a player is
+     * running the command, send a reference to them, and they will see
+     * compile errors, otherwise, null.
+     */
+    public final boolean reload(MCPlayer player) {
+        boolean is_loaded = true;
+        try {
+            Globals.clear();
+            EventUtils.UnregisterAll();            
+            IncludeCache.clearCache(); //Clear the include cache, so it re-pulls files
+            if (!aliasConfig.exists()) {
+                aliasConfig.getParentFile().mkdirs();
+                aliasConfig.createNewFile();
+                try {
+                    String samp_config = getStringResource(AliasCore.class.getResourceAsStream("/samp_config.txt"));
+                    //Because the sample config may have been written an a machine that isn't this type, replace all
+                    //line endings
+                    samp_config = samp_config.replaceAll("\n|\r\n", System.getProperty("line.separator"));
+                    file_put_contents(aliasConfig, samp_config, "o");
+                } catch (Exception e) {
+                    logger.log(Level.WARNING, "CommandHelper: Could not write sample config file");
+                }
+            }
+            
+            if(!mainFile.exists()){
+                mainFile.getParentFile().mkdirs();
+                mainFile.createNewFile();
+                try{
+                    String samp_main = getStringResource(AliasCore.class.getResourceAsStream("/samp_main.txt"));
+                    samp_main = samp_main.replaceAll("\n|\r\n", System.getProperty("line.separator"));
+                    file_put_contents(mainFile, samp_main, "o");
+                } catch(Exception e){
+                    logger.log(Level.WARNING, "CommandHelper: Could not write sample main file");
+                }
+            }
+
+            Preferences prefs = Static.getPreferences();
+            prefs.init(prefFile);
+            
+            //Run the main file once
+            try{
+                Env main_env = new Env();
+                main_env.SetCommandSender(null);
+                String main = file_get_contents(mainFile.getAbsolutePath());
+                MScriptCompiler.execute(MScriptCompiler.compile(MScriptCompiler.lex(main, mainFile)), main_env, new MScriptComplete() {
+
+                    public void done(String output) {
+                        logger.log(Level.INFO, TermColors.YELLOW + "[CommandHelper]: Main file processed" + TermColors.reset());
+                    }
+                }, null);
+            } catch(ConfigCompileException e){
+                ConfigRuntimeException.DoReport(e, "Main file could not be compiled, due to a compile error.", null);
+                is_loaded = false;
+            }
+            
+            String alias_config = file_get_contents(aliasConfig.getAbsolutePath()); //get the file again
+            //config = new AliasConfig(alias_config, null, perms);
+            scripts = MScriptCompiler.preprocess(MScriptCompiler.lex(alias_config, aliasConfig), new Env());
+            for (Script s : scripts) {
+                try {
+                    s.compile();
+                    s.checkAmbiguous((ArrayList<Script>) scripts);
+                } catch (ConfigCompileException e) {
+                    ConfigRuntimeException.DoReport(e, "Compile error in script. Compilation will attempt to continue, however.", player);
+                    is_loaded = false;
+                }
+            }
+            int errors = 0;
+            for (Script s : scripts) {
+                if (s.compilerError) {
+                    errors++;
+                }
+            }
+            if (errors > 0) {
+                System.out.println("[CommandHelper]: " + (scripts.size() - errors) + " alias(es) defined, " + TermColors.RED + "with " + errors + " aliases with compile errors." + TermColors.reset());
+                is_loaded = false;
+            } else {
+                System.out.println("[CommandHelper]: " + scripts.size() + " alias(es) defined.");
+            }
+        } catch (IOException ex) {
+            logger.log(Level.SEVERE, "[CommandHelper]: Path to config file is not correct/accessable. Please"
+                    + " check the location and try loading the plugin again.");
+        } catch (Throwable t) {
+            t.printStackTrace();
+        }
+
+        return is_loaded;
+    }
+
+//    public ArrayList<AliasConfig> parse_user_config(ArrayList<String> config, User u) throws ConfigCompileException {
+//        if (config == null) {
+//            return null;
+//        }
+//        ArrayList<AliasConfig> alac = new ArrayList<AliasConfig>();
+//        for (int i = 0; i < config.size(); i++) {
+//            alac.add(new AliasConfig(config.get(i), u, perms));
+//        }
+//        return alac;
+//    }
+    /**
+     * Returns the contents of a file as a string. Accepts the file location
+     * as a string.
+     * @param file_location
+     * @return the contents of the file as a string
+     * @throws Exception if the file cannot be found
+     */
+    public static String file_get_contents(String file_location) throws IOException {
+        BufferedReader in = new BufferedReader(new FileReader(file_location));
+        String ret = "";
+        String str;
+        while ((str = in.readLine()) != null) {
+            ret += str + "\n";
+        }
+        in.close();
+        return ret;
+    }
+
+    /**
+     * This function writes the contents of a string to a file.
+     * @param file_location the location of the file on the disk
+     * @param contents the string to be written to the file
+     * @param mode the mode in which to write the file: <br />
+     * <ul>
+     * <li>"o" - overwrite the file if it exists, without asking</li>
+     * <li>"a" - append to the file if it exists, without asking</li>
+     * <li>"c" - cancel the operation if the file exists, without asking</li>
+     * </ul>
+     * @return true if the file was written, false if it wasn't. Throws an exception
+     * if the file could not be created, or if the mode is not valid.
+     * @throws Exception if the file could not be created
+     */
+    public static boolean file_put_contents(File file_location, String contents, String mode)
+            throws Exception {
+        BufferedWriter out = null;
+        File f = file_location;
+        if (f.exists()) {
+            //do different things depending on our mode
+            if (mode.equalsIgnoreCase("o")) {
+                out = new BufferedWriter(new FileWriter(file_location));
+            } else if (mode.equalsIgnoreCase("a")) {
+                out = new BufferedWriter(new FileWriter(file_location, true));
+            } else if (mode.equalsIgnoreCase("c")) {
+                return false;
+            } else {
+                throw new RuntimeException("Undefined mode in file_put_contents: " + mode);
+            }
+        } else {
+            out = new BufferedWriter(new FileWriter(file_location));
+        }
+        //At this point, we are assured that the file is open, and ready to be written in
+        //from this point in the file.
+        if (out != null) {
+            out.write(contents);
+            out.close();
+            return true;
+        } else {
+            return false;
+        }
+    }
+
+    public static String getStringResource(InputStream is) throws IOException {
+        Writer writer = new StringWriter();
+        char[] buffer = new char[1024];
+        try {
+            Reader reader = new BufferedReader(new InputStreamReader(is));
+            int n;
+            while ((n = reader.read(buffer)) != -1) {
+                writer.write(buffer, 0, n);
+            }
+        } finally {
+            if (is != null) {
+                is.close();
+            }
+        }
+        return writer.toString();
+    }
+
+    public void removePlayerReference(MCCommandSender p) {
+        //If they're not a player, oh well.
+        if (p instanceof MCPlayer) {
+            echoCommand.remove(((MCPlayer) p).getName());
+        }
+    }
+
+    public void addPlayerReference(MCCommandSender p) {
+        if (p instanceof MCPlayer) {
+            echoCommand.add(((MCPlayer) p).getName());
+        }
+    }
+    
+    public boolean hasPlayerReference(MCCommandSender p){
+        if(p instanceof MCPlayer){
+            return echoCommand.contains(((MCPlayer)p).getName());
+        } else {
+            return false;
+        }
+    }
+}
diff --git a/src/main/java/com/laytonsmith/core/BukkitDirtyRegisteredListener.java b/src/main/java/com/laytonsmith/core/BukkitDirtyRegisteredListener.java
new file mode 100644
index 0000000..13a7c0f
--- /dev/null
+++ b/src/main/java/com/laytonsmith/core/BukkitDirtyRegisteredListener.java
@@ -0,0 +1,301 @@
+/*
+ * To change this template, choose Tools | Templates
+ * and open the template in the editor.
+ */
+package com.laytonsmith.core;
+
+import com.laytonsmith.core.functions.Debug;
+import com.laytonsmith.core.functions.Performance;
+import java.lang.reflect.Field;
+import java.lang.reflect.Method;
+import java.lang.reflect.Modifier;
+import java.util.*;
+import java.util.concurrent.LinkedBlockingQueue;
+import java.util.logging.Level;
+import java.util.logging.Logger;
+import org.bukkit.event.Cancellable;
+import org.bukkit.event.Event;
+import org.bukkit.event.Listener;
+import org.bukkit.plugin.EventExecutor;
+import org.bukkit.plugin.Plugin;
+import org.bukkit.plugin.RegisteredListener;
+import org.bukkit.plugin.SimplePluginManager;
+import org.perf4j.StopWatch;
+
+/**
+ *
+ * @author Layton
+ */
+public class BukkitDirtyRegisteredListener extends RegisteredListener {
+
+    private final Listener listener;
+    private final Event.Priority priority;
+    private final Plugin plugin;
+    private final EventExecutor executor;
+    private static final int queueCapacity = 20;
+    private static Queue<Event> cancelledEvents = new LinkedBlockingQueue<Event>(queueCapacity);
+
+    public BukkitDirtyRegisteredListener(final Listener pluginListener, final EventExecutor eventExecutor, final Event.Priority eventPriority, final Plugin registeredPlugin) {
+        super(pluginListener, eventExecutor, eventPriority, registeredPlugin);
+        listener = pluginListener;
+        priority = eventPriority;
+        plugin = registeredPlugin;
+        executor = eventExecutor;
+    }
+
+    public static class DirtyEnumMap<K extends Enum<K>, V> extends EnumMap<K, V> {
+
+        public DirtyEnumMap(Class<K> keyType) {
+            super(keyType);
+        }
+
+        public DirtyEnumMap(EnumMap<K, ? extends V> m) {
+            super(m);
+        }
+
+        public DirtyEnumMap(Map<K, ? extends V> m) {
+            super(m);
+        }
+
+        @Override
+        public V put(K key, V value) {
+            if (!(value instanceof DirtyTreeSet) && value instanceof TreeSet) {
+                return super.put(key, (V) DirtyTreeSet.GenerateDirtyTreeSet((TreeSet) value));
+            } else {
+                return super.put(key, value);
+            }
+            //return null;
+        }
+    }
+
+    public static class DirtyTreeSet<E> extends TreeSet {
+
+        public static DirtyTreeSet GenerateDirtyTreeSet(TreeSet ts) {
+            DirtyTreeSet dts = new DirtyTreeSet(ts.comparator());            
+            for (Object o : ts) {
+                dts.add(o);
+            }
+            return dts;
+        }
+        
+        public DirtyTreeSet(Comparator<? super E> comparator) {
+            super(comparator);
+        }
+
+        @Override
+        public boolean add(Object e) {
+            if(!(e instanceof BukkitDirtyRegisteredListener) && e instanceof RegisteredListener){
+                try {
+                    return super.add(Generate((RegisteredListener)e));
+                } catch (NoSuchFieldException ex) {
+                    Logger.getLogger(BukkitDirtyRegisteredListener.class.getName()).log(Level.SEVERE, null, ex);
+                } catch (IllegalArgumentException ex) {
+                    Logger.getLogger(BukkitDirtyRegisteredListener.class.getName()).log(Level.SEVERE, null, ex);
+                } catch (IllegalAccessException ex) {
+                    Logger.getLogger(BukkitDirtyRegisteredListener.class.getName()).log(Level.SEVERE, null, ex);
+                }
+            } else {
+                return super.add(e);
+            }
+            return false;
+        }
+                
+    }
+
+    public static void Repopulate() throws NoSuchFieldException, ClassCastException, IllegalArgumentException, IllegalAccessException, NoSuchMethodException {
+        //Go through the list of registered listeners, and inject our
+        //our own poisoned DirtyRegisteredListeners in instead
+        SimplePluginManager pm = (SimplePluginManager) AliasCore.parent.getServer().getPluginManager();
+        Field fListener = SimplePluginManager.class.getDeclaredField("listeners");
+        //set it to public
+        fListener.setAccessible(true);
+        EnumMap<Event.Type, SortedSet<RegisteredListener>> listeners =
+                (EnumMap<Event.Type, SortedSet<RegisteredListener>>) fListener.get(pm);
+
+        if (listeners instanceof DirtyEnumMap) {
+            return; //We don't need to bother with it, we've already injected our poisoned EnumMap,
+            //so further additions will go through that instead.
+        }
+        
+        //Remove final from the listeners, so we can modify it
+        Field modifiersField = Field.class.getDeclaredField("modifiers");
+        modifiersField.setAccessible(true);
+        modifiersField.setInt(fListener, fListener.getModifiers() & ~Modifier.FINAL);
+
+        Map<Event.Type, SortedSet<RegisteredListener>> newListeners = new DirtyEnumMap<Event.Type, SortedSet<RegisteredListener>>(Event.Type.class);
+
+        //We need the comparator, so we can create a new listener map
+        Field fComparator = SimplePluginManager.class.getDeclaredField("comparer");
+        fComparator.setAccessible(true);
+        Comparator<RegisteredListener> comparator = (Comparator<RegisteredListener>) fComparator.get(pm);
+
+        //Ok, now we have the listeners, so lets loop through them, and shove them into our own newListener object, so that
+        //we can replace the reference later, without modifying the existing variable, because it is currently being walked
+        //through elsewhere in the code.
+
+        boolean doReplace = false;
+
+        Set<Map.Entry<Event.Type, SortedSet<RegisteredListener>>> entrySet = listeners.entrySet();
+        Iterator i = entrySet.iterator();
+        while (i.hasNext()) {
+            final Map.Entry<Event.Type, SortedSet<RegisteredListener>> mySet = (Map.Entry<Event.Type, SortedSet<RegisteredListener>>) i.next();
+            Iterator k = mySet.getValue().iterator();
+            SortedSet<RegisteredListener> rls = new DirtyTreeSet<RegisteredListener>(comparator);
+            newListeners.put(mySet.getKey(), rls);
+            while (k.hasNext()) {
+                final RegisteredListener rl = (RegisteredListener) k.next();
+                if (!(rl instanceof BukkitDirtyRegisteredListener)) {
+                    doReplace = true;
+                }
+                rls.add(BukkitDirtyRegisteredListener.Generate(rl));
+            }
+        }
+
+        if (doReplace) {
+            //Only replace it if we've made changes
+            fListener.set(pm, newListeners);
+        }
+
+    }
+
+//    public static class MyEntry {
+//
+//        public Type key;
+//        public DirtyRegisteredListener value;
+//    }
+
+    public static void setCancelled(Event superCancelledEvent) {
+        if (cancelledEvents.size() >= queueCapacity) {
+            cancelledEvents.poll();
+        }
+        cancelledEvents.offer(superCancelledEvent);
+    }
+
+    public static BukkitDirtyRegisteredListener Generate(RegisteredListener real) throws NoSuchFieldException, IllegalArgumentException, IllegalAccessException {
+        if (real instanceof BukkitDirtyRegisteredListener) {
+            return (BukkitDirtyRegisteredListener) real;
+        }
+        Field rListener = real.getClass().getDeclaredField("listener");
+        rListener.setAccessible(true);
+        Listener nListener = (Listener) rListener.get(real);
+
+        Field rPriority = real.getClass().getDeclaredField("priority");
+        rPriority.setAccessible(true);
+        Event.Priority nPriority = (Event.Priority) rPriority.get(real);
+
+        Field rPlugin = real.getClass().getDeclaredField("plugin");
+        rPlugin.setAccessible(true);
+        Plugin nPlugin = (Plugin) rPlugin.get(real);
+
+        Field rExecutor = real.getClass().getDeclaredField("executor");
+        rExecutor.setAccessible(true);
+        EventExecutor nExecutor = (EventExecutor) rExecutor.get(real);
+
+        return new BukkitDirtyRegisteredListener(nListener, nExecutor, nPriority, nPlugin);
+    }
+
+    /**
+     * This is the magic method we need to override. When we call the event, if it
+     * is "super cancelled", then we don't run it. Cancelled events are still run
+     * if they aren't "super cancelled", which mirrors existing behavior.
+     * @param event 
+     */
+    @Override
+    public void callEvent(Event event) {
+        if (Debug.EVENT_LOGGING && Debug.IsFiltered(plugin)) {
+            Debug.DoLog(event.getType(), 1, "Bukkit Event received: " + event.getType().name());
+        }
+        //If it isn't super cancelled, call it, even if it is cancelled
+        if (!BukkitDirtyRegisteredListener.cancelledEvents.contains(event)) {
+            if (Debug.EVENT_LOGGING && Debug.IsFiltered(plugin)
+                    && Debug.EVENT_LOGGING_FILTER.contains(event.getType())) {
+                Debug.DoLog(event.getType(), 3, "\tEvent is not super cancelled, so triggering now");
+            }
+            callEvent0(event);
+        } else {
+            //If it's a cancellable event, and this listener isn't Monitor priority, just return
+            if (event instanceof Cancellable && this.priority != Event.Priority.Monitor) {
+                if (Debug.EVENT_LOGGING && Debug.IsFiltered(plugin)
+                        && Debug.EVENT_LOGGING_FILTER.contains(event.getType())) {
+                    Debug.DoLog(event.getType(), 3, "\tEvent is being ignored, due to play-dirty mode rules");
+                }
+                return;
+            } else {
+                if (Debug.EVENT_LOGGING && Debug.IsFiltered(plugin)
+                        && Debug.EVENT_LOGGING_FILTER.contains(event.getType())) {
+                    Debug.DoLog(event.getType(), 3, "\tEvent is super cancelled, but this listener is either monitor priority (Y/N:"
+                            + (this.priority == Event.Priority.Monitor ? "y" : "n") + " or it it is not cancellable (Y/N:"
+                            + (event instanceof Cancellable ? "n" : "y"));
+                }
+                callEvent0(event);
+            }
+        }
+    }
+
+    private void callEvent0(Event event) {
+        StopWatch stopWatch = null;
+        if (Debug.EVENT_LOGGING && Debug.IsFiltered(plugin)
+                && Debug.EVENT_LOGGING_FILTER.contains(event.getType())) {
+            if (Debug.EVENT_LOGGING_LEVEL >= 1) {
+                Debug.DoLog(event.getType(), 1, "\tEvent type: " + event.getType().name());
+                Debug.DoLog(event.getType(), 1, "\tCalled from plugin: " + this.plugin.getClass().getSimpleName());
+            }
+            if (Debug.EVENT_LOGGING_LEVEL >= 2) {
+                Debug.DoLog(event.getType(), 1, "\tListener Registered: " + this.listener.getClass().getCanonicalName());
+                Debug.DoLog(event.getType(), 2, "\tIs Cancellable? " + (event instanceof Cancellable ? "Y" : "N"));
+                if (event instanceof Cancellable) {
+                    Debug.DoLog(event.getType(), 2, "\t\tIs Cancelled? " + (((Cancellable) event).isCancelled() ? "Y" : "N"));
+                }
+            }
+            if (Debug.EVENT_LOGGING_LEVEL >= 3) {
+                Debug.DoLog(event.getType(), 3, "\tEvent class: " + event.getClass().getCanonicalName());
+            }
+            if (Debug.EVENT_LOGGING_LEVEL >= 4) {
+                //Let's just dump the fields
+                StringBuilder b = new StringBuilder("\n\tFields in this event:\n");
+                for (Field f : event.getClass().getSuperclass().getDeclaredFields()) {
+                    b.append("\t\t").append(f.getType().getSimpleName()).append(" ").append(f.getName());
+                    f.setAccessible(true);
+                    try {
+                        Object o = f.get(event);
+                        b.append(" = (actual type: ").append(o.getClass().getSimpleName()).append(") ").append(o.toString()).append("\n");
+                    } catch (IllegalArgumentException ex) {
+                        Logger.getLogger(BukkitDirtyRegisteredListener.class.getName()).log(Level.SEVERE, null, ex);
+                    } catch (IllegalAccessException ex) {
+                        Logger.getLogger(BukkitDirtyRegisteredListener.class.getName()).log(Level.SEVERE, null, ex);
+                    }
+                }
+                Debug.DoLog(event.getType(), 4, b.toString());
+            }
+            if (Debug.EVENT_LOGGING_LEVEL == 5) {
+                //dump ALL the things
+                StringBuilder b = new StringBuilder("\n\tMethods in this event:\n");
+                for (Method m : event.getClass().getSuperclass().getDeclaredMethods()) {
+                    b.append("\t\t").append(m.getReturnType().getSimpleName()).append(" ").append(m.getName()).append("(").append(Static.strJoin(m.getParameterTypes(), ", ")).append(");\n");
+                }
+                Debug.DoLog(event.getType(), 5, b.toString());
+            }
+        }
+        if ((Debug.EVENT_LOGGING && Debug.IsFiltered(plugin)
+                && Debug.EVENT_LOGGING_FILTER.contains(event.getType()) && Debug.EVENT_LOGGING_LEVEL >= 2) || Performance.PERFORMANCE_LOGGING) {
+            stopWatch = new StopWatch(
+                    this.plugin.getClass().getSimpleName() + "."//Plugin name
+                    + this.listener.getClass().getCanonicalName().replaceAll("\\.", "/") + "." //File event is being called from
+                    + (event.getType() == Event.Type.CUSTOM_EVENT ? "CUSTOM_EVENT/" + event.getEventName() : event.getType().name()) //Event name
+                    );
+        }
+        executor.execute(listener, event);
+        if (stopWatch != null) {
+            stopWatch.stop();
+            if (Debug.EVENT_LOGGING) {
+                Debug.DoLog(event.getType(), 2, "\t\t\tEvent completed in " + stopWatch.getElapsedTime() + " milliseconds");
+            }
+            if (Performance.PERFORMANCE_LOGGING) {
+                Performance.DoLog(stopWatch);
+            }
+        }
+        if (Debug.EVENT_LOGGING && Debug.IsFiltered(plugin)) {
+            Debug.DoLog(event.getType(), 1, "--------------------------------------------------------------\n");
+        }
+    }
+}
diff --git a/src/main/java/com/laytonsmith/core/Documentation.java b/src/main/java/com/laytonsmith/core/Documentation.java
new file mode 100644
index 0000000..ba8f0e0
--- /dev/null
+++ b/src/main/java/com/laytonsmith/core/Documentation.java
@@ -0,0 +1,32 @@
+/*
+ * To change this template, choose Tools | Templates
+ * and open the template in the editor.
+ */
+package com.laytonsmith.core;
+
+/**
+ * Classes that implement this method know how to provide some documentation to the DocGen
+ * class.
+ * 
+ * In general, classes that implement this should also tag themselves with the
+ * <code>@docs</code> tag, so the ClassDiscovery method can more easily find them,
+ * if the class intends on being parsed by DocGen.
+ * @author layton
+ */
+public interface Documentation {
+    /**
+     * The name of this code element
+     */
+    public String getName();
+    /**
+     * Returns documentation in a format that is specified by the code type
+     * @return 
+     */
+    public String docs();
+    /**
+     * Returns the version number of when this functionality was added. It should
+     * follow the format 0.0.0
+     * @return 
+     */
+    public String since();
+}
diff --git a/src/main/java/com/laytonsmith/core/Env.java b/src/main/java/com/laytonsmith/core/Env.java
new file mode 100644
index 0000000..8abaad1
--- /dev/null
+++ b/src/main/java/com/laytonsmith/core/Env.java
@@ -0,0 +1,230 @@
+/*
+ * To change this template, choose Tools | Templates
+ * and open the template in the editor.
+ */
+package com.laytonsmith.core;
+
+import com.laytonsmith.abstraction.MCCommandSender;
+import com.laytonsmith.abstraction.MCPlayer;
+import com.laytonsmith.core.events.BoundEvent;
+import com.laytonsmith.core.functions.IVariableList;
+import java.util.HashMap;
+import java.util.Map;
+
+/**
+ * The Env class contains the operating environment for a particular function.
+ * @author Layton
+ */
+public final class Env implements Cloneable{
+    
+    /**
+     * This is the underlying map of variables
+     */
+    private Map<String, Object> custom = new HashMap<String, Object>();   
+    private Map<String, Boolean> flags = new HashMap<String, Boolean>();
+    private MCCommandSender commandSender = null;
+    private IVariableList iVariableList = null;
+    private Map<String, Procedure> procs = null;
+    private String label = null;
+    private Script script = null;
+    private BoundEvent.ActiveEvent event = null;
+    private String command = null;
+    
+    /*
+     * The constructor has relatively little to do, most things are lazy
+     * initialized, but sometimes it's more convenient to pre-initialize
+     * certain things
+     */
+    public Env(){
+       
+    }
+    
+    /**
+     * Sets the value of a flag
+     * @param name
+     * @param value 
+     */
+    public void SetFlag(String name, boolean value){
+        flags.put(name, value);
+    }
+    
+    /**
+     * Returns the value of a flag. Null if unset.
+     * @param name
+     * @return 
+     */
+    public Boolean GetFlag(String name){
+        if(!flags.containsKey(name)){
+            return null;
+        } else {
+            return flags.get(name);
+        }
+    }
+    
+    /**
+     * Clears the value of a flag from the flag list, causing further calls to GetFlag(name) to return null.
+     * @param name 
+     */
+    public void ClearFlag(String name){
+        flags.remove(name);
+    }
+    
+    /**
+     * Use this if you would like to stick a custom variable in the environment.
+     * It should be discouraged to use this for more than one shot transfers. Typically,
+     * an setter and getter should be made to wrap the element.
+     * @param name
+     * @param var 
+     */
+    public void SetCustom(String name, Object var){
+        if(!custom.containsKey("custom")){
+            custom.put("custom", new HashMap<String, Object>());
+        }
+        ((Map<String, Object>)custom.get("custom")).put(name, var);        
+    }
+    
+    public Object GetCustom(String name){
+        if(!custom.containsKey("custom")){
+            custom.put("custom", new HashMap<String, Object>());
+        }
+        return ((Map<String, Object>)custom.get("custom")).get(name);
+    }
+    /**
+     * Given the environment, this function returns the CommandSender in the
+     * environment, which can possibly be null.
+     * @param env
+     * @return 
+     */
+    public MCCommandSender GetCommandSender(){
+        return commandSender;
+    }
+    
+    /**
+     * Sets the CommandSender in this environment
+     * @param env 
+     */
+    public void SetCommandSender(MCCommandSender cs){
+        commandSender = cs;
+    }
+    
+    /**
+     * Given the environment, this function returns the Player in the
+     * environment, which can possibly be null. It is also possible the
+     * environment contains a CommandSender object instead, which will
+     * cause null to be returned.
+     * @param env
+     * @return 
+     */
+    public MCPlayer GetPlayer(){
+        if(commandSender instanceof MCPlayer){
+            return (MCPlayer)commandSender;
+        } else {
+            return null;
+        }
+    }
+    
+    /**
+     * Sets the Player in this environment
+     * @param env 
+     */
+    public void SetPlayer(MCPlayer p){
+        commandSender = p;
+    }
+    
+    /**
+     * This function will return the variable list in this environment.
+     * If the environment doesn't contain a variable list, an empty one
+     * is created, and stored in the environment.
+     * @param env
+     * @return 
+     */
+    public IVariableList GetVarList(){
+        if(iVariableList == null){
+            iVariableList = new IVariableList();
+        }
+        return iVariableList;
+    }
+    
+    public void SetVarList(IVariableList varList){
+        iVariableList = varList;
+    }
+    
+    /**
+     * Returns the Map of known procedures in this environment. If the list
+     * of procedures is currently empty, a new one is created and stored in
+     * the environment.
+     * @param env
+     * @return 
+     */
+    public Map<String, Procedure> GetProcs(){
+        if(procs == null){
+            procs = new HashMap<String, Procedure>();
+        }
+        return procs;
+    }
+    
+    public void SetProcs(Map<String, Procedure> procs){
+        this.procs = procs;
+    }
+    
+    public String GetLabel(){
+        return label;
+    }
+    
+    public void SetLabel(String label){
+        this.label = label;
+    }
+    
+    public void SetScript(Script s){
+        this.script = s;
+    }
+    
+    public Script GetScript(){
+        return script;
+    }        
+    
+    public void SetEvent(BoundEvent.ActiveEvent e){
+        event = e;
+    }
+    
+    /**
+     * Returns the active event, or null if not in scope.
+     * @return 
+     */
+    public BoundEvent.ActiveEvent GetEvent(){
+        return event;
+    }
+    
+    @Override
+    public Env clone() throws CloneNotSupportedException{
+        Env clone = new Env();
+        clone.custom = new HashMap<String, Object>(this.custom);
+        clone.commandSender = commandSender;
+        clone.event = event;
+        if(flags != null){
+            clone.flags = new HashMap<String, Boolean>(flags);
+        } else {
+            clone.flags = new HashMap<String, Boolean>();
+        }
+        clone.label = label;
+        if(procs != null){
+            clone.procs = new HashMap<String, Procedure>(procs);
+        } else {
+            clone.procs = new HashMap<String, Procedure>();
+        }
+        clone.script = script;
+        if(iVariableList != null){
+            clone.iVariableList = (IVariableList) iVariableList.clone();
+        }
+        clone.command = command;
+        return clone;
+    }
+
+    public void SetCommand(String command) {
+        this.command = command;
+    }
+    
+    public String GetCommand(){
+        return this.command;
+    }
+}
diff --git a/src/main/java/com/laytonsmith/core/GenericTree.java b/src/main/java/com/laytonsmith/core/GenericTree.java
new file mode 100644
index 0000000..78273a5
--- /dev/null
+++ b/src/main/java/com/laytonsmith/core/GenericTree.java
@@ -0,0 +1,195 @@
+/*
+ Copyright 2010 Vivin Suresh Paliath
+ Distributed under the BSD License
+*/
+
+package com.laytonsmith.core;
+
+import java.util.ArrayList;
+import java.util.LinkedHashMap;
+import java.util.List;
+import java.util.Map;
+
+public class GenericTree<T> {
+
+    private GenericTreeNode<T> root;
+
+    public GenericTree() {
+        super();
+    }
+
+    public GenericTreeNode<T> getRoot() {
+        return this.root;
+    }
+
+    public void setRoot(GenericTreeNode<T> root) {
+        this.root = root;
+    }
+
+    public int getNumberOfNodes() {
+        int numberOfNodes = 0;
+
+        if(root != null) {
+            numberOfNodes = auxiliaryGetNumberOfNodes(root) + 1; //1 for the root!
+        }
+
+        return numberOfNodes;
+    }
+
+    private int auxiliaryGetNumberOfNodes(GenericTreeNode<T> node) {
+        int numberOfNodes = node.getNumberOfChildren();
+
+        for(GenericTreeNode<T> child : node.getChildren()) {
+            numberOfNodes += auxiliaryGetNumberOfNodes(child);
+        }
+
+        return numberOfNodes;
+    }
+
+    public boolean exists(GenericTreeNode<T> nodeToFind) {
+        return (find(nodeToFind) != null);
+    }
+
+    public GenericTreeNode<T> find(GenericTreeNode<T> nodeToFind) {
+        GenericTreeNode<T> returnNode = null;
+
+        if(root != null) {
+            returnNode = auxiliaryFind(root, nodeToFind);
+        }
+
+        return returnNode;
+    }
+
+    private GenericTreeNode<T> auxiliaryFind(GenericTreeNode<T> currentNode, GenericTreeNode<T> nodeToFind) {
+        GenericTreeNode<T> returnNode = null;
+        int i = 0;
+
+        if (currentNode.equals(nodeToFind)) {
+            returnNode = currentNode;
+        }
+
+        else if(currentNode.hasChildren()) {
+            i = 0;
+            while(returnNode == null && i < currentNode.getNumberOfChildren()) {
+                returnNode = auxiliaryFind(currentNode.getChildAt(i), nodeToFind);
+                i++;
+            }
+        }
+
+        return returnNode;
+    }
+
+    public boolean isEmpty() {
+        return (root == null);
+    }
+
+    public List<GenericTreeNode<T>> build(GenericTreeTraversalOrderEnum traversalOrder) {
+        List<GenericTreeNode<T>> returnList = null;
+
+        if(root != null) {
+            returnList = build(root, traversalOrder);
+        }
+
+        return returnList;
+    }
+
+    public List<GenericTreeNode<T>> build(GenericTreeNode<T> node, GenericTreeTraversalOrderEnum traversalOrder) {
+        List<GenericTreeNode<T>> traversalResult = new ArrayList<GenericTreeNode<T>>();
+
+        if(traversalOrder == GenericTreeTraversalOrderEnum.PRE_ORDER) {
+            buildPreOrder(node, traversalResult);
+        }
+
+        else if(traversalOrder == GenericTreeTraversalOrderEnum.POST_ORDER) {
+            buildPostOrder(node, traversalResult);
+        }
+
+        return traversalResult;
+    }
+
+    private synchronized void buildPreOrder(GenericTreeNode<T> node, List<GenericTreeNode<T>> traversalResult) {
+        traversalResult.add(node);
+        
+        for(int i = 0; i < node.getNumberOfChildren(); i++){
+        //for(GenericTreeNode<T> child : node.getChildren()) {
+            buildPreOrder(node.getChildAt(i), traversalResult);
+        }
+    }
+
+    private void buildPostOrder(GenericTreeNode<T> node, List<GenericTreeNode<T>> traversalResult) {
+        for(GenericTreeNode<T> child : node.getChildren()) {
+            buildPostOrder(child, traversalResult);
+        }
+
+        traversalResult.add(node);
+    }
+
+    public Map<GenericTreeNode<T>, Integer> buildWithDepth(GenericTreeTraversalOrderEnum traversalOrder) {
+        Map<GenericTreeNode<T>, Integer> returnMap = null;
+
+        if(root != null) {
+            returnMap = buildWithDepth(root, traversalOrder);
+        }
+
+        return returnMap;
+    }
+
+    public Map<GenericTreeNode<T>, Integer> buildWithDepth(GenericTreeNode<T> node, GenericTreeTraversalOrderEnum traversalOrder) {
+        Map<GenericTreeNode<T>, Integer> traversalResult = new LinkedHashMap<GenericTreeNode<T>, Integer>();
+
+        if(traversalOrder == GenericTreeTraversalOrderEnum.PRE_ORDER) {
+            buildPreOrderWithDepth(node, traversalResult, 0);
+        }
+
+        else if(traversalOrder == GenericTreeTraversalOrderEnum.POST_ORDER) {
+            buildPostOrderWithDepth(node, traversalResult, 0);
+        }
+
+        return traversalResult;
+    }
+
+    private void buildPreOrderWithDepth(GenericTreeNode<T> node, Map<GenericTreeNode<T>, Integer> traversalResult, int depth) {
+        traversalResult.put(node, depth);
+
+        for(GenericTreeNode<T> child : node.getChildren()) {
+            buildPreOrderWithDepth(child, traversalResult, depth + 1);
+        }
+    }
+
+    private void buildPostOrderWithDepth(GenericTreeNode<T> node, Map<GenericTreeNode<T>, Integer> traversalResult, int depth) {
+        for(GenericTreeNode<T> child : node.getChildren()) {
+            buildPostOrderWithDepth(child, traversalResult, depth + 1);
+        }
+
+        traversalResult.put(node, depth);
+    }
+
+    public String toString() {
+        /*
+        We're going to assume a pre-order traversal by default
+         */
+
+        String stringRepresentation = "";
+
+        if(root != null) {
+            stringRepresentation = build(GenericTreeTraversalOrderEnum.PRE_ORDER).toString();
+
+        }
+
+        return stringRepresentation;
+    }
+
+    public String toStringWithDepth() {
+        /*
+        We're going to assume a pre-order traversal by default
+         */
+
+        String stringRepresentation = "";
+
+        if(root != null) {
+            stringRepresentation = buildWithDepth(GenericTreeTraversalOrderEnum.PRE_ORDER).toString();
+        }
+
+        return stringRepresentation;
+    }
+}
diff --git a/src/main/java/com/laytonsmith/core/GenericTreeNode.java b/src/main/java/com/laytonsmith/core/GenericTreeNode.java
new file mode 100644
index 0000000..955b2d5
--- /dev/null
+++ b/src/main/java/com/laytonsmith/core/GenericTreeNode.java
@@ -0,0 +1,152 @@
+/*
+ Copyright 2010 Visin Suresh Paliath
+ Distributed under the BSD license
+*/
+
+package com.laytonsmith.core;
+
+import java.lang.reflect.InvocationTargetException;
+import java.lang.reflect.Method;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.List;
+import java.util.regex.Matcher;
+import java.util.regex.Pattern;
+
+public class GenericTreeNode<T> implements Cloneable{
+
+    public T data;
+    public List<GenericTreeNode<T>> children;
+    
+    @Override
+    public GenericTreeNode<T> clone() throws CloneNotSupportedException{
+        GenericTreeNode<T> clone = (GenericTreeNode<T>) super.clone();
+        Class c = data.getClass();
+        if(Arrays.asList(c.getInterfaces()).contains(Cloneable.class)){
+            try{
+                Method m = c.getMethod("clone", new Class[]{});
+                Object obj = m.invoke(data, new Object[]{});
+                clone.data = (T) obj;
+                clone.children = new ArrayList<GenericTreeNode<T>>(children);
+            } catch (IllegalAccessException ex) {
+                throw new CloneNotSupportedException();
+            } catch (IllegalArgumentException ex) {
+                throw new CloneNotSupportedException();
+            } catch (InvocationTargetException ex) {
+                throw new CloneNotSupportedException();
+            } catch(NoSuchMethodException e){
+                throw new CloneNotSupportedException();
+            }
+        }
+        return clone;
+    }
+
+    public GenericTreeNode() {
+        super();
+        children = new ArrayList<GenericTreeNode<T>>();
+    }
+
+    public GenericTreeNode(T data) {
+        this();
+        setData(data);
+    }
+
+    public synchronized List<GenericTreeNode<T>> getChildren() {
+        return this.children;
+    }
+
+    public int getNumberOfChildren() {
+        return getChildren().size();
+    }
+
+    public boolean hasChildren() {
+        return (getNumberOfChildren() > 0);
+    }
+
+    public void setChildren(List<GenericTreeNode<T>> children) {
+        this.children = children;
+    }
+
+    public void addChild(GenericTreeNode<T> child) {
+        children.add(child);
+    }
+
+    public void addChildAt(int index, GenericTreeNode<T> child) throws IndexOutOfBoundsException {
+        children.add(index, child);
+    }
+
+    public void removeChildren() {
+        this.children = new ArrayList<GenericTreeNode<T>>();
+    }
+
+    public void removeChildAt(int index) throws IndexOutOfBoundsException {
+        children.remove(index);
+    }
+
+    public GenericTreeNode<T> getChildAt(int index) throws IndexOutOfBoundsException {
+        return children.get(index);
+    }
+
+    public T getData() {
+        return this.data;
+    }
+
+    public void setData(T data) {
+        this.data = data;
+    }
+
+    public String toString() {
+        return getData().toString();
+    }
+
+	@Override
+	public boolean equals(Object obj) {
+		if (this == obj) {
+			return true;
+		}
+		if (obj == null) {
+			return false;
+		}
+		if (getClass() != obj.getClass()) {
+			return false;
+		}
+		GenericTreeNode<?> other = (GenericTreeNode<?>) obj;
+		if (data == null) {
+			if (other.data != null) {
+				return false;
+			}
+		} else if (!data.equals(other.data)) {
+			return false;
+		}
+		return true;
+	}
+
+	/* (non-Javadoc)
+	 * @see java.lang.Object#hashCode()
+	 */
+	@Override
+	public int hashCode() {
+		final int prime = 31;
+		int result = 1;
+		result = prime * result + ((data == null) ? 0 : data.hashCode());
+		return result;
+	}
+
+    public String toStringVerbose() {
+        String stringRepresentation = getData().toString() + ":[";
+
+        for (GenericTreeNode<T> node : getChildren()) {
+            stringRepresentation += node.getData().toString() + ", ";
+        }
+
+        //Pattern.DOTALL causes ^ and $ to match. Otherwise it won't. It's retarded.
+        Pattern pattern = Pattern.compile(", $", Pattern.DOTALL);
+        Matcher matcher = pattern.matcher(stringRepresentation);
+
+        stringRepresentation = matcher.replaceFirst("");
+        stringRepresentation += "]";
+
+        return stringRepresentation;
+    }
+}
+
diff --git a/src/main/java/com/laytonsmith/core/GenericTreeTraversalOrderEnum.java b/src/main/java/com/laytonsmith/core/GenericTreeTraversalOrderEnum.java
new file mode 100644
index 0000000..66175bc
--- /dev/null
+++ b/src/main/java/com/laytonsmith/core/GenericTreeTraversalOrderEnum.java
@@ -0,0 +1,11 @@
+/*
+ Copyright 2010 Vivin Suresh Paliath
+ Distributed under the BSD License
+*/
+
+package com.laytonsmith.core;
+
+public enum GenericTreeTraversalOrderEnum {
+    PRE_ORDER,
+    POST_ORDER
+}
diff --git a/src/main/java/com/laytonsmith/core/Globals.java b/src/main/java/com/laytonsmith/core/Globals.java
new file mode 100644
index 0000000..7c7682f
--- /dev/null
+++ b/src/main/java/com/laytonsmith/core/Globals.java
@@ -0,0 +1,54 @@
+/*
+ * To change this template, choose Tools | Templates
+ * and open the template in the editor.
+ */
+package com.laytonsmith.core;
+
+import com.laytonsmith.core.constructs.CNull;
+import com.laytonsmith.core.constructs.CString;
+import com.laytonsmith.core.constructs.Construct;
+import com.laytonsmith.core.constructs.IVariable;
+import java.util.HashMap;
+import java.util.Map;
+
+/**
+ *
+ * @author layton
+ */
+public class Globals {
+    
+    public static Map<String, IVariable> global_ivar = new HashMap<String, IVariable>();
+    public static Map<String, Construct> global_construct = new HashMap<String, Construct>();
+    
+    public static void SetGlobal(IVariable ivar){
+        Map<String, IVariable> vars = global_ivar;//(HashMap<String, IVariable>)env.get("global_ivar");
+        vars.put(ivar.getName(), ivar);
+    }
+    public static IVariable GetGlobalIVar(IVariable var){
+        Map<String, IVariable> vars = global_ivar;//(HashMap<String, IVariable>)env.get("global_ivar");
+        if(vars.containsKey(var.getName())){
+            return vars.get(var.getName());
+        } else {
+            IVariable v = new IVariable(var.getName(), new CString("", 0, null), 0, null);
+            vars.put(v.getName(), v);
+            return v;
+        }
+    }
+    public static void SetGlobal(String name, Construct value){
+        Map<String, Construct> vars = global_construct;//(HashMap<String, Construct>)env.get("global_construct");
+        vars.put(name, value);
+    }
+    public static Construct GetGlobalConstruct(String name){
+        Map<String, Construct> vars = global_construct;//(HashMap<String, Construct>)env.get("global_construct");
+        if(vars.containsKey(name)){
+            return vars.get(name);
+        } else {
+            return new CNull(0, null);
+        }
+    }
+    
+    public static void clear(){
+        global_ivar.clear();
+        global_construct.clear();
+    }
+}
diff --git a/src/main/java/com/laytonsmith/core/Installer.java b/src/main/java/com/laytonsmith/core/Installer.java
new file mode 100644
index 0000000..9e8f165
--- /dev/null
+++ b/src/main/java/com/laytonsmith/core/Installer.java
@@ -0,0 +1,52 @@
+/*
+ * To change this template, choose Tools | Templates
+ * and open the template in the editor.
+ */
+package com.laytonsmith.core;
+
+import com.laytonsmith.PureUtilities.fileutility.FileUtility;
+import java.io.File;
+import java.io.IOException;
+import java.util.logging.Level;
+import java.util.logging.Logger;
+
+/**
+ *
+ * @author Layton
+ */
+public class Installer {
+
+    public static void Install() {
+        //Check to see if the auto_include file exists. If not, include it now
+        new File("plugins/CommandHelper/includes").mkdirs();
+        File auto_include = new File("plugins/CommandHelper/auto_include.ms");
+        if(!auto_include.exists()){
+            String sample = parseISToString(Installer.class.getResourceAsStream("/samp_auto_include.txt"));
+            sample = sample.replaceAll("\n|\r\n", System.getProperty("line.separator"));
+            try {
+                FileUtility.write(sample, auto_include);
+            } catch (IOException ex) {
+                Logger.getLogger(Installer.class.getName()).log(Level.SEVERE, null, ex);
+            }
+        }
+    }
+
+    public static String parseISToString(java.io.InputStream is) {
+        java.io.DataInputStream din = new java.io.DataInputStream(is);
+        StringBuilder sb = new StringBuilder();
+        try {
+            String line = null;
+            while ((line = din.readLine()) != null) {
+                sb.append(line).append("\n");
+            }
+        } catch (Exception ex) {
+            ex.getMessage();
+        } finally {
+            try {
+                is.close();
+            } catch (Exception ex) {
+            }
+        }
+        return sb.toString();
+    }
+}
diff --git a/src/main/java/com/laytonsmith/core/InternalException.java b/src/main/java/com/laytonsmith/core/InternalException.java
new file mode 100644
index 0000000..19b67f8
--- /dev/null
+++ b/src/main/java/com/laytonsmith/core/InternalException.java
@@ -0,0 +1,28 @@
+/*
+ * To change this template, choose Tools | Templates
+ * and open the template in the editor.
+ */
+package com.laytonsmith.core;
+
+/**
+ * An internal exception is thrown when an unexpected error occurs
+ * in the actual plugin itself, not the user scripts. If this exception
+ * is thrown, the plugin is effectively disabled.
+ * @author Layton
+ */
+public class InternalException extends RuntimeException {
+
+    /**
+     * Creates a new instance of <code>InternalException</code> without detail message.
+     */
+    public InternalException() {
+    }
+
+    /**
+     * Constructs an instance of <code>InternalException</code> with the specified detail message.
+     * @param msg the detail message.
+     */
+    public InternalException(String msg) {
+        super(msg);
+    }
+}
diff --git a/src/main/java/com/laytonsmith/core/LICENSE b/src/main/java/com/laytonsmith/core/LICENSE
new file mode 100644
index 0000000..2b15665
--- /dev/null
+++ b/src/main/java/com/laytonsmith/core/LICENSE
@@ -0,0 +1,12 @@
+THIS LICENSE APPLIES ONLY TO THE GENERIC TREE CLASSES, NOT THE MAIN CLASS FILES
+
+Copyright (c) 2010, Vivin Suresh Paliath 
+All rights reserved.
+
+Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
+
+    * Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
+    * Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
+    * Neither the name of the <ORGANIZATION> nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
diff --git a/src/main/java/com/laytonsmith/core/MScriptCompiler.java b/src/main/java/com/laytonsmith/core/MScriptCompiler.java
new file mode 100644
index 0000000..8b5e713
--- /dev/null
+++ b/src/main/java/com/laytonsmith/core/MScriptCompiler.java
@@ -0,0 +1,534 @@
+/*
+ * To change this template, choose Tools | Templates
+ * and open the template in the editor.
+ */
+package com.laytonsmith.core;
+
+import com.laytonsmith.core.constructs.Token.TType;
+import com.laytonsmith.core.constructs.*;
+import com.laytonsmith.core.exceptions.ConfigCompileException;
+import com.laytonsmith.core.functions.FunctionList;
+import java.io.File;
+import java.util.*;
+import java.util.concurrent.atomic.AtomicInteger;
+
+/**
+ *
+ * @author Layton
+ */
+public class MScriptCompiler {
+
+    public static List<Token> lex(String config, File file) throws ConfigCompileException {
+        config = config.replaceAll("\r\n", "\n");
+        config = config + "\n";
+        List<Token> token_list = new ArrayList<Token>();
+        //Set our state variables
+        boolean state_in_quote = false;
+        boolean in_comment = false;
+            boolean comment_is_block = false;
+        boolean in_opt_var = false;
+        StringBuffer buf = new StringBuffer();
+        int line_num = 1;
+        //first we lex
+        for (int i = 0; i < config.length(); i++) {
+            Character c = config.charAt(i);
+            Character c2 = null;
+            if (i < config.length() - 1) {
+                c2 = config.charAt(i + 1);
+            }
+            if (c == '\n') {
+                line_num++;
+            }
+//            if ((token_list.isEmpty() || token_list.get(token_list.size() - 1).type.equals(TType.NEWLINE))
+//                    && c == '#') {
+            if((c == '#' || (c == '/' && (c2 == '*'))) && !in_comment && !state_in_quote){
+                in_comment = true;
+                if(c2 == '*'){
+                    comment_is_block = true;
+                    i++;
+                }
+                continue;
+            }
+            if (in_comment){                
+                if(!comment_is_block && c != '\n' || comment_is_block && c != '*' && (c2 != null && c2 != '/')){
+                    continue;
+                }
+            }
+            if(c == '*' && c2 == '/' && in_comment && comment_is_block){
+                in_comment = false;
+                comment_is_block = false;
+                i++;
+                continue;
+            }
+            if (c == '[' && !state_in_quote) {
+                if (buf.length() > 0) {
+                    token_list.add(new Token(TType.UNKNOWN, buf.toString(), line_num, file));
+                    buf = new StringBuffer();
+                }
+                token_list.add(new Token(TType.LSQUARE_BRACKET, "[", line_num, file));
+                in_opt_var = true;
+                continue;
+            }
+            if (c == '=' && !state_in_quote) {
+                if (buf.length() > 0) {
+                    token_list.add(new Token(TType.UNKNOWN, buf.toString(), line_num, file));
+                    buf = new StringBuffer();
+                }
+                if (in_opt_var) {
+                    token_list.add(new Token(TType.OPT_VAR_ASSIGN, "=", line_num, file));
+                } else {
+                    token_list.add(new Token(TType.ALIAS_END, "=", line_num, file));
+                }
+                continue;
+            }
+            if (c == ']' && !state_in_quote) {
+                if (buf.length() > 0) {
+                    token_list.add(new Token(TType.UNKNOWN, buf.toString(), line_num, file));
+                    buf = new StringBuffer();
+                }
+                token_list.add(new Token(TType.RSQUARE_BRACKET, "]", line_num, file));
+                in_opt_var = false;
+                continue;
+            }
+            if (c == ':' && !state_in_quote) {
+                if (buf.length() > 0) {
+                    token_list.add(new Token(TType.UNKNOWN, buf.toString(), line_num, file));
+                    buf = new StringBuffer();
+                }
+                token_list.add(new Token(TType.IDENT, ":", line_num, file));
+                continue;
+            }
+            if (c == ',' && !state_in_quote) {
+                if (buf.length() > 0) {
+                    token_list.add(new Token(TType.UNKNOWN, buf.toString(), line_num, file));
+                    buf = new StringBuffer();
+                }
+                token_list.add(new Token(TType.COMMA, ",", line_num, file));
+                continue;
+            }
+            if (c == '(' && !state_in_quote) {
+                if (buf.length() > 0) {
+                    token_list.add(new Token(TType.FUNC_NAME, buf.toString(), line_num, file));
+                    buf = new StringBuffer();
+                }
+                token_list.add(new Token(TType.FUNC_START, "(", line_num, file));
+                continue;
+            }
+            if (c == ')' && !state_in_quote) {
+                if (buf.length() > 0) {
+                    token_list.add(new Token(TType.UNKNOWN, buf.toString(), line_num, file));
+                    buf = new StringBuffer();
+                }
+                token_list.add(new Token(TType.FUNC_END, ")", line_num, file));
+                continue;
+            }
+            if (Character.isWhitespace(c) && !state_in_quote && c != '\n') {
+                //ignore the whitespace, but end the previous token
+                if (buf.length() > 0) {
+                    token_list.add(new Token(TType.UNKNOWN, buf.toString(), line_num, file));
+                    buf = new StringBuffer();
+                }
+            } else if (c == '\'') {
+                if (state_in_quote) {
+                    token_list.add(new Token(TType.STRING, buf.toString(), line_num, file));
+                    buf = new StringBuffer();
+                    state_in_quote = false;
+                    continue;
+                } else {
+                    state_in_quote = true;
+                    if (buf.length() > 0) {
+                        token_list.add(new Token(TType.UNKNOWN, buf.toString(), line_num, file));
+                        buf = new StringBuffer();
+                    }
+                    continue;
+                }
+            } else if (c == '\\') {
+                //escaped characters
+                if (state_in_quote) {
+                    if (c2 == '\\') {
+                        buf.append("\\");
+                    } else if (c2 == '\'') {
+                        buf.append("'");
+                    } else if(c2 == 'n'){
+                        buf.append("\n");
+                    } else if(c2 == 'u'){
+                        //Grab the next 4 characters, and check to see if they are numbers
+                        StringBuilder unicode = new StringBuilder();
+                        for(int m = 0; m < 4; m++){
+                            unicode.append(config.charAt(i + 2 + m));
+                        }
+                        try{
+                            Integer.parseInt(unicode.toString(), 16);
+                        } catch(NumberFormatException e){
+                            throw new ConfigCompileException("Unrecognized unicode escape sequence", line_num, file);
+                        }
+                        buf.append(Character.toChars(Integer.parseInt(unicode.toString(), 16)));                        
+                        i += 4;
+                    } else {
+                        //Since we might expand this list later, don't let them
+                        //use unescaped backslashes
+                        throw new ConfigCompileException("The escape sequence \\" + c2 + " is not a recognized escape sequence", line_num, file);
+                    }
+
+                    i++;
+                    continue;
+                } else {
+                    //Control character backslash
+                    token_list.add(new Token(TType.SEPERATOR, "\\", line_num, file));
+                }
+            } else if (state_in_quote) {
+                buf.append(c);
+                continue;
+            } else if (c == '\n' && !comment_is_block) {
+                if (buf.length() > 0) {
+                    token_list.add(new Token(TType.UNKNOWN, buf.toString(), line_num, file));
+                    buf = new StringBuffer();
+                }
+                token_list.add(new Token(TType.NEWLINE, "\n", line_num, file));
+                in_comment = false;
+                comment_is_block = false;
+                continue;
+            } else { //in a literal
+                buf.append(c);
+                continue;
+            }
+        } //end lexing
+        if(state_in_quote){
+            throw new ConfigCompileException("Unended string literal", line_num, file);
+        }
+        if(in_comment || comment_is_block){
+            throw new ConfigCompileException("Unended comment", line_num, file);
+        }
+                //look at the tokens, and get meaning from them
+        for (Token t : token_list) {
+            if (t.type.equals(TType.UNKNOWN)) {
+                if (t.val().matches("/.*")) {
+                    t.type = TType.COMMAND;
+                } else if (t.val().matches("\\\\")) {
+                    t.type = TType.SEPERATOR;
+                } else if (t.val().matches("\\$[a-zA-Z0-9_]+")) {
+                    t.type = TType.VARIABLE;
+                } else if (t.val().matches("\\@[a-zA-Z0-9_]+")) {
+                    t.type = TType.IVARIABLE;
+                } else if (t.val().equals("$")) {
+                    t.type = TType.FINAL_VAR;
+                } else {
+                    t.type = TType.LIT;
+                }
+            }
+        }
+        return token_list;
+    }
+
+    /**
+     * This function breaks the token stream into parts, seperating the aliases/MScript from the command triggers
+     * @param tokenStream
+     * @return
+     * @throws ConfigCompileException 
+     */
+    public static List<Script> preprocess(List<Token> tokenStream, Env env) throws ConfigCompileException {
+        //First, pull out the duplicate newlines
+        ArrayList<Token> temp = new ArrayList<Token>();
+        for (int i = 0; i < tokenStream.size(); i++) {
+            try {
+                if (tokenStream.get(i).type.equals(TType.NEWLINE)) {
+                    temp.add(new Token(TType.NEWLINE, "\n", tokenStream.get(i).line_num, tokenStream.get(i).file));
+                    while (tokenStream.get(++i).type.equals(TType.NEWLINE)) {
+                    }
+                }
+                temp.add(tokenStream.get(i));
+            } catch (IndexOutOfBoundsException e) {
+            }
+        }
+
+        if (temp.size() > 0 && temp.get(0).type.equals(TType.NEWLINE)) {
+            temp.remove(0);
+        }
+
+        tokenStream = temp;
+        temp = new ArrayList<Token>();
+
+        //Handle multiline constructs
+        ArrayList<Token> tokens1_1 = new ArrayList<Token>();
+        boolean inside_multiline = false;
+        for (int i = 0; i < tokenStream.size(); i++) {
+            Token prevToken = i - 1 >= tokenStream.size() ? tokenStream.get(i - 1) : new Token(TType.UNKNOWN, "", 0, null);
+            Token thisToken = tokenStream.get(i);
+            Token nextToken = i + 1 < tokenStream.size() ? tokenStream.get(i + 1) : new Token(TType.UNKNOWN, "", 0, null);
+            //take out newlines between the = >>> and <<< tokens (also the tokens)
+            if (thisToken.type.equals(TType.ALIAS_END) && nextToken.val().equals(">>>")) {
+                inside_multiline = true;
+                tokens1_1.add(thisToken);
+                i++;
+                continue;
+            }
+            if (thisToken.val().equals("<<<")) {
+                if (!inside_multiline) {
+                    throw new ConfigCompileException("Found multiline end symbol, and no multiline start found",
+                            thisToken.line_num, thisToken.file);
+                }
+                inside_multiline = false;
+                continue;
+            }
+            if (thisToken.val().equals(">>>") && !prevToken.type.equals(TType.ALIAS_END)) {
+                throw new ConfigCompileException("Multiline symbol must follow the alias_end token", thisToken.line_num, thisToken.file);
+            }
+
+            //If we're not in a multiline construct, or we are in it and it's not a newline, add
+            //it
+            if (!inside_multiline || (inside_multiline && !thisToken.type.equals(TType.NEWLINE))) {
+                tokens1_1.add(thisToken);
+            }
+        }
+
+        //take out newlines that are behind a \
+        ArrayList<Token> tokens2 = new ArrayList<Token>();
+        for (int i = 0; i < tokens1_1.size(); i++) {
+            if (!tokens1_1.get(i).type.equals(TType.STRING) && tokens1_1.get(i).val().equals("\\") && tokens1_1.size() > i
+                    && tokens1_1.get(i + 1).type.equals(TType.NEWLINE)) {
+                tokens2.add(tokens1_1.get(i));
+                i++;
+                continue;
+            }
+            tokens2.add(tokens1_1.get(i));
+        }
+
+
+
+
+
+        //Now that we have all lines minified, we should be able to split
+        //on newlines, and easily find the left and right sides
+
+        List<Token> left = new ArrayList<Token>();
+        List<Token> right = new ArrayList<Token>();
+        List<Script> scripts = new ArrayList<Script>();
+        boolean inLeft = true;
+        for (Token t : tokens2) {
+            if (inLeft) {
+                if (t.type == TType.ALIAS_END) {
+                    inLeft = false;
+                } else {
+                    left.add(t);
+                }
+            } else {
+                if (t.type == TType.NEWLINE) {
+                    inLeft = true;
+                    //Env newEnv = new Env();//env;
+//                    try{
+//                        newEnv = env.clone();
+//                    } catch(Exception e){}
+                    Script s = new Script(left, right);
+                    scripts.add(s);
+                    left = new ArrayList();
+                    right = new ArrayList();
+                } else {
+                    right.add(t);
+                }
+            }
+        }
+        return scripts;
+    }
+
+    public static GenericTreeNode<Construct> compile(List<Token> stream) throws ConfigCompileException {
+        GenericTreeNode<Construct> tree = new GenericTreeNode<Construct>();
+        tree.setData(new CNull(0, null));
+        Stack<GenericTreeNode> parents = new Stack<GenericTreeNode>();
+        Stack<AtomicInteger> constructCount = new Stack<AtomicInteger>();
+        constructCount.push(new AtomicInteger(0));
+        Stack<AtomicInteger> arrayStack = new Stack<AtomicInteger>();
+        arrayStack.add(new AtomicInteger(-1));
+        parents.push(tree);
+        int parens = 0;
+        Token t = null;
+        for (int i = 0; i < stream.size(); i++) {
+            t = stream.get(i);
+            Token prev = i - 1 >= 0 ? stream.get(i - 1) : new Token(TType.UNKNOWN, "", t.line_num, t.file);
+            Token next = i + 1 < stream.size() ? stream.get(i + 1) : new Token(TType.UNKNOWN, "", t.line_num, t.file); 
+                
+            //Associative array handling
+            if(next.type.equals(TType.IDENT)){
+                tree.addChild(new GenericTreeNode<Construct>(new CLabel(Static.resolveConstruct(t.val(), t.line_num, t.file))));
+                constructCount.peek().incrementAndGet();
+                i++;
+                continue;
+            }           
+            //Array notation handling
+            if(t.type.equals(TType.LSQUARE_BRACKET)){                
+                arrayStack.push(new AtomicInteger(tree.getChildren().size() - 1));
+                continue;
+            } else if(t.type.equals(TType.RSQUARE_BRACKET)){
+                boolean emptyArray = false;
+                if(prev.type.equals(TType.LSQUARE_BRACKET)){
+                    //throw new ConfigCompileException("Empty array_get operator ([])", t.line_num); 
+                    emptyArray = true;
+                }
+                if(arrayStack.size() == 1){
+                    throw new ConfigCompileException("Mismatched square bracket", t.line_num, t.file);
+                }
+                int array = arrayStack.pop().get();
+                int index = array + 1;
+                GenericTreeNode<Construct> myArray = tree.getChildAt(array);
+                GenericTreeNode<Construct> myIndex;
+                if(!emptyArray){
+                    myIndex = tree.getChildAt(index);
+                } else {
+                    myIndex = new GenericTreeNode<Construct>(new CString("0..-1", t.line_num, t.file));
+                }
+                tree.setChildren(tree.getChildren().subList(0, array));
+                GenericTreeNode<Construct> arrayGet = new GenericTreeNode<Construct>(new CFunction("array_get", t.line_num, t.file));
+                arrayGet.addChild(myArray);
+                arrayGet.addChild(myIndex);
+                tree.addChild(arrayGet);
+                constructCount.peek().decrementAndGet();
+            }
+            /*if (t.type.equals(TType.OPT_VAR_ASSIGN) || t.type.equals(TType.LSQUARE_BRACKET)
+                    || t.type.equals(TType.RSQUARE_BRACKET)) {
+                throw new ConfigCompileException("Unexpected " + t.type.toString(), t.line_num);
+            } else */if (t.type == TType.LIT) {
+                tree.addChild(new GenericTreeNode<Construct>(Static.resolveConstruct(t.val(), t.line_num, t.file)));
+                constructCount.peek().incrementAndGet();
+            } else if (t.type.equals(TType.STRING) || t.type.equals(TType.COMMAND)) {
+                tree.addChild(new GenericTreeNode<Construct>(new CString(t.val(), t.line_num, t.file)));
+                constructCount.peek().incrementAndGet();
+            } else if (t.type.equals(TType.IVARIABLE)) {
+                tree.addChild(new GenericTreeNode<Construct>(new IVariable(t.val(), t.line_num, t.file)));
+                constructCount.peek().incrementAndGet();
+            } else if(t.type.equals(TType.UNKNOWN)){
+                tree.addChild(new GenericTreeNode<Construct>(Static.resolveConstruct(t.val(), t.line_num, t.file)));
+                constructCount.peek().incrementAndGet();
+            } else if (t.type.equals(TType.VARIABLE) || t.type.equals(TType.FINAL_VAR)) {
+                tree.addChild(new GenericTreeNode<Construct>(new Variable(t.val(), null, false, t.type.equals(TType.FINAL_VAR), t.line_num, t.file)));
+                constructCount.peek().incrementAndGet();
+                //right_vars.add(new Variable(t.val(), null, t.line_num));
+            } else if (t.type.equals(TType.FUNC_NAME)) {
+                CFunction func = new CFunction(t.val(), t.line_num, t.file);
+                //This will throw an exception for us if the function doesn't exist
+                if(!func.val().matches("^_[^_].*")){
+                    FunctionList.getFunction(func);
+                }
+                GenericTreeNode<Construct> f = new GenericTreeNode<Construct>(func);
+                tree.addChild(f);
+                constructCount.push(new AtomicInteger(0));
+                tree = f;
+                parents.push(f);
+            } else if (t.type.equals(TType.FUNC_START)) {
+                if (!prev.type.equals(TType.FUNC_NAME)) {
+                    throw new ConfigCompileException("Unexpected parenthesis", t.line_num, t.file);
+                }
+                parens++;
+            } else if (t.type.equals(TType.FUNC_END)) {
+                if (parens < 0) {
+                    throw new ConfigCompileException("Unexpected parenthesis", t.line_num, t.file);
+                }
+                parens--;
+                parents.pop();
+                if(constructCount.peek().get() > 1){
+                    //We need to autoconcat some stuff
+                    int stacks = constructCount.peek().get();
+                    int replaceAt = tree.getChildren().size() - stacks;
+                    GenericTreeNode<Construct> c = new GenericTreeNode<Construct>(new CFunction("sconcat", 0, null));
+                    List<GenericTreeNode<Construct>> subChildren = new ArrayList<GenericTreeNode<Construct>>();
+                    for(int b = replaceAt; b < tree.getNumberOfChildren(); b++){
+                        subChildren.add(tree.getChildAt(b));
+                    }
+                    c.setChildren(subChildren);                    
+                    if(replaceAt > 0){
+                        List<GenericTreeNode<Construct>> firstChildren = new ArrayList<GenericTreeNode<Construct>>();
+                        for(int d = 0; d < replaceAt; d++){
+                            firstChildren.add(tree.getChildAt(d));
+                        }
+                        tree.setChildren(firstChildren);
+                    } else {
+                        tree.removeChildren();
+                    }
+                    tree.addChild(c);
+                }
+                //Check argument number now
+                if(tree.getData().val() != null){
+                    if(!tree.getData().val().matches("^_[^_].*")){
+                        Integer [] numArgs = FunctionList.getFunction(tree.getData()).numArgs();
+                        if(!Arrays.asList(numArgs).contains(Integer.MAX_VALUE) && !Arrays.asList(numArgs).contains(tree.getChildren().size())){
+                            throw new ConfigCompileException("Incorrect number of arguments passed to " + tree.getData().val(), tree.getData().getLineNum(),
+                                    tree.getData().getFile());
+                        }
+                    }
+                }
+                constructCount.pop();
+                try{
+                    constructCount.peek().incrementAndGet();
+                } catch(EmptyStackException e){                    
+                    throw new ConfigCompileException("Unexpected end parenthesis", t.line_num, t.file);
+                }
+                try{
+                    tree = parents.peek();
+                } catch(EmptyStackException e){
+                    throw new ConfigCompileException("Unexpected end parenthesis", t.line_num, t.file);
+                }
+            } else if (t.type.equals(TType.COMMA)) {
+                if(constructCount.peek().get() > 1){
+                    int stacks = constructCount.peek().get();
+                    int replaceAt = tree.getChildren().size() - stacks;
+                    GenericTreeNode<Construct> c = new GenericTreeNode<Construct>(new CFunction("sconcat", 0, null));
+                    List<GenericTreeNode<Construct>> subChildren = new ArrayList<GenericTreeNode<Construct>>();
+                    for(int b = replaceAt; b < tree.getNumberOfChildren(); b++){
+                        subChildren.add(tree.getChildAt(b));
+                    }
+                    c.setChildren(subChildren);                    
+                    if(replaceAt > 0){
+                        List<GenericTreeNode<Construct>> firstChildren = new ArrayList<GenericTreeNode<Construct>>();
+                        for(int d = 0; d < replaceAt; d++){
+                            firstChildren.add(tree.getChildAt(d));
+                        }
+                        tree.setChildren(firstChildren);
+                    } else {
+                        tree.removeChildren();
+                    }
+                    tree.addChild(c);                   
+                }
+                constructCount.peek().set(0);
+                continue;
+            } 
+        }
+        if(arrayStack.size() != 1){
+            throw new ConfigCompileException("Mismatched square brackets", t.line_num, t.file);
+        }
+        if (parens != 0) {
+            throw new ConfigCompileException("Mismatched parenthesis", t.line_num, t.file);
+        }
+        return tree;
+    }      
+    
+    /**
+     * Executes a pre-compiled mscript, given the specified Script environment. Both done and script 
+     * may be null, and if so, reasonable defaults will be provided. The value sent to done will also
+     * be returned, as a Construct, so this one function may be used synchronously also.
+     * @param root
+     * @param done
+     * @param script 
+     */
+    public static Construct execute(GenericTreeNode<Construct> root, Env env, MScriptComplete done, Script script){
+        if(script == null){
+            script = new Script(null, null);
+        }
+        StringBuilder b = new StringBuilder();
+        Construct returnable = null;
+        for (GenericTreeNode<Construct> gg : root.getChildren()) {
+            Construct retc = script.eval(gg, env);
+            if(root.getNumberOfChildren() == 1){
+                returnable = retc;
+            }
+            String ret = retc instanceof CNull?"null":retc.val();
+            if (ret != null && !ret.trim().equals("")) {
+                b.append(ret).append(" ");
+            }
+        }
+        if(done != null){
+            done.done(b.toString().trim());
+        }
+        if(returnable != null){
+            return returnable;
+        }
+        return Static.resolveConstruct(b.toString().trim(), 0, null);
+    }
+}
diff --git a/src/main/java/com/laytonsmith/core/MScriptComplete.java b/src/main/java/com/laytonsmith/core/MScriptComplete.java
new file mode 100644
index 0000000..092cb17
--- /dev/null
+++ b/src/main/java/com/laytonsmith/core/MScriptComplete.java
@@ -0,0 +1,19 @@
+/*
+ * To change this template, choose Tools | Templates
+ * and open the template in the editor.
+ */
+package com.laytonsmith.core;
+
+/**
+ *
+ * @author Layton
+ */
+public interface MScriptComplete {
+    /**
+     * This function is called when the mscript has finished. Any output generated
+     * by the script is sent here. If the script generated an error, null is sent.
+     * If the script ran successfully, but did not return any output, an empty string
+     * is sent.
+     */
+    public void done(String output);
+}
diff --git a/src/main/java/com/laytonsmith/core/Main.java b/src/main/java/com/laytonsmith/core/Main.java
new file mode 100644
index 0000000..d1c33fc
--- /dev/null
+++ b/src/main/java/com/laytonsmith/core/Main.java
@@ -0,0 +1,172 @@
+/*
+ * To change this template, choose Tools | Templates
+ * and open the template in the editor.
+ */
+package com.laytonsmith.core;
+
+import com.laytonsmith.PureUtilities.SerializedPersistance;
+import com.laytonsmith.tools.DocGen;
+import com.laytonsmith.tools.Interpreter;
+import com.laytonsmith.tools.Manager;
+import com.laytonsmith.tools.SyntaxHighlighters;
+import java.io.File;
+import java.io.FileNotFoundException;
+import java.io.IOException;
+import java.io.InputStream;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.List;
+import java.util.jar.JarEntry;
+import java.util.jar.JarFile;
+import org.bukkit.plugin.InvalidPluginException;
+import org.bukkit.plugin.PluginDescriptionFile;
+
+/**
+ *
+ * @author Layton
+ */
+public class Main {
+
+    static List<String> doctypes = new ArrayList<String>(Arrays.asList(new String[]{"html", "wiki", "text"}));
+
+    public static void main(String[] args) throws Exception {
+        System.err.println("Running with arguments: " + Arrays.asList(args));
+        try {
+            Static.getPreferences().init(new File("CommandHelper/preferences.txt"));
+            List l = Arrays.asList(args);
+            if (args.length == 0) {
+                l.add("-help");
+            }
+            if(l.contains("--manager")){
+                Manager.start();
+                System.exit(0);
+            }
+            if(l.contains("--interpreter")){
+                Interpreter.start();
+                System.exit(0);
+            }
+            if (l.contains("-help") || l.contains("-h") || l.contains("--help") || l.contains("/?")) {
+                System.out.println("CommandHelper can be run as a standalone jar with the command:\n\n"
+                        + "     java -jar CommandHelper.jar <options>\n\n"
+                        + "where options can be one of the following:\n\n"
+                        + "--version - Prints the version and exits\n"
+                        + "--help - Displays this message and exits\n"
+                        + "--docs [type] - Creates documentation for the functions that CommandHelper knows about.\n"
+                        + "     'type' can be one of the following: " + doctypes.toString() + ". Defaults to 'html'.\n"
+                        + "--test-compile [file] - Attempts to compile the config file, but does not actually start up. Any\n"
+                        + "     compile errors or warnings can be shown this way, without actually running the program.\n"
+                        + "     The location of the config file to test can be given, so that you don't actually have to\n"
+                        + "     edit your live config file. If you don't provide a file, the default config file is used.\n"
+                        + "     Regardless, the program will look in ./CommandHelper/ for the file.\n"
+                        + "--copyright - Displays the copyright notice and exits\n"
+                        + "--print-db - Prints out the built in database in a human readable form, then exits.\n"
+                        + "--manager - Launcher the built in data manager\n"
+                        + "--interpreter - Lauches the minimal cmdline interpreter\n"
+                        + "--syntax [type] - Generates the syntax highlighter for the specified editor (if available).\n"
+                        + "     Don't specify a type to see the available options.\n"
+                        );
+            }
+            if (l.contains("--version")) {
+                PluginDescriptionFile me = loadSelf();
+                System.out.println("You are running CommandHelper version " + me.getVersion());
+                return;
+            }
+            if (l.contains("--copyright")) {
+                System.out.println("CommandHelper/CommandHelper\n"
+                        + "Copyright (C) 2010-2011 sk89q <http://www.sk89q.com> and \n"
+                        + "wraithguard01 <http://www.laytonsmith.com>\n"
+                        + "\n"
+                        + "This program is free software: you can redistribute it and/or modify\n"
+                        + "it under the terms of the GNU General Public License as published by\n"
+                        + "the Free Software Foundation, either version 3 of the License, or\n"
+                        + "(at your option) any later version.\n"
+                        + "\n"
+                        + "This program is distributed in the hope that it will be useful,\n"
+                        + "but WITHOUT ANY WARRANTY; without even the implied warranty of\n"
+                        + "MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n"
+                        + "GNU General Public License for more details.\n"
+                        + "\n"
+                        + "You should have received a copy of the GNU General Public License\n"
+                        + "along with this program. If not, see <http://www.gnu.org/licenses/>.\n");
+                return;
+            }
+            if (l.contains("--print-db")) {
+                new SerializedPersistance(new File("CommandHelper/persistance.ser"), null).printValues(System.out);
+                return;
+            }
+            for (int i = 0; i < l.size(); i++) {
+                String s = l.get(i).toString();
+                if (s.matches("--docs")) {
+                    //Documentation generator
+                    String type = (i + 1 <= l.size() - 1 ? l.get(i + 1).toString().toLowerCase() : null);
+                    if (type == null) {
+                        type = "html";
+                    }
+                    if (!doctypes.contains(type)) {
+                        System.out.println("The type of documentation must be one of the following: " + doctypes.toString());
+                        return;
+                    }
+                    System.out.println("Creating " + type + " documentation.");
+                    DocGen.functions(type);
+                } else if (s.matches("--test-compile")) {
+                    System.out.println("This functionality is not currently implemented!");
+//                    File f = new File(".");
+//                    for (File a : f.listFiles()) {
+//                        if (a.getName().equals("CommandHelper.jar")) {
+//                            //We are in the plugins folder
+//                            f = new File("CommandHelper/bukkit.jar");
+//                            if (!f.exists()) {
+//                                System.out.println("In order to run the --test-compile command, you must include the latest build of bukkit (not craftbukkit)"
+//                                        + " in the CommandHelper folder. You MUST rename it to bukkit.jar. See the wiki for more information.");
+//                                System.exit(1);
+//                            }
+//                            break;
+//                        }
+//                    }
+//                    String file = (i + 1 <= l.size() - 1 ? l.get(i + 1).toString().toLowerCase() : null);
+//                    
+//                    return;
+                } else if(s.matches("--syntax")){
+                    String type = (i + 1 <= l.size() - 1 ? l.get(i + 1).toString().toLowerCase() : null);
+                    String theme = (i + 2 <= l.size() - 1 ? l.get(i + 2).toString().toLowerCase() : null);
+                    System.out.println(SyntaxHighlighters.generate(type, theme));
+                }
+            }
+        } catch (NoClassDefFoundError error) {
+            System.err.println("The main class requires craftbukkit or bukkit to be included in order to run. If you are seeing"
+                    + " this message, you have two options. First, it seems you have renamed your craftbukkit jar, or"
+                    + " you are altogether not using craftbukkit. If this is the case, you can download craftbukkit and place"
+                    + " it in the correct directory (one above this one) or you can download bukkit, rename it to bukkit.jar,"
+                    + " and put it in the CommandHelper directory. If you're dying for more details, here:");
+            error.printStackTrace();
+        }
+    }
+    
+    private static PluginDescriptionFile loadSelf() throws Exception{
+        PluginDescriptionFile description = null;
+        System.out.println(new File(".").getAbsolutePath());
+        File file = new File("./target/commandhelper-3.1.2-ShadedBundle.jar");
+        if (!file.exists()) {
+            throw new InvalidPluginException(new FileNotFoundException(String.format("%s does not exist", file.getPath())));
+        }
+        try {
+            JarFile jar = new JarFile(file);
+            JarEntry entry = jar.getJarEntry("plugin.yml");
+
+            if (entry == null) {
+                throw new InvalidPluginException(new FileNotFoundException("Jar does not contain plugin.yml"));
+            }
+
+            InputStream stream = jar.getInputStream(entry);
+            description = new PluginDescriptionFile(stream);
+
+            stream.close();
+            jar.close();
+        } catch (IOException ex) {
+            throw new InvalidPluginException(ex);
+        } catch (Exception ex) {
+            throw new InvalidPluginException(ex);
+        }
+        return description;
+    }
+}
diff --git a/src/main/java/com/laytonsmith/core/MainSandbox.java b/src/main/java/com/laytonsmith/core/MainSandbox.java
new file mode 100644
index 0000000..667ddb8
--- /dev/null
+++ b/src/main/java/com/laytonsmith/core/MainSandbox.java
@@ -0,0 +1,61 @@
+/*
+ * To change this template, choose Tools | Templates
+ * and open the template in the editor.
+ */
+package com.laytonsmith.core;
+
+/**
+ * This class is for testing concepts
+ * @author Layton
+ */
+public class MainSandbox {
+    public static void main(String[] args) throws Exception{
+
+    }
+    
+    
+
+    
+    public static class hashClass{
+        int x;
+        int y;
+        int z;
+        String world;
+
+        private static long top = (long)(Math.pow(2, 63) - Math.pow(2, 56));
+        private static long middle = (long)(Math.pow(2, 55) - Math.pow(2, 28));
+        private static long bottom = (long)Math.pow(2, 27) - 1;
+        public static long GetHashCode(int x, int y, int z) {
+            System.out.println(top);
+            System.out.println(middle);
+            System.out.println(bottom);
+            long hash = 0;
+            hash |= ((long)y << 55) & top;
+            hash |= ((long)x << 27) & middle;
+            hash |= (long)z & bottom;            
+            return hash;
+        }
+                
+    }
+    
+    public static void printPackets(){
+//        Class [] classes = ClassDiscovery.DiscoverClasses(net.minecraft.server.Packet.class, null, null);
+//        for(Class c : classes){
+//            //The superclass can be null if it's an interface
+//            if(c != null && c.getSuperclass() != null && c.getSuperclass().equals(net.minecraft.server.Packet.class)){
+//                try {
+//                    System.out.println("Packet subclass: " + c.getSimpleName());
+//                    Constructor [] constructors = c.getConstructors();
+//                    for(Constructor constructor : constructors){
+//                        if(constructor.getParameterTypes().length != 0){
+//                            //Candidate for use
+//                            System.out.println("\tConstructor: " + Arrays.toString(constructor.getParameterTypes()));
+//                        } //Else it's a no-arg constructor, which happens from time to time
+//                    }
+//                } catch (Exception ex) {
+//                    Logger.getLogger(MainSandbox.class.getName()).log(Level.SEVERE, null, ex);
+//                }
+//            }
+//        }
+    }
+}
diff --git a/src/main/java/com/laytonsmith/core/NotInitializedYetException.java b/src/main/java/com/laytonsmith/core/NotInitializedYetException.java
new file mode 100644
index 0000000..6749fdc
--- /dev/null
+++ b/src/main/java/com/laytonsmith/core/NotInitializedYetException.java
@@ -0,0 +1,15 @@
+/*
+ * To change this template, choose Tools | Templates
+ * and open the template in the editor.
+ */
+package com.laytonsmith.core;
+
+/**
+ *
+ * @author Layton
+ */
+public class NotInitializedYetException extends RuntimeException{
+    public NotInitializedYetException(String msg){
+        super(msg);
+    }
+}
diff --git a/src/main/java/com/laytonsmith/core/ObjectGenerator.java b/src/main/java/com/laytonsmith/core/ObjectGenerator.java
new file mode 100644
index 0000000..5b5886e
--- /dev/null
+++ b/src/main/java/com/laytonsmith/core/ObjectGenerator.java
@@ -0,0 +1,276 @@
+/*
+ * To change this template, choose Tools | Templates
+ * and open the template in the editor.
+ */
+package com.laytonsmith.core;
+
+import com.laytonsmith.abstraction.*;
+import com.laytonsmith.core.constructs.*;
+import com.laytonsmith.core.exceptions.ConfigRuntimeException;
+import com.laytonsmith.core.functions.Exceptions.ExceptionType;
+import java.io.File;
+import java.util.HashMap;
+import java.util.Map;
+
+/**
+ * This file is responsible for converting CH objects into server objects,
+ * and vice versa
+ * @author layton
+ */
+public class ObjectGenerator {
+    
+    private static ObjectGenerator pog = null;
+    public static ObjectGenerator GetGenerator(){
+        if(pog == null){
+            pog = new ObjectGenerator();
+        }
+        return pog;
+    }
+    
+    /**
+     * Gets a Location Object, given a MCLocation
+     * @param l
+     * @return 
+     */
+    public CArray location(MCLocation l){
+        CArray ca = new CArray(0, null);
+        Construct x = new CDouble(l.getX(), 0, null);
+        Construct y = new CDouble(l.getY(), 0, null);
+        Construct z = new CDouble(l.getZ(), 0, null);
+        Construct world = new CString(l.getWorld().getName(), 0, null);
+        Construct yaw = new CDouble(l.getYaw(), 0, null);
+        Construct pitch = new CDouble(l.getPitch(), 0, null);
+        ca.forceAssociativeMode();
+        ca.set("0", x);
+        ca.set("1", y);
+        ca.set("2", z);
+        ca.set("3", world);
+        ca.set("4", yaw);
+        ca.set("5", pitch);
+        ca.set("x", x);
+        ca.set("y", y);
+        ca.set("z", z);
+        ca.set("world", world);
+        ca.set("yaw", yaw);
+        ca.set("pitch", pitch);
+        return ca;
+    }
+    
+    /**
+     * Given a Location Object, returns a MCLocation. If the optional world is
+     * not specified in the object, the world provided is used instead.
+     * Location "objects" are mscript arrays that represent a location in game. There are 
+     * 4 usages:
+     * <ul>
+     * <li>(x, y, z)</li>
+     * <li>(x, y, z, world)</li>
+     * <li>(x, y, z, yaw, pitch)</li>
+     * <li>(x, y, z, world, yaw, pitch)</li>
+     * </ul>
+     * In all cases, the pitch and yaw default to 0, and the world defaults to the specified world.
+     * <em>More conveniently: ([world], x, y, z, [yaw, pitch])</em> 
+     */    
+    public MCLocation location(Construct c, MCWorld w, int line_num, File f) {
+        if (!(c instanceof CArray)) {
+            throw new ConfigRuntimeException("Expecting an array, received " + c.getCType(), ExceptionType.FormatException, line_num, f);
+        }
+        CArray array = (CArray) c;
+        MCWorld world = w;
+        double x = 0;
+        double y = 0;
+        double z = 0;
+        float yaw = 0;
+        float pitch = 0;
+        if (array.size() == 3) {
+            //Just the xyz, with default yaw and pitch, and given world
+            x = Static.getNumber(array.get(0, line_num, f));
+            y = Static.getNumber(array.get(1, line_num, f));
+            z = Static.getNumber(array.get(2, line_num, f));
+        } else if (array.size() == 4) {
+            //x, y, z, world
+            x = Static.getNumber(array.get(0, line_num, f));
+            y = Static.getNumber(array.get(1, line_num, f));
+            z = Static.getNumber(array.get(2, line_num, f));
+            world = Static.getServer().getWorld(array.get(3, line_num, f).val());
+        } else if (array.size() == 5) {
+            //x, y, z, yaw, pitch, with given world
+            x = Static.getNumber(array.get(0, line_num, f));
+            y = Static.getNumber(array.get(1, line_num, f));
+            z = Static.getNumber(array.get(2, line_num, f));
+            yaw = (float) Static.getNumber(array.get(3, line_num, f));
+            pitch = (float) Static.getNumber(array.get(4, line_num, f));
+        } else if (array.size() == 6) {
+            //All have been given
+            x = Static.getNumber(array.get(0, line_num, f));
+            y = Static.getNumber(array.get(1, line_num, f));
+            z = Static.getNumber(array.get(2, line_num, f));
+            world = Static.getServer().getWorld(array.get(3, line_num, f).val());
+            yaw = (float) Static.getNumber(array.get(4, line_num, f));
+            pitch = (float) Static.getNumber(array.get(5, line_num, f));
+        } else {
+            throw new ConfigRuntimeException("Expecting a Location array, but the array did not meet the format specifications", ExceptionType.FormatException, line_num, f);
+        }
+        if(array.containsKey("x")){
+            x = Static.getNumber(array.get("x"));
+        }
+        if(array.containsKey("y")){
+            y = Static.getNumber(array.get("y"));
+        }
+        if(array.containsKey("z")){
+            z = Static.getNumber(array.get("z"));
+        }
+        if(array.containsKey("world")){
+            world = Static.getServer().getWorld(array.get("world").val());
+        }
+        if(array.containsKey("yaw")){
+            yaw = (float)Static.getDouble(array.get("yaw"));
+        }
+        if(array.containsKey("pitch")){
+            pitch = (float)Static.getDouble(array.get("pitch"));
+        }
+        return StaticLayer.GetLocation(world, x, y, z, yaw, pitch);
+    }
+    
+    /**
+     * An Item Object consists of data about a particular item stack.
+     * Information included is: type, data, qty, and an array of
+     * enchantment objects (labeled enchants): etype (enchantment type) and 
+     * elevel (enchantment level). For backwards compatibility, this information
+     * is also listed in numerical slots as well as associative slots. If the MCItemStack
+     * is null, or the underlying item is nonexistant (or air) CNull is returned.     
+     * @param is
+     * @return 
+     */
+    public Construct item(MCItemStack is, int line_num, File f){
+        if(is == null || is.getAmount() == 0){
+            return new CNull(line_num, f);
+        }
+        int type = is.getTypeId();        
+        int data = (is.getData()!=null?is.getData().getData():0);
+        int qty = is.getAmount();
+        CArray enchants = new CArray(line_num, f);
+        for(Map.Entry<MCEnchantment, Integer> entry : is.getEnchantments().entrySet()){
+            CArray enchObj = new CArray(line_num, f);
+            enchObj.forceAssociativeMode();
+            enchObj.set("etype", new CString(entry.getKey().getName(), line_num, f));
+            enchObj.set("elevel", new CInt(entry.getValue(), line_num, f));
+            enchants.push(enchObj);
+        }
+        CArray ret = new CArray(line_num, f);
+        ret.forceAssociativeMode();
+        ret.set("type", Integer.toString(type));
+        ret.set("data", Integer.toString(data));
+        ret.set("qty", Integer.toString(qty));
+        ret.set("enchants", enchants);
+        return ret;
+    }
+    
+    /**
+     * Gets an MCItemStack from a given item "object". Supports both the old
+     * and new formats currently
+     * @param i
+     * @param line_num
+     * @param f
+     * @return 
+     */
+    public MCItemStack item(Construct i, int line_num, File f){
+        if(i instanceof CNull){
+            return EmptyItem();
+        }
+        if(!(i instanceof CArray)){
+            throw new ConfigRuntimeException("Expected an array!", ExceptionType.FormatException, line_num, f);
+        }
+        CArray item = (CArray)i;
+        int type = 0;
+        int data = 0;
+        int qty = 1;
+        Map<MCEnchantment, Integer> enchants = new HashMap<MCEnchantment, Integer>();
+
+        if(item.containsKey("type")){
+            try{
+                type = Integer.parseInt(item.get("type").val());
+            }catch(NumberFormatException e){
+                throw new ConfigRuntimeException("Could not get item information from given information (" + item.get("type").val() + ")", ExceptionType.FormatException, line_num, f, e);
+            }
+        } else {
+            throw new ConfigRuntimeException("Could not find item type!", ExceptionType.FormatException, line_num, f);
+        }
+        if(item.containsKey("data")){
+            try{
+                data = Integer.parseInt(item.get("data").val());
+            } catch(NumberFormatException e){
+                throw new ConfigRuntimeException("Could not get item data from given information (" + item.get("data").val() + ")", ExceptionType.FormatException, line_num, f, e);                    
+            }            
+        }
+        if(item.containsKey("qty")){
+            //This is the qty
+            String sqty = "notanumber";
+            if(item.containsKey("qty")){
+                sqty = item.get("qty").val();
+            }
+            try{
+                qty = Integer.parseInt(sqty);
+            } catch(NumberFormatException e){
+                throw new ConfigRuntimeException("Could not get qty from given information (" + sqty + ")", ExceptionType.FormatException, line_num, f, e);                                    
+            }
+        }
+        
+        if(item.containsKey("enchants")){
+            CArray enchantArray = null;
+            try{
+                if(item.containsKey("enchants")){
+                    enchantArray = (CArray)item.get("enchants");
+                }
+                if(enchantArray == null){
+                    throw new NullPointerException();
+                }
+            } catch(Exception e){
+                throw new ConfigRuntimeException("Could not get enchantment data from given information.", ExceptionType.FormatException, line_num, f, e);
+            }
+            
+            for(String index : enchantArray.keySet()){
+                try{
+                    CArray enchantment = (CArray)enchantArray.get(index);
+                    String setype = null;
+                    String selevel = null;
+                    if(enchantment.containsKey("etype")){
+                        setype = enchantment.get("etype").val();
+                    }
+                    
+                    if(enchantment.containsKey("elevel")){
+                        selevel = enchantment.get("elevel").val();                     
+                    }
+                    if(setype == null || selevel == null){
+                        throw new ConfigRuntimeException("Could not get enchantment data from given information.", ExceptionType.FormatException, line_num, f);                                            
+                    }
+                    int elevel = 0;
+                    try{
+                        elevel = Integer.parseInt(selevel);
+                    } catch(NumberFormatException e){                        
+                        throw new ConfigRuntimeException("Could not get enchantment data from given information.", ExceptionType.FormatException, line_num, f);                                            
+                    }
+                    MCEnchantment etype = StaticLayer.GetEnchantmentByName(setype);
+                    enchants.put(etype, elevel);
+                } catch(ClassCastException e){
+                    throw new ConfigRuntimeException("Could not get enchantment data from given information.", ExceptionType.FormatException, line_num, f, e);                    
+                }
+            }
+        }
+        MCItemStack ret = StaticLayer.GetItemStack(type, qty);
+        ret.setData(data);
+        ret.setDurability((short)data);
+        for(Map.Entry<MCEnchantment, Integer> entry : enchants.entrySet()){
+            ret.addEnchantment(entry.getKey(), entry.getValue());
+        }
+
+        //Giving them air crashes the client, so just clear the inventory slot
+        if(ret.getTypeId() == 0){
+            ret = EmptyItem();
+        }
+        return ret;        
+    }
+    
+    private static MCItemStack EmptyItem(){
+        return StaticLayer.GetItemStack(0, 1);
+    }
+}
diff --git a/src/main/java/com/laytonsmith/core/Procedure.java b/src/main/java/com/laytonsmith/core/Procedure.java
new file mode 100644
index 0000000..ef8766c
--- /dev/null
+++ b/src/main/java/com/laytonsmith/core/Procedure.java
@@ -0,0 +1,96 @@
+/*
+ * To change this template, choose Tools | Templates
+ * and open the template in the editor.
+ */
+package com.laytonsmith.core;
+
+import com.laytonsmith.core.constructs.*;
+import com.laytonsmith.core.exceptions.ConfigRuntimeException;
+import com.laytonsmith.core.exceptions.FunctionReturnException;
+import com.laytonsmith.core.functions.Exceptions.ExceptionType;
+import com.laytonsmith.core.functions.IVariableList;
+import com.sk89q.util.StringUtil;
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+
+/**
+ *
+ * @author Layton
+ */
+public class Procedure implements Cloneable {
+    private String name;
+    private Map<String, IVariable> varList;
+    private Map<String, Construct> originals = new HashMap<String, Construct>();
+    private List<IVariable> varIndex = new ArrayList<IVariable>();
+    private GenericTreeNode<Construct> tree;
+
+    
+    public Procedure(String name, List<IVariable> varList, GenericTreeNode<Construct> tree, CFunction f){
+        this.name = name;        
+        this.varList = new HashMap<String, IVariable>();
+        for(IVariable var : varList){
+            this.varList.put(var.getName(), var);
+            this.varIndex.add(var);
+            this.originals.put(var.getName(), var.ival());
+        }        
+        this.tree = tree;
+        if(!this.name.matches("^_[^_].*")){
+            throw new ConfigRuntimeException("Procedure names must start with an underscore", ExceptionType.FormatException, f.getLineNum(), f.getFile());
+        }
+    }
+    
+    public String getName(){
+        return name;
+    }
+    
+    @Override
+    public String toString(){
+        return name + "(" + StringUtil.joinString(varList.keySet(), ", ", 0) + ")";
+    }
+    
+    public Construct cexecute(List<GenericTreeNode<Construct>> args, Env env){
+        List<Construct> list = new ArrayList<Construct>();
+        for(GenericTreeNode<Construct> arg : args){
+            list.add(env.GetScript().seval(arg, env));
+        }
+        return execute(list, env);
+    }
+    public Construct execute(List<Construct> args, Env env){
+        env.SetVarList(new IVariableList());
+        CArray array = new CArray(0, null);        
+        for(String key : originals.keySet()){
+            Construct c = originals.get(key);
+            env.GetVarList().set(new IVariable(key, c, 0, null));
+            array.push(c);
+        }
+        GenericTree<Construct> root = new GenericTree<Construct>();
+        root.setRoot(tree);
+        Script fakeScript = Script.GenerateScript(tree, env.GetLabel());//new Script(null, null);        
+        for(int i = 0; i < args.size(); i++){
+            Construct c = args.get(i);
+            array.set(i, c);
+            if(varIndex.size() > i){
+                String varname = varIndex.get(i).getName();
+                env.GetVarList().set(new IVariable(varname, c, c.getLineNum(), c.getFile()));
+            }
+        }
+        env.GetVarList().set(new IVariable("@arguments", array, 0, null));
+        
+        try{
+            fakeScript.eval(tree, env);
+        } catch(FunctionReturnException e){
+            return e.getReturn();
+        }
+        return new CVoid(0, null);
+    }
+    
+    @Override
+    public Procedure clone() throws CloneNotSupportedException{
+        Procedure clone = (Procedure) super.clone();
+        if(this.varList != null) clone.varList = new HashMap<String, IVariable>(this.varList);
+        if(this.tree != null) clone.tree = this.tree.clone();
+        return clone;
+    }
+}
diff --git a/src/main/java/com/laytonsmith/core/Script.java b/src/main/java/com/laytonsmith/core/Script.java
new file mode 100644
index 0000000..4a5e56d
--- /dev/null
+++ b/src/main/java/com/laytonsmith/core/Script.java
@@ -0,0 +1,884 @@
+/*
+ * To change this template, choose Tools | Templates
+ * and open the template in the editor.
+ */
+package com.laytonsmith.core;
+
+import com.laytonsmith.abstraction.MCCommandSender;
+import com.laytonsmith.abstraction.MCPlayer;
+import com.laytonsmith.core.constructs.Construct.ConstructType;
+import com.laytonsmith.core.constructs.Token.TType;
+import com.laytonsmith.core.constructs.*;
+import com.laytonsmith.core.exceptions.*;
+import com.laytonsmith.core.functions.BasicLogic._if;
+import com.laytonsmith.core.functions.BasicLogic._switch;
+import com.laytonsmith.core.functions.BasicLogic.and;
+import com.laytonsmith.core.functions.BasicLogic.ifelse;
+import com.laytonsmith.core.functions.BasicLogic.nand;
+import com.laytonsmith.core.functions.BasicLogic.nor;
+import com.laytonsmith.core.functions.BasicLogic.or;
+import com.laytonsmith.core.functions.DataHandling._for;
+import com.laytonsmith.core.functions.DataHandling.assign;
+import com.laytonsmith.core.functions.DataHandling.call_proc;
+import com.laytonsmith.core.functions.DataHandling.closure;
+import com.laytonsmith.core.functions.DataHandling.foreach;
+import com.laytonsmith.core.functions.DataHandling.include;
+import com.laytonsmith.core.functions.DataHandling.proc;
+import com.laytonsmith.core.functions.EventBinding.bind;
+import com.laytonsmith.core.functions.Exceptions.ExceptionType;
+import com.laytonsmith.core.functions.Exceptions._try;
+import com.laytonsmith.core.functions.Function;
+import com.laytonsmith.core.functions.FunctionList;
+import com.laytonsmith.core.functions.IVariableList;
+import com.laytonsmith.core.functions.IncludeCache;
+import com.laytonsmith.core.functions.Meta.eval;
+import com.laytonsmith.core.functions.Meta.scriptas;
+import com.laytonsmith.core.functions.StringHandling.sconcat;
+import com.sk89q.bukkit.migration.PermissionsResolverManager;
+import java.io.File;
+import java.util.*;
+
+/**
+ * A script is a section of code that has been preprocessed and split into separate 
+ * commands/actions. For instance, the config script:
+ * 
+ * /command = /cmd
+ * 
+ * /test = /test
+ * 
+ * would be two seperate scripts, the first being the /command, and the second being /test.
+ * Certain key information is stored in the Script class. First, the information needed
+ * to see if a target string should trigger this script. Secondly, the default values
+ * of any variables, and thirdly, the unparsed tree for the right side of the script.
+ * @author Layton
+ */
+public class Script {
+
+    private List<Token> left;
+    private List<List<Token>> right;
+    private List<Token> fullRight;
+    private List<Construct> cleft;
+    private List<GenericTreeNode<Construct>> cright;
+    private Map<String, Variable> left_vars;
+    boolean hasBeenCompiled = false;
+    boolean compilerError = false;
+    private String label;
+    private Env CurrentEnv;
+
+    @Override
+    public String toString() {
+        StringBuilder b = new StringBuilder();
+        for (Token t : left) {
+            b.append(t.val()).append(" ");
+        }
+        b.append("compiled: ").append(hasBeenCompiled).append("; errors? ").append(compilerError);
+        return b.toString();
+    }
+
+    private Procedure getProc(String name) {
+        return CurrentEnv.GetProcs().get(name);
+    }
+    
+    public Env getCurrentEnv(){
+        return CurrentEnv;
+    }
+    
+    public String getLabel(){
+        return label;
+    }
+    
+    public Script(List<Token> left, List<Token> right) {
+        this.left = left;
+        this.fullRight = right;
+        this.left_vars = new HashMap<String, Variable>();        
+        //this.OriginalEnv = env;
+    }
+    
+    private Script(){}
+    
+    public static Script GenerateScript(GenericTreeNode<Construct> tree, String label){
+        Script s = new Script();
+        
+        s.hasBeenCompiled = true;
+        s.compilerError = false;
+        s.cright = new ArrayList<GenericTreeNode<Construct>>();
+        s.cright.add(tree);
+        s.label = label;
+        //s.OriginalEnv = env;
+        GenericTree<Construct> root = new GenericTree<Construct>();
+        root.setRoot(tree);
+//        for(GenericTreeNode<Construct> node : root.build(GenericTreeTraversalOrderEnum.PRE_ORDER)){
+//            if(node.getData() instanceof IVariable){
+//                s.OriginalEnv.GetVarList().set((IVariable)node.getData());
+//            }
+//        }
+        
+        return s;
+    }
+
+    public boolean uncompilable() {
+        return compilerError;
+    }
+
+    public void run(final List<Variable> vars, Env myEnv, final MScriptComplete done) {
+        //Some things, such as the label are determined at compile time
+        this.CurrentEnv = myEnv;
+        this.CurrentEnv.SetLabel(this.label);
+        MCCommandSender p = myEnv.GetCommandSender();
+        if (!hasBeenCompiled || compilerError) {
+            int line_num = 0;
+            if (left.size() >= 1) {
+                line_num = left.get(0).line_num;
+            }
+            throw new ConfigRuntimeException("Unable to run command, script not yet compiled, or a compiler error occured for that command.",
+                    null, line_num, null);
+        }
+        if (p instanceof MCPlayer) {
+            if (CurrentEnv.GetLabel() != null) {
+                PermissionsResolverManager perms = Static.getPermissionsResolverManager();
+                String[] groups = CurrentEnv.GetLabel().substring(1).split("/");
+                for (String group : groups) {
+                    if (group.startsWith("-") && perms.inGroup(((MCPlayer)p).getName(), group.substring(1))) {
+                        //negative permission
+                        throw new ConfigRuntimeException("You do not have permission to use that command", ExceptionType.InsufficientPermissionException,
+                                0, null);
+                    } else if (perms.inGroup(((MCPlayer)p).getName(), group)) {
+                        //They do have permission.
+                        break;
+                    }
+                }
+            }
+        }
+
+        try {
+            for (GenericTreeNode<Construct> rootNode : cright) {
+                GenericTree<Construct> tree = new GenericTree<Construct>();
+                tree.setRoot(rootNode);
+                for (GenericTreeNode<Construct> tempNode : tree.build(GenericTreeTraversalOrderEnum.PRE_ORDER)) {
+                    if (tempNode.data instanceof Variable) {
+                        ((Variable) tempNode.data).setVal(
+                                Static.resolveConstruct(
+                                Static.resolveDollarVar(left_vars.get(((Variable) tempNode.data).getName()), vars).toString(), tempNode.data.getLineNum(), tempNode.data.getFile()));
+                    }
+                }
+                File auto_include = new File("plugins/CommandHelper/auto_include.ms");
+                if (auto_include.exists()) {
+                    MScriptCompiler.execute(IncludeCache.get(auto_include, 0, auto_include), CurrentEnv, null, this);
+                }
+                MScriptCompiler.execute(tree.getRoot(), CurrentEnv, done, this);
+            }
+        } catch (ConfigRuntimeException ex) {
+            //We don't know how to handle this really, so let's pass it up the chain.
+            throw ex;
+        } catch (CancelCommandException e) {
+            //p.sendMessage(e.getMessage());
+            //The message in the exception is actually empty
+        } catch (LoopBreakException e) {            
+            if(p != null){
+                p.sendMessage("The break() function must be used inside a for() or foreach() loop");
+            }
+            System.out.println("The break() function must be used inside a for() or foreach() loop");
+        } catch (LoopContinueException e) {
+            if(p != null){
+                p.sendMessage("The continue() function must be used inside a for() or foreach() loop");
+            }
+            System.out.println("The continue() function must be used inside a for() or foreach() loop");
+        } catch (FunctionReturnException e) {
+            if(myEnv.GetEvent() != null){
+                //Oh, we're running in an event handler. Those know how to catch it too.
+                throw e;
+            }
+            if(p != null){
+                p.sendMessage("The return() function must be used inside a procedure.");
+            }
+            System.out.println("The return() function must be used inside a procedure.");
+        } catch (Throwable t) {
+            System.out.println("An unexpected exception occured during the execution of a script.");
+            t.printStackTrace();
+            if(p != null){
+                p.sendMessage("An unexpected exception occured during the execution of your script. Please check the console for more information.");
+            }
+        }
+        if (done != null) {
+            done.done(null);
+        }
+    }
+    
+    public Construct seval(GenericTreeNode<Construct> c, final Env env){
+        Construct ret = eval(c, env);
+        if(ret instanceof IVariable){
+            return env.GetVarList().get(((IVariable)ret).getName()).ival();
+        }
+        return ret;
+    }
+
+    public Construct eval(GenericTreeNode<Construct> c, final Env env) throws CancelCommandException {
+        final Construct m = c.getData();
+        CurrentEnv = env;
+        CurrentEnv.SetLabel(this.label);
+        if (m.getCType() == ConstructType.FUNCTION) {
+                env.SetScript(this);
+                if (m.val().matches("^_[^_].*")) {
+                    //Not really a function, so we can't put it in Function.
+                    Procedure p = getProc(m.val());
+                    if (p == null) {
+                        throw new ConfigRuntimeException("Unknown procedure \"" + m.val() + "\"", ExceptionType.InvalidProcedureException, m.getLineNum(), m.getFile());
+                    }
+//                    List<Construct> variables = new ArrayList<Construct>();
+//                    for (GenericTreeNode<Construct> child : c.getChildren()) {
+//                        variables.add(eval(child, env));
+//                    }
+//                    variables = Arrays.asList(preResolveVariables(variables.toArray(new Construct[]{})));
+                    Env newEnv = env;
+                    try{
+                        newEnv = env.clone();
+                    } catch(Exception e){}
+                    return p.cexecute(c.getChildren(), newEnv);
+                }
+                final Function f;
+                try{
+                    f = FunctionList.getFunction(m);
+                } catch(ConfigCompileException e){
+                    //Turn it into a config runtime exception. This shouldn't ever happen though.
+                    throw new ConfigRuntimeException("Unable to find function " + m.val(), m.getLineNum(), m.getFile());
+                }
+                //We have special handling for loop and other control flow functions
+                if(f instanceof assign){
+                    if(c.getChildAt(0).getData() instanceof CFunction){
+                        CFunction test = (CFunction)c.getChildAt(0).getData();
+                        if(test.val().equals("array_get")){
+                            env.SetFlag("array_get_alt_mode", true);
+                            Construct arrayAndIndex = eval(c.getChildAt(0), env);
+                            env.ClearFlag("array_get_alt_mode");
+                            return ((assign)f).array_assign(m.getLineNum(), m.getFile(), env, arrayAndIndex, eval(c.getChildAt(1), env));
+                        }
+                    }
+                }
+                if (f instanceof _for) {
+                    _for fr = (_for) f;
+                    List<GenericTreeNode<Construct>> ch = c.getChildren();
+                    try {
+                        return fr.execs(m.getLineNum(), m.getFile(), env, this, ch.get(0), ch.get(1), ch.get(2), ch.get(3));
+                    } catch (IndexOutOfBoundsException e) {
+                        throw new ConfigRuntimeException("Invalid number of parameters passed to for", ExceptionType.InsufficientArgumentsException, m.getLineNum(), m.getFile());
+                    }
+                } else if (f instanceof _if) {
+                    _if fr = (_if) f;
+                    List<GenericTreeNode<Construct>> ch = c.getChildren();
+                    try {
+                        return fr.execs(m.getLineNum(), m.getFile(), env, this, ch.get(0), ch.get(1), ch.size() > 2 ? ch.get(2) : null);
+                    } catch (IndexOutOfBoundsException e) {
+                        throw new ConfigRuntimeException("Invalid number of parameters passed to if", ExceptionType.InsufficientArgumentsException, m.getLineNum(), m.getFile());
+                    }
+                } else if (f instanceof foreach) {
+                    foreach fe = (foreach) f;
+                    List<GenericTreeNode<Construct>> ch = c.getChildren();
+                    try {
+                        return fe.execs(m.getLineNum(), m.getFile(), env, this, ch.get(0), ch.get(1), ch.get(2));
+                    } catch (IndexOutOfBoundsException e) {
+                        throw new ConfigRuntimeException("Invalid number of parameters passed to foreach", ExceptionType.InsufficientArgumentsException, m.getLineNum(), m.getFile());
+                    }
+                } else if (f instanceof eval) {
+                    List<GenericTreeNode<Construct>> ch = c.getChildren();
+                    if (ch.size() > 1) {
+                        throw new ConfigRuntimeException("Invalid number of parameters passed to eval", ExceptionType.InsufficientArgumentsException, m.getLineNum(), m.getFile());
+                    }
+                    try{
+                        GenericTreeNode<Construct> root = MScriptCompiler.compile(MScriptCompiler.lex(ch.get(0).getData().val(), null));
+                        StringBuilder b = new StringBuilder();
+                        for (GenericTreeNode<Construct> child : root.getChildren()) {
+                            CString cs = new CString(eval(child, env).val(), 0, null);
+                            if (!cs.val().trim().equals("")) {
+                                b.append(cs.val()).append(" ");
+                            }
+                        }
+                        return new CString(b.toString(), 0, null);
+                    } catch(ConfigCompileException e){
+                        
+                    }
+                } else if (f instanceof _try) {
+                    List<GenericTreeNode<Construct>> ch = c.getChildren();
+                    if (ch.size() != 4 && ch.size() != 3) {
+                        throw new ConfigRuntimeException("Invalid number of parameters passed to try", ExceptionType.InsufficientArgumentsException, m.getLineNum(), m.getFile());
+                    }
+                    GenericTreeNode<Construct> fourth = null;
+                    if (ch.size() == 4) {
+                        fourth = ch.get(3);
+                    }
+                    return ((_try) f).execs(m.getLineNum(), m.getFile(), env, this, ch.get(0), ch.get(1), ch.get(2), fourth);
+                } else if (f instanceof proc) {
+                    List<GenericTreeNode<Construct>> ch = c.getChildren();
+                    if (ch.size() <= 1) {
+                        throw new ConfigRuntimeException("Invalid number of parameters sent to proc()", ExceptionType.InvalidProcedureException, m.getLineNum(), m.getFile());
+                    }
+                    String name = "";
+                    List<IVariable> vars = new ArrayList<IVariable>();
+                    GenericTreeNode<Construct> tree = null;
+                    for (int i = 0; i < ch.size(); i++) {
+                        if (i == ch.size() - 1) {
+                            tree = ch.get(i);
+                        } else {
+                            Construct cons = eval(ch.get(i), env);
+                            if (i == 0 && cons instanceof IVariable) {
+                                //Soon, this will be allowed, so anonymous procedures can be created, but for now
+                                //it's not allowed
+                                throw new ConfigRuntimeException("Anonymous Procedures are not allowed", ExceptionType.InvalidProcedureException, m.getLineNum(), m.getFile());
+                            } else {
+                                if (i == 0 && !(cons instanceof IVariable)) {
+                                    name = cons.val();
+                                } else {
+                                    if (!(cons instanceof IVariable)) {
+                                        throw new ConfigRuntimeException("You must use IVariables as the arguments", ExceptionType.InvalidProcedureException, m.getLineNum(), m.getFile());
+                                    } else {
+                                        vars.add((IVariable) cons);
+                                    }
+                                }
+                            }
+                        }
+                    }
+                    Procedure myProc = new Procedure(name, vars, tree, (CFunction) c.getData());
+                    env.GetProcs().put(name, myProc);
+                    return new CVoid(m.getLineNum(), m.getFile());                
+                } else if (f instanceof call_proc) {
+                    Construct[] ar = new Construct[c.getChildren().size()];
+                    for (int i = 0; i < c.getChildren().size(); i++) {
+                        ar[i] = eval(c.getChildAt(i), env);
+                    }
+                    ar = preResolveVariables(ar);
+                    return ((call_proc) f).execs(m.getLineNum(), m.getFile(), env, ar);
+                } else if (f instanceof include) {
+                    return ((include) f).execs(m.getLineNum(), m.getFile(), env, c.getChildren(), this);
+                } else if(f instanceof bind){
+                    if(c.getChildren().size() < 5){
+                        throw new ConfigRuntimeException("bind accepts 5 or more parameters", ExceptionType.InsufficientArgumentsException, m.getLineNum(), m.getFile());
+                    }
+                    Construct name = preResolveVariable(eval(c.getChildAt(0), env));
+                    Construct options = preResolveVariable(eval(c.getChildAt(1), env));
+                    Construct prefilter = preResolveVariable(eval(c.getChildAt(2), env));
+                    Construct event_object = eval(c.getChildAt(3), env);
+                    IVariableList custom_params = new IVariableList();
+                    for(int a = 0; a < c.getChildren().size() - 5; a++){
+                        Construct var = eval(c.getChildAt(4 + a), env);
+                        if(!(var instanceof IVariable)){
+                            throw new ConfigRuntimeException("The custom parameters must be ivariables", ExceptionType.CastException, m.getLineNum(), m.getFile());
+                        }
+                        ((IVariable)var).setIval(env.GetVarList().get(((IVariable)var).getName()).ival());
+                        custom_params.set((IVariable)var);
+                    }
+                    Env newEnv = env;
+                    try{
+                        newEnv = env.clone();
+                    } catch(Exception e){}
+                    newEnv.SetVarList(custom_params);
+                    GenericTreeNode<Construct> tree = c.getChildAt(c.getChildren().size() - 1);
+                    return ((bind)f).execs(name, options, prefilter, event_object, tree, newEnv, m.getLineNum(), m.getFile());
+                } else if(f instanceof scriptas){
+                    return ((scriptas)f).execs(m.getLineNum(), m.getFile(), env, c.getChildren());
+//                    Construct user = eval(c.getChildAt(0), env);
+//                    GenericTreeNode<Construct> script = c.getChildAt(1);
+//                    env.SetCustom("script_node", script);
+//                    return ((scriptas)f).exec(m.getLineNum(), m.getFile(), env, user);
+                } else if(f instanceof sconcat){
+                    return ((sconcat)f).execs(m.getLineNum(), m.getFile(), env, c.getChildren());
+                } else if(f instanceof ifelse){
+                    return ((ifelse)f).execs(m.getLineNum(), m.getFile(), env, c.getChildren());
+                } else if(f instanceof _switch){
+                    return ((_switch)f).execs(m.getLineNum(), m.getFile(), env, c.getChildren());                    
+                } else if(f instanceof and){
+                    return ((and)f).execs(m.getLineNum(), m.getFile(), env, c.getChildren());
+                } else if(f instanceof nand){
+                    return ((nand)f).execs(m.getLineNum(), m.getFile(), env, c.getChildren());
+                } else if(f instanceof or){
+                    return ((or)f).execs(m.getLineNum(), m.getFile(), env, c.getChildren());
+                } else if(f instanceof nor){
+                    return ((nor)f).execs(m.getLineNum(), m.getFile(), env, c.getChildren());
+                } else if(f instanceof closure){
+                    return ((closure)f).execs(m.getLineNum(), m.getFile(), env, c.getChildren());
+                }
+
+
+                ArrayList<Construct> args = new ArrayList<Construct>();
+                for (GenericTreeNode<Construct> c2 : c.getChildren()) {
+                    args.add(eval(c2, env));
+                }
+                if (f.isRestricted()) {
+                    boolean perm = Static.hasCHPermission(f.getName(), env);
+                    if (!perm) {
+                        throw new ConfigRuntimeException("You do not have permission to use the " + f.getName() + " function.",
+                                ExceptionType.InsufficientPermissionException, m.getLineNum(), m.getFile());
+                    }
+                }
+                Object[] a = args.toArray();
+                Construct[] ca = new Construct[a.length];
+                for (int i = 0; i < a.length; i++) {
+                    ca[i] = (Construct) a[i];
+                    //CArray, CBoolean, CDouble, CInt, CNull, CString, CVoid, CEntry, CLabel (only to sconcat).
+                    if (!(ca[i] instanceof CArray || ca[i] instanceof CBoolean || ca[i] instanceof CDouble
+                            || ca[i] instanceof CInt || ca[i] instanceof CNull
+                            || ca[i] instanceof CString || ca[i] instanceof CVoid 
+                            || ca[i] instanceof IVariable || ca[i] instanceof CEntry)
+                            && (!f.getName().equals("sconcat") && (ca[i] instanceof CLabel))) {
+                        throw new ConfigRuntimeException("Invalid Construct (" 
+                                + ca[i].getClass() + ") being passed as an argument to a function (" 
+                                + f.getName() + ")", null, m.getLineNum(), m.getFile());
+                    }
+                    if(env.GetFlag("array_get_alt_mode") == Boolean.TRUE && i == 0){
+                        continue;
+                    }
+                    if(f.preResolveVariables() && ca[i] instanceof IVariable){
+                        ca[i] = env.GetVarList().get(((IVariable)ca[i]).getName()).ival();
+                    }
+                }
+
+                Construct ret = f.exec(m.getLineNum(), m.getFile(), env, ca);
+                return ret;
+
+        } else if (m.getCType() == ConstructType.VARIABLE) {
+            return Static.resolveConstruct(m.val(), m.getLineNum(), m.getFile());
+        } else {
+            return m;
+        }
+    }
+    public Construct preResolveVariable(Construct ca){
+        Construct[] c = new Construct[1];
+        c[0] = ca;
+        return preResolveVariables(c)[0];
+    }
+    public Construct[] preResolveVariables(Construct[] ca) {
+        for (int i = 0; i < ca.length; i++) {
+            if (ca[i] instanceof IVariable) {
+                IVariable v = (IVariable) ca[i];
+                ca[i] = CurrentEnv.GetVarList().get(v.getName()).ival();
+            } else if (ca[i] instanceof CArray) {
+//                CArray ca2 = (CArray) ca[i];
+//                Construct [] ca_raw = new Construct[ca2.size()];
+//                for(int j = 0; j < ca_raw.length; j++){
+//                    ca_raw[j] = ca2.get(j, 0);
+//                }
+//                List<Construct> resolved = Arrays.asList(preResolveVariables(ca_raw));
+//                for(int j = 0; j < resolved.size(); j++){
+//                    
+//                }
+            }
+        }
+        return ca;
+    }
+
+//    private Construct blockingNonThreadSafe(final Player p, Callable task) throws CancelCommandException {
+//        Plugin self = CommandHelperPlugin.self;
+//        try {
+//            Future<Construct> f = Static.getServer().getScheduler().callSyncMethod(self, task);
+//            while (!f.isDone()) {
+//                Thread.sleep(10);
+//            }
+//            return f.get();
+//        } catch (InterruptedException ex) {
+//            Logger.getLogger(Script.class.getName()).log(Level.SEVERE, null, ex);
+//        } catch (ExecutionException ex) {
+//            if (ex.getCause() instanceof CancelCommandException) {
+//                CancelCommandException e = (CancelCommandException) ex.getCause();
+//                throw e;
+//            } else {
+//                Logger.getLogger(Script.class.getName()).log(Level.SEVERE, null, ex.getCause());
+//            }
+//        }
+//        return null;
+//    }
+    public boolean match(String command) {
+        boolean case_sensitive = (Boolean)Static.getPreferences().getPreference("case-sensitive");
+        String[] cmds = command.split(" ");
+        List<String> args = new ArrayList(Arrays.asList(cmds));
+        boolean isAMatch = true;
+        StringBuilder lastVar = new StringBuilder();
+        int lastJ = 0;
+        try {
+            for (int j = 0; j < cleft.size(); j++) {
+                if (!isAMatch) {
+                    break;
+                }
+                lastJ = j;
+                Construct c = cleft.get(j);
+                String arg = args.get(j);
+                if (c.getCType() != ConstructType.VARIABLE) {
+//                        || c.getCType() == ConstructType.TOKEN
+//                        || c.getCType() == ConstructType.LITERAL
+//                        || c.getCType() == ConstructType.STRING || ConstructType.) {
+                    if (case_sensitive && !c.val().equals(arg) || !case_sensitive && !c.val().equalsIgnoreCase(arg)) {
+                        isAMatch = false;
+                        continue;
+                    }
+                } else {
+                    //It's a variable. If it's optional, the rest of them are optional too, so as long as the size of
+                    //args isn't greater than the size of cleft, it's a match
+                    if (((Variable) c).isOptional()) {
+                        if (args.size() <= cleft.size()) {
+                            return true;
+                        } else {
+                            Construct fin = cleft.get(cleft.size() - 1);
+                            if (fin instanceof Variable) {
+                                if (((Variable) fin).isFinal()) {
+                                    return true;
+                                }
+                            }
+                            return false;
+                        }
+                    }
+                }
+                if (j == cleft.size() - 1) {
+                    if (cleft.get(j).getCType() == ConstructType.VARIABLE) {
+                        Variable lv = (Variable) cleft.get(j);
+                        if (lv.isFinal()) {
+                            for (int a = j; a < args.size(); a++) {
+                                if (lastVar.length() == 0) {
+                                    lastVar.append(args.get(a));
+                                } else {
+                                    lastVar.append(" ").append(args.get(a));
+                                }
+                            }
+                        }
+                    }
+                }
+            }
+        } catch (IndexOutOfBoundsException e) {
+            if (cleft.get(lastJ).getCType() != ConstructType.VARIABLE
+                    || cleft.get(lastJ).getCType() == ConstructType.VARIABLE
+                    && !((Variable) cleft.get(lastJ)).isOptional()) {
+                isAMatch = false;
+            }
+        }
+        boolean lastIsFinal = false;
+        if (cleft.get(cleft.size() - 1) instanceof Variable) {
+            Variable v = (Variable) cleft.get(cleft.size() - 1);
+            if (v.isFinal()) {
+                lastIsFinal = true;
+            }
+        }
+        if ((cleft.get(lastJ) instanceof Variable && ((Variable) cleft.get(lastJ)).isOptional())) {
+            return true;
+        }
+
+        if (cleft.size() != cmds.length && !lastIsFinal) {
+            isAMatch = false;
+        }
+        ArrayList<Variable> vars = new ArrayList<Variable>();
+        Variable v = null;
+        for (int j = 0; j < cleft.size(); j++) {
+            try {
+                if (cleft.get(j).getCType() == ConstructType.VARIABLE) {
+                    if (((Variable) cleft.get(j)).getName().equals("$")) {
+                        v = new Variable(((Variable) cleft.get(j)).getName(),
+                                lastVar.toString(), 0, null);
+                    } else {
+                        v = new Variable(((Variable) cleft.get(j)).getName(),
+                                args.get(j), 0, null);
+                    }
+                }
+            } catch (IndexOutOfBoundsException e) {
+                v = new Variable(((Variable) cleft.get(j)).getName(),
+                        ((Variable) cleft.get(j)).getDefault(), 0, null);
+            }
+            if (v != null) {
+                vars.add(v);
+            }
+        }
+        return isAMatch;
+    }
+
+    public List<Variable> getVariables(String command) {
+        String[] cmds = command.split(" ");
+        List<String> args = new ArrayList(Arrays.asList(cmds));
+
+        StringBuilder lastVar = new StringBuilder();
+
+        ArrayList<Variable> vars = new ArrayList<Variable>();
+        Variable v = null;
+        for (int j = 0; j < cleft.size(); j++) {
+            try {
+                if (cleft.get(j).getCType() == ConstructType.VARIABLE) {
+                    if (((Variable) cleft.get(j)).getName().equals("$")) {
+                        for (int k = j; k < args.size(); k++) {
+                            lastVar.append(args.get(k).trim()).append(" ");
+                        }
+                        v = new Variable(((Variable) cleft.get(j)).getName(),
+                                lastVar.toString().trim(), 0, null);
+                    } else {
+                        v = new Variable(((Variable) cleft.get(j)).getName(),
+                                args.get(j), 0, null);
+                    }
+                }
+            } catch (IndexOutOfBoundsException e) {
+                v = new Variable(((Variable) cleft.get(j)).getName(),
+                        ((Variable) cleft.get(j)).getDefault(), 0, null);
+            }
+            if (v != null) {
+                vars.add(v);
+            }
+        }
+        return vars;
+    }
+
+    public void compile() throws ConfigCompileException {
+        try {
+            verifyLeft();
+            compileLeft();
+            compileRight();
+        } catch (ConfigCompileException e) {
+            compilerError = true;
+            throw e;
+        }
+        compilerError = false;
+        hasBeenCompiled = true;
+    }
+
+    private boolean verifyLeft() throws ConfigCompileException {
+        boolean inside_opt_var = false;
+        boolean after_no_def_opt_var = false;
+        String lastVar = null;
+        for (int j = 0; j < left.size(); j++) {
+            Token t = left.get(j);
+            //Token prev_token = j - 2 >= 0?c.tokens.get(j - 2):new Token(TType.UNKNOWN, "", t.line_num);
+            Token last_token = j - 1 >= 0 ? left.get(j - 1) : new Token(TType.UNKNOWN, "", t.line_num, t.file);
+            Token next_token = j + 1 < left.size() ? left.get(j + 1) : new Token(TType.UNKNOWN, "", t.line_num, t.file);
+            Token after_token = j + 2 < left.size() ? left.get(j + 2) : new Token(TType.UNKNOWN, "", t.line_num, t.file);
+
+            if (j == 0) {
+                if (next_token.type == TType.IDENT) {
+                    this.label = t.val();
+                    j--;
+                    left.remove(0);
+                    left.remove(0);
+                    continue;
+                }
+            }
+
+            if (t.type == TType.IDENT) {
+                continue;
+            }
+
+            if (t.type.equals(TType.FINAL_VAR) && left.size() - j >= 5) {
+                throw new ConfigCompileException("FINAL_VAR must be the last argument in the alias", t.line_num, t.file);
+            }
+            if (t.type.equals(TType.VARIABLE) || t.type.equals(TType.FINAL_VAR)) {
+                Variable v = new Variable(t.val(), null, t.line_num, t.file);
+                lastVar = t.val();
+                v.setOptional(last_token.type.equals(TType.LSQUARE_BRACKET));
+                left_vars.put(t.val(), v);
+                if (v.isOptional()) {
+                    after_no_def_opt_var = true;
+                } else {
+                    v.setDefault("");
+                }
+            }
+            if (j == 0 && !t.type.equals(TType.COMMAND)) {
+                if (!(next_token.type == TType.IDENT && after_token.type == TType.COMMAND)) {
+                    throw new ConfigCompileException("Expected command (/command) at start of alias."
+                            + " Instead, found " + t.type + " (" + t.val() + ")", t.line_num, t.file);
+                }
+            }
+            if (last_token.type.equals(TType.LSQUARE_BRACKET)) {
+                inside_opt_var = true;
+                if (!(t.type.equals(TType.FINAL_VAR) || t.type.equals(TType.VARIABLE))) {
+                    throw new ConfigCompileException("Unexpected " + t.type.toString() + " (" + t.val() + ")", t.line_num, t.file);
+                }
+            }
+            if (after_no_def_opt_var && !inside_opt_var) {
+                if (t.type.equals(TType.VARIABLE) || t.type.equals(TType.FINAL_VAR)) {
+                    throw new ConfigCompileException("You cannot have anything other than optional arguments after your"
+                            + " first optional argument, other that other optional arguments with no default", t.line_num, t.file);
+                }
+            }
+            if (!t.type.equals(TType.LSQUARE_BRACKET)
+                    && !t.type.equals(TType.OPT_VAR_ASSIGN)
+                    && !t.type.equals(TType.RSQUARE_BRACKET)
+                    && !t.type.equals(TType.VARIABLE)
+                    && !t.type.equals(TType.LIT)
+                    && !t.type.equals(TType.COMMAND)
+                    && !t.type.equals(TType.FINAL_VAR)) {
+                if (!(t.type.equals(TType.STRING) && j - 1 > 0 && left.get(j - 1).type.equals(TType.OPT_VAR_ASSIGN))) {
+                    throw new ConfigCompileException("Unexpected " + t.type + " (" + t.val() + ")", t.line_num, t.file);
+                }
+            }
+            if (last_token.type.equals(TType.COMMAND)) {
+                if (!(t.type.equals(TType.VARIABLE) || t.type.equals(TType.LSQUARE_BRACKET) || t.type.equals(TType.FINAL_VAR)
+                        || t.type.equals(TType.LIT))) {
+                    throw new ConfigCompileException("Unexpected " + t.type + " (" + t.val() + ") after command", t.line_num, t.file);
+                }
+            }
+            if (inside_opt_var && t.type.equals(TType.OPT_VAR_ASSIGN)) {
+                if (!((next_token.type.equals(TType.STRING) || next_token.type.equals(TType.LIT)) && after_token.type.equals(TType.RSQUARE_BRACKET)
+                        || (next_token.type.equals(TType.RSQUARE_BRACKET)))) {
+                    throw new ConfigCompileException("Unexpected token in optional variable", t.line_num, t.file);
+                } else if (next_token.type.equals(TType.STRING) || next_token.type.equals(TType.LIT)) {
+                    left_vars.get(lastVar).setDefault(next_token.val());
+                }
+            }
+            if (t.type.equals(TType.RSQUARE_BRACKET)) {
+                if (!inside_opt_var) {
+                    throw new ConfigCompileException("Unexpected " + t.type.toString(), t.line_num, t.file);
+                }
+                inside_opt_var = false;
+//                if (last_token.type.equals(TType.VARIABLE)
+//                        || last_token.type.equals(TType.FINAL_VAR)) {
+//                    after_no_def_opt_var = true;
+//                }
+            }
+        }
+
+        return true;
+    }
+
+    private boolean compileLeft() {
+        cleft = new ArrayList<Construct>();
+        for (int i = 0; i < left.size(); i++) {
+            Token t = left.get(i);
+            if (t.type == Token.TType.COMMAND) {
+                cleft.add(new Command(t.val(), t.line_num, t.file));
+            } else if (t.type == Token.TType.VARIABLE) {
+                cleft.add(new Variable(t.val(), null, t.line_num, t.file));
+            } else if (t.type.equals(TType.FINAL_VAR)) {
+                Variable v = new Variable(t.val(), null, t.line_num, t.file);
+                v.setFinal(true);
+                cleft.add(v);
+            } else if (t.type.equals(TType.LSQUARE_BRACKET)) {
+                if (i + 2 < left.size() && left.get(i + 2).type.equals(TType.OPT_VAR_ASSIGN)) {
+                    Variable v = new Variable(left.get(i + 1).val(),
+                            left.get(i + 3).val(), t.line_num, t.file);
+                    v.setOptional(true);
+                    if (left.get(i + 1).type.equals(TType.FINAL_VAR)) {
+                        v.setFinal(true);
+                    }
+                    cleft.add(v);
+                    i += 4;
+                } else {
+                    t = left.get(i + 1);
+                    Variable v = new Variable(t.val(), null, t.line_num, t.file);
+                    v.setOptional(true);
+                    if (t.val().equals("$")) {
+                        v.setFinal(true);
+                    }
+                    cleft.add(v);
+                    i += 2;
+                }
+            } else {
+                cleft.add(new CString(t.val(), t.line_num, t.file));
+            }
+        }
+        return true;
+    }
+
+    public void compileRight() throws ConfigCompileException {
+        List<Token> temp = new ArrayList<Token>();
+        right = new ArrayList<List<Token>>();
+        for (Token t : fullRight) {
+            if (t.type == TType.SEPERATOR) {
+                right.add(temp);
+                temp = new ArrayList<Token>();
+            } else {
+                temp.add(t);
+            }
+        }
+        right.add(temp);
+        cright = new ArrayList<GenericTreeNode<Construct>>();
+        for (List<Token> l : right) {
+            cright.add(MScriptCompiler.compile(l));
+        }
+    }
+
+    public void checkAmbiguous(ArrayList<Script> scripts) throws ConfigCompileException {
+        //for (int i = 0; i < scripts.size(); i++) {
+        List<Construct> thisCommand = this.cleft;
+        for (int j = 0; j < scripts.size(); j++) {
+            List<Construct> thatCommand = scripts.get(j).cleft;
+            if (thatCommand == null) {
+                //it hasn't been compiled yet.
+                return;
+            }
+            if (this.cleft == scripts.get(j).cleft) {
+                //Of course this command is going to match it's own signature
+                continue;
+            }
+            boolean soFarAMatch = true;
+            for (int k = 0; k < thisCommand.size(); k++) {
+                try {
+                    Construct c1 = thisCommand.get(k);
+                    Construct c2 = thatCommand.get(k);
+                    if (c1.getCType() != c2.getCType() || ((c1 instanceof Variable) && !((Variable) c1).isOptional())) {
+                        soFarAMatch = false;
+                    } else {
+                        //It's a literal, check to see if it's the same literal
+                        if (c1.val() == null || !c1.val().equals(c2.val())) {
+                            soFarAMatch = false;
+                        }
+                    }
+                } catch (IndexOutOfBoundsException e) {
+                    /**
+                     * The two commands:
+                     * /cmd $var1 [$var2]
+                     * /cmd $var1
+                     * would cause this exception to be thrown, but the signatures
+                     * are the same, so the fact that they've matched this far means
+                     * they are ambiguous. However,
+                     * /cmd $var1 $var2
+                     * /cmd $var1
+                     * is not ambiguous
+                     */
+                    //thatCommand is the short one
+                    if (!(thisCommand.get(k) instanceof Variable)
+                            || (thisCommand.get(k) instanceof Variable
+                            && !((Variable) thisCommand.get(k)).isOptional())) {
+                        soFarAMatch = false;
+                    }
+                }
+            }
+            if (thatCommand.size() > thisCommand.size()) {
+                int k = thisCommand.size();
+                //thisCommand is the short one
+                if (!(thatCommand.get(k) instanceof Variable)
+                        || (thatCommand.get(k) instanceof Variable
+                        && !((Variable) thatCommand.get(k)).isOptional())) {
+                    soFarAMatch = false;
+                }
+            }
+
+            if (soFarAMatch) {
+                String commandThis = "";
+                for (Construct c : thisCommand) {
+                    commandThis += c.val() + " ";
+                }
+                String commandThat = "";
+                for (Construct c : thatCommand) {
+                    commandThat += c.val() + " ";
+                }
+                scripts.get(j).compilerError = true;
+                this.compilerError = true;
+                throw new ConfigCompileException("The command " + commandThis.trim() + " is ambiguous because it "
+                        + "matches the signature of " + commandThat.trim(), thisCommand.get(0).getLineNum(), thisCommand.get(0).getFile());
+            }
+        }
+
+        //Also, check for undefined variables on the right, and unused variables on the left
+        ArrayList<String> left_copy = new ArrayList<String>();
+        for (Map.Entry<String, Variable> v : left_vars.entrySet()) {
+            left_copy.add(v.getValue().getName());
+        }
+        Arrays.asList(new String[]{}).toArray(new String[]{});
+        for (GenericTreeNode<Construct> gtn : cright) {
+            GenericTree<Construct> tree = new GenericTree<Construct>();
+            tree.setRoot(gtn);
+            List<GenericTreeNode<Construct>> builtTree = tree.build(GenericTreeTraversalOrderEnum.PRE_ORDER);
+            for (GenericTreeNode<Construct> c : builtTree) {
+                if (c.getData() instanceof Variable) {
+                    for (Map.Entry<String, Variable> v : left_vars.entrySet()) {
+                        if (v.getValue().getName().equals(((Variable) c.getData()).getName())) {
+                            //Found it, remove this from the left_copy, and break
+                            left_copy.remove(v.getValue().getName());
+                            break;
+                            //TODO: Layton!
+                        }
+                    }
+                }
+            }
+        }
+        //}
+    }
+}
diff --git a/src/main/java/com/laytonsmith/core/Static.java b/src/main/java/com/laytonsmith/core/Static.java
new file mode 100644
index 0000000..483a55f
--- /dev/null
+++ b/src/main/java/com/laytonsmith/core/Static.java
@@ -0,0 +1,819 @@
+/*
+ * To change this template, choose Tools | Templates
+ * and open the template in the editor.
+ */
+package com.laytonsmith.core;
+
+import com.laytonsmith.PureUtilities.Preferences;
+import com.laytonsmith.PureUtilities.Preferences.Preference;
+import com.laytonsmith.PureUtilities.Preferences.Type;
+import com.laytonsmith.PureUtilities.SerializedPersistance;
+import com.laytonsmith.PureUtilities.TermColors;
+import com.laytonsmith.PureUtilities.fileutility.LineCallback;
+import com.laytonsmith.PureUtilities.rParser;
+import com.laytonsmith.abstraction.*;
+import com.laytonsmith.abstraction.blocks.MCBlock;
+import com.laytonsmith.abstraction.bukkit.BukkitMCPlugin;
+import com.laytonsmith.commandhelper.CommandHelperPlugin;
+import com.laytonsmith.core.constructs.*;
+import com.laytonsmith.core.exceptions.ConfigRuntimeException;
+import com.laytonsmith.core.functions.Debug;
+import com.laytonsmith.core.functions.Exceptions.ExceptionType;
+import com.sk89q.bukkit.migration.PermissionsResolverManager;
+import com.sk89q.worldedit.bukkit.WorldEditPlugin;
+import com.sk89q.worldguard.bukkit.WorldGuardPlugin;
+import java.io.File;
+import java.io.FileWriter;
+import java.io.IOException;
+import java.util.*;
+import java.util.logging.Level;
+import java.util.logging.Logger;
+
+
+/**
+ * This class contains several static methods to get various objects that really should be static in the first
+ * place, but aren't. For the most part, when any code is running, these things will have been initialized, but
+ * in the event they aren't, each function will throw a NotInitializedYetException, which is a RuntimeException,
+ * so you don't have to check for exceptions whenever you use them. The Exception is caught on a higher
+ * level though, so it shouldn't bubble up too far.
+ * @author Layton
+ */
+public class Static {
+
+    /**
+     * This function pulls a numerical equivalent from any given construct. It throws a ConfigRuntimeException
+     * if it cannot be converted, for instance the string "s" cannot be cast to a number. The number returned
+     * will always be a double.
+     * @param c
+     * @return 
+     */
+    public static double getNumber(Construct c) {
+        double d;
+        if (c == null) {
+            return 0.0;
+        }
+        if (c instanceof CInt) {
+            d = ((CInt) c).getInt();
+        } else if (c instanceof CDouble) {
+            d = ((CDouble) c).getDouble();
+        } else if (c instanceof CString) {
+            try {
+                d = Double.parseDouble(c.val());
+            } catch (NumberFormatException e) {
+                throw new ConfigRuntimeException("Expecting a number, but received " + c.val() + " instead",
+                        ExceptionType.CastException, c.getLineNum(), c.getFile());
+            }
+        } else {
+            throw new ConfigRuntimeException("Expecting a number, but received " + c.val() + " instead",
+                    ExceptionType.CastException, c.getLineNum(), c.getFile());
+        }
+        return d;
+    }
+
+    /**
+     * Alias to getNumber
+     * @param c
+     * @return 
+     */
+    public static double getDouble(Construct c) {
+        try {
+            return getNumber(c);
+        } catch (ConfigRuntimeException e) {
+            throw new ConfigRuntimeException("Expecting a double, but received " + c.val() + " instead",
+                    ExceptionType.CastException, c.getLineNum(), c.getFile());
+        }
+    }
+
+    /**
+     * Returns an integer from any given construct. If the number is not castable to an int, a ConfigRuntimeException
+     * is thrown.
+     * @param c
+     * @return 
+     */
+    public static long getInt(Construct c) {
+        long i;
+        if (c == null) {
+            return 0;
+        }
+        if (c instanceof CInt) {
+            i = ((CInt) c).getInt();
+        } else {
+            try {
+                i = Long.parseLong(c.val());
+            } catch (NumberFormatException e) {
+                throw new ConfigRuntimeException("Expecting an integer, but received " + c.val() + " instead",
+                        ExceptionType.CastException, c.getLineNum(), c.getFile());
+            }
+        }
+        return i;
+    }
+
+    /**
+     * Returns a boolean from any given construct. Depending on the type of the construct being converted, it follows the following rules:
+     * If it is an integer or a double, it is false if 0, true otherwise. If it is a string, if it is empty, it is false, otherwise it is true.
+     * @param c
+     * @return 
+     */
+    public static boolean getBoolean(Construct c) {
+        boolean b = false;
+        if (c == null) {
+            return false;
+        }
+        if (c instanceof CBoolean) {
+            b = ((CBoolean) c).getBoolean();
+        } else if (c instanceof CString) {
+            b = (c.val().length() > 0);
+        } else if (c instanceof CInt || c instanceof CDouble) {
+            b = (getNumber(c) > 0 || getNumber(c) < 0);
+        }
+        return b;
+    }
+
+    /**
+     * Returns true if any of the constructs are a CDouble, false otherwise.
+     * @param c
+     * @return 
+     */
+    public static boolean anyDoubles(Construct... c) {
+        for (int i = 0; i < c.length; i++) {
+            if (c[i] instanceof CDouble) {
+                return true;
+            }
+        }
+        return false;
+    }
+
+    /**
+     * Return true if any of the constructs are CStrings, false otherwise.
+     * @param c
+     * @return 
+     */
+    public static boolean anyStrings(Construct... c) {
+        for (int i = 0; i < c.length; i++) {
+            if (c[i] instanceof CString) {
+                return true;
+            }
+        }
+        return false;
+    }
+
+    /**
+     * Returns true if any of the constructs are CBooleans, false otherwise.
+     * @param c
+     * @return 
+     */
+    public static boolean anyBooleans(Construct... c) {
+        for (int i = 0; i < c.length; i++) {
+            if (c[i] instanceof CBoolean) {
+                return true;
+            }
+        }
+        return false;
+    }
+
+    /**
+     * Returns the logger for the plugin
+     * @return
+     * @throws NotInitializedYetException 
+     */
+    public static Logger getLogger() throws NotInitializedYetException {
+        Logger l = com.laytonsmith.commandhelper.CommandHelperPlugin.logger;
+        if (l == null) {
+            throw new NotInitializedYetException("The logger has not been initialized yet");
+        }
+        return l;
+    }
+
+    /**
+     * Returns the server for this plugin
+     * @return
+     * @throws NotInitializedYetException 
+     */
+    public static MCServer getServer() throws NotInitializedYetException {
+        MCServer s = com.laytonsmith.commandhelper.CommandHelperPlugin.myServer;
+        if (s == null) {
+            throw new NotInitializedYetException("The server has not been initialized yet");
+        }
+        return s;
+    }
+
+    /**
+     * Gets the reference to the AliasCore for this plugin
+     * @return
+     * @throws NotInitializedYetException 
+     */
+    public static AliasCore getAliasCore() throws NotInitializedYetException {
+        AliasCore ac = com.laytonsmith.commandhelper.CommandHelperPlugin.getCore();
+        if (ac == null) {
+            throw new NotInitializedYetException("The core has not been initialized yet");
+        }
+        return ac;
+    }
+
+    /**
+     * Gets the persistance object for this plugin
+     * @return
+     * @throws NotInitializedYetException 
+     */
+    public static SerializedPersistance getPersistance() throws NotInitializedYetException {
+        SerializedPersistance p = com.laytonsmith.commandhelper.CommandHelperPlugin.persist;
+        if (p == null) {
+            throw new NotInitializedYetException("The persistance framework has not been initialized yet");
+        }
+        return p;
+    }
+
+    /**
+     * Gets the permissions resolver manager this plugin uses
+     * @return
+     * @throws NotInitializedYetException 
+     */
+    public static PermissionsResolverManager getPermissionsResolverManager() throws NotInitializedYetException {
+        PermissionsResolverManager prm = com.laytonsmith.commandhelper.CommandHelperPlugin.perms;
+        if (prm == null) {
+            throw new NotInitializedYetException("The permissions framework has not been initialized yet");
+        }
+        return prm;
+    }
+
+    /**
+     * Gets the current version of the plugin
+     * @return
+     * @throws NotInitializedYetException 
+     */
+    public static Version getVersion() throws NotInitializedYetException {
+        Version v = com.laytonsmith.commandhelper.CommandHelperPlugin.version;
+        if (v == null) {
+            throw new NotInitializedYetException("The plugin has not been initialized yet");
+        }
+        return v;
+    }
+
+    /**
+     * Gets the preferences object for this plugin, as well as setting it up if
+     * it is not already activated.
+     * @return
+     * @throws NotInitializedYetException 
+     */
+    public static Preferences getPreferences() throws NotInitializedYetException {
+        if (com.laytonsmith.commandhelper.CommandHelperPlugin.prefs == null) {
+            ArrayList<Preferences.Preference> a = new ArrayList<Preferences.Preference>();
+            //a.add(new Preference("check-for-updates", "false", Type.BOOLEAN, "Whether or not to check to see if there's an update for CommandHelper"));
+            a.add(new Preference("debug-mode", "false", Type.BOOLEAN, "Whether or not to display debug information in the console"));
+            a.add(new Preference("show-warnings", "true", Type.BOOLEAN, "Whether or not to display warnings in the console, while compiling"));
+            a.add(new Preference("console-log-commands", "true", Type.BOOLEAN, "Whether or not to display the original command in the console when it is run"));
+            //a.add(new Preference("max-sleep-time", "5", Type.INT, "The maximum number of seconds a sleep function can sleep for. If <= 0, no limit is imposed. Must be an integer."));
+            a.add(new Preference("script-name", "config.txt", Type.STRING, "The path to the config file, relative to the CommandHelper plugin folder"));
+            a.add(new Preference("enable-interpreter", "false", Type.BOOLEAN, "Whether or not to enable the /interpreter command. Note that even with this enabled, a player must still have the commandhelper.interpreter permission, but"
+                    + " setting it to false prevents all players from accessing the interpreter regardless of their permissions."));
+            a.add(new Preference("base-dir", "", Type.STRING, "The base directory that scripts can read and write to. If left blank, then the default of the server directory will be used. "
+                    + "This setting affects functions like include and read."));
+            a.add(new Preference("play-dirty", "false", Type.BOOLEAN, "Makes CommandHelper play dirty and break all sorts of programming rules, so that other plugins can't interfere with the operations that you defined. Note that doing this essentially makes CommandHelper have absolute say over commands. Use this setting only if you can't get another plugin to cooperate with CH, because it is a global setting."));
+            a.add(new Preference("case-sensitive", "true", Type.BOOLEAN, "Makes command matching be case sensitive. If set to false, if your config defines /cmd, but the user runs /CMD, it will trigger the command anyways."));
+            a.add(new Preference("main-file", "main.ms", Type.STRING, "The path to the main file, relative to the CommandHelper folder"));
+            a.add(new Preference("allow-debug-logging", "false", Type.BOOLEAN, "If set to false, the Debug class of functions will do nothing."));
+            a.add(new Preference("debug-log-file", "logs/debug/%Y-%M-%D-debug.log", Type.STRING, "The path to the debug output log file. Six variables are available, %Y, %M, and %D, %h, %m, %s, which are replaced with the current year, month, day, hour, minute and second respectively. It is highly recommended that you use at least year, month, and day if you are for whatever reason leaving logging on, otherwise the file size would get excessively large. The path is relative to the CommandHelper directory and is not bound by the base-dir restriction."));
+            a.add(new Preference("standard-log-file", "logs/%Y-%M-%D-commandhelper.log", Type.STRING, "The path the standard log files that the log() function writes to. Six variables are available, %Y, %M, and %D, %h, %m, %s, which are replaced with the current year, month, day, hour, minute and second respectively. It is highly recommended that you use at least year, month, and day if you are actively logging things, otherwise the file size would get excessively large. The path is relative to the CommandHelper directory and is not bound by the base-dir restriction."));
+            a.add(new Preference("allow-profiling", "false", Type.BOOLEAN, "If set to false, the Profiling class of functions will do nothing."));
+            a.add(new Preference("profiling-file", "logs/profiling/%Y-%M-%D-profiling.log", Type.STRING, "The path to the profiling logs. These logs are perf4j formatted logs. Consult the documentation for more information."));
+            a.add(new Preference("show-splash-screen", "true", Type.BOOLEAN, "Whether or not to show the splash screen at server startup"));
+            com.laytonsmith.commandhelper.CommandHelperPlugin.prefs = new Preferences("CommandHelper", getLogger(), a);
+        }
+        return com.laytonsmith.commandhelper.CommandHelperPlugin.prefs;
+    }
+    private static String debugLogFileCurrent = null;
+    private static FileWriter debugLogFileHandle = null;
+
+    /**
+     * Returns a file that is most likely ready to write to. The timestamp variables have already been replaced, and parent directories
+     * are all created.
+     * @return 
+     */
+    public static FileWriter debugLogFile() throws IOException {
+        String currentFileName = "plugins" + File.separator + "CommandHelper" + File.separator + ParseCalendarNotation((String) getPreferences().getPreference("debug-log-file"));
+        if (!currentFileName.equals(debugLogFileCurrent)) {
+            if (debugLogFileHandle != null) {
+                //We're done with the old one, close it.
+                debugLogFileHandle.close();
+            }
+            debugLogFileCurrent = currentFileName;
+            new File(debugLogFileCurrent).getParentFile().mkdirs();
+            debugLogFileHandle = new FileWriter(currentFileName);
+        }
+        return debugLogFileHandle;
+    }
+    private static String standardLogFileCurrent = null;
+    private static FileWriter standardLogFileHandle = null;
+
+    public static FileWriter standardLogFile() throws IOException {
+        String currentFileName = "plugins" + File.separator + "CommandHelper" + File.separator + ParseCalendarNotation((String) getPreferences().getPreference("standard-log-file"));
+        if (!currentFileName.equals(standardLogFileCurrent)) {
+            if (standardLogFileHandle != null) {
+                //We're done with the old one, close it.
+                standardLogFileHandle.close();
+            }
+            standardLogFileCurrent = currentFileName;
+            new File(standardLogFileCurrent).getParentFile().mkdirs();
+            standardLogFileHandle = new FileWriter(currentFileName);
+        }
+        return standardLogFileHandle;
+    }
+    private static String profilingLogFileCurrent = null;
+    private static FileWriter profilingLogFileHandle = null;
+
+    public static FileWriter profilingLogFile() throws IOException {
+        String currentFileName = "plugins" + File.separator + "CommandHelper" + File.separator + ParseCalendarNotation((String) getPreferences().getPreference("profiling-file"));
+        if (!currentFileName.equals(profilingLogFileCurrent)) {
+            if (profilingLogFileHandle != null) {
+                //We're done with the old one, close it.
+                profilingLogFileHandle.close();
+            }
+            profilingLogFileCurrent = currentFileName;
+            new File(profilingLogFileCurrent).getParentFile().mkdirs();
+            profilingLogFileHandle = new FileWriter(currentFileName);
+        }
+        return profilingLogFileHandle;
+    }
+
+    /**
+     * Convenience notation for ParseCalendarNotation(name, null)
+     */
+    public static String ParseCalendarNotation(String name) {
+        return ParseCalendarNotation(name, null);
+    }
+
+    /**
+     * Parses a calendar notation. The following patterns are replaced with the following:
+     * <table>
+     * <tr><td>%Y</td><td>Year</td></tr>
+     * <tr><td>%M</td><td>Month</td></tr>
+     * <tr><td>%D</td><td>Day</td></tr>
+     * <tr><td>%h</td><td>Hour</td></tr>
+     * <tr><td>%m</td><td>Minute</td></tr>
+     * <tr><td>%s</td><td>Second</td></tr>
+     * </table>
+     * 
+     * A generally standard format for human readable logs is: %Y-%M-%D %h:%m.%s
+     * @param name
+     * @param c
+     * @return 
+     */
+    public static String ParseCalendarNotation(String name, Calendar c) {
+        if (c == null) {
+            c = Calendar.getInstance();
+        }
+        String year = String.format("%04d", c.get(Calendar.YEAR));
+        String month = String.format("%02d", 1 + c.get(Calendar.MONTH)); //January is 0
+        String day = String.format("%02d", c.get(Calendar.DAY_OF_MONTH));
+        String hour = String.format("%02d", c.get(Calendar.HOUR));
+        String minute = String.format("%02d", c.get(Calendar.MINUTE));
+        String second = String.format("%02d", c.get(Calendar.SECOND));
+        return name.replaceAll("%Y", year).replaceAll("%M", month)
+                .replaceAll("%D", day).replaceAll("%h", hour)
+                .replaceAll("%m", minute).replaceAll("%s", second);
+    }
+
+    public static WorldEditPlugin getWorldEditPlugin(int line_num, File file) {
+        if (Implementation.GetServerType() != Implementation.Type.BUKKIT) {
+            throw new ConfigRuntimeException("Trying to use WorldEdit on non-bukkit server.", ExceptionType.InvalidPluginException, line_num, file);
+        }
+        if (CommandHelperPlugin.wep == null) {
+            MCPlugin pwep = getServer().getPluginManager().getPlugin("WorldEdit");
+            if (pwep != null && pwep.isEnabled() && pwep.isInstanceOf(WorldEditPlugin.class) && pwep instanceof BukkitMCPlugin) {
+                CommandHelperPlugin.wep = (WorldEditPlugin) ((BukkitMCPlugin)pwep).getPlugin();
+            }
+        }
+        return CommandHelperPlugin.wep;
+    }
+
+    public static WorldGuardPlugin getWorldGuardPlugin(int line_num, File file) {
+        if (Implementation.GetServerType() != Implementation.Type.BUKKIT) {
+            throw new ConfigRuntimeException("Trying to use WorldGuard on non-bukkit server.", ExceptionType.InvalidPluginException, line_num, file);
+        }
+        MCPlugin pwgp = getServer().getPluginManager().getPlugin("WorldGuard");
+        if (pwgp != null && pwgp.isEnabled() && pwgp.isInstanceOf(WorldGuardPlugin.class) && pwgp instanceof BukkitMCPlugin) {
+            return (WorldGuardPlugin) ((BukkitMCPlugin)pwgp).getPlugin();
+        }
+        return null;
+    }
+
+    public static void checkPlugin(String name, int line_number, File f) throws ConfigRuntimeException {
+        if (Static.getServer().getPluginManager().getPlugin(name) == null) {
+            throw new ConfigRuntimeException("Needed plugin " + name + " not found!",
+                    ExceptionType.InvalidPluginException, line_number, f);
+        }
+    }
+
+    /**
+     * Given a string input, creates and returns a Construct of the appropriate
+     * type. This takes into account that null, true, and false are keywords.
+     * @param val
+     * @param line_num
+     * @return 
+     */
+    public static Construct resolveConstruct(String val, int line_num, File file) {
+        if (val == null) {
+            return new CString("", line_num, file);
+        }
+        if (val.equalsIgnoreCase("null")) {
+            return new CNull(line_num, file);
+        } else if (val.equalsIgnoreCase("true")) {
+            return new CBoolean(true, line_num, file);
+        } else if (val.equalsIgnoreCase("false")) {
+            return new CBoolean(false, line_num, file);
+        } else {
+            try {
+                return new CInt(Integer.parseInt(val), line_num, file);
+            } catch (NumberFormatException e) {
+                try {
+                    if (val.contains(" ") || val.contains("\t")) {
+                        //Interesting behavior in Double.parseDouble causes it to "trim" strings first, then
+                        //try to parse them, which is not desireable in our case. So, if the value contains
+                        //any characters other than [\-0-9\.], we want to make it a string instead
+                        return new CString(val, line_num, file);
+                    }
+                    return new CDouble(Double.parseDouble(val), line_num, file);
+                } catch (NumberFormatException g) {
+                    //It's a literal, but not a keyword. Push it in as a string to standardize everything
+                    //later
+                    return new CString(val, line_num, file);
+                }
+            }
+        }
+    }
+
+    public static Construct resolveDollarVar(Construct variable, List<Variable> vars) {
+        if (variable.getCType() == Construct.ConstructType.VARIABLE) {
+            for (Variable var : vars) {
+                if (var.getName().equals(((Variable) variable).getName())) {
+                    return Static.resolveConstruct(var.val(), var.getLineNum(), var.getFile());
+                }
+            }
+            return Static.resolveConstruct(((Variable) variable).getDefault(), variable.getLineNum(), variable.getFile());
+        } else {
+            return variable;
+        }
+    }
+
+    /**
+     * This function breaks a string into chunks based on Minecraft line length,
+     * and newlines, then calls the LineCallback with each line.
+     * @param c
+     * @param msg 
+     */
+    public static void SendMessage(LineCallback c, String msg) {
+        String[] newlines = msg.split("\n");
+        for (String line : newlines) {
+            String[] arr = rParser.wordWrap(line);
+            for (String toMsg : arr) {                
+                c.run(toMsg.trim());
+            }
+        }
+
+    }
+
+    /**
+     * This function sends a message to the player. It is useful to use this function because:
+     * It handles newlines and wordwrapping for you.
+     * @param p
+     * @param msg 
+     */
+    public static void SendMessage(final MCCommandSender m, String msg, final int line_num, final File f) {
+        SendMessage(new LineCallback() {
+
+            public void run(String line) {
+                MCPlayer p = null;
+                if (m instanceof MCPlayer) {
+                    p = (MCPlayer) m;
+                    if (p == null || !p.isOnline()) {
+                        throw new ConfigRuntimeException("The player " + p.getName() + " is not online", ExceptionType.PlayerOfflineException, line_num, f);
+                    }
+                    p.sendMessage(line);
+                } else {
+                    if (m != null) {
+                        m.sendMessage(line);
+                    } else {
+                        System.out.println(line);
+                    }
+                }
+            }
+        }, msg);
+    }
+
+    public static void SendMessage(final MCCommandSender m, String msg) {
+        SendMessage(new LineCallback() {
+
+            public void run(String line) {
+                MCPlayer p = null;
+                if (m instanceof MCPlayer) {
+                    p = (MCPlayer) m;
+                    if (p != null && p.isOnline()) {
+                        p.sendMessage(line);
+                    }
+                } else {
+                    if (m != null) {
+                        m.sendMessage(line);
+                    } else {
+                        System.out.println(line);
+                    }
+                }
+            }
+        }, msg);
+    }
+
+    /**
+     * Returns true if this filepath is accessible to CH, false otherwise.
+     * @param location
+     * @return 
+     */
+    public static boolean CheckSecurity(String location) {
+        String pref = (String) Static.getPreferences().getPreference("base-dir");
+        if (pref.trim().equals("")) {
+            pref = ".";
+        }
+        File base_dir = new File(pref);
+        String base_final = base_dir.getAbsolutePath();
+        if (base_final.endsWith(".")) {
+            base_final = base_final.substring(0, base_final.length() - 1);
+        }
+        File loc = new File(location);
+        return loc.getAbsolutePath().startsWith(base_final);
+    }
+
+    /**
+     * Returns whether or not this location appears to be a url.
+     */
+    public static boolean ApparentURL(String toCheck) {
+        return false;
+    }
+
+    public static MCItemStack ParseItemNotation(String functionName, String notation, int qty, int line_num, File f) {
+        int type = 0;
+        byte data = 0;
+        MCItemStack is = null;
+        if (notation.matches("\\d*:\\d*")) {
+            String[] sData = notation.split(":");
+            try {
+                type = (int) Integer.parseInt(sData[0]);
+                if (sData.length > 1) {
+                    data = (byte) Integer.parseInt(sData[1]);
+                }
+            } catch (NumberFormatException e) {
+                throw new ConfigRuntimeException("Item value passed to " + functionName + " is invalid: " + notation, ExceptionType.FormatException, line_num, f);
+            }
+        } else {
+            type = (int) Static.getInt(Static.resolveConstruct(notation, line_num, f));
+        }
+
+        is = StaticLayer.GetItemStack(type, qty);
+        is.setDurability(data);
+        //is.setData(new MaterialData(type, data));
+        return is;
+    }
+
+    /**
+     * Works in reverse from the other ParseItemNotation
+     * @param is
+     * @return 
+     */
+    public static String ParseItemNotation(MCItemStack is) {
+        if (is == null) {
+            return "0";
+        }
+        String append = null;
+        if (is.getData() != null) {
+            append = Byte.toString(is.getData().getData());
+        } else if (is.getDurability() != 0) {
+            append = Short.toString(is.getDurability());
+        }
+        return is.getTypeId() + (append == null ? "" : ":" + append);
+    }
+
+    public static String ParseItemNotation(MCBlock b) {
+        if (b == null || b.isNull()) {
+            return "0";
+        }
+        return b.getTypeId() + (b.getData() == 0 ? "" : ":" + Byte.toString(b.getData()));
+    }
+
+    private static Map<String, MCPlayer> injectedPlayers = new HashMap<String, MCPlayer>();
+    public static MCPlayer GetPlayer(String player, int line_num, File f) throws ConfigRuntimeException {        
+        MCPlayer m = Static.getServer().getPlayer(player);
+        if(injectedPlayers.containsKey(player)){
+            m = injectedPlayers.get(player);
+        }
+        if (m == null || (!m.isOnline() && !injectedPlayers.containsKey(player))) {
+            throw new ConfigRuntimeException("The specified player (player) is not online", ExceptionType.PlayerOfflineException, line_num, f);
+        }
+        return m;
+    }
+
+    public static MCPlayer GetPlayer(Construct player, int line_num, File f) throws ConfigRuntimeException {
+        return GetPlayer(player.val(), line_num, f);
+    }
+
+    public static MCPlayer GetPlayer(String player) {
+        return GetPlayer(player, 0, null);
+    }
+
+    public static MCPlayer GetPlayer(Construct player) {
+        return GetPlayer(player, 0, null);
+    }
+
+    public static boolean isNull(Construct construct) {
+        return construct instanceof CNull;
+    }
+
+    public static int Normalize(int i, int min, int max) {
+        return java.lang.Math.min(max, java.lang.Math.max(min, i));
+    }
+
+    /**
+     * Returns the specified id, or null if it doesn't exist.
+     * @param id
+     * @return 
+     */
+    public static MCEntity getEntity(int id) {
+        for (MCWorld w : Static.getServer().getWorlds()) {
+            for (MCLivingEntity e : w.getLivingEntities()) {
+                if (e.getEntityId() == id) {
+                    return e;
+                }
+            }
+        }
+        return null;
+    }
+
+    public static String strJoin(Collection c, String inner) {
+        StringBuilder b = new StringBuilder();
+        Object[] o = c.toArray();
+        for (int i = 0; i < o.length; i++) {
+            if (i != 0) {
+                b.append(inner);
+            }
+            b.append(o[i]);
+        }
+        return b.toString();
+    }
+
+    public static String strJoin(Object[] o, String inner) {
+        StringBuilder b = new StringBuilder();
+        for (int i = 0; i < o.length; i++) {
+            if (i != 0) {
+                b.append(inner);
+            }
+            b.append(o[i]);
+        }
+        return b.toString();
+    }
+
+    public static String LF() {
+        return System.getProperty("line.separator");
+    }
+
+    public static synchronized void LogDebug(String message) throws IOException {
+        if (Debug.LOG_TO_SCREEN) {
+            Static.getLogger().log(Level.INFO, message);
+        }
+        String timestamp = Static.ParseCalendarNotation("%Y-%M-%D %h:%m.%s - ");
+        QuickAppend(Static.debugLogFile(), timestamp + message + Static.LF());
+    }
+
+    public static void QuickAppend(FileWriter f, String message) throws IOException {
+        f.append(message);
+        f.flush();
+    }
+
+    /**
+     * Sets up CommandHelper to play-dirty, if the user has specified as such
+     */
+    public static void PlayDirty() {
+        if ((Boolean) Static.getPreferences().getPreference("play-dirty")) {
+            try {
+                //Set up our "proxy"
+                BukkitDirtyRegisteredListener.Repopulate();
+            } catch (NoSuchMethodException ex) {
+                Logger.getLogger(Static.class.getName()).log(Level.SEVERE, null, ex);
+            } catch (NoSuchFieldException ex) {
+                AliasCore.logger.log(Level.SEVERE, "Uh oh, play dirty mode isn't working.", ex);
+            } catch (ClassCastException ex) {
+                AliasCore.logger.log(Level.SEVERE, "Uh oh, play dirty mode isn't working.", ex);
+            } catch (IllegalArgumentException ex) {
+                AliasCore.logger.log(Level.SEVERE, "Uh oh, play dirty mode isn't working.", ex);
+            } catch (IllegalAccessException ex) {
+                AliasCore.logger.log(Level.SEVERE, "Uh oh, play dirty mode isn't working.", ex);
+            }
+        } //else play nice :(
+    }
+
+    public static boolean hasCHPermission(String functionName, Env env) {
+        //The * label completely overrides everything
+        if("*".equals(env.GetLabel())){
+            return true;
+        }
+        boolean perm = false;
+        PermissionsResolverManager perms = Static.getPermissionsResolverManager();
+        if (perms != null) {
+            if (env.GetCommandSender() instanceof MCPlayer) {
+                perm = perms.hasPermission(env.GetPlayer().getName(), "ch.func.use." + functionName)
+                        || perms.hasPermission(env.GetPlayer().getName(), "commandhelper.func.use." + functionName);
+                if (env.GetLabel() != null && env.GetLabel().startsWith("~")) {
+                    String[] groups = env.GetLabel().substring(1).split("/");
+                    for (String group : groups) {
+                        if (perms.inGroup(env.GetPlayer().getName(), group)) {
+                            perm = true;
+                            break;
+                        }
+                    }
+                } else {
+                    if (env.GetLabel() != null){
+                        if(env.GetLabel().contains(".")){
+                            //We are using a non-standard permission. Don't automatically
+                            //add CH's prefix
+                            if(perms.hasPermission(env.GetPlayer().getName(), env.GetLabel())){
+                                perm = true;
+                            }
+                        } else if((perms.hasPermission(env.GetPlayer().getName(), "ch.alias." + env.GetLabel()))
+                            || perms.hasPermission(env.GetPlayer().getName(), "commandhelper.alias." + env.GetLabel())) {
+                            perm = true;
+                        }
+                    }
+                }
+            } else if (env.GetCommandSender() instanceof MCConsoleCommandSender) {
+                perm = true;
+            }
+        } else {
+            perm = true;
+        }
+        if (env.GetLabel() != null && env.GetLabel().equals("*")) {
+            perm = true;
+        }
+        if (env.GetCommandSender() == null
+                || env.GetCommandSender().isOp()) {
+            perm = true;
+        }
+        return perm;
+    }
+    
+    public static String Logo(){
+        String logo = Installer.parseISToString(Static.class.getResourceAsStream("/mainlogo"));
+        logo = logo.replaceAll("( +)", TermColors.BG_BLACK + "$1");
+        logo = logo.replaceAll("_", TermColors.BG_RED + TermColors.RED + "_");
+        logo = logo.replaceAll("/", TermColors.BG_BRIGHT_WHITE + TermColors.WHITE + "/");
+        String s = logo + TermColors.reset();
+        return s;
+    }
+    
+    public static String DataManagerLogo(){
+        String logo = Installer.parseISToString(Static.class.getResourceAsStream("/datamanagerlogo"));
+        logo = logo.replaceAll("( +)", TermColors.BG_BLACK + "$1");
+        logo = logo.replaceAll("_", TermColors.CYAN + TermColors.BG_CYAN + "_");
+        logo = logo.replaceAll("/", TermColors.BG_WHITE + TermColors.WHITE + "/");
+        String s = logo + TermColors.reset();
+        return s;
+    }
+    
+    public static String GetStringResource(String name){
+        return GetStringResource(Static.class, name);
+    }
+    
+    public static String GetStringResource(Class path, String name){
+        return Installer.parseISToString(path.getResourceAsStream(name));
+    }
+
+    /**
+     * Pulls out the MCChatColors from the string, and replaces them
+     * with the nearest match ANSI terminal color.
+     * @param mes
+     * @return 
+     */
+    public static String MCToANSIColors(String mes) {
+        //Pull out the MC colors
+        return mes
+                .replaceAll("0", TermColors.BLACK + TermColors.BG_WHITE)
+                .replaceAll("1", TermColors.BLUE)
+                .replaceAll("2", TermColors.GREEN)
+                .replaceAll("3", TermColors.CYAN)
+                .replaceAll("4", TermColors.RED)
+                .replaceAll("5", TermColors.MAGENTA)
+                .replaceAll("6", TermColors.YELLOW)
+                .replaceAll("7", TermColors.WHITE)
+                .replaceAll("8", TermColors.BRIGHT_BLACK + TermColors.BG_BRIGHT_WHITE)
+                .replaceAll("9", TermColors.BRIGHT_BLUE)
+                .replaceAll("a", TermColors.BRIGHT_GREEN)
+                .replaceAll("b", TermColors.BRIGHT_CYAN)
+                .replaceAll("c", TermColors.BRIGHT_RED)
+                .replaceAll("d", TermColors.BRIGHT_MAGENTA)
+                .replaceAll("e", TermColors.BRIGHT_YELLOW)
+                .replaceAll("f", TermColors.BRIGHT_WHITE) + TermColors.reset();
+                
+    }
+
+    public static void InjectPlayer(MCPlayer player) {
+        injectedPlayers.put(player.getName(), player);
+    }
+    
+    public static void UninjectPlayer(MCPlayer player){
+        injectedPlayers.remove(player.getName());
+    }
+}
diff --git a/src/main/java/com/laytonsmith/core/UserManager.java b/src/main/java/com/laytonsmith/core/UserManager.java
new file mode 100644
index 0000000..72e27a6
--- /dev/null
+++ b/src/main/java/com/laytonsmith/core/UserManager.java
@@ -0,0 +1,133 @@
+/*
+ * To change this template, choose Tools | Templates
+ * and open the template in the editor.
+ */
+package com.laytonsmith.core;
+
+import com.laytonsmith.PureUtilities.Persistance;
+import com.laytonsmith.abstraction.MCChatColor;
+import com.laytonsmith.core.constructs.Token;
+import com.laytonsmith.core.exceptions.ConfigCompileException;
+import java.io.File;
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+
+/**
+ * This class manages user aliases, and repeat commands.
+ * @author layton
+ */
+public class UserManager {
+    
+    private static Map<String, UserManager> map = new HashMap<String, UserManager>();
+    private static Map<String, List<Token>> script_cache = new HashMap<String, List<Token>>();
+    
+    public static UserManager GetUserManager(String name){
+        if(!map.containsKey(name)){
+            map.put(name, new UserManager(name));
+        }
+        return map.get(name);
+    }
+    
+    public static void ClearUser(String name){
+        if(map.containsKey(name)){
+            map.remove(name);
+        }
+    }
+    
+    String name;
+    String lastCommand;
+    
+    private UserManager(String name){
+        this.name = name;
+    }
+    
+    public void setLastCommand(String lastCommand){
+        this.lastCommand = lastCommand;
+    }
+    
+    public String getLastCommand(){
+        return lastCommand;
+    }
+    
+    public int addAlias(String alias) throws ConfigCompileException {
+        try{
+            MScriptCompiler.preprocess(MScriptCompiler.lex(alias, new File("User Alias")), new Env()).get(0).compile();
+        } catch(IndexOutOfBoundsException e){
+            throw new ConfigCompileException("Improperly formatted alias");
+        }
+        Persistance persist = Static.getPersistance();
+        List<Map.Entry<String, Object>> list = persist.getNamespaceValues(new String[]{"user", name, "aliases"});
+        Integer nextValue = 0;
+        for (Map.Entry e : list) {
+            String[] x = e.getKey().toString().split("\\.");
+            Integer thisX = Integer.parseInt(x[x.length - 1]);
+            nextValue = Math.max(thisX + 1, nextValue + 1);
+        }
+        persist.setValue(new String[]{"user", name, "aliases", nextValue.toString()}, alias);
+        return nextValue;
+    }
+    
+    public Script getAlias(int id) throws ConfigCompileException{
+        String alias = (String)Static.getPersistance().getValue(new String[]{"user", name, "aliases", Integer.toString(id)});
+        if(alias == null){
+            return null;
+        }
+        return getAlias(alias);
+    }
+    
+    private Script getAlias(String alias) throws ConfigCompileException{
+        Env env = new Env();
+        env.SetPlayer(Static.GetPlayer(name));            
+        List<Token> tokens;
+        if(script_cache.containsKey(alias)){
+            tokens = script_cache.get(alias);
+        } else {
+            tokens = MScriptCompiler.lex(alias, new File("User Alias"));            
+        }
+        return MScriptCompiler.preprocess(tokens, env).get(0);
+    }
+    
+    public void delAlias(int id){
+        Static.getPersistance().setValue(new String[]{"user", name, "aliases", Integer.toString(id)}, null);
+    }
+    
+    public String getAllAliases(int page){
+        if(page < 1){
+            page = 1;
+        }
+        List<Map.Entry<String, Object>> al = Static.getPersistance().getNamespaceValues(new String[]{"user", name, "aliases"});
+        StringBuilder b = new StringBuilder();
+
+        for(Map.Entry e : al){
+            String [] key = e.getKey().toString().split("\\.");
+            b.append(MCChatColor.AQUA)
+                    .append(key[key.length - 1])
+                    .append(":")
+                    .append(e.getValue().toString().substring(0, Math.min(e.getValue().toString().length(), 45)))
+                    .append(e.getValue().toString().length() > 45?"...":"")
+                    .append("\n");
+        }
+        if(al.isEmpty()){
+            b.append(MCChatColor.AQUA).append("You have no aliases defined");
+        }
+        return b.toString();
+    }
+    
+    public List<Script> getAllScripts(){
+        List<Map.Entry<String, Object>> scripts = Static.getPersistance().getNamespaceValues(new String[]{"user", name, "aliases"});
+        List<Script> list = new ArrayList<Script>();
+        for(Map.Entry<String, Object> entry : scripts){
+            try{
+                list.add(getAlias((String)entry.getValue()));
+            } catch(ConfigCompileException e){
+                //Ignore this one
+            }
+        }
+        return list;
+    }
+    
+    
+    
+}
diff --git a/src/main/java/com/laytonsmith/core/Version.java b/src/main/java/com/laytonsmith/core/Version.java
new file mode 100644
index 0000000..a139e69
--- /dev/null
+++ b/src/main/java/com/laytonsmith/core/Version.java
@@ -0,0 +1,105 @@
+/*
+ * To change this template, choose Tools | Templates
+ * and open the template in the editor.
+ */
+package com.laytonsmith.core;
+
+import java.util.regex.Matcher;
+import java.util.regex.Pattern;
+
+/**
+ * A version is formatted as such: 1.2.10 beta-1 where 1 is the major version,
+ * 2 is the minor version, 10 is the supplemental version, and beta-1 is the tag.
+ * When comparing two versions, the tag is not considered.
+ * @author Layton
+ */
+public class Version implements Comparable<Version>{
+    
+    private int major;
+    private int minor;
+    private int supplemental;
+    private String tag;
+    
+    /**
+     * Creates a new Version object from a string version number. The tag is
+     * optional, but all other parameters are required. If left off, each version
+     * part is set to 0.
+     * @param version 
+     */
+    public Version(String version){
+        Pattern p = Pattern.compile("(\\d+)\\.(\\d+)\\.(\\d+)\\s+(.*)?");
+        Matcher m = p.matcher(version);
+        if(m.find()){
+            major = Integer.parseInt(m.group(1)==null?"0":m.group(1));
+            minor = Integer.parseInt(m.group(2)==null?"0":m.group(2));
+            supplemental = Integer.parseInt(m.group(3)==null?"0":m.group(3));
+            tag = m.group(4)==null?"":m.group(4);
+        } else {
+            major = minor = supplemental = 0;
+            tag = "";
+        }
+    }
+    
+    public Version(int major, int minor, int supplemental, String tag){
+        this.major = major;
+        this.minor = minor;
+        this.supplemental = supplemental;
+        this.tag = tag;
+    }
+    
+    public Version(int major, int minor, int supplemental){
+        this(major, minor, supplemental, "");
+    }
+    
+    @Override
+    public String toString(){
+        return (major + "." + minor + "." + supplemental + " " + tag).trim();
+    }
+
+    public int compareTo(Version o) {
+        if(major < o.major){
+            return -1;
+        } else if(major > o.major){
+            return 1;
+        } else {
+            if(minor < o.minor){
+                return -1;
+            } else if(minor > o.minor){
+                return 1;
+            } else {
+                if(supplemental < o.supplemental){
+                    return -1;
+                } else if(supplemental > o.supplemental){
+                    return 1;
+                } else {
+                    return 0;
+                }
+            }
+        }
+    }
+
+    @Override
+    public boolean equals(Object obj) {
+        if(obj instanceof Version){
+            Version v = (Version) obj;
+            if(major == v.major && minor == v.minor && supplemental == v.supplemental){
+                return true;
+            } else {
+                return false;
+            }
+        } else {
+            return false;
+        }
+    }
+
+    @Override
+    public int hashCode() {
+        int hash = 5;
+        hash = 97 * hash + this.major;
+        hash = 97 * hash + this.minor;
+        hash = 97 * hash + this.supplemental;
+        return hash;
+    }
+    
+    
+}
diff --git a/src/main/java/com/laytonsmith/core/api.java b/src/main/java/com/laytonsmith/core/api.java
new file mode 100644
index 0000000..a18d566
--- /dev/null
+++ b/src/main/java/com/laytonsmith/core/api.java
@@ -0,0 +1,18 @@
+/*
+ * To change this template, choose Tools | Templates
+ * and open the template in the editor.
+ */
+package com.laytonsmith.core;
+
+import java.lang.annotation.ElementType;
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
+import java.lang.annotation.Target;
+
+/**
+ * Marks a function as an API function, which includes it in the list of functions.
+ * @author Layton
+ */
+@Retention(RetentionPolicy.RUNTIME)
+@Target(ElementType.TYPE)
+public @interface api {}
diff --git a/src/main/java/com/laytonsmith/core/constructs/CArray.java b/src/main/java/com/laytonsmith/core/constructs/CArray.java
new file mode 100644
index 0000000..a4b79f8
--- /dev/null
+++ b/src/main/java/com/laytonsmith/core/constructs/CArray.java
@@ -0,0 +1,383 @@
+/*
+ * To change this template, choose Tools | Templates
+ * and open the template in the editor.
+ */
+package com.laytonsmith.core.constructs;
+
+import com.laytonsmith.core.Static;
+import com.laytonsmith.core.exceptions.ConfigRuntimeException;
+import com.laytonsmith.core.functions.Exceptions.ExceptionType;
+import java.io.File;
+import java.util.*;
+
+/**
+ *
+ * @author layton
+ */
+public class CArray extends Construct {
+
+    private boolean associative_mode = false;
+    private long next_index = 0;
+    private List<Construct> array;
+    private SortedMap<String, Construct> associative_array;
+    private String mutVal;
+    CArray parent = null;
+
+    public CArray(int line_num, File file, Construct... items) {
+        super(null, ConstructType.ARRAY, line_num, file);
+        for(Construct item : items){
+            if(item instanceof CEntry){
+                //it's an associative array
+                associative_mode = true;
+                break;
+            }
+        }
+        if(associative_mode){
+            associative_array = new TreeMap<String, Construct>(comparator);
+            for(Construct item : items){
+                if(item instanceof CEntry){
+                    associative_array.put(normalizeConstruct(((CEntry)item).ckey), ((CEntry)item).construct);
+                } else {
+                    int max = Integer.MIN_VALUE;            
+                    for (String key : associative_array.keySet()) {
+                        try{
+                            int i = Integer.parseInt(key);
+                            max = java.lang.Math.max(max, i);
+                        } catch(NumberFormatException e){}
+                    }
+                    if(max == Integer.MIN_VALUE){
+                        max = -1; //Special case, there are no integer indexes in here yet.
+                    }
+                    associative_array.put(Integer.toString(max + 1), item);
+                    if(item instanceof CArray){
+                        ((CArray)item).parent = this;
+                    }
+                }
+            }
+        } else {
+            array = new ArrayList<Construct>();
+            for(Construct item : items){
+                array.add(item);
+                if(item instanceof CArray){
+                    ((CArray)item).parent = this;
+                }
+            }
+            this.next_index = array.size();
+        }
+        regenValue();
+    }
+
+    /**
+     * @return Whether or not this array is operating in associative mode
+     */
+    public boolean inAssociativeMode() {
+        return associative_mode;
+    }
+    
+    /**
+     * This should only be used when copying an array that is already known to be associative, so integer keys will
+     * remain associative.
+     */
+    public void forceAssociativeMode(){
+        if(associative_array == null){
+            associative_array = new TreeMap<String, Construct>();
+        }
+        associative_mode = true;
+    }
+
+    private void regenValue() {
+        StringBuilder b = new StringBuilder();
+        b.append("{");
+        if (!associative_mode) {
+            for (int i = 0; i < array.size(); i++) {
+                if (i > 0) {
+                    b.append(", ");
+                    b.append(array.get(i).val());
+                } else {
+                    b.append(array.get(i).val());
+                }
+            }
+        } else {
+            boolean first = true;
+            for(String key : associative_array.keySet()){
+                if(!first){
+                    b.append(", ");
+                }
+                first = false;
+                b.append(key).append(": ").append(associative_array.get(key).val());
+            }
+        }
+        b.append("}");
+        mutVal = b.toString();
+        if(parent != null){
+            parent.regenValue();
+        }
+    }
+
+    /**
+     * Pushes a new Construct onto the array
+     * @param c 
+     */
+    public void push(Construct c) {
+        if (!associative_mode) {
+            array.add(c);
+            next_index++;
+        } else {
+            int max = 0;            
+            for (String key : associative_array.keySet()) {
+                try{
+                    int i = Integer.parseInt(key);
+                    max = java.lang.Math.max(max, i);
+                } catch(NumberFormatException e){}
+            }
+            if(c instanceof CEntry){
+                associative_array.put(Integer.toString(max + 1), ((CEntry)c).construct());
+            } else {
+                associative_array.put(Integer.toString(max + 1), c);
+            }
+        }
+        if(c instanceof CArray){
+            ((CArray)c).parent = this;
+        }
+        regenValue();
+    }
+    
+    /**
+     * Returns the key set for this array. If it's an associative array, it simply returns
+     * the key set of the map, otherwise it generates a set real quick from 0 - size-1, and
+     * returns that.
+     * @return 
+     */
+    public Set<String> keySet(){
+        Set<String> set = new HashSet<String>(!associative_mode?array.size():associative_array.size());
+        if(!associative_mode){
+            for(int i = 0; i < array.size(); i++){
+                set.add(Integer.toString(i));
+            }
+            set = new TreeSet(set);
+        } else {
+            set = associative_array.keySet();
+        }        
+        return set;
+    }
+
+    /**
+     * 
+     * @param index
+     * @param c 
+     */
+    public void set(Construct index, Construct c) {
+        if (!associative_mode) {
+            try {
+                int indx = (int) Static.getInt(index);
+                if (indx > next_index || indx < 0) {
+                    throw new ConfigRuntimeException("", 0, null);
+                } else if(indx == next_index){
+                    this.push(c);
+                } else {
+                    array.set(indx, c);
+                }
+            } catch (ConfigRuntimeException e) {
+                //Not a number. Convert to associative.
+                associative_array = new TreeMap<String, Construct>(comparator);
+                for (int i = 0; i < array.size(); i++) {
+                    associative_array.put(Integer.toString(i), array.get(i));
+                }
+                associative_mode = true;
+                array = null; // null out the original array container so it can be GC'd
+            }
+        }
+        if (associative_mode) {
+            associative_array.put(normalizeConstruct(index), c);
+        }
+        if(c instanceof CArray){
+            ((CArray)c).parent = this;
+        }
+        regenValue();
+    }
+    
+    public void set(int index, Construct c){
+        this.set(new CInt(index, 0, null), c);
+    }
+    /* Shortcuts */
+    
+    public void set(String index, Construct c){
+        set(new CString(index, c.getLineNum(), c.getFile()), c);
+    }
+    
+    public void set(String index, String value, int line_num, File f){
+        set(index, new CString(value, line_num, f));
+    }
+    
+    public void set(String index, String value){
+        set(index, value, 0, null);
+    }
+
+    public Construct get(Construct index, int line_num, File f) {
+        if(!associative_mode){
+            try {
+                return array.get((int)Static.getInt(index));
+            } catch (IndexOutOfBoundsException e) {
+                throw new ConfigRuntimeException("The element at index \"" + index.val() + "\" does not exist", ExceptionType.IndexOverflowException, line_num, f);
+            }
+        } else {
+            if(associative_array.containsKey(normalizeConstruct(index))){
+                Construct val = associative_array.get(normalizeConstruct(index));
+                if(val instanceof CEntry){
+                    return ((CEntry)val).construct();
+                }
+                return val;
+            } else {
+                throw new ConfigRuntimeException("The element at index \"" + index.val() + "\" does not exist", ExceptionType.IndexOverflowException, line_num, f);
+            }
+        }
+    }
+    
+    public Construct get(int index, int line_num, File f){
+        return this.get(new CInt(index, line_num, f), line_num, f);
+    }
+    
+    public Construct get(String index, int line_num, File f){
+        return this.get(new CString(index, line_num, f), line_num, f);
+    }
+    
+    public Construct get(String index){
+        return this.get(index, 0, null);
+    }
+    
+    public Construct get(int index){
+        return this.get(index, 0, null);
+    }
+    
+    public boolean containsKey(String c){
+        Integer i;
+        try{
+            i = Integer.valueOf(c);
+        } catch(NumberFormatException e){
+            i = null;
+        }
+        if(associative_mode){
+            return associative_array.containsKey(c);
+        } else {
+            if(i == null){
+                return false;
+            } else {
+                return array.size() > i;
+            }
+        }
+    }
+    
+    public boolean containsKey(int i){
+        return this.containsKey(Integer.toString(i));
+    }
+    
+    public boolean contains(Construct c){
+        if(associative_mode){
+            return associative_array.containsValue(c);
+        } else {
+            return array.contains(c);
+        }
+    }
+    
+    public boolean contains(String c){
+        return contains(new CString(c, 0, null));
+    }
+    
+    public boolean contains(int i){
+        return contains(new CString(Integer.toString(i), 0, null));
+    }
+
+    @Override
+    public String val() {
+        return mutVal;
+    }
+
+    @Override
+    public String toString() {
+        return mutVal;
+    }
+
+    public int size() {
+        if(associative_mode){
+            return associative_array.size();
+        } else {
+            return array.size();
+        }
+    }
+
+    @Override
+    public CArray clone() throws CloneNotSupportedException {
+        CArray clone = (CArray) super.clone();
+        clone.associative_mode = associative_mode;
+        if(associative_mode){
+            if (array != null) {
+                clone.array = new ArrayList<Construct>(this.array);
+            }
+        } else {
+            if(associative_array != null){
+                clone.associative_array = new TreeMap<String, Construct>(this.associative_array);
+            }
+        }
+        clone.regenValue();
+        return clone;
+    }
+    
+    private String normalizeConstruct(Construct c){
+        if(c instanceof CArray){
+            throw new ConfigRuntimeException("Arrays cannot be used as the key in an associative array", ExceptionType.CastException, c.line_num, c.file);
+        } else if(c instanceof CString || c instanceof CInt){
+            return c.val();
+        } else if(c instanceof CNull){
+            return "";
+        } else if(c instanceof CBoolean){
+            if(((CBoolean)c).getBoolean()){
+                return "1";
+            } else {
+                return "0";
+            }
+        } else if(c instanceof CLabel){
+            return normalizeConstruct(((CLabel)c).cVal());
+        } else {
+            return c.val();
+        }
+    }
+
+    public void remove(Construct construct) {
+        String c = normalizeConstruct(construct);
+        if(!associative_mode){
+            array.remove((int)Static.getInt(construct));
+        } else {
+            associative_array.remove(construct.val());
+        }
+        regenValue();
+    }
+    
+    private Comparator<String> comparator = new Comparator<String>(){
+
+        public int compare(String o1, String o2) {
+            //Due to a dumb behavior in Double.parseDouble, 
+            //we need to check to see if there are non-digit characters in
+            //the keys, and if so, do a string comparison.
+            if(o1.matches(".*[^0-9\\.]+.*") || o2.matches(".*[^0-9\\.]+.*")){
+                return o1.compareTo(o2);
+            }
+            try{
+                int i1 = Integer.parseInt(o1);
+                int i2 = Integer.parseInt(o2);
+                //They're both integers, do an integer comparison
+                return new Integer(i1).compareTo(new Integer(i2));
+            } catch(NumberFormatException e){
+                try{                    
+                    double d1 = Double.parseDouble(o1);
+                    double d2 = Double.parseDouble(o2);
+                    //They're both doubles, do a double comparison
+                    return new Double(d1).compareTo(new Double(d2));
+                } catch(NumberFormatException ee){
+                    //Just do a string comparison
+                    return o1.compareTo(o2);
+                }
+            }
+        }
+        
+    };
+}
diff --git a/src/main/java/com/laytonsmith/core/constructs/CArrayReference.java b/src/main/java/com/laytonsmith/core/constructs/CArrayReference.java
new file mode 100644
index 0000000..55f3599
--- /dev/null
+++ b/src/main/java/com/laytonsmith/core/constructs/CArrayReference.java
@@ -0,0 +1,62 @@
+/*
+ * To change this template, choose Tools | Templates
+ * and open the template in the editor.
+ */
+package com.laytonsmith.core.constructs;
+
+import com.laytonsmith.core.Env;
+
+/**
+ *
+ * @author Layton
+ */
+public class CArrayReference extends Construct{
+    public Construct array;
+    public Construct index;
+    public IVariable name = null;
+    public CArrayReference(Construct array, Construct index, Env env){
+        super("", ConstructType.ARRAY, 0, null);
+        this.array = array;
+        if(array instanceof CArrayReference){
+            this.name = ((CArrayReference)array).name;
+        }
+        if(!(array instanceof CArray) && !(array instanceof CArrayReference)){
+            if(array instanceof IVariable){
+                name = (IVariable)array;
+                Construct ival = env.GetVarList().get(name.getName()).ival();
+                if(ival instanceof CArray){
+                    this.array = ival;
+                } else {
+                    this.array = new CArray(line_num, file);
+                }
+            } else {
+                this.array = new CArray(line_num, file);
+            }
+        }
+        this.index = index;
+    }
+    
+    @Override
+    public String toString(){
+        return "(" + array + ") -> " + index;
+    }
+    
+    public Construct getInternalArray(){
+        Construct temp = array;
+        while(temp instanceof CArrayReference){
+            temp = ((CArrayReference)temp).array;
+        }
+        return temp;
+    }
+    
+    public Construct getInternalIndex(){
+        if(!(array instanceof CArrayReference)){
+            return index;
+        }
+        CArrayReference temp = (CArrayReference)array;
+        while(temp.array instanceof CArrayReference){
+            temp = (CArrayReference)temp.array;
+        }
+        return temp.index;
+    }
+}
diff --git a/src/main/java/com/laytonsmith/core/constructs/CBoolean.java b/src/main/java/com/laytonsmith/core/constructs/CBoolean.java
new file mode 100644
index 0000000..66b29bc
--- /dev/null
+++ b/src/main/java/com/laytonsmith/core/constructs/CBoolean.java
@@ -0,0 +1,70 @@
+/*
+ * To change this template, choose Tools | Templates
+ * and open the template in the editor.
+ */
+
+package com.laytonsmith.core.constructs;
+
+import com.laytonsmith.core.exceptions.ConfigRuntimeException;
+import com.laytonsmith.core.functions.Exceptions.ExceptionType;
+import java.io.File;
+
+/**
+ *
+ * @author layton
+ */
+public class CBoolean extends Construct implements Cloneable{
+    
+    public static final long serialVersionUID = 1L;
+    private boolean val;
+    public CBoolean(boolean value, int line_num, File file){
+        super(Boolean.toString(value), ConstructType.BOOLEAN, line_num, file);
+        val = value;
+    }
+
+    public CBoolean(String value, int line_num, File file){
+        super(value, ConstructType.BOOLEAN, line_num, file);
+        try{
+            int i = Integer.parseInt(value);
+            if(i == 0){
+                val = false;
+            } else {
+                val = true;
+            }
+        } catch(NumberFormatException e){
+            try{
+                double d = Double.parseDouble(value);
+                if(d == 0){
+                    val = false;
+                } else {
+                    val = true;
+                }
+            } catch(NumberFormatException f){
+                try{
+                    val = Boolean.parseBoolean(value);
+                } catch(NumberFormatException g){
+                    throw new ConfigRuntimeException("Could not parse value " + value + " into a Boolean type", ExceptionType.FormatException, line_num, file);
+                }
+            }
+        }
+    }
+
+    public boolean getBoolean(){
+        return val;
+    }
+
+    @Override
+    public String val() {
+        if(val){
+            return "true";
+        } else{
+            return "false";
+        }
+    }
+    
+    @Override
+    public CBoolean clone() throws CloneNotSupportedException{
+        return (CBoolean) super.clone();
+    }
+
+}
diff --git a/src/main/java/com/laytonsmith/core/constructs/CClosure.java b/src/main/java/com/laytonsmith/core/constructs/CClosure.java
new file mode 100644
index 0000000..342b88f
--- /dev/null
+++ b/src/main/java/com/laytonsmith/core/constructs/CClosure.java
@@ -0,0 +1,70 @@
+/*
+ * To change this template, choose Tools | Templates
+ * and open the template in the editor.
+ */
+package com.laytonsmith.core.constructs;
+
+import com.laytonsmith.core.Env;
+import com.laytonsmith.core.GenericTreeNode;
+import java.io.File;
+
+/**
+ * A closure is just an anonymous procedure. 
+ * @author Layton
+ */
+public class CClosure extends Construct {
+    
+    public static final long serialVersionUID = 1L;
+
+    GenericTreeNode<Construct> node;
+    Env env;
+
+    public CClosure(String name, GenericTreeNode<Construct> node, Env env, int line_num, File file) {
+        super(node!=null?node.toString():"", ConstructType.CLOSURE, line_num, file);
+        this.node = node;
+        this.env = env;
+    }
+    
+    @Override
+    public String val(){
+        StringBuilder b = new StringBuilder();
+        condense(getNode(), b);
+        return b.toString();
+    }
+    
+    private void condense(GenericTreeNode<Construct> node, StringBuilder b){
+        if(node.data instanceof CFunction){            
+            b.append(((CFunction)node.data).val()).append("(");
+            for(int i = 0; i < node.children.size(); i++){
+                condense(node.children.get(i), b);
+                if(i > 0 && !((CFunction)node.data).val().equals("sconcat")){
+                    //sconcat handles itself in the reversal
+                    b.append(",");
+                }
+                //TODO: optimize concat and sconcat
+            }
+            b.append(")");
+        } else if(node.data instanceof CString){
+            CString data = (CString)node.data;
+            // Convert: \ -> \\ and ' -> \'
+            b.append("'").append(data.val().replaceAll("\t", "\\t").replaceAll("\n", "\\n").replace("\\", "\\\\").replaceAll("'", "\\'")).append("'");
+        } else {
+            b.append(node.data.val());
+        }
+    }
+
+    public GenericTreeNode<Construct> getNode() {
+        return node;
+    }        
+    
+    @Override
+    public CClosure clone() throws CloneNotSupportedException{
+        CClosure clone = (CClosure) super.clone();
+        if(this.node != null) clone.node = this.node.clone();
+        return clone;
+    }
+    
+    public void execute(){
+        //TODO
+    }
+}
diff --git a/src/main/java/com/laytonsmith/core/constructs/CDouble.java b/src/main/java/com/laytonsmith/core/constructs/CDouble.java
new file mode 100644
index 0000000..53a4366
--- /dev/null
+++ b/src/main/java/com/laytonsmith/core/constructs/CDouble.java
@@ -0,0 +1,43 @@
+/*
+ * To change this template, choose Tools | Templates
+ * and open the template in the editor.
+ */
+
+package com.laytonsmith.core.constructs;
+
+import com.laytonsmith.core.exceptions.ConfigRuntimeException;
+import com.laytonsmith.core.functions.Exceptions.ExceptionType;
+import java.io.File;
+
+/**
+ *
+ * @author layton
+ */
+public class CDouble extends Construct implements Cloneable{
+    
+    public static final long serialVersionUID = 1L;
+    final double val;
+
+    public CDouble(String value, int line_num, File file){
+        super(value, ConstructType.INT, line_num, file);
+        try{
+            val = Double.parseDouble(value);
+        } catch(NumberFormatException e){
+            throw new ConfigRuntimeException("Could not cast " + value + " to double", ExceptionType.FormatException, line_num, file);
+        }
+    }
+
+    public CDouble(double value, int line_num, File file){
+        super(Double.toString(value), ConstructType.DOUBLE, line_num, file);
+        val = value;
+    }
+
+    public double getDouble(){
+        return val;
+    }
+    
+    @Override
+    public CDouble clone() throws CloneNotSupportedException{
+        return (CDouble) super.clone();
+    }
+}
diff --git a/src/main/java/com/laytonsmith/core/constructs/CEntry.java b/src/main/java/com/laytonsmith/core/constructs/CEntry.java
new file mode 100644
index 0000000..b3e028f
--- /dev/null
+++ b/src/main/java/com/laytonsmith/core/constructs/CEntry.java
@@ -0,0 +1,35 @@
+/*
+ * To change this template, choose Tools | Templates
+ * and open the template in the editor.
+ */
+package com.laytonsmith.core.constructs;
+
+import java.io.File;
+
+/**
+ *
+ * @author Layton
+ */
+public class CEntry extends Construct{
+    Construct ckey;
+    Construct construct;
+
+    public CEntry(String value, int line_num, File file){
+        super(value, ConstructType.ENTRY, line_num, file);
+        throw new UnsupportedOperationException("CEntry Constructs cannot use this constructor");
+    }
+    public CEntry(Construct key, Construct value, int line_num, File file){
+        super(key.val() + ":(CEntry)", ConstructType.ENTRY, line_num, file);
+        this.ckey = key;
+        this.construct = value;
+    }
+    
+    @Override
+    public String val(){
+        return construct.val();
+    }
+    
+    public Construct construct(){
+        return this.construct;
+    }
+}
diff --git a/src/main/java/com/laytonsmith/core/constructs/CFunction.java b/src/main/java/com/laytonsmith/core/constructs/CFunction.java
new file mode 100644
index 0000000..d9e23ba
--- /dev/null
+++ b/src/main/java/com/laytonsmith/core/constructs/CFunction.java
@@ -0,0 +1,29 @@
+/*
+ * To change this template, choose Tools | Templates
+ * and open the template in the editor.
+ */
+package com.laytonsmith.core.constructs;
+
+import java.io.File;
+
+/**
+ *
+ * @author layton
+ */
+public class CFunction extends Construct {
+    
+    public static final long serialVersionUID = 1L;
+
+    public CFunction(String name, int line_num, File file) {
+        super(name, ConstructType.FUNCTION, line_num, file);
+    }
+
+    public String toString() {
+        return this.value;
+    }
+    
+    @Override
+    public CFunction clone() throws CloneNotSupportedException{
+        return (CFunction) super.clone();
+    }
+}
diff --git a/src/main/java/com/laytonsmith/core/constructs/CInt.java b/src/main/java/com/laytonsmith/core/constructs/CInt.java
new file mode 100644
index 0000000..6f53612
--- /dev/null
+++ b/src/main/java/com/laytonsmith/core/constructs/CInt.java
@@ -0,0 +1,42 @@
+/*
+ * To change this template, choose Tools | Templates
+ * and open the template in the editor.
+ */
+
+package com.laytonsmith.core.constructs;
+
+import com.laytonsmith.core.exceptions.ConfigRuntimeException;
+import com.laytonsmith.core.functions.Exceptions.ExceptionType;
+import java.io.File;
+
+/**
+ *
+ * @author layton
+ */
+public class CInt extends Construct implements Cloneable{
+    
+    public static final long serialVersionUID = 1L;
+    final long val;
+    public CInt(String value, int line_num, File file){
+        super(value, ConstructType.INT, line_num, file);
+        try{
+            val = Long.parseLong(value);
+        } catch(NumberFormatException e){
+            throw new ConfigRuntimeException("Could not parse " + value + " as an integer", ExceptionType.FormatException, line_num, file);
+        }
+    }
+    
+    public CInt(long value, int line_num, File file){
+        super(Long.toString(value), ConstructType.INT, line_num, file);
+        val = value;
+    }
+
+    public long getInt(){
+        return val;
+    }
+    
+    public CInt clone() throws CloneNotSupportedException{
+        return (CInt) super.clone();
+    }
+
+}
diff --git a/src/main/java/com/laytonsmith/core/constructs/CLabel.java b/src/main/java/com/laytonsmith/core/constructs/CLabel.java
new file mode 100644
index 0000000..f4bd478
--- /dev/null
+++ b/src/main/java/com/laytonsmith/core/constructs/CLabel.java
@@ -0,0 +1,23 @@
+/*
+ * To change this template, choose Tools | Templates
+ * and open the template in the editor.
+ */
+package com.laytonsmith.core.constructs;
+
+import com.laytonsmith.core.constructs.Construct.ConstructType;
+
+/**
+ *
+ * @author Layton
+ */
+public class CLabel extends Construct{
+    Construct label;
+    public CLabel(Construct value){
+        super(value.val(), ConstructType.LABEL, value.line_num, value.file); 
+        label = value;
+    }
+    
+    public Construct cVal(){
+        return label;
+    }
+}
diff --git a/src/main/java/com/laytonsmith/core/constructs/CNull.java b/src/main/java/com/laytonsmith/core/constructs/CNull.java
new file mode 100644
index 0000000..292daf9
--- /dev/null
+++ b/src/main/java/com/laytonsmith/core/constructs/CNull.java
@@ -0,0 +1,31 @@
+/*
+ * To change this template, choose Tools | Templates
+ * and open the template in the editor.
+ */
+
+package com.laytonsmith.core.constructs;
+
+import java.io.File;
+
+/**
+ *
+ * @author layton
+ */
+public class CNull extends Construct implements Cloneable{
+    
+    public static final long serialVersionUID = 1L;
+    public CNull(int line_num, File file){
+        super("null", ConstructType.NULL, line_num, file);
+    }
+    
+    @Override
+    public CNull clone() throws CloneNotSupportedException{
+        return (CNull) super.clone();
+    }
+    
+    @Override
+    public String val(){
+        return null;
+    }
+    
+}
diff --git a/src/main/java/com/laytonsmith/core/constructs/CString.java b/src/main/java/com/laytonsmith/core/constructs/CString.java
new file mode 100644
index 0000000..4771532
--- /dev/null
+++ b/src/main/java/com/laytonsmith/core/constructs/CString.java
@@ -0,0 +1,24 @@
+/*
+ * To change this template, choose Tools | Templates
+ * and open the template in the editor.
+ */
+package com.laytonsmith.core.constructs;
+
+import java.io.File;
+
+/**
+ *
+ * @author Layton
+ */
+public class CString extends Construct implements Cloneable{
+    
+    public static final long serialVersionUID = 1L;
+    public CString(String value, int line_num, File file){
+        super(value, ConstructType.STRING, line_num, file);
+    }
+    
+    @Override
+    public CString clone() throws CloneNotSupportedException{
+        return (CString) super.clone();
+    }
+}
diff --git a/src/main/java/com/laytonsmith/core/constructs/CVoid.java b/src/main/java/com/laytonsmith/core/constructs/CVoid.java
new file mode 100644
index 0000000..3911a23
--- /dev/null
+++ b/src/main/java/com/laytonsmith/core/constructs/CVoid.java
@@ -0,0 +1,24 @@
+/*
+ * To change this template, choose Tools | Templates
+ * and open the template in the editor.
+ */
+package com.laytonsmith.core.constructs;
+
+import java.io.File;
+
+/**
+ *
+ * @author Layton
+ */
+public class CVoid extends Construct implements Cloneable{
+    
+    public static final long serialVersionUID = 1L;
+    public CVoid(int line_num, File file){
+        super("", ConstructType.VOID, line_num, file);
+    }
+    
+    @Override
+    public CVoid clone() throws CloneNotSupportedException{
+        return (CVoid) super.clone();
+    }
+}
diff --git a/src/main/java/com/laytonsmith/core/constructs/Command.java b/src/main/java/com/laytonsmith/core/constructs/Command.java
new file mode 100644
index 0000000..ef96cc5
--- /dev/null
+++ b/src/main/java/com/laytonsmith/core/constructs/Command.java
@@ -0,0 +1,24 @@
+/*
+ * To change this template, choose Tools | Templates
+ * and open the template in the editor.
+ */
+package com.laytonsmith.core.constructs;
+
+import java.io.File;
+
+/**
+ *
+ * @author layton
+ */
+public class Command extends Construct implements Cloneable {
+    
+    public Command(String name, int line_num, File file) {
+        super(name, ConstructType.COMMAND, line_num, file);
+    }
+
+    @Override
+    public Command clone() throws CloneNotSupportedException{
+        return (Command) super.clone();
+    }
+
+}
diff --git a/src/main/java/com/laytonsmith/core/constructs/Construct.java b/src/main/java/com/laytonsmith/core/constructs/Construct.java
new file mode 100644
index 0000000..318408e
--- /dev/null
+++ b/src/main/java/com/laytonsmith/core/constructs/Construct.java
@@ -0,0 +1,221 @@
+/*
+ * To change this template, choose Tools | Templates
+ * and open the template in the editor.
+ */
+package com.laytonsmith.core.constructs;
+
+import com.laytonsmith.core.exceptions.MarshalException;
+import java.io.File;
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+import org.json.simple.JSONArray;
+import org.json.simple.JSONObject;
+import org.json.simple.JSONValue;
+
+/**
+ *
+ * @author layton
+ */
+public abstract class Construct implements Cloneable, Comparable<Construct> {
+
+    public static final long serialVersionUID = 1L;
+
+    public enum ConstructType {
+
+        TOKEN, COMMAND, FUNCTION, VARIABLE, LITERAL, ARRAY, MAP, ENTRY, INT, DOUBLE, BOOLEAN, NULL, STRING, VOID, IVARIABLE, CLOSURE, LABEL
+    }
+    protected ConstructType ctype;
+    protected String value;
+    protected int line_num;
+    transient protected File file;
+
+    public ConstructType getCType() {
+        return ctype;
+    }
+
+    public String getValue() {
+        return value;
+    }
+
+    public int getLineNum() {
+        return line_num;
+    }
+
+    public File getFile() {
+        return file;
+    }
+
+    public Construct(String value, ConstructType ctype, int line_num, File file) {
+        this.value = value;
+        this.ctype = ctype;
+        this.line_num = line_num;
+        this.file = file;
+    }
+
+    public String val() {
+        return value;
+    }
+
+    @Override
+    public String toString() {
+        return value;
+    }
+
+    @Override
+    public Construct clone() throws CloneNotSupportedException {
+        return (Construct) super.clone();
+    }
+
+    /**
+     * This function takes a Construct, and turns it into a JSON value. If the construct is
+     * not one of the following, a MarshalException is thrown: CArray, CBoolean, CDouble, CInt, CNull, 
+     * CString, CVoid, Command. Currently unsupported, but will be in the future are: CClosure/CFunction
+     * The following map is applied when encoding and decoding:
+     * <table border='1'>
+     * <tr><th>JSON</th><th>MScript</th></tr>
+     * <tr><td>string</td><td>CString, CVoid, Command, but all are decoded into CString</td></tr>
+     * <tr><td>number</td><td>CInt, CDouble, and it is decoded intelligently</td></tr>
+     * <tr><td>boolean</td><td>CBoolean</td></tr>
+     * <tr><td>null</td><td>CNull</td></tr>
+     * <tr><td>array/object</td><td>CArray</td></tr>
+     * </table>
+     * @param c
+     * @return 
+     */
+    public static String json_encode(Construct c, int line_num, File f) throws MarshalException{
+        return json_encode(c, false, line_num, f);
+    }
+
+    /**
+     * Use the other one.
+     * @deprecated 
+     * @param c
+     * @param raw
+     * @param line_num
+     * @param f
+     * @return
+     * @throws MarshalException
+     * @deprecated
+     */
+    @Deprecated
+    public static String json_encode(Construct c, boolean raw, int line_num, File f) throws MarshalException {
+        return JSONValue.toJSONString(json_encode0(c, line_num, f));
+    }
+    
+    private static Object json_encode0(Construct c, int line_num, File f) throws MarshalException{
+        if (c instanceof CString || c instanceof Command) {
+            return c.val();
+        } else if (c instanceof CVoid) {
+            return "";
+        } else if (c instanceof CInt) {
+            return ((CInt) c).getInt();
+        } else if (c instanceof CDouble) {
+            return ((CDouble) c).getDouble();
+        } else if (c instanceof CBoolean) {
+            return ((CBoolean) c).getBoolean();
+        } else if (c instanceof CNull) {
+            return null;
+        } else if (c instanceof CArray) {
+            CArray ca = (CArray) c;
+            if (!ca.inAssociativeMode()) {
+                List<Object> list = new ArrayList<Object>();
+                for(int i = 0; i < ca.size(); i++){
+                    list.add(json_encode0(ca.get(i, line_num, f), line_num, f));
+                }
+                return list;
+            } else {
+                Map<String, Object> map = new HashMap<String, Object>();
+                for(String key : ca.keySet()){
+                    map.put(key, json_encode0(ca.get(key, line_num, f), line_num, f));
+                }
+                return map;
+            }
+        } else {
+            throw new MarshalException("The type of " + c.getClass().getSimpleName() + " is not currently supported", c);
+        }
+    }
+    /**
+     * Takes a string and converts it into a Construct
+     * @param s
+     * @return 
+     */
+    public static Construct json_decode(String s, int line_num, File f) throws MarshalException {
+        if (s.startsWith("{")) {
+            //Object
+            JSONObject obj = (JSONObject) JSONValue.parse(s);
+            CArray ca = new CArray(line_num, f);
+            ca.forceAssociativeMode();
+            for(Object key : obj.keySet()){
+                ca.set(convertJSON(key, line_num, f), 
+                        convertJSON(obj.get(key), line_num, f));
+            }
+            return ca;
+        } else if (s.startsWith("[")) {
+            //It's an array
+            JSONArray array = (JSONArray) JSONValue.parse(s);
+            CArray carray = new CArray(line_num, f);
+            for (int i = 0; i < array.size(); i++) {
+                carray.push(convertJSON(array.get(i), line_num, f));
+            }
+            return carray;
+        } else {
+            //It's a single value, but we're gonna wrap it in an array, then deconstruct it
+            s = "[" + s + "]";
+            JSONArray array = (JSONArray) JSONValue.parse(s);
+            Object o = array.get(0);
+            return convertJSON(o, line_num, f);
+        }
+    }
+
+    private static Construct convertJSON(Object o, int line_num, File f) throws MarshalException {
+        if (o instanceof String) {
+            return new CString((String) o, 0, null);
+        } else if (o instanceof Number) {
+            Number n = (Number) o;
+            if (n.longValue() == n.doubleValue()) {
+                //It's an int
+                return new CInt(n.longValue(), 0, null);
+            } else {
+                //It's a double
+                return new CDouble(n.doubleValue(), 0, null);
+            }
+        } else if (o instanceof Boolean) {
+            return new CBoolean(((Boolean) o).booleanValue(), 0, null);
+        } else if (o instanceof java.util.List) {
+            java.util.List l = (java.util.List) o;
+            CArray ca = new CArray(line_num, f);
+            for (int i = 0; i < l.size(); i++) {
+                ca.push(convertJSON(l.get(i), line_num, f));
+            }
+            return ca;
+        } else if (o == null) {
+            return new CNull(0, null);
+        } else if(o instanceof java.util.Map){
+            CArray ca = new CArray(line_num, f);
+            ca.forceAssociativeMode();
+            for(Object key : ((java.util.Map)o).keySet()){
+                ca.set(convertJSON(key, line_num, f), 
+                        convertJSON(((java.util.Map)o).get(key), line_num, f));
+            }
+            return ca;
+        } else {
+            throw new MarshalException(o.getClass().getSimpleName() + " are not currently supported");
+        }
+    }
+
+    public int compareTo(Construct c) {
+        if(this.value.contains(" ") || this.value.contains("\t") 
+                || c.value.contains(" ") || c.value.contains("\t")){
+            return this.value.compareTo(c.value);
+        }
+        try {
+            Double d1 = Double.valueOf(this.value);
+            Double d2 = Double.valueOf(c.value);
+            return d1.compareTo(d2);
+        } catch (NumberFormatException e) {
+            return this.value.compareTo(c.value);
+        }
+    }
+}
diff --git a/src/main/java/com/laytonsmith/core/constructs/IVariable.java b/src/main/java/com/laytonsmith/core/constructs/IVariable.java
new file mode 100644
index 0000000..aa44938
--- /dev/null
+++ b/src/main/java/com/laytonsmith/core/constructs/IVariable.java
@@ -0,0 +1,57 @@
+/*
+ * To change this template, choose Tools | Templates
+ * and open the template in the editor.
+ */
+
+package com.laytonsmith.core.constructs;
+
+import java.io.File;
+
+/**
+ *
+ * @author layton
+ */
+public class IVariable extends Construct implements Cloneable{
+    
+    public static final long serialVersionUID = 1L;
+    private Construct var_value;
+    final private String name;
+
+    public IVariable(String name, int line_num, File file){
+        super(name, ConstructType.IVARIABLE, line_num, file);
+        this.var_value = new CString("", line_num, file);
+        this.name = name;
+    }
+    public IVariable(String name, Construct value, int line_num, File file){
+        super(name, ConstructType.IVARIABLE, line_num, file);
+        this.var_value = value;
+        this.name = name;
+    }
+    @Override
+    public String val(){
+        return var_value.val();
+    }
+    public Construct ival(){
+        return var_value;
+    }
+    public String getName(){
+        return name;
+    }
+    public void setIval(Construct c){
+        var_value = c;
+    }
+
+    @Override
+    public String toString() {
+        return this.name + ":(" + this.ival().getClass().getSimpleName() + ") '" + this.ival().val() + "'";
+    }
+    
+    
+    @Override
+    public IVariable clone() throws CloneNotSupportedException{
+        IVariable clone = (IVariable) super.clone();
+        if(this.var_value != null) clone.var_value = this.var_value.clone();
+        return (IVariable) clone;
+    }
+
+}
diff --git a/src/main/java/com/laytonsmith/core/constructs/Token.java b/src/main/java/com/laytonsmith/core/constructs/Token.java
new file mode 100644
index 0000000..6748fb7
--- /dev/null
+++ b/src/main/java/com/laytonsmith/core/constructs/Token.java
@@ -0,0 +1,75 @@
+/*
+ * To change this template, choose Tools | Templates
+ * and open the template in the editor.
+ */
+package com.laytonsmith.core.constructs;
+
+import java.io.File;
+
+/**
+ *
+ * @author layton
+ */
+public class Token{
+    public TType type;
+    public String value;
+    public int line_num;
+    public File file;
+    
+    public enum TType{
+        UNKNOWN, LSQUARE_BRACKET, RSQUARE_BRACKET, OPT_VAR_ASSIGN, ALIAS_END, COMMA, FUNC_NAME, FUNC_START,
+        FUNC_END, STRING, NEWLINE, MULTILINE_START, MULTILINE_END, COMMAND, SEPERATOR, VARIABLE,
+        IVARIABLE, FINAL_VAR, LIT, ROOT, IDENT
+    }
+    public Token(TType type, String value, int line_num, File file) {
+        this.type = type;
+        this.value = value;
+        this.line_num = line_num;
+        this.file = file;
+    }
+    
+    public String val(){
+        return value;
+    }
+
+    @Override
+    public int hashCode() {
+        int hash = 7;
+        hash = 59 * hash + (this.type != null ? this.type.hashCode() : 0);
+        hash = 59 * hash + (this.value != null ? this.value.hashCode() : 0);
+        return hash;
+    }
+    
+    public boolean equals(Object o){
+        if(o instanceof Token){
+            Token t = (Token)o;
+            return (this.type.equals(t.type) && this.value.equals(t.value));
+        }
+        return false;
+    }
+
+    @Override
+    public String toString() {
+        if (type.equals(TType.NEWLINE)) {
+            return "newline";
+        }
+        if (type.equals(TType.STRING)) {
+            return "string:'" + value + "'";
+        }
+        return type + ":" + value;
+    }
+
+    public String toSimpleString() {
+        if (type.equals(TType.STRING)) {
+            return "'" + value + "'";
+        }
+        return value;
+    }
+
+    public String toOutputString() {
+        if (type.equals(TType.STRING)) {
+            return value.replace("'", "\\'");
+        }
+        return value;
+    }
+}
diff --git a/src/main/java/com/laytonsmith/core/constructs/Variable.java b/src/main/java/com/laytonsmith/core/constructs/Variable.java
new file mode 100644
index 0000000..629df84
--- /dev/null
+++ b/src/main/java/com/laytonsmith/core/constructs/Variable.java
@@ -0,0 +1,77 @@
+/*
+ * To change this template, choose Tools | Templates
+ * and open the template in the editor.
+ */
+package com.laytonsmith.core.constructs;
+
+import com.laytonsmith.core.Static;
+import java.io.File;
+
+/**
+ *
+ * @author layton
+ */
+public class Variable extends Construct {
+    
+    public static final long serialVersionUID = 1L;
+
+    final private String name;
+    private String def;
+    private boolean optional;
+    private boolean final_var;
+    private Construct var_value;
+    
+
+    public Variable(String name, String def, boolean optional, boolean final_var, int line_num, File file) {
+        super(name, ConstructType.VARIABLE, line_num, file);
+        this.name = name;
+        this.def = def;
+        this.final_var = final_var;
+        this.optional = optional;
+        this.var_value = Static.resolveConstruct(def, line_num, file);
+    }
+    
+    public Variable(String name, String def, int line_num, File file){
+        this(name, def, false, false, line_num, file);
+    }
+
+    @Override
+    public String toString() {
+        return "var:" + name;
+    }
+    public String getName(){
+        return name;
+    }
+    public void setFinal(boolean final_var){
+        this.final_var = final_var;
+    }
+    public boolean isFinal(){
+        return final_var;
+    }
+    public void setOptional(boolean optional){
+        this.optional = optional;
+    }
+    public boolean isOptional(){
+        return optional;
+    }
+    public String getDefault(){
+        return def;
+    }
+    public void setDefault(String def){
+        this.def = def;
+    }
+    @Override
+    public String val(){
+        return var_value.toString();
+    }
+    public void setVal(Construct val){
+        this.var_value = val;
+    }
+    @Override
+    public Variable clone() throws CloneNotSupportedException{
+        Variable clone = (Variable) super.clone();
+        if(this.var_value != null) clone.var_value = var_value;
+        return clone;
+    }
+
+}
diff --git a/src/main/java/com/laytonsmith/core/docs.java b/src/main/java/com/laytonsmith/core/docs.java
new file mode 100644
index 0000000..c7588db
--- /dev/null
+++ b/src/main/java/com/laytonsmith/core/docs.java
@@ -0,0 +1,24 @@
+/*
+ * To change this template, choose Tools | Templates
+ * and open the template in the editor.
+ */
+package com.laytonsmith.core;
+
+import java.lang.annotation.ElementType;
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
+import java.lang.annotation.Target;
+
+/**
+ * Used to tag the documentation portion of a certain method type. The annotated
+ * code must implement the Documentation interface.
+ * @author layton
+ */
+@Retention(RetentionPolicy.RUNTIME)
+@Target(ElementType.TYPE)
+public @interface docs {
+    public enum type{
+        EVENT, FUNCTION
+    }
+    public type type();
+}
diff --git a/src/main/java/com/laytonsmith/core/events/AbstractEvent.java b/src/main/java/com/laytonsmith/core/events/AbstractEvent.java
new file mode 100644
index 0000000..a0da535
--- /dev/null
+++ b/src/main/java/com/laytonsmith/core/events/AbstractEvent.java
@@ -0,0 +1,145 @@
+/*
+ * To change this template, choose Tools | Templates
+ * and open the template in the editor.
+ */
+package com.laytonsmith.core.events;
+
+import com.laytonsmith.core.Env;
+import com.laytonsmith.core.Script;
+import com.laytonsmith.core.constructs.CArray;
+import com.laytonsmith.core.constructs.Construct;
+import com.laytonsmith.core.exceptions.ConfigRuntimeException;
+import com.laytonsmith.core.exceptions.EventException;
+import com.laytonsmith.core.exceptions.PrefilterNonMatchException;
+import java.util.HashMap;
+import java.util.Map;
+
+/**
+ * This helper class implements a few of the common functions in event, and
+ * most (all?) Events should extend this class.
+ * @author layton
+ */
+public abstract class AbstractEvent implements Event, Comparable<Event> {
+    
+    protected EventMixinInterface mixin;
+    protected EventHandlerInterface handler;
+    
+    protected AbstractEvent(EventHandlerInterface handler){
+        this.handler = handler;
+    }
+    
+    public final void setAbstractEventMixin(EventMixinInterface mixin){
+        this.mixin = mixin;
+    }
+    
+
+    /**
+     * If the event needs to run special code when a player binds the event, it
+     * can be done here. By default, an UnsupportedOperationException is thrown,
+     * but is caught and ignored.
+     */
+    public void bind() {
+        throw new UnsupportedOperationException("Not supported yet.");
+    }
+
+    /**
+     * If the event needs to run special code at server startup, it can be done
+     * here. By default, an UnsupportedOperationException is thrown, but is caught
+     * and ignored.
+     */
+    public void hook() {
+        throw new UnsupportedOperationException("Not supported yet.");
+    }
+
+    
+    /**
+     * This function is run when the actual event occurs.
+     * @param s
+     * @param b 
+     */
+    public final void execute(Script s, BoundEvent b, Env env, BoundEvent.ActiveEvent activeEvent) throws ConfigRuntimeException{          
+        try{
+            handler.preExecution(env, activeEvent);
+        } catch(UnsupportedOperationException e){
+            //Ignore. This particular event doesn't need to customize
+        }
+        s.run(null, env, null);
+        try{
+            handler.postExecution(env, activeEvent);
+        } catch(UnsupportedOperationException e){
+            //Ignore.
+        }
+    }
+
+    /**
+     * For sorting and optimizing events, we need a comparison operation. By default
+     * it is compared by looking at the event name.
+     * @param o
+     * @return 
+     */
+    public int compareTo(Event o) {
+        return this.getName().compareTo(o.getName());
+    }
+    
+    /**
+     * Since most events are minecraft events, we return true by default.
+     * @return 
+     */
+    public boolean supportsExternal(){
+        return true;
+    }
+    
+    /**
+     * If it is ok to by default do a simple conversion from a CArray to a
+     * Map, this method can do it for you. Likely this is not acceptable,
+     * so hard-coding the conversion will be necessary.
+     * @param manualObject
+     * @return 
+     */
+    public static Object DoConvert(CArray manualObject){
+        Map<String, Construct> map = new HashMap<String, Construct>();
+        for(String key : manualObject.keySet()){
+            map.put(key, manualObject.get(key, 0, null));
+        }
+        return map;        
+    }
+    
+    public boolean matches(Map<String, Construct> prefilter, Object e) throws PrefilterNonMatchException{
+        return handler.matches(prefilter, e);
+    }
+    
+    public Map<String, Construct> evaluate(Object e) throws EventException{
+        return handler.evaluate(e, this.mixin);
+    }
+    
+    public Object convert(CArray manual) throws ConfigRuntimeException{
+        //So as to return the appropriate exception if a parameter is missing,
+        //force the array into associative mode
+        manual.forceAssociativeMode();
+        return handler.convert(manual);
+    }
+    
+    public boolean modifyEvent(String key, Construct value, Object event){
+        return handler.modifyEvent(key, value, event);
+    }
+    
+    /**
+     * By default, this function triggers the event by calling the mixin
+     * handler. If this is not the desired behavior, this method can be overridden
+     * in the actual event (if it's an external event, for instance)
+     * @param o 
+     */
+    public void manualTrigger(Object o){
+        mixin.manualTrigger(o);
+    }
+    
+    public void cancel(Object o, boolean state){
+        mixin.cancel(o, state);
+    }
+    
+    public boolean isCancellable(Object o){
+        return mixin.isCancellable(o);
+    }
+    
+    
+}
diff --git a/src/main/java/com/laytonsmith/core/events/BoundEvent.java b/src/main/java/com/laytonsmith/core/events/BoundEvent.java
new file mode 100644
index 0000000..433564c
--- /dev/null
+++ b/src/main/java/com/laytonsmith/core/events/BoundEvent.java
@@ -0,0 +1,471 @@
+/*
+ * To change this template, choose Tools | Templates
+ * and open the template in the editor.
+ */
+package com.laytonsmith.core.events;
+
+import com.laytonsmith.PureUtilities.Pair;
+import com.laytonsmith.abstraction.MCPlayer;
+import com.laytonsmith.core.Env;
+import com.laytonsmith.core.GenericTreeNode;
+import com.laytonsmith.core.Script;
+import com.laytonsmith.core.Static;
+import com.laytonsmith.core.constructs.*;
+import com.laytonsmith.core.exceptions.ConfigRuntimeException;
+import com.laytonsmith.core.exceptions.EventException;
+import java.io.File;
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+import java.util.logging.Level;
+import java.util.logging.Logger;
+
+/**
+ * This class represents an actually bound event. When the script runs bind(), a
+ * new BoundEvent is created as a closure. 
+ * @author layton
+ */
+public class BoundEvent implements Comparable<BoundEvent> {
+
+    private final String eventName;
+    private final String id;
+    private final Priority priority;
+    private final Map<String, Construct> prefilter;
+    private final String eventObjName;
+    private Env originalEnv;
+    private final GenericTreeNode<Construct> tree; //The code closure for this event
+    private final Driver driver; //For efficiency sake, cache it here
+    private static int EventID = 0;
+    private final int line_num;
+    private final File file;
+
+    /**
+     * Returns a unique ID that can be used to identify an event.
+     * @return 
+     */
+    private static int GetUniqueID() {
+        synchronized (BoundEvent.class) {
+            return ++EventID;
+        }
+    }
+    
+
+    /**
+     * Event priorities. This is sorted and events are run in a particular order.
+     */
+    public enum Priority {
+        LOWEST(5),
+        LOW(4),
+        NORMAL(3),
+        HIGH(2),
+        HIGHEST(1),
+        MONITOR(1000);
+        private final int id;
+
+        private Priority(int i) {
+            this.id = i;
+        }
+
+        public int getId() {
+            return this.id;
+        }
+        
+        public boolean isHigherPriority(Priority other){
+            return other.getId() > this.getId();
+        }
+        
+        public boolean isLowerPriority(Priority other){
+            return other.getId() < this.getId();
+        }
+    }
+
+    /**
+     * Compares two event's IDs, and if they are the same, they should
+     * be the actual same event. Since only one event of a given ID exists,
+     * technically == should work on these events.
+     * @param obj
+     * @return 
+     */
+    @Override
+    public boolean equals(Object obj) {
+        if (obj instanceof BoundEvent) {
+            return this.id.equals(((BoundEvent) obj).id);
+        } else {
+            return false;
+        }
+    }
+
+    @Override
+    public int hashCode() {
+        return id.hashCode();
+    }
+
+    @Override
+    public String toString() {
+        return "(" + eventName + ") " + id;
+    }
+
+    /**
+     * Constructs a new BoundEvent.
+     * @param name The name of the event
+     * @param options The options for this event. Contains the priority and assigned id, possibly
+     * @param prefilter The prefilter provided by the user
+     * @param eventObjName The name of the variable that should be assigned the event object
+     * @param env The script's environment
+     * @param tree The closure of the BoundEvent
+     * @throws EventException If the priority or id are improperly specified
+     */
+    public BoundEvent(String name, CArray options, CArray prefilter, String eventObjName,
+            Env env, GenericTreeNode<Construct> tree, int line_num, File file) throws EventException {
+        this.eventName = name;
+
+        if (options != null && options.containsKey("id")) {
+            this.id = options.get("id").val();
+            if (this.id.matches(".*?:\\d*?")) {
+                throw new EventException("The id given may not match the format\"string:number\"");
+            }
+        } else {
+            //Generate a new event id
+            id = name + ":" + GetUniqueID();
+        }
+        if (options != null && options.containsKey("priority")) {
+            try{
+            this.priority = Priority.valueOf(options.get("priority").val().toUpperCase());
+            } catch(IllegalArgumentException e){
+                throw new EventException("Priority must be one of: LOWEST, LOW, NORMAL, HIGH, HIGHEST, MONITOR");                
+            }
+        } else {
+            this.priority = Priority.NORMAL;
+        }
+
+        this.prefilter = new HashMap<String, Construct>();
+        if (prefilter != null) {
+            for (String key : prefilter.keySet()) {
+                this.prefilter.put(key, prefilter.get(key, 0, null));
+            }
+        }
+
+        this.originalEnv = env;
+        this.tree = tree;
+        
+        if(EventList.getEvent(this.eventName) == null){
+            throw new EventException("No event named \"" + this.eventName + "\" is registered!");
+        }
+        this.driver = EventList.getEvent(this.eventName).driver();
+        this.eventObjName = eventObjName;
+        
+        this.line_num = line_num;
+        this.file = file;
+
+    }
+
+    public int getLineNum(){
+        return line_num;
+    }
+    
+    public File getFile(){
+        return file;
+    }
+    
+    public String getEventName() {
+        return eventName;
+    }
+
+    public String getEventObjName() {
+        return eventObjName;
+    }
+
+    public Driver getDriver() {
+        return driver;
+    }
+
+    public String getId() {
+        return id;
+    }
+
+    public Map<String, Construct> getPrefilter() {
+        return prefilter;
+    }
+
+    public Priority getPriority() {
+        return priority;
+    }
+
+
+    /**
+     * Events are sorted by priority
+     * @param o
+     * @return 
+     */
+    public int compareTo(BoundEvent o) {
+        if (this.getPriority().getId() < o.getPriority().getId()) {
+            return -1;
+        } else if (this.getPriority().getId() > o.getPriority().getId()) {
+            return 1;
+        } else {
+            return this.id.compareTo(o.id);
+        }
+    }
+
+    /**
+     * When the event actually occurs, this should be run, after translating the
+     * original event object (of whatever type it may be) into a standard map, which
+     * contains the event object data. It is converted into a CArray here, and then
+     * the script is executed with the driver's execute function.
+     * @param event 
+     */
+    public void trigger(ActiveEvent activeEvent) throws EventException {
+        try {
+    //        GenericTree<Construct> root = new GenericTree<Construct>();
+    //        root.setRoot(tree);
+            Env env = originalEnv.clone();
+            CArray ca = new CArray(0, null);
+            for (String key : activeEvent.parsedEvent.keySet()) {
+                ca.set(new CString(key, 0, null), activeEvent.parsedEvent.get(key));
+            }
+            if(activeEvent.parsedEvent.containsKey("player")){
+                MCPlayer p = Static.getServer().getPlayer(activeEvent.parsedEvent.get("player").val());
+                if(p != null && p.isOnline()){
+                    env.SetPlayer(p);                
+                }
+            }
+            env.GetVarList().set(new IVariable(eventObjName, ca, 0, null));
+            env.SetEvent(activeEvent);
+            activeEvent.addHistory("Triggering bound event: " + this);
+            try{
+                this.execute(env, activeEvent);
+            } catch(ConfigRuntimeException e){
+                //We don't know how to handle this, but we need to set the env,
+                //then pass it up the chain
+                e.setEnv(env);
+                throw e;
+            }
+        } catch (CloneNotSupportedException ex) {
+            Logger.getLogger(BoundEvent.class.getName()).log(Level.SEVERE, null, ex);
+        }
+    }
+    
+    /**
+     * Used to manually trigger an event, the underlying event is set to null.
+     * @param event
+     * @throws EventException 
+     */
+    public void manual_trigger(CArray event) throws EventException{
+        try {
+            Env env = originalEnv.clone();
+            env.GetVarList().set(new IVariable(eventObjName, event, 0, null));
+            Map<String, Construct> map = new HashMap<String, Construct>();
+            for(String key : event.keySet()){
+                map.put(key, event.get(key, 0, null));
+            }
+            ActiveEvent activeEvent = new ActiveEvent(null);
+            activeEvent.setParsedEvent(map);
+            activeEvent.setBoundEvent(this);
+            env.SetEvent(activeEvent);
+            this.execute(env, activeEvent);
+        } catch (CloneNotSupportedException ex) {
+            Logger.getLogger(BoundEvent.class.getName()).log(Level.SEVERE, null, ex);
+        }
+    }
+    
+    private void execute(Env env, ActiveEvent activeEvent) throws EventException{
+        GenericTreeNode<Construct> superRoot = new GenericTreeNode<Construct>(null);
+        superRoot.addChild(tree);
+        Script s = Script.GenerateScript(superRoot, "*");        
+        Event myDriver = this.getEventDriver();
+        myDriver.execute(s, this, env, activeEvent);
+    }
+    
+    /**
+     * Returns the Event driver that knows how to handle this event.
+     * @return 
+     */
+    public Event getEventDriver(){
+        return EventList.getEvent(this.getDriver(), this.getEventName());
+    }
+    
+    /**
+     * The bound event is essentially an ActiveEvent generator. Because bound events don't change from run to run, it doesn't
+     * make sense to store triggered event specific information with the bound event itself. Instead, when the event is triggered,
+     * an ActiveEvent is generated, stored in the environment, and then the script is triggered. This ActiveEvent contains both
+     * the underlying event (if needed for things like cancellation or other event manipulation) and the BoundEvent object itself
+     * (which can be used to get the event id and other information as needed). For convenience, the parsed event information
+     * is also cached here.
+     */
+    public static class ActiveEvent{
+        private final Object underlyingEvent;
+        private Map<String, Construct> parsedEvent;
+        private BoundEvent boundEvent;
+        private boolean cancelled;
+        private BoundEvent consumedAt;
+        private final Map<String, BoundEvent> lockedAt;
+        private final List<Pair<CClosure, Env>> whenCancelled;
+        private final List<Pair<CClosure, Env>> whenTriggered;
+        
+        private final List<String> history;
+        
+        public ActiveEvent(Object underlyingEvent){
+            this.underlyingEvent = underlyingEvent;
+            this.cancelled = false;
+            whenCancelled = new ArrayList<Pair<CClosure, Env>>();
+            whenTriggered = new ArrayList<Pair<CClosure, Env>>();
+            lockedAt = new HashMap<String, BoundEvent>();
+            history = new ArrayList<String>();
+        }
+        
+        public void addHistory(String history){
+            if(((Boolean)Static.getPreferences().getPreference("debug-mode"))){
+                this.history.add(Static.ParseCalendarNotation("%Y-%M-%D %h:%m.%s - ") + history);
+            }
+        }
+        
+        public List<String> getHistory(){
+            return history;
+        }
+
+        public Map<String, Construct> getParsedEvent() {
+            return parsedEvent;
+        }
+
+        public Object getUnderlyingEvent() {
+            return underlyingEvent;
+        }
+
+        public BoundEvent getBoundEvent() {
+            return boundEvent;
+        }
+        
+        public void setBoundEvent(BoundEvent boundEvent){
+            this.boundEvent = boundEvent;
+        }
+        
+        public void setParsedEvent(Map<String, Construct> parsedEvent){
+            this.parsedEvent = parsedEvent;
+        }
+
+        public boolean isCancelled() {
+            return cancelled;
+        }
+
+        public void setCancelled(boolean cancelled) {
+            this.addHistory("Setting cancelled flag to " + cancelled + " " + boundEvent);
+            this.cancelled = cancelled;
+            try {
+                boundEvent.getEventDriver().cancel(underlyingEvent, cancelled);
+            } catch (EventException ex) {
+                //Ignore this exception. This is thrown if the event isn't cancellable.
+                //Who cares.
+            }
+        }         
+        
+        public Event getEventDriver(){
+            return this.boundEvent.getEventDriver();
+        }
+
+        public boolean isCancellable() {
+            return boundEvent.getEventDriver().isCancellable(this.underlyingEvent);
+        }
+        
+        public void consume(){
+            this.addHistory("Consuming event" + boundEvent);
+            if(consumedAt == null){
+                consumedAt = boundEvent;
+            }
+        }
+        
+        public boolean canReceive(){
+            if(consumedAt == null){
+                return true;
+            }
+            return consumedAt.getPriority().isLowerPriority(boundEvent.getPriority());
+        }
+        
+        public boolean isConsumed(){
+            return consumedAt != null;
+        }
+        
+        public Priority consumedAt(){
+            return consumedAt.getPriority();
+        }
+        
+        public void lock(String parameter){
+            this.addHistory("Locking " + (parameter==null?"the whole event":parameter) + " " + boundEvent);
+            if(lockedAt.containsKey(null)){
+                return; //Everything is already locked
+            }
+            if(parameter == null && !lockedAt.containsKey(null)){
+                lockedAt.put(null, boundEvent); //Everything is locked now
+            } else if(!lockedAt.containsKey(parameter)) {
+                lockedAt.put(parameter, boundEvent);
+            }
+        }
+        
+        public boolean isLocked(String parameter){           
+            Priority param = lockedAt.get(parameter)==null?null:lockedAt.get(parameter).getPriority();
+            Priority global = lockedAt.get(parameter)==null?null:lockedAt.get(null).getPriority();
+            if(param == null && global == null){
+                return false;
+            } else if(param == null){
+                return global.isHigherPriority(boundEvent.getPriority());
+            } else if(global == null){
+                return param.isHigherPriority(boundEvent.getPriority());
+            } else {
+                if(param.isHigherPriority(global)){
+                    return param.isHigherPriority(boundEvent.getPriority());
+                } else {
+                    return global.isHigherPriority(boundEvent.getPriority());
+                }
+            }
+        }
+        
+        public Priority lockedAt(String parameter){            
+            Priority param = lockedAt.get(parameter)==null?null:lockedAt.get(parameter).getPriority();
+            Priority global = lockedAt.get(parameter)==null?null:lockedAt.get(null).getPriority();
+            if(param == null && global == null){
+                return null; //It's not locked
+            } else if(param == null){
+                return global; //It's not parameter locked, but it is globally locked
+            } else if(global == null){
+                return param; //It's not globally locked, but it is parameter locked
+            } else {
+                //It's both. The higher priority one wins.
+                if(param.isHigherPriority(global)){
+                    return param;
+                } else {
+                    return global;
+                }
+            }
+        }
+        
+        public void addWhenTriggered(CClosure tree){
+            this.addHistory("Adding a whenTriggered callback. " + boundEvent);
+            try {
+                whenTriggered.add(new Pair<CClosure, Env>(tree, boundEvent.originalEnv.clone()));
+            } catch (CloneNotSupportedException ex) {
+                Logger.getLogger(BoundEvent.class.getName()).log(Level.SEVERE, null, ex);
+            }
+        }
+        
+        public void addWhenCancelled(CClosure tree){
+            this.addHistory("Adding a whenCancelled callback. " + boundEvent);
+            try {
+                whenCancelled.add(new Pair<CClosure, Env>(tree, boundEvent.originalEnv.clone()));
+            } catch (CloneNotSupportedException ex) {
+                Logger.getLogger(BoundEvent.class.getName()).log(Level.SEVERE, null, ex);
+            }
+        }
+        
+        public void executeTriggered(){
+//            for(Pair<CClosure, Env> pair : whenTriggered){
+//                MScriptCompiler.execute(pair.fst, pair.snd, null, null);
+//            }            
+        }
+        
+        public void executeCancelled(){
+//            for(Pair<CClosure, Env> pair : whenCancelled){
+//                MScriptCompiler.execute(pair.fst, pair.snd, null, null);
+//            }            
+        }
+    }
+}
diff --git a/src/main/java/com/laytonsmith/core/events/Driver.java b/src/main/java/com/laytonsmith/core/events/Driver.java
new file mode 100644
index 0000000..c46b1b4
--- /dev/null
+++ b/src/main/java/com/laytonsmith/core/events/Driver.java
@@ -0,0 +1,17 @@
+/*
+ * To change this template, choose Tools | Templates
+ * and open the template in the editor.
+ */
+package com.laytonsmith.core.events;
+
+/**
+ * This class is an enum class that represents all the types of events that CH is aware of. The
+ * reason an enum is required, is because events can more easily be sorted and found this way.
+ * @author layton
+ */
+public enum Driver {
+    PLAYER_JOIN,    
+    PLAYER_INTERACT, 
+    PLAYER_SPAWN,     
+    PLAYER_DEATH,
+}
diff --git a/src/main/java/com/laytonsmith/core/events/Event.java b/src/main/java/com/laytonsmith/core/events/Event.java
new file mode 100644
index 0000000..61a71c9
--- /dev/null
+++ b/src/main/java/com/laytonsmith/core/events/Event.java
@@ -0,0 +1,134 @@
+/*
+ * To change this template, choose Tools | Templates
+ * and open the template in the editor.
+ */
+package com.laytonsmith.core.events;
+
+import com.laytonsmith.core.Documentation;
+import com.laytonsmith.core.Env;
+import com.laytonsmith.core.Script;
+import com.laytonsmith.core.constructs.CArray;
+import com.laytonsmith.core.constructs.Construct;
+import com.laytonsmith.core.events.BoundEvent.ActiveEvent;
+import com.laytonsmith.core.exceptions.EventException;
+import com.laytonsmith.core.exceptions.PrefilterNonMatchException;
+import java.util.Map;
+
+/**
+ * This interface should be implemented to allow the bind() function to bind to
+ * a particular event type. To be recognized as an event type, it should also tag
+ * itself with @api, and it will be included in the EventList.
+ * @author layton
+ */
+public interface Event extends Comparable<Event>, Documentation{
+    /**
+     * This should return the name of the event.
+     * @return 
+     */
+    public String getName();
+    /**
+     * This should return the docs that are used in the wiki. The format should
+     * be as follows: {prefilter: explanation | ...} Documentation {event_obj: explanation | ...}
+     * The explanation for the prefilter may follow certain formatting, which will expand to a link:
+     * &lt;string match&gt;<br />
+     * &lt;regex&gt;<br />
+     * &lt;math match&gt;<br />
+     * &lt;expr&gt;
+     * @return 
+     */
+    public String docs();
+
+    /**
+     * This function should return true if the event code should be run, based
+     * on this prefilter and triggering event's parameters.
+     */
+    public boolean matches(Map<String, Construct> prefilter, Object e) throws PrefilterNonMatchException;
+    
+    /**
+     * If an event is manually triggered, then it may be required for an event
+     * object to be faked, so the rest of the event will work properly.
+     * @param manualObject
+     * @return 
+     */
+    public Object convert(CArray manualObject);
+    
+    /**
+     * This function is called when an event is triggered. It passes the event, and expects
+     * back a Map, which will be converted into a CArray, and passed to the bound event,
+     * as the event object. If an EventException is thrown, it is considered a fatal error,
+     * and will throw an uncatchable CH exception.
+     * @param e
+     * @return 
+     */
+    public Map<String, Construct> evaluate(Object e) throws EventException;
+    
+    /**
+     * This is called to determine if an event is cancellable in the first place
+     */
+    public boolean isCancellable(Object e);
+    
+    /**
+     * This is called if the script attempts to cancel the event, so the underlying
+     * event can also be cancelled. If the underlying event is not cancellable, this
+     * should throw an EventException, which is caught in the triggering code, and
+     * at this time ignored.
+     */
+    public void cancel(Object e, boolean state) throws EventException;
+    
+    
+    /**
+     * This function returns the "driver" class of the event needed to trigger it.
+     * Though not strictly needed, this method helps optimize code. All events may
+     * more strictly filter events based on other conditions, but all events must
+     * have a single Type of event that drives the CH event. This is also the type of
+     * the event that will be sent to the matches function.
+     */
+    public Driver driver();
+    
+    /**
+     * This function is called once a script binds to this event, which gives 
+     * this event type a chance to "activate" if needed. It may throw an 
+     * UnsupportedOperationException if it is not needed. The listener
+     * is automatically registered, based on the driver returned.
+     */
+    public void bind();
+    
+    /**
+     * This function is called once when the plugin starts up, to give this
+     * event a chance to make a hook into the server if it needs it.
+     * It may throw an UnsupportedOperationException if it is not needed.
+     */
+    public void hook();
+    
+    /**
+     * Because an event type knows best how to actually trigger an event, the prebuild,
+     * preconfigured script, and the BoundEvent generating the action are passed to
+     * the Event itself. AbstractEvent's default implementation is to simply run the
+     * script, but an event can choose to override this functionality if needed.
+     */
+    public void execute(Script s, BoundEvent b, Env env, ActiveEvent activeEvent) throws EventException;
+    
+    /**
+     * If it is required to do something extra for server wide events, this can be
+     * done here. This is called when the EventHandler is instructed to manually trigger
+     * this event server-wide.
+     * @param e 
+     */
+    public void manualTrigger(Object e);
+    
+    /**
+     * If the event is an external event, and there is no reason to attempt a serverwide manual
+     * triggering, this function should return false, in which case the serverWide variable
+     * is ignored, and it is only piped through CH specific handlers.
+     * @return 
+     */
+    public boolean supportsExternal();
+    
+    /**
+     * Called when a script wishes to modify an event specific parameter, this function
+     * takes a key, a construct, and the underlying event. It returns true if the underlying
+     * event was successfully updated.
+     */
+    public boolean modifyEvent(String key, Construct value, Object event);
+    
+}
diff --git a/src/main/java/com/laytonsmith/core/events/EventHandlerInterface.java b/src/main/java/com/laytonsmith/core/events/EventHandlerInterface.java
new file mode 100644
index 0000000..fcc79ce
--- /dev/null
+++ b/src/main/java/com/laytonsmith/core/events/EventHandlerInterface.java
@@ -0,0 +1,79 @@
+/*
+ * To change this template, choose Tools | Templates
+ * and open the template in the editor.
+ */
+package com.laytonsmith.core.events;
+
+import com.laytonsmith.core.Env;
+import com.laytonsmith.core.constructs.CArray;
+import com.laytonsmith.core.constructs.Construct;
+import com.laytonsmith.core.exceptions.EventException;
+import com.laytonsmith.core.exceptions.PrefilterNonMatchException;
+import java.util.Map;
+
+/**
+ * This interface contains all the methods needed to manipulate a particular
+ * event in a particular implementation. Methods that are common to all events
+ * in this implementation go in AbstractEventMixin instead.
+ * @author layton
+ */
+public interface EventHandlerInterface {
+    /**
+     * If a given prefilter matches the given implementation specific event.
+     * @param prefilter
+     * @param e
+     * @return
+     * @throws PrefilterNonMatchException 
+     */
+    public boolean matches(Map<String, Construct> prefilter, Object e) throws PrefilterNonMatchException;
+    /**
+     * Given the specified event, change the event data into a Map of data (which is then further
+     * converted into a CArray later)
+     * @param e
+     * @param mixin
+     * @return
+     * @throws EventException 
+     */
+    public Map<String, Construct> evaluate(Object e, EventMixinInterface mixin) throws EventException;
+    /**
+     * Converts a CArray into an actual implementation specific event, so it can be
+     * manually triggered
+     * @param manual
+     * @return 
+     */
+    public Object convert(CArray manual);
+    /**
+     * Given a key, a value, and an event, this function should modify the implementation
+     * event as specified.
+     * @param key
+     * @param value
+     * @param event 
+     */
+    public boolean modifyEvent(String key, Construct value, Object event);
+    
+    /**
+     * If a custom mixin is needed, this event may specify it here. Null should be
+     * returned if a custom mixin isn't needed. A UnsupportedOperationException will
+     * also be caught and ignored.
+     * @return 
+     */
+    public EventMixinInterface customMixin(AbstractEvent e);
+    
+    /**
+     * At the last moment, an event is allowed to customize the environment or server
+     * if needed. Most events probably won't need this hook, and can safely throw
+     * an UnsupportedOperationException.
+     * @param env
+     * @param activeEvent 
+     */
+    public void preExecution(Env env, BoundEvent.ActiveEvent activeEvent);
+    
+    /**
+     * Right after the script is run, this function is fired, allowing
+     * an event to unhook if hooks had previously been inserted that shouldn't
+     * remain.
+     * @param env
+     * @param activeEvent 
+     */
+    public void postExecution(Env env, BoundEvent.ActiveEvent activeEvent);
+}
diff --git a/src/main/java/com/laytonsmith/core/events/EventList.java b/src/main/java/com/laytonsmith/core/events/EventList.java
new file mode 100644
index 0000000..aab1cc7
--- /dev/null
+++ b/src/main/java/com/laytonsmith/core/events/EventList.java
@@ -0,0 +1,167 @@
+/*
+ * To change this template, choose Tools | Templates
+ * and open the template in the editor.
+ */
+package com.laytonsmith.core.events;
+
+import com.laytonsmith.PureUtilities.ClassDiscovery;
+import com.laytonsmith.abstraction.Implementation;
+import com.laytonsmith.abstraction.StaticLayer;
+import com.laytonsmith.commandhelper.CommandHelperPlugin;
+import java.lang.reflect.Constructor;
+import java.lang.reflect.InvocationTargetException;
+import java.util.*;
+import java.util.logging.Level;
+import java.util.logging.Logger;
+
+
+/**
+ *
+ * @author layton
+ */
+public class EventList {
+    private static final Map<Driver, SortedSet<Event>> event_list =
+            new EnumMap<Driver, SortedSet<Event>>(Driver.class);
+    static {
+        //Initialize all our events as soon as we start up
+        initEvents();
+    }
+    
+    /**
+     * Gets all the events of the specified type.
+     * @param type
+     * @return 
+     */
+    public static SortedSet<Event> GetEvents(Driver type){
+        SortedSet<Event> set = event_list.get(type);
+        return set;
+    }
+    
+    /**
+     * A more efficient lookup, this method will return a value in near constant time,
+     * as opposed to the other getEvent, which will return in O(n) time. This could
+     * return null if there is no event named name.
+     */
+    public static Event getEvent(Driver type, String name){
+        if(type == null){
+            return getEvent(name);
+        }
+        SortedSet<Event> set = event_list.get(type);
+        if(set != null){
+            Iterator<Event> i = set.iterator();
+            while(i.hasNext()){
+                Event e = i.next();
+                if(e.getName().equals(name)){
+                    return e;
+                }
+            }
+        }
+        return null;
+    }
+    /**
+     * This could return null if there is no event named name.
+     * @param name
+     * @return 
+     */
+    public static Event getEvent(String name){
+        for(Driver type : event_list.keySet()){
+            SortedSet<Event> set = event_list.get(type);
+            Iterator<Event> i = set.iterator();
+            while(i.hasNext()){
+                Event e = i.next();
+                if(e.getName().equals(name)){
+                    return e;
+                }
+            }
+        }
+        return null;
+    }
+    
+    private static void initEvents() {
+        //Register internal classes first, so they can't be overridden
+        Class[] classes = ClassDiscovery.GetClassesWithAnnotation(abstraction.class);
+        int total = 0;
+        for(Class c : classes){
+            String apiClass = (c.getEnclosingClass() != null
+                    ? c.getEnclosingClass().getName().split("\\.")[c.getEnclosingClass().getName().split("\\.").length - 1]
+                    : "<global>");
+            if (EventHandlerInterface.class.isAssignableFrom(c)) {
+                try {
+                    registerEvent(c, apiClass);
+                    total++;
+                } catch (NoSuchMethodException ex) {
+                    Logger.getLogger(EventList.class.getName()).log(Level.SEVERE, null, ex);
+                } catch (IllegalArgumentException ex) {
+                    Logger.getLogger(EventList.class.getName()).log(Level.SEVERE, null, ex);
+                } catch (InvocationTargetException ex) {
+                    Logger.getLogger(EventList.class.getName()).log(Level.SEVERE, null, ex);
+                } catch (InstantiationException ex) {
+                    Logger.getLogger(EventList.class.getName()).log(Level.SEVERE, null, ex);
+                } catch (IllegalAccessException ex) {
+                    Logger.getLogger(EventList.class.getName()).log(Level.SEVERE, null, ex);
+                }
+            } else {
+                System.out.println("@abstraction events must implement " + EventList.class.getPackage().getName() + ".Event! " + c.getSimpleName() + " cannot be loaded.");
+            }            
+        }
+        
+        if((Boolean)com.laytonsmith.core.Static.getPreferences().getPreference("debug-mode")){
+            System.out.println("CommandHelper: Loaded " + total + " event" + (total==1?"":"s"));
+        }
+    }
+    
+    public static void registerEvent(Class c, String apiClass) throws InstantiationException, IllegalAccessException, NoSuchMethodException, IllegalArgumentException, InvocationTargetException {
+        abstraction a = (abstraction)c.getAnnotation(abstraction.class);
+        if(a.type() == Implementation.GetServerType()){
+            //First, instantiate the handler
+            Class load = a.load();
+            if(EventHandlerInterface.class.isAssignableFrom(c)){
+                 if(Event.class.isAssignableFrom(load)){
+                    EventHandlerInterface handler = (EventHandlerInterface) c.newInstance();
+                    Constructor loaderConstructor = load.getConstructor(EventHandlerInterface.class);
+                    AbstractEvent e = (AbstractEvent) loaderConstructor.newInstance(handler);                   
+                    //Get the mixin for this server, and add it to e
+                    Class mixinClass = StaticLayer.GetServerEventMixin();
+                    Constructor mixinConstructor = mixinClass.getConstructor(AbstractEvent.class);
+                    EventMixinInterface mixin = (EventMixinInterface) mixinConstructor.newInstance(e);
+                    try{
+                        if(handler.customMixin(e) != null){
+                            mixin = handler.customMixin(e);
+                        }
+                    } catch(UnsupportedOperationException ex){
+                        //Oh well
+                    }
+                    e.setAbstractEventMixin(mixin);
+                    if(!apiClass.equals("Sandbox")){
+                        if((Boolean)com.laytonsmith.core.Static.getPreferences().getPreference("debug-mode")){
+                            System.out.println("CommandHelper: Loaded event \"" + e.getName() + "\"");
+                        }
+                    }
+                    if(!event_list.containsKey(e.driver())){
+                        event_list.put(e.driver(), new TreeSet<Event>());
+                    }
+                    event_list.get(e.driver()).add(e);
+                    try{
+                        e.hook();
+                    } catch(UnsupportedOperationException ex){}
+            
+                 } else {
+                     System.out.println("CommandHelper: Loaded event " + load.getSimpleName() + " must implement Event");
+                 }
+            } else {
+                System.out.println("CommandHelper: Loaded event " + c.getSimpleName() + " must implement AbstractEventHandler");
+            }
+        }
+    }
+    
+
+    
+    
+    /**
+     * This should be called when the plugin starts up. It registers all server event listeners.
+     * This should only be called once, in onEnable from the main plugin.
+     */
+    public static void Startup(CommandHelperPlugin chp){
+        StaticLayer.Startup(chp);        
+    }
+}
diff --git a/src/main/java/com/laytonsmith/core/events/EventMixinInterface.java b/src/main/java/com/laytonsmith/core/events/EventMixinInterface.java
new file mode 100644
index 0000000..0e4c9cd
--- /dev/null
+++ b/src/main/java/com/laytonsmith/core/events/EventMixinInterface.java
@@ -0,0 +1,34 @@
+/*
+ * To change this template, choose Tools | Templates
+ * and open the template in the editor.
+ */
+package com.laytonsmith.core.events;
+
+import com.laytonsmith.core.constructs.Construct;
+import com.laytonsmith.core.exceptions.EventException;
+import java.util.Map;
+
+/**
+ * The abstract event mixin contains functions that are common to all
+ * event types in a particular implementation.
+ * @author layton
+ */
+public interface EventMixinInterface {
+    /**
+     * Cancel this event, if possible.
+     * @param e 
+     */
+    public void cancel(Object e, boolean state);
+    /**
+     * Return if this event is cancellable
+     * @param o
+     * @return 
+     */
+    public boolean isCancellable(Object o);    
+    public Map<String, Construct> evaluate_helper(Object e) throws EventException;
+    /**
+     * Manually trigger this implementation specific event
+     * @param e 
+     */
+    public void manualTrigger(Object e);
+}
diff --git a/src/main/java/com/laytonsmith/core/events/EventUtils.java b/src/main/java/com/laytonsmith/core/events/EventUtils.java
new file mode 100644
index 0000000..2c0ce91
--- /dev/null
+++ b/src/main/java/com/laytonsmith/core/events/EventUtils.java
@@ -0,0 +1,220 @@
+/*
+ * To change this template, choose Tools | Templates
+ * and open the template in the editor.
+ */
+package com.laytonsmith.core.events;
+
+import com.laytonsmith.core.constructs.CArray;
+import com.laytonsmith.core.constructs.CString;
+import com.laytonsmith.core.constructs.Construct;
+import com.laytonsmith.core.events.BoundEvent.Priority;
+import com.laytonsmith.core.exceptions.ConfigRuntimeException;
+import com.laytonsmith.core.exceptions.EventException;
+import com.laytonsmith.core.exceptions.FunctionReturnException;
+import com.laytonsmith.core.exceptions.PrefilterNonMatchException;
+import java.util.*;
+
+/**
+ *
+ * @author layton
+ */
+public class EventUtils {
+
+    private static final Map<Driver, SortedSet<BoundEvent>> event_handles =
+            new EnumMap<Driver, SortedSet<BoundEvent>>(Driver.class);
+
+    /**
+     * Registers a BoundEvent.
+     * @param b
+     * @throws EventException 
+     */
+    public static void RegisterEvent(BoundEvent b) throws EventException {
+        Event event = EventList.getEvent(b.getEventName());
+        if (event == null) {
+            throw new EventException("The event type \"" + b.getEventName() + "\" could not be found.");
+        }
+        if (!event_handles.containsKey(event.driver())) {
+            event_handles.put(event.driver(), new TreeSet<BoundEvent>());
+        }
+        SortedSet<BoundEvent> set = event_handles.get(event.driver());
+        set.add(b);
+        try {
+            event.bind();
+        } catch (UnsupportedOperationException e) {
+        }
+    }
+
+    /**
+     * Looks through all the events for an event with id <code>id</code>. Once found, removes it.
+     * If no event with that id is registered, nothing happens.
+     * @param id 
+     */
+    public static void UnregisterEvent(String id) {
+        for (Driver type : event_handles.keySet()) {
+            SortedSet<BoundEvent> set = event_handles.get(type);
+            Iterator<BoundEvent> i = set.iterator();
+            while (i.hasNext()) {
+                BoundEvent b = i.next();
+                if (b.getId().equals(id)) {
+                    i.remove();
+                    return;
+                }
+            }
+        }
+    }
+
+    /**
+     * Unregisters all event handlers. Runs in O(n)
+     */
+    public static void UnregisterAll(String name) {
+        for (Driver type : event_handles.keySet()) {
+            SortedSet<BoundEvent> set = event_handles.get(type);
+            Iterator<BoundEvent> i = set.iterator();
+            while (i.hasNext()) {
+                BoundEvent b = i.next();
+                if (b.getEventObjName().equals(name)) {
+                    i.remove();
+                    return;
+                }
+            }
+        }
+    }
+
+    /**
+     * This should be used in the case the plugin is disabled, or /reloadalises is run.
+     */
+    public static void UnregisterAll() {
+        event_handles.clear();
+    }
+
+    /**
+     * Returns all events driven by type. O(1).
+     * @param type
+     * @return 
+     */
+    public static SortedSet<BoundEvent> GetEvents(Driver type) {
+        return event_handles.get(type);
+    }
+
+    public static void ManualTrigger(String eventName, CArray object, boolean serverWide) {
+        for (Driver type : event_handles.keySet()) {
+            SortedSet<BoundEvent> toRun = new TreeSet<BoundEvent>();
+            SortedSet<BoundEvent> bounded = GetEvents(type);
+            Event driver = EventList.getEvent(type, eventName);
+            if (bounded != null) {
+                for (BoundEvent b : bounded) {
+                    if(b.getEventName().equalsIgnoreCase(eventName)){
+                        try {
+                            Object convertedEvent = null;
+                            try{
+                                convertedEvent = driver.convert(object);
+                            } catch(ConfigRuntimeException e){
+                                if(ConfigRuntimeException.HandleUncaughtException(e) == ConfigRuntimeException.Reaction.REPORT){
+                                    ConfigRuntimeException.DoReport(e, "Did you include all the event parameters?");
+                                }
+                                continue;
+                            }
+                            if (driver.matches(b.getPrefilter(), convertedEvent)) {
+                                toRun.add(b);
+                            }
+                        } catch (PrefilterNonMatchException ex) {
+                            //Not running this one
+                        }
+                    }
+                }
+            }
+            //If it's not a serverwide event, or this event doesn't support external events.
+            if (!toRun.isEmpty()) {
+                if (!serverWide || !driver.supportsExternal()) {
+                    FireListeners(toRun, driver, driver.convert(object));
+                } else {
+                    //It's serverwide, so we can just trigger it normally with the driver, and it should trickle back down to us
+                    driver.manualTrigger(driver.convert(object));
+                }
+            } else {
+                //TODO: They have fired a non existant event, which is currently silently
+                //ignored. This should fire off a warning instead
+            }
+        }
+    }
+
+    /**
+     * Triggers an event by name. The event name is the primary filter for this event, but
+     * to increase event lookup efficiency, the driver is required. This will run in O(n),
+     * where n is the number of bound events driven by type <code>type</code>.
+     * @param type
+     * @param e 
+     */
+    public static void TriggerListener(Driver type, String eventName, Object e) {
+        SortedSet<BoundEvent> toRun = new TreeSet<BoundEvent>();
+        //This is the Event driver
+        Event driver = EventList.getEvent(type, eventName);
+        //This is the set of bounded events of this driver type. 
+        //We must now look through the bound events to see if they are
+        //the eventName, and if so, we will also run the prefilter.
+        SortedSet<BoundEvent> bounded = GetEvents(type);
+        if (bounded != null) {
+            for (BoundEvent b : bounded) {
+                try {
+                    if (driver.getName().equals(eventName) && driver.matches(b.getPrefilter(), e)) {
+                        toRun.add(b);
+                    }
+                } catch (PrefilterNonMatchException ex) {
+                    //Not running this one
+                }
+            }
+        }
+
+        FireListeners(toRun, driver, e);
+    }
+
+    private static void FireListeners(SortedSet<BoundEvent> toRun, Event driver, Object e) {
+        //Sort our event handlers by priorities
+        BoundEvent.ActiveEvent activeEvent = new BoundEvent.ActiveEvent(e);
+        for (BoundEvent b : toRun) {
+            if(activeEvent.canReceive() || b.getPriority().equals(Priority.MONITOR)){
+                try {
+                    //We must re-set the active event's bound event and parsed event
+                    activeEvent.setBoundEvent(b);
+                    activeEvent.setParsedEvent(driver.evaluate(e));                    
+                    b.trigger(activeEvent);
+                } catch (FunctionReturnException ex){
+                    //We also know how to deal with this
+                } catch (EventException ex) {
+                    throw new ConfigRuntimeException(ex.getMessage(), null, 0, null);
+                } catch(ConfigRuntimeException ex){
+                    //An exception has bubbled all the way up
+                    switch(ConfigRuntimeException.HandleUncaughtException(ex)){
+                        case REPORT:
+                            ConfigRuntimeException.DoReport(ex);
+                            break;
+                        case IGNORE:
+                            break;
+                        case FATAL:
+                            throw ex;
+                        default:
+                            break;
+                    }
+                }
+            }
+        }
+        if(activeEvent.isCancelled()){
+            activeEvent.executeCancelled();
+        } else {
+            activeEvent.executeTriggered();
+        }
+    }
+
+    public static Construct DumpEvents() {
+        CArray ca = new CArray(0, null);
+        for (Driver type : event_handles.keySet()) {
+            SortedSet<BoundEvent> set = event_handles.get(type);
+            Iterator<BoundEvent> i = set.iterator();
+            while (i.hasNext()) {
+                BoundEvent b = i.next();
+                ca.push(new CString(b.toString() + ":" + b.getFile() + ":" + b.getLineNum(), 0, null));
+            }
+        }
+        return ca;
+    }
+}
diff --git a/src/main/java/com/laytonsmith/core/events/Prefilters.java b/src/main/java/com/laytonsmith/core/events/Prefilters.java
new file mode 100644
index 0000000..592719d
--- /dev/null
+++ b/src/main/java/com/laytonsmith/core/events/Prefilters.java
@@ -0,0 +1,197 @@
+/*
+ * To change this template, choose Tools | Templates
+ * and open the template in the editor.
+ */
+package com.laytonsmith.core.events;
+
+import com.laytonsmith.core.Static;
+import com.laytonsmith.core.constructs.CDouble;
+import com.laytonsmith.core.constructs.CInt;
+import com.laytonsmith.core.constructs.CString;
+import com.laytonsmith.core.constructs.Construct;
+import com.laytonsmith.core.exceptions.ConfigRuntimeException;
+import com.laytonsmith.core.exceptions.PrefilterNonMatchException;
+import com.laytonsmith.core.functions.Exceptions.ExceptionType;
+import com.sk89q.worldedit.expression.Expression;
+import com.sk89q.worldedit.expression.ExpressionException;
+import java.util.Map;
+
+/**
+ *
+ * @author layton
+ */
+public class Prefilters {
+    public enum PrefilterType{
+        /**
+         * Item matches are fuzzy matches for item notation. Red wool and black wool
+         * will match. Essentially, this match ignores the item's data value when
+         * comparing.
+         */
+        ITEM_MATCH,
+        /**
+         * String matches are just exact string matches
+         */
+        STRING_MATCH,
+        /**
+         * Math match parses numbers out and checks to see if the numbers
+         * are equivalent. i.e. 1.0 does equal 1.
+         */
+        MATH_MATCH,
+        /**
+         * Regexes allow for more complex matching. A full blown regular expression
+         * is accepted as the argument.
+         */
+        REGEX,
+        /**
+         * An expression allows for more complex numerical matching. Similar to a regex,
+         * but designed for numerical values.
+         */
+        EXPRESSION,
+        /**
+         * A macro expression allows for either an exact string match, or a regular expression,
+         * or an expression. It is parsed according to the format of the prefilter. In
+         * general, this should be used most often for things that are not definitively
+         * another type, so as to give scripts more flexibility.
+         */
+        MACRO
+    }
+    
+    public static void match(Map<String, Construct> map, String key,
+            String actualValue, PrefilterType type) throws PrefilterNonMatchException{
+        match(map, key, new CString(actualValue, 0, null), type);
+    }
+    
+    public static void match(Map<String, Construct> map, String key,
+            int actualValue, PrefilterType type) throws PrefilterNonMatchException{
+        match(map, key, new CInt(actualValue, 0, null), type);
+    }
+    
+    public static void match(Map<String, Construct> map, String key,
+            double actualValue, PrefilterType type) throws PrefilterNonMatchException{
+        match(map, key, new CDouble(actualValue, 0, null), type);
+    }
+    
+    /**
+     * Given a prototype and the actual user provided value, determines if it matches.
+     * If it doesn't, it throws an exception. If the value is not provided, or it does
+     * match, it returns void, which means that the test passed, and the event matches.
+     */
+    public static void match(Map<String, Construct> map, String key,
+            Construct actualValue, PrefilterType type) throws PrefilterNonMatchException{
+        if(!map.containsKey(key)){
+            return;
+        } else {
+            switch(type){
+                case ITEM_MATCH:
+                    ItemMatch(map.get(key), actualValue);
+                    break;
+                case STRING_MATCH:
+                    StringMatch(map.get(key).val(), actualValue.val());
+                    break;
+                case MATH_MATCH:
+                    MathMatch(map.get(key), actualValue);
+                    break;
+                case EXPRESSION:
+                    ExpressionMatch(MathReplace(key, map.get(key), actualValue), actualValue);
+                    break;
+                case REGEX:
+                    RegexMatch(map.get(key), actualValue);
+                    break;
+                case MACRO:
+                    MacroMatch(key, map.get(key), actualValue);
+            }
+        }
+    }
+    
+    private static void ItemMatch(Construct item1, Construct item2) throws PrefilterNonMatchException{
+        String i1 = item1.val();
+        String i2 = item2.val();
+        if(item1.val().contains(":")){
+            String[] split = item1.val().split(":");
+            i1 = split[0].trim();
+        }
+        if(item2.val().contains(":")){
+            String[] split = item2.val().split(":");
+            i2 = split[0].trim();
+        }
+        if(!i1.trim().equalsIgnoreCase(i2.trim())){
+            throw new PrefilterNonMatchException();
+        }
+    }
+    
+    private static void StringMatch(String string1, String string2) throws PrefilterNonMatchException{
+        if(!string1.equals(string2)){
+            throw new PrefilterNonMatchException();
+        }
+    }
+    
+    private static void MathMatch(Construct one, Construct two) throws PrefilterNonMatchException{
+        try{
+            double dOne = Static.getNumber(one);
+            double dTwo = Static.getNumber(two);
+            if(dOne != dTwo){
+                throw new PrefilterNonMatchException();
+            }
+        } catch(ConfigRuntimeException e){
+            throw new PrefilterNonMatchException();
+        }
+    }
+    
+    private static void ExpressionMatch(Construct expression, Construct dvalue) throws PrefilterNonMatchException{
+        if(expression.val().matches("\\(.*\\)")){
+            String exp = expression.val().substring(1, expression.val().length() - 1);
+            boolean inequalityMode = false;
+            if(exp.contains("<") || exp.contains(">") || exp.contains("==")){
+                inequalityMode = true;
+            }
+            try{
+                double val = Expression.compile(exp).evaluate();
+                if(inequalityMode){
+                    if(val == 0){
+                        throw new PrefilterNonMatchException();
+                    }
+                } else {
+                    if(val != Static.getDouble(dvalue)){
+                        throw new PrefilterNonMatchException();
+                    }
+                }
+            } catch(ExpressionException e){
+                throw new ConfigRuntimeException("Your expression is invalidly formatted", 
+                        ExceptionType.FormatException, expression.getLineNum(), expression.getFile());
+            }
+        } else {
+            throw new ConfigRuntimeException("Prefilter expecting expression type, and \"" 
+                    + expression.val() + "\" does not follow expression format. "
+                    + "(Did you surround it in parenthesis?)", 
+                    ExceptionType.FormatException, expression.getLineNum(), 
+                    expression.getFile());
+        }
+    }
+    
+    private static void RegexMatch(Construct expression, Construct value) throws PrefilterNonMatchException{
+        if(expression.val().matches("/.*/")){
+            String exp = expression.val().substring(1, expression.val().length());
+            if(!value.val().matches(exp)){
+                throw new PrefilterNonMatchException();
+            }
+        } else {
+            throw new ConfigRuntimeException("Prefilter expecting regex type, and \"" 
+                    + expression.val() + "\" does not follow regex format", ExceptionType.FormatException, expression.getLineNum(), expression.getFile());
+        }
+    }
+    
+    private static void MacroMatch(String key, Construct expression, Construct value) throws PrefilterNonMatchException{
+        if(expression.val().matches("\\(.*\\)")){
+            ExpressionMatch(MathReplace(key, expression, value), value);
+        } else if(expression.val().matches("/.*/")){
+            RegexMatch(expression, value);
+        } else {
+            StringMatch(expression.val(), value.val());
+        }
+    }
+    
+    private static Construct MathReplace(String key, Construct expression, Construct value){
+        return new CString(expression.val().replaceAll(key, value.val()), expression.getLineNum(),
+                expression.getFile());
+    }
+}
diff --git a/src/main/java/com/laytonsmith/core/events/abstraction.java b/src/main/java/com/laytonsmith/core/events/abstraction.java
new file mode 100644
index 0000000..a6d082f
--- /dev/null
+++ b/src/main/java/com/laytonsmith/core/events/abstraction.java
@@ -0,0 +1,22 @@
+/*
+ * To change this template, choose Tools | Templates
+ * and open the template in the editor.
+ */
+package com.laytonsmith.core.events;
+
+import com.laytonsmith.abstraction.Implementation;
+import java.lang.annotation.ElementType;
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
+import java.lang.annotation.Target;
+
+/**
+ *
+ * @author layton
+ */
+@Retention(RetentionPolicy.RUNTIME)
+@Target(ElementType.TYPE)
+public @interface abstraction {
+    Class load();
+    Implementation.Type type();
+}
diff --git a/src/main/java/com/laytonsmith/core/events/drivers/PlayerEvents.java b/src/main/java/com/laytonsmith/core/events/drivers/PlayerEvents.java
new file mode 100644
index 0000000..dc92540
--- /dev/null
+++ b/src/main/java/com/laytonsmith/core/events/drivers/PlayerEvents.java
@@ -0,0 +1,157 @@
+/*
+ * To change this template, choose Tools | Templates
+ * and open the template in the editor.
+ */
+package com.laytonsmith.core.events.drivers;
+
+import com.laytonsmith.core.docs;
+import com.laytonsmith.core.events.AbstractEvent;
+import com.laytonsmith.core.events.Driver;
+import com.laytonsmith.core.events.EventHandlerInterface;
+
+
+/**
+ *
+ * @author layton
+ */
+public class PlayerEvents {
+    public static String docs(){
+        return "Contains events related to a player";
+    }
+    
+    @docs(type= docs.type.EVENT)
+    public static class player_join extends AbstractEvent{
+        
+        public player_join(EventHandlerInterface handler){
+            super(handler);
+        }
+
+        public String getName() {
+            return "player_join";
+        }
+
+        public String docs() {
+            return "{player: <string match> |"
+                    + "join_message: <regex>} This event is called when a player logs in. "
+                    + "Setting join_message to null causes it to not be displayed at all. Cancelling "
+                    + "the event does not prevent them from logging in. Instead, you should just kick() them."
+                    + "{player: The player's name | join_message: The default join message}"
+                    + "{join_message}"
+                    + "{player|join_message}";
+        }
+
+        public String since() {
+            return "3.3.0";
+        }
+        
+        public Driver driver(){
+            return Driver.PLAYER_JOIN;
+        }
+
+        
+        
+    }
+    
+    @docs(type= docs.type.EVENT)
+    public static class player_interact extends AbstractEvent{
+        
+        public player_interact(EventHandlerInterface handler){
+            super(handler);
+        }
+
+        public String getName() {
+            return "player_interact";
+        }
+
+        public String docs() {
+            return "{block: <item match> If the block the player interacts with is this"
+                    + " | button: <string match> left or right. If they left or right clicked |"
+                    + " item: <item match> The item they are holding when they interacted |"
+                    + " player: <string match> The player that triggered the event} "
+                    + "Fires when a player left or right clicks a block or the air"
+                    + "{action: One of either: left_click_block, right_click_block, left_click_air, or right_click_air |"
+                    + "block: The id of the block they clicked, or 0 if they clicked the air. If they clicked the air, "
+                    + " neither facing or location will be present. |"
+                    + "player: The player associated with this event |"
+                    + "facing: The (lowercase) face of the block they clicked. See <<jd:[bukkit]org.bukkit.block.BlockFace>> for"
+                    + " the possible values |"
+                    + "location: The (x, y, z, world) location of the block they clicked}"
+                    + "{}"
+                    + "{player|action|item|location|facing}";
+        }
+
+        public String since() {
+            return "3.3.0";
+        }
+
+        public Driver driver() {
+            return Driver.PLAYER_INTERACT;
+        }
+
+        
+        
+    }
+    
+    @docs(type = docs.type.EVENT)
+    public static class player_spawn extends AbstractEvent {
+        
+        public player_spawn(EventHandlerInterface handler) {
+            super(handler);
+        }
+        
+        public String getName() {
+            return "player_spawn";
+        }
+        
+        public String docs() {
+            return "{x: <expression>| y: <expression>| z: <expression>| world: <string match>| player: <macro>}"
+                    + "Fires when a player respawns"
+                    + "{player: The player that is respawning | "
+                    + "location: The location they are going to respawn at}"
+                    + "{location}"
+                    + "{player|location}";
+        }
+        
+        public Driver driver() {
+            return Driver.PLAYER_SPAWN;
+        }
+        
+        public String since() {
+            return "3.3.0";
+        }
+    }
+    
+    @docs(type = docs.type.EVENT)
+    public static class player_death extends AbstractEvent {
+        
+        public player_death(EventHandlerInterface handler) {
+            super(handler);
+        }
+        
+        public String getName() {
+            return "player_death";
+        }
+        
+        public String docs() {
+            return "{player: <macro>}"
+                    + "Fired when a player dies."
+                    + "{player: The player that died | drops: An array of the dropped items"
+                    + "| xp: The xp that will be dropped | cause: The cause of death | death_message: The"
+                    + " death message}"
+                    + "{xp|drops: An array of item objects, or null. The items to be dropped"
+                    + " are replaced with the given items, not added to|death_message: the death message,"
+                    + " or null to remove it entirely}"
+                    + "{player| drops}";
+        }
+        
+        public Driver driver() {
+            return Driver.PLAYER_DEATH;
+        }
+        
+        public String since() {
+            return "3.3.0";
+        }
+    }
+    
+    
+}
diff --git a/src/main/java/com/laytonsmith/core/exceptions/CancelCommandException.java b/src/main/java/com/laytonsmith/core/exceptions/CancelCommandException.java
new file mode 100644
index 0000000..09c61db
--- /dev/null
+++ b/src/main/java/com/laytonsmith/core/exceptions/CancelCommandException.java
@@ -0,0 +1,23 @@
+/*
+ * To change this template, choose Tools | Templates
+ * and open the template in the editor.
+ */
+
+package com.laytonsmith.core.exceptions;
+
+/**
+ *
+ * @author Layton
+ */
+public class CancelCommandException extends RuntimeException{
+    String message;
+    public CancelCommandException(String message){
+        this.message = message;
+    }
+
+    @Override
+    public String getMessage() {
+        return message;
+    }
+
+}
diff --git a/src/main/java/com/laytonsmith/core/exceptions/ConfigCompileException.java b/src/main/java/com/laytonsmith/core/exceptions/ConfigCompileException.java
new file mode 100644
index 0000000..169075f
--- /dev/null
+++ b/src/main/java/com/laytonsmith/core/exceptions/ConfigCompileException.java
@@ -0,0 +1,63 @@
+/*
+ * To change this template, choose Tools | Templates
+ * and open the template in the editor.
+ */
+
+package com.laytonsmith.core.exceptions;
+
+import java.io.File;
+
+/**
+ *
+ * @author Layton
+ */
+public class ConfigCompileException extends Exception{
+
+    int line_num;
+    String message;
+    File file;
+
+    public ConfigCompileException(String message, int line_num, File f) {
+        this.message = message;
+        this.line_num = line_num;
+        this.file = f;
+    }
+
+    public ConfigCompileException(String string) {
+        message = string;
+        line_num = 0;
+    }
+    
+    @Override
+    public String getMessage() {
+        return message;
+    }
+
+    public String getLineNum(){
+        return Integer.toString(line_num);
+    }
+
+
+    @Override
+    public String toString(){
+        if(line_num != 0){
+            return "Configuration Compile Exception: " + message + " near line " + line_num + " of configuration file. Please "
+                    + "check your config file and try again. " + (file!=null?"(" + file.getAbsolutePath() + ")":"");
+        } else{
+            return "Configuration Compile Exception: " + message + ". Please check your config file and try again. " 
+                    + (file!=null?"(" + file.getAbsolutePath() + ")":"");
+        }
+    }
+
+    public File getFile() {
+        return this.file;
+    }
+
+    public String getSimpleFile(){
+        if(this.file != null){
+            return this.file.getName();
+        } else {
+            return null;
+        }
+    }
+}
diff --git a/src/main/java/com/laytonsmith/core/exceptions/ConfigRuntimeException.java b/src/main/java/com/laytonsmith/core/exceptions/ConfigRuntimeException.java
new file mode 100644
index 0000000..002faf5
--- /dev/null
+++ b/src/main/java/com/laytonsmith/core/exceptions/ConfigRuntimeException.java
@@ -0,0 +1,247 @@
+/*
+ * To change this template, choose Tools | Templates
+ * and open the template in the editor.
+ */
+
+package com.laytonsmith.core.exceptions;
+
+import com.laytonsmith.PureUtilities.TermColors;
+import com.laytonsmith.abstraction.MCChatColor;
+import com.laytonsmith.abstraction.MCPlayer;
+import com.laytonsmith.core.Env;
+import com.laytonsmith.core.Static;
+import com.laytonsmith.core.functions.Exceptions.ExceptionType;
+import java.io.File;
+import java.util.logging.Level;
+
+
+/**
+ *
+ * @author layton
+ */
+public class ConfigRuntimeException extends RuntimeException {
+
+    /**
+     * Creates a new instance of <code>ConfigRuntimeException</code> without detail message.
+     */
+    protected ConfigRuntimeException() {
+    }
+
+    public void setEnv(Env env) {
+        this.env = env;
+    }
+    
+    /**
+     * This returns the environment that was set when the exception was thrown.
+     * It may be null, though that's due to an incomplete swapover, and should be
+     * fixed.
+     */
+    public Env getEnv(){
+        return this.env;
+    }
+
+    public void setFile(File f) {
+        if(file == null){
+            file = f;
+        }
+    }
+
+    public void setLineNum(int line_num) {
+        if(this.line_num == 0){
+            this.line_num = line_num;
+        }
+    }
+    
+    public static enum Reaction{
+        /**
+         * This exception should be ignored, because a handler dealt with it
+         * as desired. The plugin is no longer responsible for dealing with this
+         * exception
+         */
+        IGNORE,
+        /**
+         * No handler knew how to deal with this exception, or they chose not
+         * to handle it. The plugin should handle it by using the default action
+         * for an uncaught exception
+         */
+        REPORT,
+        /**
+         * A handler knew how to deal with this exception, and furthermore, it escalated
+         * it to a more serious category. Though the behavior may be undefined, the
+         * plugin should pass the exception up further.
+         */
+        FATAL
+    }
+    
+    /**
+     * If a exception bubbles all the way up to the top, this should be called first,
+     * to see what reaction the plugin should take.
+     * @param e
+     * @return 
+     */
+    public static Reaction HandleUncaughtException(ConfigRuntimeException e){
+        //For now just return DEFAULT, but eventually, we will also see what the
+        //bound events do for it
+        return Reaction.REPORT;
+    }
+    
+    /**
+     * If the Reaction returned by HandleUncaughtException is to report the exception,
+     * this function should be used to standardize the report format.
+     * @param e 
+     */
+    public static void DoReport(ConfigRuntimeException e){
+        DoReport(e, null);
+    }
+    
+    /**
+     * If the Reaction returned by HandleUncaughtException is to report the exception,
+     * this function should be used to standardize the report format. If the error message
+     * wouldn't be very useful by itself, or if a hint is desired, an optional message
+     * may be provided (null otherwise)
+     * @param e
+     * @param optionalMessage 
+     */
+    public static void DoReport(String message, String exceptionType, String file, String simpleFile, String line_num, String optionalMessage, MCPlayer player){
+        String formatted = optionalMessage==null?"":"; " + optionalMessage;
+        System.out.println(TermColors.RED + message + formatted 
+                + TermColors.WHITE + " :: " + TermColors.GREEN 
+                + exceptionType + TermColors.WHITE + ":" 
+                + TermColors.YELLOW + file + TermColors.WHITE + ":" 
+                + TermColors.CYAN + line_num + TermColors.reset());
+        if(player != null){
+            player.sendMessage(MCChatColor.RED.toString() + message + formatted
+                    + MCChatColor.WHITE + " :: " + MCChatColor.GREEN
+                    + exceptionType + MCChatColor.WHITE + ":" 
+                    + MCChatColor.YELLOW + simpleFile + MCChatColor.WHITE + ":" 
+                    + MCChatColor.AQUA + line_num);
+        }
+    }
+    
+    public static void DoReport(ConfigRuntimeException e, String optionalMessage){
+        DoReport(e.getMessage(), e.getExceptionType().toString(), e.getFile()==null?null:e.getFile().getPath(), e.getSimpleFile(), Integer.toString(e.getLineNum()), optionalMessage, e.getEnv().GetPlayer());
+    }
+    
+    public static void DoReport(ConfigCompileException e, String optionalMessage, MCPlayer player){
+        DoReport(e.getMessage(), "COMPILE ERROR", e.getFile()==null?null:e.getFile().getPath(), e.getSimpleFile(), e.getLineNum(), optionalMessage, player);
+    }
+        
+    
+    /**
+     * Shorthand for DoWarning(exception, null, true);
+     * @param e 
+     */
+    public static void DoWarning(Exception e){
+        DoWarning(e, null, true);
+    }
+    
+    /**
+     * Shorthand for DoWarning(null, message, true);
+     * @param optionalMessage 
+     */
+    public static void DoWarning(String optionalMessage){
+        DoWarning(null, optionalMessage, true);
+    }
+    
+    /**
+     * To standardize the warning messages displayed, this function should
+     * be used. It checks the preference setting for warnings to see if
+     * the warning should be shown to begin with, if checkPref is true. The exception
+     * is simply used to get an error message, and is otherwise unused. If the exception
+     * is a ConfigRuntimeException, it is displayed specially (including line number
+     * and file)
+     * @param e
+     * @param optionalMessage 
+     * @throws NullPointerException If both the exception and message are null (or empty)
+     */
+    public static void DoWarning(Exception e, String optionalMessage, boolean checkPrefs){
+        if(e == null && (optionalMessage == null || optionalMessage.isEmpty())){
+            throw new NullPointerException("Both the exception and the message cannot be empty");
+        }
+        if(!checkPrefs || (Boolean)Static.getPreferences().getPreference("show-warnings")){
+            String exceptionMessage = "";
+            if(e instanceof ConfigRuntimeException){
+                ConfigRuntimeException cre = (ConfigRuntimeException)e;
+                exceptionMessage = MCChatColor.YELLOW + cre.getMessage() 
+                + MCChatColor.WHITE + " :: " + MCChatColor.GREEN 
+                + cre.getExceptionType() + MCChatColor.WHITE + ":" 
+                + MCChatColor.YELLOW + cre.getFile() + MCChatColor.WHITE + ":" 
+                + MCChatColor.AQUA + cre.getLineNum();
+            } else if(e != null){
+                exceptionMessage = MCChatColor.YELLOW + e.getMessage();
+            }
+            String message = exceptionMessage + MCChatColor.WHITE + optionalMessage;
+            Static.getLogger().log(Level.WARNING, Static.MCToANSIColors(message) + TermColors.reset());
+            //Warnings are not shown to players ever
+        }
+    }
+    
+    
+    private ExceptionType ex;
+    private int line_num;
+    private File file;
+    private Env env;
+    /**
+     * Creates a new ConfigRuntimeException. If ex is not null, this exception can be caught
+     * by user level code. Otherwise, it will be ignored by the try() function.
+     * @param msg The message to be displayed
+     * @param ex The type of exception this is, as seen by user level code
+     * @param line_num The line this exception is being thrown from
+     * @param file The file this code resides in
+     */
+    public ConfigRuntimeException(String msg, ExceptionType ex, int line_num, File file){
+        this(msg, ex, line_num, file, null);
+    }
+    
+    public ConfigRuntimeException(String msg, ExceptionType ex, int line_num, File file, Throwable cause){
+        super(msg, cause);
+        this.ex = ex;
+        this.line_num = line_num;
+        this.file = file;
+    }
+    
+//    public ConfigRuntimeException(String msg, ExceptionType ex, int line_num){
+//        this(msg, ex, line_num, null);
+//    }
+//    public ConfigRuntimeException(String msg, int line_num){
+//        this(msg, null, line_num, null);
+//    }
+    
+    /**
+     * Creates an uncatchable exception (by user level code)
+     * @param msg
+     * @param line_num
+     * @param file 
+     */
+    public ConfigRuntimeException(String msg, int line_num, File file){
+        this(msg, null, line_num, file);
+    }
+
+    /**
+     * Constructs an instance of <code>ConfigRuntimeException</code> with the specified detail message.
+     * @param msg the detail message.
+     */
+    private ConfigRuntimeException(String msg) {
+        super(msg);
+    }
+    
+    public ExceptionType getExceptionType(){
+        return this.ex;
+    }
+    
+    public int getLineNum(){
+        return this.line_num;
+    }
+    
+    public File getFile(){
+        return this.file;
+    }
+    
+    public String getSimpleFile(){
+        if(this.file != null){
+            return this.file.getName();
+        } else {
+            return null;
+        }
+    }
+}
diff --git a/src/main/java/com/laytonsmith/core/exceptions/EventException.java b/src/main/java/com/laytonsmith/core/exceptions/EventException.java
new file mode 100644
index 0000000..c3b3747
--- /dev/null
+++ b/src/main/java/com/laytonsmith/core/exceptions/EventException.java
@@ -0,0 +1,26 @@
+/*
+ * To change this template, choose Tools | Templates
+ * and open the template in the editor.
+ */
+package com.laytonsmith.core.exceptions;
+
+/**
+ *
+ * @author layton
+ */
+public class EventException extends Exception {
+
+    /**
+     * Creates a new instance of <code>EventException</code> without detail message.
+     */
+    public EventException() {
+    }
+
+    /**
+     * Constructs an instance of <code>EventException</code> with the specified detail message.
+     * @param msg the detail message.
+     */
+    public EventException(String msg) {
+        super(msg);
+    }
+}
diff --git a/src/main/java/com/laytonsmith/core/exceptions/FunctionReturnException.java b/src/main/java/com/laytonsmith/core/exceptions/FunctionReturnException.java
new file mode 100644
index 0000000..6230e2f
--- /dev/null
+++ b/src/main/java/com/laytonsmith/core/exceptions/FunctionReturnException.java
@@ -0,0 +1,21 @@
+/*
+ * To change this template, choose Tools | Templates
+ * and open the template in the editor.
+ */
+package com.laytonsmith.core.exceptions;
+
+import com.laytonsmith.core.constructs.Construct;
+
+/**
+ *
+ * @author Layton
+ */
+public class FunctionReturnException extends RuntimeException{
+    Construct ret;
+    public FunctionReturnException(Construct ret){
+        this.ret = ret;
+    }
+    public Construct getReturn(){
+        return ret;
+    }
+}
diff --git a/src/main/java/com/laytonsmith/core/exceptions/LoopBreakException.java b/src/main/java/com/laytonsmith/core/exceptions/LoopBreakException.java
new file mode 100644
index 0000000..52ae1a9
--- /dev/null
+++ b/src/main/java/com/laytonsmith/core/exceptions/LoopBreakException.java
@@ -0,0 +1,22 @@
+/*
+ * To change this template, choose Tools | Templates
+ * and open the template in the editor.
+ */
+package com.laytonsmith.core.exceptions;
+
+/**
+ *
+ * @author Layton
+ */
+public class LoopBreakException extends RuntimeException{
+    int number;
+    public LoopBreakException(int times){
+        number = times;
+    }
+    public int getTimes(){
+        return number;
+    }    
+    public void setTimes(int number){
+        this.number = number;
+    }
+}
diff --git a/src/main/java/com/laytonsmith/core/exceptions/LoopContinueException.java b/src/main/java/com/laytonsmith/core/exceptions/LoopContinueException.java
new file mode 100644
index 0000000..432cd15
--- /dev/null
+++ b/src/main/java/com/laytonsmith/core/exceptions/LoopContinueException.java
@@ -0,0 +1,22 @@
+/*
+ * To change this template, choose Tools | Templates
+ * and open the template in the editor.
+ */
+package com.laytonsmith.core.exceptions;
+
+/**
+ *
+ * @author Layton
+ */
+public class LoopContinueException extends RuntimeException{
+    int number;
+    public LoopContinueException(int times){
+        number = times;
+    }
+    public int getTimes(){
+        return number;
+    }    
+    public void setTimes(int number){
+        this.number = number;
+    }
+}
diff --git a/src/main/java/com/laytonsmith/core/exceptions/MarshalException.java b/src/main/java/com/laytonsmith/core/exceptions/MarshalException.java
new file mode 100644
index 0000000..12d2765
--- /dev/null
+++ b/src/main/java/com/laytonsmith/core/exceptions/MarshalException.java
@@ -0,0 +1,37 @@
+/*
+ * To change this template, choose Tools | Templates
+ * and open the template in the editor.
+ */
+package com.laytonsmith.core.exceptions;
+
+import com.laytonsmith.core.constructs.Construct;
+
+/**
+ *
+ * @author Layton
+ */
+public class MarshalException extends Exception {
+
+    /**
+     * Creates a new instance of <code>MarshalException</code> without detail message.
+     */
+    public MarshalException() {
+    }
+
+    /**
+     * Constructs an instance of <code>MarshalException</code> with the specified detail message.
+     * @param msg the detail message.
+     */
+    public MarshalException(String msg) {
+        super(msg);
+    }
+    
+    /**
+     * This is caused when a particular Construct was given that is incompatible.
+     * @param msg
+     * @param c 
+     */
+    public MarshalException(String msg, Construct c){
+        super(msg + ": " + c.toString());
+    }
+}
diff --git a/src/main/java/com/laytonsmith/core/exceptions/PrefilterNonMatchException.java b/src/main/java/com/laytonsmith/core/exceptions/PrefilterNonMatchException.java
new file mode 100644
index 0000000..a1b7638
--- /dev/null
+++ b/src/main/java/com/laytonsmith/core/exceptions/PrefilterNonMatchException.java
@@ -0,0 +1,20 @@
+/*
+ * To change this template, choose Tools | Templates
+ * and open the template in the editor.
+ */
+package com.laytonsmith.core.exceptions;
+
+/**
+ * Thrown if a prefilter is set, and doesn't match. A missing prefilter
+ * is a match, and a matching prefilter is a match.
+ * @author layton
+ */
+public class PrefilterNonMatchException extends Exception {
+
+    /**
+     * Creates a new instance of <code>PrefilterNonMatchException</code> without detail message.
+     */
+    public PrefilterNonMatchException() {
+    }
+    
+}
diff --git a/src/main/java/com/laytonsmith/core/functions/ArrayHandling.java b/src/main/java/com/laytonsmith/core/functions/ArrayHandling.java
new file mode 100644
index 0000000..8b838c3
--- /dev/null
+++ b/src/main/java/com/laytonsmith/core/functions/ArrayHandling.java
@@ -0,0 +1,846 @@
+/*
+ * To change this template, choose Tools | Templates
+ * and open the template in the editor.
+ */
+package com.laytonsmith.core.functions;
+
+import com.laytonsmith.core.Env;
+import com.laytonsmith.core.Static;
+import com.laytonsmith.core.api;
+import com.laytonsmith.core.constructs.*;
+import com.laytonsmith.core.exceptions.CancelCommandException;
+import com.laytonsmith.core.exceptions.ConfigRuntimeException;
+import com.laytonsmith.core.functions.BasicLogic.equals;
+import com.laytonsmith.core.functions.BasicLogic.equals_ic;
+import com.laytonsmith.core.functions.Exceptions.ExceptionType;
+import java.io.File;
+
+/**
+ *
+ * @author Layton
+ */
+public class ArrayHandling {
+    public static String docs(){
+        return "This class contains functions that provide a way to manipulate arrays. To create an array, use the <code>array</code> function."
+                + " For more detailed information on array usage, see the page on [[CommandHelper/Arrays|arrays]]";
+    }
+    @api public static class array_size implements Function{
+
+        public String getName() {
+            return "array_size";
+        }
+
+        public Integer[] numArgs() {
+            return new Integer[]{1};
+        }
+
+        public Construct exec(int line_num, File f, Env env, Construct... args) throws CancelCommandException, ConfigRuntimeException {
+            if(args[0] instanceof CArray){
+                return new CInt(((CArray)args[0]).size(), line_num, f);
+            }
+            throw new ConfigRuntimeException("Argument 1 of array_size must be an array", ExceptionType.CastException, line_num, f);
+        }
+        
+        public ExceptionType[] thrown(){
+            return new ExceptionType[]{ExceptionType.CastException};
+        }
+
+        public String docs() {
+            return "int {array} Returns the size of this array as an integer.";
+        }
+
+        public boolean isRestricted() {
+            return false;
+        }
+
+        public void varList(IVariableList varList) {}
+
+        public boolean preResolveVariables() {
+            return true;
+        }
+
+        public String since() {
+            return "3.0.1";
+        }
+
+        public Boolean runAsync() {
+            return null;
+        }
+        
+    }
+    
+    @api public static class array_get implements Function{
+
+        public String getName() {
+            return "array_get";
+        }
+
+        public Integer[] numArgs() {
+            return new Integer[]{1, 2};
+        }
+
+        public Construct exec(int line_num, File f, Env env, Construct... args) throws CancelCommandException, ConfigRuntimeException {
+            String index = "0..-1";
+            if(args.length == 2){
+                index = args[1].val();
+            }
+            if(env.GetFlag("array_get_alt_mode") == Boolean.TRUE){                
+                return new CArrayReference(args[0], new CString(index, line_num, f), env);
+            }
+            if(args[0] instanceof CArray){
+                CArray ca = (CArray)args[0];
+                if(index.contains("..")){
+                    if(ca.inAssociativeMode()){
+                        if(index.equals("0..-1")){
+                            //Special exception, we want to clone the whole array
+                            CArray na = new CArray(line_num, f);
+                            na.forceAssociativeMode();
+                            for(String key : ca.keySet()){                                
+                                try {
+                                    na.set(key, ca.get(key, line_num, f).clone());
+                                } catch (CloneNotSupportedException ex) {
+                                    na.set(key, ca.get(key, line_num, f));
+                                }
+                            }
+                            return na;
+                        }
+                        throw new ConfigRuntimeException("Array slices are not allowed with an associative array", ExceptionType.CastException, line_num, f);
+                    }
+                    //It's a range
+                    int start = 0;
+                    int finish = 0;
+                    String[] split = index.split("\\.\\.");
+                    try{
+                        if(split[0].isEmpty()){
+                            start = 0;
+                        } else {
+                            start = Integer.parseInt(split[0]);
+                        }
+                        if(split.length == 1 || split[1].isEmpty()){
+                            finish = ca.size() - 1;
+                        } else {
+                            finish = Integer.parseInt(split[1]);
+                        }
+                        //Convert negative indexes 
+                        if(start < 0){
+                            start = ca.size() + start;
+                        }
+                        if(finish < 0){
+                            finish = ca.size() + finish;
+                        }
+                        CArray na = new CArray(line_num, f);
+                        if(finish < start){
+                            //return an empty array in cases where the indexes don't make sense
+                            return na;
+                        }
+                        for(int i = start; i <= finish; i++){
+                            try{
+                                na.push(ca.get(i, line_num, f).clone());
+                            } catch(CloneNotSupportedException e){
+                                na.push(ca.get(i, line_num, f));
+                            }
+                        }
+                        return na;
+                    } catch(NumberFormatException e){
+                        throw new ConfigRuntimeException("Ranges must be integer numbers, i.e., [0..5]", ExceptionType.CastException, line_num, f);
+                    }
+                } else {
+                    if(!ca.inAssociativeMode()){
+                        int iindex = (int)Static.getInt(args[1]);
+                        if(iindex < 0){
+                            //negative index, convert to positive index
+                            iindex = ca.size() + iindex;
+                        }
+                        return ca.get(iindex, line_num, f);
+                    } else {
+                        return ca.get(args[1], line_num, f);
+                    }
+                }
+            } else{
+                throw new ConfigRuntimeException("Argument 1 of array_get must be an array", ExceptionType.CastException, line_num, f);
+            }
+        }
+        
+        public ExceptionType[] thrown(){
+            return new ExceptionType[]{ExceptionType.CastException, ExceptionType.IndexOverflowException};
+        }
+
+        public String docs() {
+            return "mixed {array, index} Returns the element specified at the index of the array. If the element doesn't exist, an exception is thrown. "
+                    + "array_get(array, index). Note also that as of 3.1.2, you can use a more traditional method to access elements in an array: "
+                    + "array[index] is the same as array_get(array, index), where array is a variable, or function that is an array. In fact, the compiler"
+                    + " does some magic under the covers, and literally converts array[index] into array_get(array, index), so if there is a problem "
+                    + "with your code, you will get an error message about a problem with the array_get function, even though you may not be using "
+                    + "that function directly.";
+        }
+
+        public boolean isRestricted() {
+            return false;
+        }
+
+        public void varList(IVariableList varList) {}
+
+        public boolean preResolveVariables() {
+            return true;
+        }
+        public String since() {
+            return "3.0.1";
+        }
+        
+        public Boolean runAsync() {
+            return null;
+        }
+        
+    }
+    
+    @api public static class array_set implements Function{
+
+        public String getName() {
+            return "array_set";
+        }
+
+        public Integer[] numArgs() {
+            return new Integer[]{3};
+        }
+
+        public Construct exec(int line_num, File f, Env env, Construct... args) throws CancelCommandException, ConfigRuntimeException {
+            if(args[0] instanceof CArray){
+                try{
+                ((CArray)args[0]).set(args[1], args[2]);
+                } catch(IndexOutOfBoundsException e){
+                    throw new ConfigRuntimeException("The index " + args[1].val() + " is out of bounds", ExceptionType.IndexOverflowException, line_num, f);
+                }
+                return new CVoid(line_num, f);
+            }
+            throw new ConfigRuntimeException("Argument 1 of array_set must be an array, and argument 2 must be an integer", ExceptionType.CastException, line_num, f);        
+        }
+
+        public ExceptionType[] thrown(){
+            return new ExceptionType[]{ExceptionType.CastException, ExceptionType.IndexOverflowException};
+        }
+        
+        public String docs() {
+            return "void {array, index, value} Sets the value of the array at the specified index. array_set(array, index, value). Returns void. If"
+                    + " the element at the specified index isn't already set, throws an exception. Use array_push to avoid this.";
+        }
+
+        public boolean isRestricted() {
+            return false;
+        }
+
+        public void varList(IVariableList varList) {}
+
+        public boolean preResolveVariables() {
+            return true;
+        }
+        public String since() {
+            return "3.0.1";
+        }
+        
+        public Boolean runAsync() {
+            return null;
+        }
+    }
+    
+    @api public static class array_push implements Function{
+
+        public String getName() {
+            return "array_push";
+        }
+
+        public Integer[] numArgs() {
+            return new Integer[]{Integer.MAX_VALUE};
+        }
+
+        public Construct exec(int line_num, File f, Env env, Construct... args) throws CancelCommandException, ConfigRuntimeException {
+            if(args[0] instanceof CArray){
+                if(args.length < 2){
+                    throw new ConfigRuntimeException("At least 2 arguments must be provided to array_push", ExceptionType.InsufficientArgumentsException, line_num, f);
+                }
+                for(int i = 1; i < args.length; i++){
+                    ((CArray)args[0]).push(args[i]);
+                }
+                return new CVoid(line_num, f);
+            }
+            throw new ConfigRuntimeException("Argument 1 of array_push must be an array", ExceptionType.CastException, line_num, f);
+        }
+        
+        public ExceptionType[] thrown(){
+            return new ExceptionType[]{ExceptionType.CastException};
+        }
+
+        public String docs() {
+            return "void {array, value, [value2...]} Pushes the specified value(s) onto the end of the array";
+        }
+
+        public boolean isRestricted() {
+            return false;
+        }
+
+        public void varList(IVariableList varList) {}
+
+        public boolean preResolveVariables() {
+            return true;
+        }
+        public String since() {
+            return "3.0.1";
+        }
+        
+        public Boolean runAsync() {
+            return null;
+        }
+        
+    }
+    @api public static class array_contains implements Function {
+
+        public String getName() {
+            return "array_contains";
+        }
+
+        public Integer[] numArgs() {
+            return new Integer[]{2};
+        }
+
+        public Construct exec(int line_num, File f, Env env, Construct... args) throws CancelCommandException, ConfigRuntimeException {
+            equals e = new equals();
+            if(args[0] instanceof CArray){
+                CArray ca = (CArray) args[0];
+                for(int i = 0; i < ca.size(); i++){
+                    if(((CBoolean)e.exec(line_num, f, env, ca.get(i, line_num, f), args[1])).getBoolean()){
+                        return new CBoolean(true, line_num, f);
+                    }
+                }
+                return new CBoolean(false, line_num, f);
+            } else {
+                throw new ConfigRuntimeException("Argument 1 of array_contains must be an array", ExceptionType.CastException, line_num, f);
+            }
+        }
+        
+        public ExceptionType[] thrown(){
+            return new ExceptionType[]{ExceptionType.CastException};
+        }
+
+        public String docs() {
+            return "boolean {array, testValue} Checks to see if testValue is in array.";
+        }
+
+        public boolean isRestricted() {
+            return false;
+        }
+
+        public void varList(IVariableList varList) {}
+
+        public boolean preResolveVariables() {
+            return true;
+        }
+        public String since() {
+            return "3.0.1";
+        }
+        
+        public Boolean runAsync() {
+            return null;
+        }
+        
+    }
+    
+    @api public static class array_contains_ic implements Function{
+
+        public String getName() {
+            return "array_contains_ic";
+        }
+
+        public Integer[] numArgs() {
+            return new Integer[]{2};
+        }
+
+        public String docs() {
+            return "boolean {array, testValue} Works like array_contains, except the comparison ignores case.";
+        }
+
+        public ExceptionType[] thrown() {
+            return new ExceptionType[]{ExceptionType.CastException};
+        }
+
+        public boolean isRestricted() {
+            return false;
+        }
+
+        public boolean preResolveVariables() {
+            return true;
+        }
+
+        public String since() {
+            return "3.3.0";
+        }
+
+        public Boolean runAsync() {
+            return null;
+        }
+
+        public Construct exec(int line_num, File f, Env environment, Construct... args) throws ConfigRuntimeException {
+            equals_ic e = new equals_ic();
+            if(args[0] instanceof CArray){
+                CArray ca = (CArray) args[0];
+                for(int i = 0; i < ca.size(); i++){
+                    if(((CBoolean)e.exec(line_num, f, environment, ca.get(i, line_num, f), args[1])).getBoolean()){
+                        return new CBoolean(true, line_num, f);
+                    }
+                }
+                return new CBoolean(false, line_num, f);
+            } else {
+                throw new ConfigRuntimeException("Argument 1 of array_contains_ic must be an array", ExceptionType.CastException, line_num, f);
+            }
+        }
+        
+    }
+    
+    @api public static class array_index_exists implements Function{
+
+        public String getName() {
+            return "array_index_exists";
+        }
+
+        public Integer[] numArgs() {
+            return new Integer[]{2};
+        }
+
+        public String docs() {
+            return "boolean {array, index} Checks to see if the specified array has an element at index";
+        }
+
+        public ExceptionType[] thrown() {
+            return new ExceptionType[]{ExceptionType.CastException};
+        }
+
+        public boolean isRestricted() {
+            return false;
+        }
+
+        public void varList(IVariableList varList) {}
+
+        public boolean preResolveVariables() {
+            return true;
+        }
+
+        public String since() {
+            return "3.1.2";
+        }
+
+        public Boolean runAsync() {
+            return null;
+        }
+
+        public Construct exec(int line_num, File f, Env env, Construct... args) throws ConfigRuntimeException {
+            if(args[0] instanceof CArray){
+                if(!((CArray)args[0]).inAssociativeMode()){
+                    int index = (int)Static.getInt(args[1]);
+                    CArray ca = (CArray)args[0];
+                    return new CBoolean(index <= ca.size() - 1, line_num, f);
+                } else {
+                    CArray ca = (CArray)args[0];
+                    return new CBoolean(ca.containsKey(args[1].val()), line_num, f);
+                }
+            } else {
+                throw new ConfigRuntimeException("Expecting argument 1 to be an array", ExceptionType.CastException, line_num, f);
+            }
+        }
+        
+    }
+    
+    @api public static class array_resize implements Function{
+
+        public String getName() {
+            return "array_resize";
+        }
+
+        public Integer[] numArgs() {
+            return new Integer[]{2, 3};
+        }
+
+        public String docs() {
+            return "void {array, size, [fill]} Resizes the given array so that it is at least of size size, filling the blank spaces with"
+                    + " fill, or null by default. If the size of the array is already at least size, nothing happens; in other words this"
+                    + " function can only be used to increase the size of the array.";
+                    //+ " If the array is an associative array, the non numeric values are simply copied over.";
+        }
+
+        public ExceptionType[] thrown() {
+            return new ExceptionType[]{ExceptionType.CastException};
+        }
+
+        public boolean isRestricted() {
+            return false;
+        }
+
+
+        public boolean preResolveVariables() {
+            return true;
+        }
+
+        public String since() {
+            return "3.2.0";
+        }
+
+        public Boolean runAsync() {
+            return null;
+        }
+
+        public Construct exec(int line_num, File f, Env env, Construct... args) throws ConfigRuntimeException {
+            if(args[0] instanceof CArray && args[1] instanceof CInt){
+                CArray original = (CArray)args[0];
+                int size = (int)((CInt)args[1]).getInt();
+                Construct fill = new CNull(line_num, f);
+                if(args.length == 3){
+                    fill = args[2];
+                }
+                for(int i = original.size(); i < size; i++){
+                    original.push(fill);
+                }
+            } else {
+                throw new ConfigRuntimeException("Argument 1 must be an array, and argument 2 must be an integer in array_resize", ExceptionType.CastException, line_num, f);
+            }
+            return new CVoid(line_num, f);
+        }
+        
+    }
+    
+    @api public static class range implements Function{
+
+        public String getName() {
+            return "range";
+        }
+
+        public Integer[] numArgs() {
+            return new Integer[]{1, 2, 3};
+        }
+
+        public String docs() {
+            return "array {start, finish, [increment] | finish} Returns an array of numbers from start to (finish - 1)"
+                    + " skipping increment integers per count. start defaults to 0, and increment defaults to 1. All inputs"
+                    + " must be integers. If the input doesn't make sense, it will reasonably degrade, and return an empty array.";
+        }
+
+        public ExceptionType[] thrown() {
+            return new ExceptionType[]{ExceptionType.CastException};
+        }
+
+        public boolean isRestricted() {
+            return false;
+        }
+
+        public void varList(IVariableList varList) {}
+
+        public boolean preResolveVariables() {
+            return true;
+        }
+
+        public String since() {
+            return "3.2.0";
+        }
+
+        public Boolean runAsync() {
+            return null;
+        }
+
+        public Construct exec(int line_num, File f, Env env, Construct... args) throws ConfigRuntimeException {
+            long start = 0;
+            long finish = 0;
+            long increment = 1;
+            if(args.length == 1){
+                finish = Static.getInt(args[0]);
+            } else if(args.length == 2){
+                start = Static.getInt(args[0]);
+                finish = Static.getInt(args[1]);
+            } else if(args.length == 3){
+                start = Static.getInt(args[0]);
+                finish = Static.getInt(args[1]);
+                increment = Static.getInt(args[2]);
+            }
+            if(start < finish && increment < 0 || start > finish && increment > 0  || increment == 0){
+                return new CArray(line_num, f);
+            }
+            CArray ret = new CArray(line_num, f);
+            for(long i = start; (increment > 0?i < finish:i > finish); i = i + increment){
+                ret.push(new CInt(i, line_num, f));
+            }
+            return ret;
+        }
+        
+    }
+    
+    @api public static class array_keys implements Function{
+
+        public String getName() {
+            return "array_keys";
+        }
+
+        public Integer[] numArgs() {
+            return new Integer[]{1};
+        }
+
+        public String docs() {
+            return "array {array} Returns the keys in this array as a normal array. If the array passed in is already a normal array,"
+                    + " the keys will be 0 -> (array_size(array) - 1)";
+        }
+
+        public ExceptionType[] thrown() {
+            return new ExceptionType[]{ExceptionType.CastException};
+        }
+
+        public boolean isRestricted() {
+            return false;
+        }
+
+        public void varList(IVariableList varList) {}
+
+        public boolean preResolveVariables() {
+            return true;
+        }
+
+        public String since() {
+            return "3.3.0";
+        }
+
+        public Boolean runAsync() {
+            return null;
+        }
+
+        public Construct exec(int line_num, File f, Env env, Construct... args) throws ConfigRuntimeException {
+            if(args[0] instanceof CArray){
+                CArray ca = (CArray)args[0];
+                CArray ca2 = new CArray(line_num, f);
+                for(String c : ca.keySet()){
+                    ca2.push(new CString(c, line_num, f));
+                }
+                return ca2;
+            } else {
+                throw new ConfigRuntimeException(this.getName() + " expects arg 1 to be an array", ExceptionType.CastException, line_num, f);
+            }
+        }
+        
+    }
+    
+    @api public static class array_normalize implements Function{
+
+        public String getName() {
+            return "array_normalize";
+        }
+
+        public Integer[] numArgs() {
+            return new Integer[]{1};
+        }
+
+        public String docs() {
+            return "array {array} Returns a new normal array, given an associative array. (If the array passed in is not associative, a copy of the "
+                    + " array is returned).";
+        }
+
+        public ExceptionType[] thrown() {
+            return new ExceptionType[]{ExceptionType.CastException};
+        }
+
+        public boolean isRestricted() {
+            return false;
+        }
+
+        public void varList(IVariableList varList) {}
+
+        public boolean preResolveVariables() {
+            return true;
+        }
+
+        public String since() {
+            return "3.3.0";
+        }
+
+        public Boolean runAsync() {
+            return null;
+        }
+
+        public Construct exec(int line_num, File f, Env env, Construct... args) throws ConfigRuntimeException {
+            if(args[0] instanceof CArray){
+                CArray ca = (CArray)args[0];
+                CArray ca2 = new CArray(line_num, f);
+                for(String c : ca.keySet()){
+                    ca2.push(ca.get(c, line_num, f));
+                }
+                return ca2;
+            } else {
+                throw new ConfigRuntimeException(this.getName() + " expects arg 1 to be an array", ExceptionType.CastException, line_num, f);
+            }
+        }
+        
+    }
+    
+    @api public static class array_merge implements Function{
+
+        public String getName() {
+            return "array_merge";
+        }
+
+        public Integer[] numArgs() {
+            return new Integer[]{Integer.MAX_VALUE};
+        }
+
+        public String docs() {
+            return "array {array1, array2, [arrayN...]} Merges the specified arrays from left to right, and returns a new array. If the array"
+                    + " merged is associative, it will overwrite the keys from left to right, but if the arrays are normal, the keys are ignored,"
+                    + " and values are simply pushed.";
+        }
+
+        public ExceptionType[] thrown() {
+            return new ExceptionType[]{ExceptionType.InsufficientArgumentsException, ExceptionType.CastException};
+        }
+
+        public boolean isRestricted() {
+            return false;
+        }
+
+        public boolean preResolveVariables() {
+            return true;
+        }
+
+        public String since() {
+            return "3.3.0";
+        }
+
+        public Boolean runAsync() {
+            return null;
+        }
+
+        public Construct exec(int line_num, File f, Env environment, Construct... args) throws ConfigRuntimeException {
+            CArray newArray = new CArray(line_num, f);
+            if(args.length < 2){
+                throw new ConfigRuntimeException("array_merge must be called with at least two parameters", ExceptionType.InsufficientArgumentsException, line_num, f);
+            }
+            for(int i = 0; i < args.length; i++){
+                if(args[i] instanceof CArray){
+                    CArray cur = (CArray)args[i];
+                    if(!cur.inAssociativeMode()){
+                        for(int j = 0; j < cur.size(); j++){
+                            newArray.push(cur.get(j, line_num, f));
+                        }
+                    } else {
+                        for(String key : cur.keySet()){
+                            newArray.set(key, cur.get(key, line_num, f));
+                        }
+                    }
+                } else {
+                    throw new ConfigRuntimeException("All arguments to array_merge must be arrays", ExceptionType.CastException, line_num, f);
+                }
+            }
+            return newArray;
+        }
+        
+    }
+    
+    @api public static class array_remove implements Function{
+
+        public String getName() {
+            return "array_remove";
+        }
+
+        public Integer[] numArgs() {
+            return new Integer[]{2};
+        }
+
+        public String docs() {
+            return "void {array, index} Removes an index from an array. If the array is a normal"
+                    + " array, all values' indicies are shifted left one. If the array is associative,"
+                    + " the index is simply removed. If the index doesn't exist, the array remains"
+                    + " unchanged.";
+        }
+
+        public ExceptionType[] thrown() {
+            return new ExceptionType[]{ExceptionType.CastException};
+        }
+
+        public boolean isRestricted() {
+            return false;
+        }
+
+        public boolean preResolveVariables() {
+            return true;
+        }
+
+        public String since() {
+            return "3.3.0";
+        }
+
+        public Boolean runAsync() {
+            return null;
+        }
+
+        public Construct exec(int line_num, File f, Env environment, Construct... args) throws ConfigRuntimeException {
+            if(args[0] instanceof CArray){
+                CArray ca = (CArray)args[0];
+                ca.remove(args[1]);
+            } else {
+                throw new ConfigRuntimeException("Argument 1 of array_remove should be an array", ExceptionType.CastException, line_num, f);
+            }
+            return new CVoid(line_num, f);
+        }
+        
+    }
+    
+    @api public static class array_implode implements Function{
+
+        public String getName() {
+            return "array_implode";
+        }
+
+        public Integer[] numArgs() {
+            return new Integer[]{1, 2};
+        }
+
+        public String docs() {
+            return "string {array, [glue]} Given an array and glue, to-strings all the elements"
+                    + " in the array (just the values, not the keys), and joins them with the glue, defaulting to a space. For instance"
+                    + " array_implode(array(1, 2, 3), '-') will return \"1-2-3\".";
+        }
+
+        public ExceptionType[] thrown() {
+            return new ExceptionType[]{ExceptionType.CastException};
+        }
+
+        public boolean isRestricted() {
+            return false;
+        }
+
+        public boolean preResolveVariables() {
+            return true;
+        }
+
+        public Boolean runAsync() {
+            return null;
+        }
+
+        public Construct exec(int line_num, File f, Env environment, Construct... args) throws ConfigRuntimeException {
+            if(!(args[0] instanceof CArray)){
+                throw new ConfigRuntimeException("Expecting argument 1 to be an array", ExceptionType.CastException, line_num, f);
+            }
+            StringBuilder b = new StringBuilder();
+            CArray ca = (CArray)args[0];
+            String glue = " ";
+            if(args.length == 2){
+                glue = args[1].val();
+            }
+            boolean first = true;
+            for(String key : ca.keySet()){
+                Construct value = ca.get(key, line_num, f);
+                if(!first){
+                    b.append(glue).append(value.val());
+                } else {
+                    b.append(value.val());
+                    first = false;
+                }
+            }
+            return new CString(b.toString(), line_num, f);
+        }
+
+        public String since() {
+            return "3.3.0";
+        }
+        
+    }
+}
diff --git a/src/main/java/com/laytonsmith/core/functions/BasicLogic.java b/src/main/java/com/laytonsmith/core/functions/BasicLogic.java
new file mode 100644
index 0000000..83f36db
--- /dev/null
+++ b/src/main/java/com/laytonsmith/core/functions/BasicLogic.java
@@ -0,0 +1,1179 @@
+
+package com.laytonsmith.core.functions;
+
+import com.laytonsmith.core.*;
+import com.laytonsmith.core.constructs.*;
+import com.laytonsmith.core.exceptions.CancelCommandException;
+import com.laytonsmith.core.exceptions.ConfigRuntimeException;
+import com.laytonsmith.core.functions.Exceptions.ExceptionType;
+import java.io.File;
+import java.util.List;
+
+/**
+ * 
+ * @author Layton
+ */
+public class BasicLogic {
+    public static String docs(){
+        return "These functions provide basic logical operations.";
+    }
+    @api public static class _if implements Function{
+
+        public String getName() {
+            return "if";
+        }
+
+        public Integer[] numArgs() {
+            return new Integer[]{2, 3};
+        }
+        
+        public Construct execs(int line_num, File f, Env env, Script parent, 
+                GenericTreeNode<Construct> condition, GenericTreeNode<Construct> __if, 
+                GenericTreeNode<Construct> __else) throws CancelCommandException{
+            if(Static.getBoolean(parent.eval(condition, env))){
+                return parent.eval(__if, env);
+            } else {
+                if(__else == null){
+                    return new CVoid(line_num, f);
+                }
+                return parent.eval(__else, env);
+            }
+        }
+
+        public Construct exec(int line_num, File f, Env env, Construct... args) throws CancelCommandException, ConfigRuntimeException {
+            return new CVoid(line_num, f);
+        }
+        
+        public ExceptionType[] thrown(){
+            return new ExceptionType[]{ExceptionType.CastException};
+        }
+
+        public String docs() {
+            return "mixed {cond, trueRet, [falseRet]} If the first argument evaluates to a true value, the second argument is returned, otherwise the third argument is returned."
+                    + " If there is no third argument, it returns void.";
+        }
+
+        public boolean isRestricted() {
+            return false;
+        }
+
+        public void varList(IVariableList varList) {}
+
+        public boolean preResolveVariables() {
+            return false;
+        }
+        public String since() {
+            return "3.0.1";
+        }
+        //Doesn't matter, this function is run out of state
+        public Boolean runAsync() {
+            return false;
+        }
+        
+    }
+    
+    @api public static class _switch implements Function{
+
+        public String getName() {
+            return "switch";
+        }
+
+        public Integer[] numArgs() {
+            return new Integer[]{Integer.MAX_VALUE};
+        }
+
+        public String docs() {
+            return "mixed {value, [equals, code]..., [defaultCode]} Provides a switch statement. If none of the conditions"
+                    + " match, and no default is provided, void is returned."
+                    + " See the documentation on [[CommandHelper/Logic|Logic]] for more information.";
+        }
+
+        public ExceptionType[] thrown() {
+            return new ExceptionType[]{ExceptionType.InsufficientArgumentsException};
+        }
+
+        public boolean isRestricted() {
+            return false;
+        }
+
+        public boolean preResolveVariables() {
+            return false;
+        }
+
+        public String since() {
+            return "3.3.0";
+        }
+
+        public Boolean runAsync() {
+            return null;
+        }
+
+        public Construct exec(int line_num, File f, Env environment, Construct... args) throws ConfigRuntimeException {
+            return new CNull(line_num, f);
+        }
+        
+        public Construct execs(int line_num, File f, Env env, List<GenericTreeNode<Construct>> children){
+            Construct value = env.GetScript().preResolveVariable(env.GetScript().eval(children.get(0), env));
+            equals equals = new equals();
+            for(int i = 1; i < children.size() - 2; i+=2){
+                GenericTreeNode<Construct> statement = children.get(i);
+                GenericTreeNode<Construct> code = children.get(i + 1);
+                Construct evalStatement = env.GetScript().eval(statement, env);
+                evalStatement = env.GetScript().preResolveVariable(evalStatement);
+                if(((CBoolean)equals.exec(line_num, f, env, value, evalStatement)).getBoolean()){
+                    return env.GetScript().eval(code, env);
+                }
+            }
+            if(children.size() % 2 == 0){
+                return env.GetScript().eval(children.get(children.size() - 1), env);
+            }
+            return new CVoid(line_num, f);
+        }
+        
+    }
+    
+    @api public static class ifelse implements Function{
+
+        public String getName() {
+            return "ifelse";
+        }
+
+        public Integer[] numArgs() {
+            return new Integer[]{Integer.MAX_VALUE};
+        }
+
+        public String docs() {
+            return "mixed {[boolean1, code]..., [elseCode]} Provides a more convenient method"
+                    + " for running if/else chains. If none of the conditions are true, and"
+                    + " there is no 'else' condition, void is returned.";
+        }
+
+        public ExceptionType[] thrown() {
+            return new ExceptionType[]{ExceptionType.InsufficientArgumentsException};
+        }
+
+        public boolean isRestricted() {
+            return false;
+        }
+
+        public boolean preResolveVariables() {
+            return false;
+        }
+
+        public String since() {
+            return "3.3.0";
+        }
+
+        public Boolean runAsync() {
+            return null;
+        }
+
+        public Construct exec(int line_num, File f, Env environment, Construct... args) throws ConfigRuntimeException {
+            return new CNull(line_num, f);
+        }
+        
+        public Construct execs(int line_num, File f, Env env, List<GenericTreeNode<Construct>> children){
+            if(children.size() < 2){
+                throw new ConfigRuntimeException("ifelse expects at least 2 arguments", ExceptionType.InsufficientArgumentsException, line_num, f);
+            }
+            for(int i = 0; i <= children.size() - 2; i+=2){
+                GenericTreeNode<Construct> statement = children.get(i);
+                GenericTreeNode<Construct> code = children.get(i + 1);
+                Construct evalStatement = env.GetScript().eval(statement, env);
+                evalStatement = env.GetScript().preResolveVariable(evalStatement);
+                if(Static.getBoolean(evalStatement)){
+                    return env.GetScript().eval(code, env);
+                }
+            }
+            if(children.size() % 2 == 1){
+                return env.GetScript().eval(children.get(children.size() - 1), env);
+            }
+            return new CVoid(line_num, f);
+        }
+        
+    }
+    
+    @api public static class equals implements Function{
+
+        public String getName() {
+            return "equals";
+        }
+
+        public Integer[] numArgs() {
+            return new Integer[]{2};
+        }
+
+        public Construct exec(int line_num, File f, Env env, Construct... args) throws CancelCommandException, ConfigRuntimeException {
+            if(Static.anyBooleans(args)){
+                boolean arg1 = Static.getBoolean(args[0]);
+                boolean arg2 = Static.getBoolean(args[1]);
+                return new CBoolean(arg1 == arg2, line_num, f);
+            }
+            if(args[0].val().equals(args[1].val())){
+                return new CBoolean(true, line_num, f);
+            }
+            try{
+                double arg1 = Static.getNumber(args[0]);
+                double arg2 = Static.getNumber(args[1]);
+                return new CBoolean(arg1 == arg2, line_num, f);
+            } catch (ConfigRuntimeException e){
+                return new CBoolean(false, line_num, f);
+            }
+        }
+        
+        public ExceptionType[] thrown(){
+            return new ExceptionType[]{ExceptionType.CastException};
+        }
+
+        public String docs() {
+            return "boolean {var1, var2} Returns true or false if the two arguments are equal";
+        }
+
+        public boolean isRestricted() {
+            return false;
+        }
+
+        public void varList(IVariableList varList) {}
+
+        public boolean preResolveVariables() {
+            return true;
+        }
+        public String since() {
+            return "3.0.1";
+        }
+        public Boolean runAsync() {
+            return null;
+        }
+    }
+    
+    @api public static class sequals implements Function{
+
+        public String getName() {
+            return "sequals";
+        }
+
+        public Integer[] numArgs() {
+            return new Integer[]{2};
+        }
+
+        public String docs() {
+            return "boolean {val1, val2} Uses a strict equals check, which determines if"
+                    + " two values are not only equal, but also the same type. So, while"
+                    + " equals('1', 1) returns true, sequals('1', 1) returns false, because"
+                    + " the first one is a string, and the second one is an int. More often"
+                    + " than not, you want to use plain equals().";
+        }
+
+        public ExceptionType[] thrown() {
+            return new ExceptionType[]{};
+        }
+
+        public boolean isRestricted() {
+            return false;
+        }
+
+        public boolean preResolveVariables() {
+            return true;
+        }
+
+        public String since() {
+            return "3.3.0";
+        }
+
+        public Boolean runAsync() {
+            return null;
+        }
+
+        public Construct exec(int line_num, File f, Env environment, Construct... args) throws ConfigRuntimeException {
+            equals equals = new equals();
+            if(args[1].getClass().equals(args[0].getClass())
+                    && ((CBoolean)equals.exec(line_num, f, environment, args)).getBoolean()){
+                return new CBoolean(true, line_num, f);
+            } else {
+                return new CBoolean(false, line_num, f);
+            }
+        }
+        
+    }
+    
+    @api public static class nequals implements Function{
+
+        public String getName() {
+            return "nequals";
+        }
+
+        public Integer[] numArgs() {
+            return new Integer[]{2};
+        }
+
+        public String docs() {
+            return "boolean {val1, val2} Returns true if the two values are NOT equal, or false"
+                    + " otherwise. Equivalent to not(equals(val1, val2))";
+        }
+
+        public ExceptionType[] thrown() {
+            return new ExceptionType[]{};
+        }
+
+        public boolean isRestricted() {
+            return false;
+        }
+
+        public boolean preResolveVariables() {
+            return true;
+        }
+
+        public String since() {
+            return "3.3.0";
+        }
+
+        public Boolean runAsync() {
+            return null;
+        }
+
+        public Construct exec(int line_num, File f, Env env, Construct... args) throws ConfigRuntimeException {
+            equals e = new equals();
+            CBoolean b = (CBoolean) e.exec(line_num, f, env, args);
+            return new CBoolean(!b.getBoolean(), line_num, f);
+        }
+        
+    }
+    
+    @api public static class equals_ic implements Function{
+
+        public String getName() {
+            return "equals_ic";
+        }
+
+        public Integer[] numArgs() {
+            return new Integer[]{2};
+        }
+
+        public String docs() {
+            return "boolean {val1, val2} Returns true if the two values are equal to each other, while"
+                    + " ignoring case.";
+        }
+
+        public ExceptionType[] thrown() {
+            return new ExceptionType[]{};
+        }
+
+        public boolean isRestricted() {
+            return false;
+        }
+
+        public void varList(IVariableList varList) {}
+
+        public boolean preResolveVariables() {
+            return true;
+        }
+
+        public String since() {
+            return "3.2.0";
+        }
+
+        public Boolean runAsync() {
+            return null;
+        }
+
+        public Construct exec(int line_num, File f, Env env, Construct... args) throws ConfigRuntimeException {
+            if(Static.anyBooleans(args)){
+                boolean arg1 = Static.getBoolean(args[0]);
+                boolean arg2 = Static.getBoolean(args[1]);
+                return new CBoolean(arg1 == arg2, line_num, f);
+            }
+            if(args[0].val().equalsIgnoreCase(args[1].val())){
+                return new CBoolean(true, line_num, f);
+            }
+            try{
+                double arg1 = Static.getNumber(args[0]);
+                double arg2 = Static.getNumber(args[1]);
+                return new CBoolean(arg1 == arg2, line_num, f);
+            } catch (ConfigRuntimeException e){
+                return new CBoolean(false, line_num, f);
+            }
+        }
+        
+    }
+    
+    @api public static class nequals_ic implements Function{
+
+        public String getName() {
+            return "nequals_ic";
+        }
+
+        public Integer[] numArgs() {
+            return new Integer[]{2};
+        }
+
+        public String docs() {
+            return "boolean {val1, val2} Returns true if the two values are NOT equal to each other, while"
+                    + " ignoring case.";
+        }
+
+        public ExceptionType[] thrown() {
+            return new ExceptionType[]{};
+        }
+
+        public boolean isRestricted() {
+            return false;
+        }
+
+        public boolean preResolveVariables() {
+            return true;
+        }
+
+        public String since() {
+            return "3.3.0";
+        }
+
+        public Boolean runAsync() {
+            return null;
+        }
+
+        public Construct exec(int line_num, File f, Env environment, Construct... args) throws ConfigRuntimeException {
+            equals_ic e = new equals_ic();
+            return new CBoolean(!((CBoolean)e.exec(line_num, f, environment, args)).getBoolean(), line_num, f);
+        }
+        
+    }
+    
+    @api public static class lt implements Function{
+
+        public String getName() {
+            return "lt";
+        }
+
+        public Integer[] numArgs() {
+            return new Integer[]{2};
+        }
+
+        public Construct exec(int line_num, File f, Env env, Construct... args) throws CancelCommandException, ConfigRuntimeException {
+            double arg1 = Static.getNumber(args[0]);
+            double arg2 = Static.getNumber(args[1]);
+            return new CBoolean(arg1 < arg2, line_num, f);
+        }
+        
+        public ExceptionType[] thrown(){
+            return new ExceptionType[]{ExceptionType.CastException};
+        }
+
+        public String docs() {
+            return "boolean {var1, var2} Returns the results of a less than operation";
+        }
+
+        public boolean isRestricted() {
+            return false;
+        }
+
+        public void varList(IVariableList varList) {}
+
+        public boolean preResolveVariables() {
+            return true;
+        }
+        public String since() {
+            return "3.0.1";
+        }
+        public Boolean runAsync() {
+            return null;
+        }
+    }
+    
+    @api public static class gt implements Function{
+
+        public String getName() {
+            return "gt";
+        }
+
+        public Integer[] numArgs() {
+            return new Integer[]{2};
+        }
+
+        public Construct exec(int line_num, File f, Env env, Construct... args) throws CancelCommandException, ConfigRuntimeException {
+            double arg1 = Static.getNumber(args[0]);
+            double arg2 = Static.getNumber(args[1]);
+            return new CBoolean(arg1 > arg2, line_num, f);
+        }
+        
+        public ExceptionType[] thrown(){
+            return new ExceptionType[]{ExceptionType.CastException};
+        }
+
+        public String docs() {
+            return "boolean {var1, var2} Returns the result of a greater than operation";
+        }
+
+        public boolean isRestricted() {
+            return false;
+        }
+
+        public void varList(IVariableList varList) {}
+
+        public boolean preResolveVariables() {
+            return true;
+        }
+        public String since() {
+            return "3.0.1";
+        }
+        
+        public Boolean runAsync() {
+            return null;
+        }
+    }
+    
+    @api public static class lte implements Function{
+
+        public String getName() {
+            return "lte";
+        }
+
+        public Integer[] numArgs() {
+            return new Integer[]{2};
+        }
+
+        public Construct exec(int line_num, File f, Env env, Construct... args) throws CancelCommandException, ConfigRuntimeException {
+            double arg1 = Static.getNumber(args[0]);
+            double arg2 = Static.getNumber(args[1]);
+            return new CBoolean(arg1 <= arg2, line_num, f);
+        }
+        
+        public ExceptionType[] thrown(){
+            return new ExceptionType[]{ExceptionType.CastException};
+        }
+
+        public String docs() {
+            return "boolean {var1, var2} Returns the result of a less than or equal to operation";
+        }
+
+        public boolean isRestricted() {
+            return false;
+        }
+
+        public void varList(IVariableList varList) {}
+
+        public boolean preResolveVariables() {
+            return true;
+        }
+        public String since() {
+            return "3.0.1";
+        }
+        public Boolean runAsync() {
+            return null;
+        }
+    }
+    
+    @api public static class gte implements Function{
+
+        public String getName() {
+            return "gte";
+        }
+
+        public Integer[] numArgs() {
+            return new Integer[]{2};
+        }
+
+        public Construct exec(int line_num, File f, Env env, Construct... args) throws CancelCommandException, ConfigRuntimeException {
+            double arg1 = Static.getNumber(args[0]);
+            double arg2 = Static.getNumber(args[1]);
+            return new CBoolean(arg1 >= arg2, line_num, f);
+        }
+        
+        public ExceptionType[] thrown(){
+            return new ExceptionType[]{ExceptionType.CastException};
+        }
+
+        public String docs() {
+            return "boolean {var1, var2} Returns the result of a greater than or equal to operation";
+        }
+
+        public boolean isRestricted() {
+            return false;
+        }
+
+        public void varList(IVariableList varList) {}
+
+        public boolean preResolveVariables() {
+            return true;
+        }
+        public String since() {
+            return "3.0.1";
+        }
+        public Boolean runAsync() {
+            return null;
+        }
+    }
+    
+    @api public static class and implements Function{
+
+        public String getName() {
+            return "and";
+        }
+
+        public Integer[] numArgs() {
+            return new Integer[]{Integer.MAX_VALUE};
+        }
+        public Construct exec(int line_num, File f, Env env, Construct ... args){
+            return new CNull(line_num, f);
+        }
+        public Construct execs(int line_num, File f, Env env, List<GenericTreeNode<Construct>> args) throws CancelCommandException, ConfigRuntimeException {
+            for(GenericTreeNode<Construct> tree : args){
+                Construct c = env.GetScript().eval(tree, env);
+                boolean b = Static.getBoolean(c);
+                if(b == false){
+                    return new CBoolean(false, line_num, f);
+                }
+            }
+            return new CBoolean(true, line_num, f);
+        }
+        
+        public ExceptionType[] thrown(){
+            return new ExceptionType[]{ExceptionType.CastException};
+        }
+
+        public String docs() {
+            return "boolean {var1, [var2...]} Returns the boolean value of a logical AND across all arguments. Uses lazy determination, so once "
+                    + "an argument returns false, the function returns.";
+        }
+
+        public boolean isRestricted() {
+            return false;
+        }
+
+        public void varList(IVariableList varList) {}
+
+        public boolean preResolveVariables() {
+            return true;
+        }
+        public String since() {
+            return "3.0.1";
+        }
+        public Boolean runAsync() {
+            return null;
+        }
+    }
+    
+    @api public static class or implements Function{
+
+        public String getName() {
+            return "or";
+        }
+
+        public Integer[] numArgs() {
+            return new Integer[]{Integer.MAX_VALUE};
+        }
+
+        public Construct exec(int line_num, File f, Env env, Construct... args){
+            return new CNull(line_num, f);
+        }
+        
+        public Construct execs(int line_num, File f, Env env, List<GenericTreeNode<Construct>> args) throws CancelCommandException, ConfigRuntimeException {            
+            for(GenericTreeNode<Construct> tree: args){
+                Construct c = env.GetScript().eval(tree, env);
+                if(Static.getBoolean(c)){
+                    return new CBoolean(true, line_num, f);
+                }
+            }
+            return new CBoolean(false, line_num, f);
+        }
+        
+        public ExceptionType[] thrown(){
+            return new ExceptionType[]{ExceptionType.CastException};
+        }
+
+        public String docs() {
+            return "boolean {var1, [var2...]} Returns the boolean value of a logical OR across all arguments. Uses lazy determination, so once an "
+                    + "argument resolves to true, the function returns.";
+        }
+
+        public boolean isRestricted() {
+            return false;
+        }
+
+        public void varList(IVariableList varList) {}
+
+        public boolean preResolveVariables() {
+            return true;
+        }
+        public String since() {
+            return "3.0.1";
+        }
+        public Boolean runAsync() {
+            return null;
+        }
+    }
+    
+    @api public static class not implements Function{
+
+        public String getName() {
+            return "not";
+        }
+
+        public Integer[] numArgs() {
+            return new Integer[]{1};
+        }
+
+        public Construct exec(int line_num, File f, Env env, Construct... args) throws CancelCommandException, ConfigRuntimeException {
+            return new CBoolean(!Static.getBoolean(args[0]), line_num, f);
+        }
+        
+        public ExceptionType[] thrown(){
+            return new ExceptionType[]{ExceptionType.CastException};
+        }
+
+        public String docs() {
+            return "boolean {var1} Returns the boolean value of a logical NOT for this argument";
+        }
+
+        public boolean isRestricted() {
+            return false;
+        }
+
+        public void varList(IVariableList varList) {}
+
+        public boolean preResolveVariables() {
+            return true;
+        }
+        public String since() {
+            return "3.0.1";
+        }
+        public Boolean runAsync() {
+            return null;
+        }
+    }
+    
+    @api public static class xor implements Function{
+
+        public String getName() {
+            return "xor";
+        }
+
+        public Integer[] numArgs() {
+            return new Integer[]{2};
+        }
+
+        public String docs() {
+            return "boolean {val1, val2} Returns the xor of the two values.";
+        }
+
+        public ExceptionType[] thrown() {
+            return new ExceptionType[]{ExceptionType.CastException};
+        }
+
+        public boolean isRestricted() {
+            return false;
+        }
+
+        public boolean preResolveVariables() {
+            return true;
+        }
+
+        public String since() {
+            return "3.3.0";
+        }
+
+        public Boolean runAsync() {
+            return null;
+        }
+
+        public Construct exec(int line_num, File f, Env environment, Construct... args) throws ConfigRuntimeException {
+            boolean val1 = Static.getBoolean(args[0]);
+            boolean val2 = Static.getBoolean(args[1]);
+            return new CBoolean(val1 ^ val2, line_num, f);
+        }
+        
+    }
+    
+    @api public static class nand implements Function{
+
+        public String getName() {
+            return "nand";
+        }
+
+        public Integer[] numArgs() {
+            return new Integer[]{Integer.MAX_VALUE};
+        }
+
+        public String docs() {
+            return "boolean {val1, [val2...]} Return the equivalent of not(and())";
+        }
+
+        public ExceptionType[] thrown() {
+            return new ExceptionType[]{ExceptionType.CastException};
+        }
+
+        public boolean isRestricted() {
+            return false;
+        }
+
+        public boolean preResolveVariables() {
+            return true;
+        }
+
+        public String since() {
+            return "3.3.0";
+        }
+
+        public Boolean runAsync() {
+            return null;
+        }
+        public Construct exec(int line_num, File f, Env environment, Construct... args){
+            return new CNull(line_num, f);
+        }
+        public Construct execs(int line_num, File f, Env environment, List<GenericTreeNode<Construct>> args) throws ConfigRuntimeException {
+            and and = new and();
+            boolean val = ((CBoolean)and.execs(line_num, f, environment, args)).getBoolean();
+            return new CBoolean(!val, line_num, f);
+        }
+        
+    }
+    
+    @api public static class nor implements Function{
+
+        public String getName() {
+            return "nor";
+        }
+
+        public Integer[] numArgs() {
+            return new Integer[]{Integer.MAX_VALUE};
+        }
+
+        public String docs() {
+            return "boolean {val1, [val2...]} Returns the equivalent of not(or())";
+        }
+
+        public ExceptionType[] thrown() {
+            return new ExceptionType[]{ExceptionType.CastException};
+        }
+
+        public boolean isRestricted() {
+            return false;
+        }
+
+        public boolean preResolveVariables() {
+            return true;
+        }
+
+        public String since() {
+            return "3.3.0";
+        }
+
+        public Boolean runAsync() {
+            return null;
+        }
+        public Construct exec(int line_num, File f, Env environment, Construct ... args){
+            return new CNull(line_num, f);
+        }
+        
+        public Construct execs(int line_num, File f, Env environment, List<GenericTreeNode<Construct>> args) throws ConfigRuntimeException {
+            or or = new or();
+            boolean val = ((CBoolean)or.execs(line_num, f, environment, args)).getBoolean();
+            return new CBoolean(!val, line_num, f);
+        }
+        
+    }
+    
+    @api public static class xnor implements Function{
+
+        public String getName() {
+            return "xnor";
+        }
+
+        public Integer[] numArgs() {
+            return new Integer[]{2};
+        }
+
+        public String docs() {
+            return "boolean {val1, val2} Returns the xnor of the two values";
+        }
+
+        public ExceptionType[] thrown() {
+            return new ExceptionType[]{ExceptionType.CastException};
+        }
+
+        public boolean isRestricted() {
+            return false;
+        }
+
+        public boolean preResolveVariables() {
+            return true;
+        }
+
+        public String since() {
+            return "3.3.0";
+        }
+
+        public Boolean runAsync() {
+            return null;
+        }
+
+        public Construct exec(int line_num, File f, Env environment, Construct... args) throws ConfigRuntimeException {
+            xor xor = new xor();
+            boolean val = ((CBoolean)xor.exec(line_num, f, environment, args)).getBoolean();
+            return new CBoolean(!val, line_num, f);
+        }
+        
+    }
+    
+    @api public static class bit_and implements Function{
+
+        public String getName() {
+            return "bit_and";
+        }
+
+        public Integer[] numArgs() {
+            return new Integer[]{Integer.MAX_VALUE};
+        }
+
+        public String docs() {
+            return "int {int1, [int2...]} Returns the bitwise AND of the values";
+        }
+
+        public ExceptionType[] thrown() {
+            return new ExceptionType[]{ExceptionType.CastException, ExceptionType.InsufficientArgumentsException};
+        }
+
+        public boolean isRestricted() {
+            return false;
+        }
+
+        public boolean preResolveVariables() {
+            return true;
+        }
+
+        public String since() {
+            return "3.3.0";
+        }
+
+        public Boolean runAsync() {
+            return null;
+        }
+
+        public Construct exec(int line_num, File f, Env environment, Construct... args) throws ConfigRuntimeException {
+            if(args.length < 1){
+                throw new ConfigRuntimeException("bit_and requires at least one argument", ExceptionType.InsufficientArgumentsException, line_num, f);
+            }
+            long val = Static.getInt(args[0]);
+            for(int i = 1; i < args.length; i++){
+                val = val & Static.getInt(args[i]);
+            }
+            return new CInt(val, line_num, f);
+        }
+        
+    }
+    
+    @api public static class bit_or implements Function{
+
+        public String getName() {
+            return "bit_or";
+        }
+
+        public Integer[] numArgs() {
+            return new Integer[]{Integer.MAX_VALUE};
+        }
+
+        public String docs() {
+            return "int {int1, [int2...]} Returns the bitwise OR of the specified values";
+        }
+
+        public ExceptionType[] thrown() {
+            return new ExceptionType[]{ExceptionType.CastException, ExceptionType.InsufficientArgumentsException};
+        }
+
+        public boolean isRestricted() {
+            return false;
+        }
+
+        public boolean preResolveVariables() {
+            return true;
+        }
+
+        public String since() {
+            return "3.3.0";
+        }
+
+        public Boolean runAsync() {
+            return null;
+        }
+
+        public Construct exec(int line_num, File f, Env environment, Construct... args) throws ConfigRuntimeException {
+            if(args.length < 1){
+                throw new ConfigRuntimeException("bit_or requires at least one argument", ExceptionType.InsufficientArgumentsException, line_num, f);
+            }
+            long val = Static.getInt(args[0]);
+            for(int i = 1; i < args.length; i++){
+                val = val | Static.getInt(args[i]);
+            }
+            return new CInt(val, line_num, f);
+        }
+        
+    }
+    
+    @api public static class bit_not implements Function{
+
+        public String getName() {
+            return "bit_not";
+        }
+
+        public Integer[] numArgs() {
+            return new Integer[]{1};
+        }
+
+        public String docs() {
+            return "int {int1} Returns the bitwise NOT of the given value";
+        }
+
+        public ExceptionType[] thrown() {
+            return new ExceptionType[]{ExceptionType.CastException};
+        }
+
+        public boolean isRestricted() {
+            return false;
+        }
+
+        public boolean preResolveVariables() {
+            return true;
+        }
+
+        public String since() {
+            return "3.3.0";
+        }
+
+        public Boolean runAsync() {
+            return null;
+        }
+
+        public Construct exec(int line_num, File f, Env environment, Construct... args) throws ConfigRuntimeException {
+            return new CInt(~Static.getInt(args[0]), line_num, f);
+        }
+        
+    }
+    
+    @api public static class lshift implements Function{
+
+        public String getName() {
+            return "lshift";
+        }
+
+        public Integer[] numArgs() {
+            return new Integer[]{2};
+        }
+
+        public String docs() {
+            return "int {value, bitsToShift} Left shifts the value bitsToShift times";
+        }
+
+        public ExceptionType[] thrown() {
+            return new ExceptionType[]{ExceptionType.CastException};
+        }
+
+        public boolean isRestricted() {
+            return false;
+        }
+
+        public boolean preResolveVariables() {
+            return true;
+        }
+
+        public String since() {
+            return "3.3.0";
+        }
+
+        public Boolean runAsync() {
+            return null;
+        }
+
+        public Construct exec(int line_num, File f, Env environment, Construct... args) throws ConfigRuntimeException {
+            long value = Static.getInt(args[0]);
+            long toShift = Static.getInt(args[1]);
+            return new CInt(value << toShift, line_num, f);            
+        }
+                
+    }
+    
+    @api public static class rshift implements Function{
+
+        public String getName() {
+            return "rshift";
+        }
+
+        public Integer[] numArgs() {
+            return new Integer[]{2};
+        }
+
+        public String docs() {
+            return "int {value, bitsToShift} Right shifts the value bitsToShift times";
+        }
+
+        public ExceptionType[] thrown() {
+            return new ExceptionType[]{ExceptionType.CastException};
+        }
+
+        public boolean isRestricted() {
+            return false;
+        }
+
+        public boolean preResolveVariables() {
+            return true;
+        }
+
+        public String since() {
+            return "3.3.0";
+        }
+
+        public Boolean runAsync() {
+            return null;
+        }
+
+        public Construct exec(int line_num, File f, Env environment, Construct... args) throws ConfigRuntimeException {
+            long value = Static.getInt(args[0]);
+            long toShift = Static.getInt(args[1]);
+            return new CInt(value >> toShift, line_num, f);
+        }
+        
+    }
+    
+    @api public static class urshift implements Function{
+
+        public String getName() {
+            return "urshift";
+        }
+
+        public Integer[] numArgs() {
+            return new Integer[]{2};
+        }
+
+        public String docs() {
+            return "int {value, bitsToShift} Right shifts value bitsToShift times, pushing a 0, making"
+                    + " this an unsigned right shift.";
+        }
+
+        public ExceptionType[] thrown() {
+            return new ExceptionType[]{ExceptionType.CastException};
+        }
+
+        public boolean isRestricted() {
+            return false;
+        }
+
+        public boolean preResolveVariables() {
+            return true;
+        }
+
+        public String since() {
+            return "3.3.0";
+        }
+
+        public Boolean runAsync() {
+            return null;
+        }
+
+        public Construct exec(int line_num, File f, Env environment, Construct... args) throws ConfigRuntimeException {
+            long value = Static.getInt(args[0]);
+            long toShift = Static.getInt(args[1]);
+            return new CInt(value >>> toShift, line_num, f);
+        }
+        
+    }
+    
+    
+}
diff --git a/src/main/java/com/laytonsmith/core/functions/Crypto.java b/src/main/java/com/laytonsmith/core/functions/Crypto.java
new file mode 100644
index 0000000..ccdcd2b
--- /dev/null
+++ b/src/main/java/com/laytonsmith/core/functions/Crypto.java
@@ -0,0 +1,183 @@
+/*
+ * To change this template, choose Tools | Templates
+ * and open the template in the editor.
+ */
+package com.laytonsmith.core.functions;
+
+import com.laytonsmith.core.Env;
+import com.laytonsmith.core.api;
+import com.laytonsmith.core.constructs.CString;
+import com.laytonsmith.core.constructs.Construct;
+import com.laytonsmith.core.exceptions.ConfigRuntimeException;
+import com.laytonsmith.core.functions.Exceptions.ExceptionType;
+import java.io.File;
+import java.math.BigInteger;
+import java.security.MessageDigest;
+import java.security.NoSuchAlgorithmException;
+
+/**
+ * @author Layton
+ */
+public class Crypto {
+
+    public static String docs() {
+        return "Provides common cryptographic functions";
+    }
+
+    @api
+    public static class rot13 implements Function {
+
+        public String getName() {
+            return "rot13";
+        }
+
+        public Integer[] numArgs() {
+            return new Integer[]{1};
+        }
+
+        public String docs() {
+            return "string {val} Returns the rot13 version of val. Note that rot13(rot13(val)) returns val";
+        }
+
+        public ExceptionType[] thrown() {
+            return new ExceptionType[]{};
+        }
+
+        public boolean isRestricted() {
+            return false;
+        }
+
+        public boolean preResolveVariables() {
+            return true;
+        }
+
+        public String since() {
+            return "3.3.0";
+        }
+
+        public Boolean runAsync() {
+            return null;
+        }
+
+        public Construct exec(int line_num, File f, Env environment, Construct... args) throws ConfigRuntimeException {
+            String s = args[0].val();
+            StringBuilder b = new StringBuilder();
+            for (int i = 0; i < s.length(); i++) {
+                char c = s.charAt(i);
+                if (c >= 'a' && c <= 'm') {
+                    c += 13;
+                } else if (c >= 'n' && c <= 'z') {
+                    c -= 13;
+                } else if (c >= 'A' && c <= 'M') {
+                    c += 13;
+                } else if (c >= 'A' && c <= 'Z') {
+                    c -= 13;
+                }
+                b.append(c);
+            }
+            return new CString(b.toString(), line_num, f);
+        }
+    }
+
+    @api
+    public static class md5 implements Function {
+
+        public String getName() {
+            return "md5";
+        }
+
+        public Integer[] numArgs() {
+            return new Integer[]{1};
+        }
+
+        public String docs() {
+            return "string {val} Returns the md5 hash of the specified string. The md5 hash is no longer considered secure, so you should"
+                    + " not use it for storage of sensitive data, however for general hashing, it is a quick and easy solution. md5 is"
+                    + " a one way hashing algorithm.";
+        }
+
+        public ExceptionType[] thrown() {
+            return new ExceptionType[]{ExceptionType.PluginInternalException};
+        }
+
+        public boolean isRestricted() {
+            return false;
+        }
+
+        public boolean preResolveVariables() {
+            return true;
+        }
+
+        public String since() {
+            return "3.3.0";
+        }
+
+        public Boolean runAsync() {
+            return null;
+        }
+
+        public Construct exec(int line_num, File f, Env environment, Construct... args) throws ConfigRuntimeException {
+            try {
+                MessageDigest digest = java.security.MessageDigest.getInstance("MD5");
+                digest.update(args[0].val().getBytes());
+                String hash = toHex(digest.digest()).toLowerCase();
+                return new CString(hash, line_num, f);
+            } catch (NoSuchAlgorithmException ex) {
+                throw new ConfigRuntimeException("An error occured while trying to hash your data", ExceptionType.PluginInternalException, line_num, f, ex);
+            }
+        }
+    }
+
+    @api
+    public static class sha1 implements Function {
+
+        public String getName() {
+            return "sha1";
+        }
+
+        public Integer[] numArgs() {
+            return new Integer[]{1};
+        }
+
+        public String docs() {
+            return "string {val} Returns the sha1 hash of the specified string. Note that sha1 is considered more secure than md5, and is"
+                    + " typically used when storing sensitive data. It is a one way hashing algorithm.";
+        }
+
+        public ExceptionType[] thrown() {
+            return new ExceptionType[]{ExceptionType.PluginInternalException};
+        }
+
+        public boolean isRestricted() {
+            return false;
+        }
+
+        public boolean preResolveVariables() {
+            return true;
+        }
+
+        public String since() {
+            return "3.3.0";
+        }
+
+        public Boolean runAsync() {
+            return null;
+        }
+
+        public Construct exec(int line_num, File f, Env environment, Construct... args) throws ConfigRuntimeException {
+            try {
+                MessageDigest digest = java.security.MessageDigest.getInstance("SHA1");
+                digest.update(args[0].val().getBytes());
+                String hash = toHex(digest.digest()).toLowerCase();
+                return new CString(hash, line_num, f);
+            } catch (NoSuchAlgorithmException ex) {
+                throw new ConfigRuntimeException("An error occured while trying to hash your data", ExceptionType.PluginInternalException, line_num, f, ex);
+            }
+        }
+    }
+
+    public static String toHex(byte[] bytes) {
+        BigInteger bi = new BigInteger(1, bytes);
+        return String.format("%0" + (bytes.length << 1) + "X", bi);
+    }
+}
diff --git a/src/main/java/com/laytonsmith/core/functions/DataHandling.java b/src/main/java/com/laytonsmith/core/functions/DataHandling.java
new file mode 100644
index 0000000..d8f3414
--- /dev/null
+++ b/src/main/java/com/laytonsmith/core/functions/DataHandling.java
@@ -0,0 +1,1131 @@
+/*
+ * To change this template, choose Tools | Templates
+ * and open the template in the editor.
+ */
+package com.laytonsmith.core.functions;
+
+import com.laytonsmith.core.*;
+import com.laytonsmith.core.constructs.*;
+import com.laytonsmith.core.exceptions.*;
+import com.laytonsmith.core.functions.Exceptions.ExceptionType;
+import java.io.File;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.List;
+
+/**
+ *
+ * @author Layton
+ */
+public class DataHandling {
+    public static String docs(){
+        return "This class provides various methods to control script data and program flow.";
+    }
+    @api public static class array implements Function{
+
+        public String getName() {
+            return "array";
+        }
+
+        public Integer[] numArgs() {
+            return new Integer[]{Integer.MAX_VALUE};
+        }
+
+        public Construct exec(int line_num, File f, Env env, Construct... args) throws CancelCommandException, ConfigRuntimeException {
+            return new CArray(line_num, f, args);
+        }
+        
+        public ExceptionType[] thrown(){
+            return new ExceptionType[]{};
+        }
+
+        public String docs() {
+            return "array {[var1, [var2...]]} Creates an array of values.";
+        }
+
+        public boolean isRestricted() {
+            return false;
+        }
+
+        public void varList(IVariableList varList) {}
+
+        public boolean preResolveVariables() {
+            return true;
+        }
+        public String since() {
+            return "3.0.1";
+        }
+        public Boolean runAsync() {
+            return null;
+        }
+    }
+    
+    @api public static class assign implements Function{
+        public String getName() {
+            return "assign";
+        }
+
+        public Integer[] numArgs() {
+            return new Integer[]{2};
+        }
+
+        public Construct exec(int line_num, File f, Env env, Construct... args) throws CancelCommandException, ConfigRuntimeException {
+            Construct c = args[1];
+            while(c instanceof IVariable){
+                c = env.GetVarList().get(((IVariable)c).getName()).ival();
+            }
+            if(args[0] instanceof IVariable){
+                IVariable v = new IVariable(((IVariable)args[0]).getName(), c, line_num, f);
+                env.GetVarList().set(v);
+                return v;
+            }
+            throw new ConfigRuntimeException("assign only accepts an ivariable or array reference as the first argument", ExceptionType.CastException, line_num, f);
+        }
+        private static class Chain {
+            ArrayList<Construct> indexChain = new ArrayList<Construct>();
+        }
+        private void prepare(CArrayReference container, Chain c){
+            if(container.array instanceof CArrayReference){
+                prepare((CArrayReference)container.array, c);
+                c.indexChain.add(container.index);
+            } else {
+                c.indexChain.add(container.index);               
+            }
+        }
+        
+        public Construct array_assign(int line_num, File f, Env env, Construct arrayAndIndex, Construct toSet){
+            Construct ival = toSet;
+            while(ival instanceof IVariable){
+                ival = env.GetVarList().get(((IVariable)ival).getName()).ival();
+            }
+            Chain c = new Chain();
+            prepare((CArrayReference)arrayAndIndex, c);
+            CArray inner = (CArray)((CArrayReference)arrayAndIndex).getInternalArray();
+            for(int i = 0; i < c.indexChain.size(); i++){
+                if(i == c.indexChain.size() - 1){
+                    //Last one, set it
+                    inner.set(c.indexChain.get(i), ival);
+                } else {
+                    boolean makeIt = false;
+                    Construct t = null;
+                    if(!inner.containsKey(c.indexChain.get(i).val())){
+                        makeIt = true;
+                    } else {
+                        t = inner.get(c.indexChain.get(i), line_num, f);
+                        if(!(t instanceof CArray)){
+                            makeIt = true;
+                        }
+                    }
+                    if(makeIt){
+                        Construct newArray = new CArray(line_num, f);
+                        inner.set(c.indexChain.get(i), newArray);
+                        t = newArray;
+                    }
+                    inner = (CArray)t;
+                }
+            }
+            String name = ((CArrayReference)arrayAndIndex).name.getName();
+            env.GetVarList().set(new IVariable(name, (CArray)((CArrayReference)arrayAndIndex).getInternalArray(), line_num, f));
+            return new IVariable("=anon", ival, line_num, f);
+        }
+        
+        public ExceptionType[] thrown(){
+            return new ExceptionType[]{ExceptionType.CastException};
+        }
+
+        public String docs() {
+            return "ivariable {ivar, mixed} Accepts an ivariable ivar as a parameter, and puts the specified value mixed in it. Returns the variable that was assigned.";
+        }
+
+        public boolean isRestricted() {
+            return false;
+        }
+
+        public boolean preResolveVariables() {
+            return false;
+        }
+        public String since() {
+            return "3.0.1";
+        }
+        public Boolean runAsync() {
+            return null;
+        }
+    }
+    
+    @api public static class _for implements Function{
+        public String getName() {
+            return "for";
+        }
+
+        public Integer[] numArgs() {
+            return new Integer[]{4};
+        }
+        public Construct execs(int line_num, File f, Env env, Script parent, GenericTreeNode<Construct> assign, 
+                GenericTreeNode<Construct> condition, GenericTreeNode<Construct> expression, 
+                GenericTreeNode<Construct> runnable) throws CancelCommandException{
+            Construct counter = parent.eval(assign, env);
+            if(!(counter instanceof IVariable)){
+                throw new ConfigRuntimeException("First parameter of for must be an ivariable", ExceptionType.CastException, line_num, f);
+            }
+            int _continue = 0;
+            while(true){
+                Construct cond = Static.resolveConstruct(parent.eval(condition, env).val(), line_num, f);
+                if(!(cond instanceof CBoolean)){
+                    throw new ConfigRuntimeException("Second parameter of for must return a boolean", ExceptionType.CastException, line_num, f);
+                }
+                CBoolean bcond = ((CBoolean) cond);
+                if(bcond.getBoolean() == false){
+                    break;
+                }
+                if(_continue >= 1){
+                    --_continue;                    
+                    parent.eval(expression, env);
+                    continue;
+                }
+                try{
+                    Static.resolveConstruct(parent.eval(runnable, env).val(), line_num, f);
+                } catch(LoopBreakException e){
+                    int num = e.getTimes();
+                    if(num > 1){
+                        e.setTimes(--num);
+                        throw e;
+                    }
+                    return new CVoid(line_num, f);
+                } catch(LoopContinueException e){
+                    _continue = e.getTimes() - 1;                    
+                    parent.eval(expression, env);
+                    continue;
+                }
+                parent.eval(expression, env);
+            }
+            return new CVoid(line_num, f);
+        }
+        public ExceptionType[] thrown(){
+            return new ExceptionType[]{ExceptionType.CastException};
+        }
+        public Construct exec(int line_num, File f, Env env, Construct... args) throws CancelCommandException, ConfigRuntimeException {
+            return null;
+        }
+
+        public String docs() {
+            return "void {assign, condition, expression1, expression2} Acts as a typical for loop. The assignment is first run. Then, a"
+                    + " condition is checked. If that condition is checked and returns true, expression2 is run. After that, expression1 is run. In java"
+                    + " syntax, this would be: for(assign; condition; expression1){expression2}. assign must be an ivariable, either a "
+                    + "pre defined one, or the results of the assign() function. condition must be a boolean.";
+        }
+
+        public boolean isRestricted() {
+            return false;
+        }
+
+        public boolean preResolveVariables() {
+            return false;
+        }
+        public String since() {
+            return "3.0.1";
+        }
+        //Doesn't matter, run out of state
+        public Boolean runAsync() {
+            return null;
+        }
+    }
+    
+    @api public static class foreach implements Function{
+        public String getName() {
+            return "foreach";
+        }
+
+        public Integer[] numArgs() {
+            return new Integer[]{3};
+        }
+
+        public Construct exec(int line_num, File f, Env env, Construct... args) throws CancelCommandException, ConfigRuntimeException {
+            return new CVoid(line_num, f);
+        }
+        
+        public Construct execs(int line_num, File f, Env env, Script that, GenericTreeNode<Construct> array, 
+                GenericTreeNode<Construct> ivar, GenericTreeNode<Construct> code) throws CancelCommandException{
+            
+            Construct arr = that.eval(array, env);
+            if(arr instanceof IVariable){
+                arr = env.GetVarList().get(((IVariable)arr).getName()).ival();
+            }
+            Construct iv = that.eval(ivar, env);
+            
+            if(arr instanceof CArray){
+                if(iv instanceof IVariable){
+                    CArray one = (CArray)arr;
+                    IVariable two = (IVariable)iv;
+                    if(!one.inAssociativeMode()){
+                        for(int i = 0; i < one.size(); i++){
+                            env.GetVarList().set(new IVariable(two.getName(), one.get(i, line_num, f), line_num, f));
+                            try{
+                                that.eval(code, env);
+                            } catch(LoopBreakException e){
+                                int num = e.getTimes();
+                                if(num > 1){
+                                    e.setTimes(--num);
+                                    throw e;
+                                }
+                                return new CVoid(line_num, f);
+                            } catch(LoopContinueException e){
+                                i += e.getTimes() - 1;
+                                continue;
+                            }
+                        }
+                    } else {
+                        for(int i = 0; i < one.size(); i++){
+                            String index = one.keySet().toArray(new String[]{})[i];
+                            env.GetVarList().set(new IVariable(two.getName(), one.get(index, line_num, f), line_num, f));
+                            try{
+                                that.eval(code, env);
+                            } catch(LoopBreakException e){
+                                int num = e.getTimes();
+                                if(num > 1){
+                                    e.setTimes(--num);
+                                    throw e;
+                                }
+                                return new CVoid(line_num, f);
+                            } catch(LoopContinueException e){
+                                i += e.getTimes() - 1;
+                                continue;
+                            }
+                        }
+                    }
+                } else {
+                    throw new ConfigRuntimeException("Parameter 2 of foreach must be an ivariable", ExceptionType.CastException, line_num, f);
+                }
+            } else {
+                throw new ConfigRuntimeException("Parameter 1 of foreach must be an array", ExceptionType.CastException, line_num, f);
+            }
+            
+            return new CVoid(line_num, f);
+        }
+        
+        public ExceptionType[] thrown(){
+            return new ExceptionType[]{ExceptionType.CastException};
+        }
+
+        public String docs() {
+            return "void {array, ivar, code} Walks through array, setting ivar equal to each element in the array, then running code.";
+        }
+
+        public boolean isRestricted() {
+            return false;
+        }
+
+        public boolean preResolveVariables() {
+            return false;
+        }
+        public String since() {
+            return "3.0.1";
+        }
+        //Doesn't matter, runs out of state anyways
+        public Boolean runAsync(){
+            return null;
+        }
+    }
+    
+    @api public static class _break implements Function{
+
+        public String getName() {
+            return "break";
+        }
+
+        public Integer[] numArgs() {
+            return new Integer[]{0,1};
+        }
+
+        public String docs() {
+            return "nothing {[int]} Stops the current loop. If int is specified, and is greater than 1, the break travels that many loops up. So, if you had"
+                    + " a loop embedded in a loop, and you wanted to break in both loops, you would call break(2). If this function is called outside a loop"
+                    + " (or the number specified would cause the break to travel up further than any loops are defined), the function will fail. If no"
+                    + " argument is specified, it is the same as calling break(1).";
+        }
+        
+        public ExceptionType[] thrown(){
+            return new ExceptionType[]{ExceptionType.CastException};
+        }
+
+        public boolean isRestricted() {
+            return false;
+        }
+
+        public void varList(IVariableList varList) {}
+
+        public boolean preResolveVariables() {
+            return true;
+        }
+
+        public String since() {
+            return "3.1.0";
+        }
+
+        public Boolean runAsync() {
+            return null;
+        }
+
+        public Construct exec(int line_num, File f, Env env, Construct... args) throws CancelCommandException, ConfigRuntimeException {
+            int num = 1;
+            if(args.length == 1){
+                num = (int)Static.getInt(args[0]);
+            }
+            throw new LoopBreakException(num);
+        }
+        
+    }
+    
+    @api public static class _continue implements Function{
+
+        public String getName() {
+            return "continue";
+        }
+
+        public Integer[] numArgs() {
+            return new Integer[]{0, 1};
+        }
+
+        public String docs() {
+            return "void {[int]} Skips the rest of the code in this loop, and starts the loop over, with it continuing at the next index. If this function"
+                    + " is called outside of a loop, the command will fail. If int is set, it will skip 'int' repetitions. If no argument is specified,"
+                    + " 1 is used.";
+        }
+        
+        public ExceptionType[] thrown(){
+            return new ExceptionType[]{ExceptionType.CastException};
+        }
+
+        public boolean isRestricted() {
+            return false;
+        }
+
+        public void varList(IVariableList varList) {}
+
+        public boolean preResolveVariables() {
+            return true;
+        }
+
+        public String since() {
+            return "3.1.0";
+        }
+
+        public Boolean runAsync() {
+            return null;
+        }
+
+        public Construct exec(int line_num, File f, Env env, Construct... args) throws CancelCommandException, ConfigRuntimeException {
+            int num = 1;
+            if(args.length == 1){
+                num = (int)Static.getInt(args[0]);
+            }
+            throw new LoopContinueException(num);
+        }
+        
+    }
+    
+    @api public static class is_string implements Function{
+
+        public String getName() {
+            return "is_string";
+        }
+
+        public Integer[] numArgs() {
+            return new Integer[]{1};
+        }
+
+        public String docs() {
+            return "boolean {item} Returns whether or not the item is a string. Everything but arrays can be used as strings.";
+        }
+
+        public ExceptionType[] thrown() {
+            return null;
+        }
+
+        public boolean isRestricted() {
+            return false;
+        }
+
+        public void varList(IVariableList varList) {}
+
+        public boolean preResolveVariables() {
+            return true;
+        }
+
+        public String since() {
+            return "3.1.2";
+        }
+
+        public Boolean runAsync() {
+            return null;
+        }
+
+        public Construct exec(int line_num, File f, Env env, Construct... args) throws ConfigRuntimeException {
+            return new CBoolean(!(args[0] instanceof CArray), line_num, f);
+        }
+        
+    }
+    
+    @api public static class is_array implements Function{
+
+        public String getName() {
+            return "is_array";
+        }
+
+        public Integer[] numArgs() {
+            return new Integer[]{1};
+        }
+
+        public String docs() {
+            return "boolean {item} Returns whether or not the item is an array";
+        }
+
+        public ExceptionType[] thrown() {
+            return null;
+        }
+
+        public boolean isRestricted() {
+            return false;
+        }
+
+        public boolean preResolveVariables() {
+            return true;
+        }
+
+        public String since() {
+            return "3.1.2";
+        }
+
+        public Boolean runAsync() {
+            return null;
+        }
+
+        public Construct exec(int line_num, File f, Env env, Construct... args) throws ConfigRuntimeException {
+            return new CBoolean(args[0] instanceof CArray, line_num, f);
+        }
+        
+    }
+    
+    @api public static class is_double implements Function{
+
+        public String getName() {
+            return "is_double";
+        }
+
+        public Integer[] numArgs() {
+            return new Integer[]{1};
+        }
+
+        public String docs() {
+            return "boolean {item} Returns whether or not the given item is a double. Note that a numeric string will return true, and so"
+                    + " will integers.";
+        }
+
+        public ExceptionType[] thrown() {
+            return null;
+        }
+
+        public boolean isRestricted() {
+            return false;
+        }
+
+        public boolean preResolveVariables() {
+            return true;
+        }
+
+        public String since() {
+            return "3.1.2";
+        }
+
+        public Boolean runAsync() {
+            return null;
+        }
+
+        public Construct exec(int line_num, File f, Env env, Construct... args) throws ConfigRuntimeException {
+            boolean b = true;
+            try{
+                Static.getDouble(args[0]);
+            } catch(ConfigRuntimeException e){
+                b = false;
+            }
+            return new CBoolean(b, line_num, f);
+        }
+        
+    }
+    
+    @api public static class is_integer implements Function{
+
+        public String getName() {
+            return "is_integer";
+        }
+
+        public Integer[] numArgs() {
+            return new Integer[]{1};
+        }
+
+        public String docs() {
+            return "boolean {item} Returns whether or not the given item is an integer. Note that numeric strings can be used as integers.";
+        }
+
+        public ExceptionType[] thrown() {
+            return null;
+        }
+
+        public boolean isRestricted() {
+            return false;
+        }
+
+        public void varList(IVariableList varList) {}
+
+        public boolean preResolveVariables() {
+            return true;
+        }
+
+        public String since() {
+            return "3.1.2";
+        }
+
+        public Boolean runAsync() {
+            return null;
+        }
+
+        public Construct exec(int line_num, File f, Env env, Construct... args) throws ConfigRuntimeException {
+            boolean b = true;
+            try{
+                Static.getInt(args[0]);
+            } catch(ConfigRuntimeException e){
+                b = false;
+            }
+            return new CBoolean(b, line_num, f);
+        }
+        
+    }
+    
+    @api public static class is_boolean implements Function{
+
+        public String getName() {
+            return "is_boolean";
+        }
+
+        public Integer[] numArgs() {
+            return new Integer[]{1};
+        }
+
+        public String docs() {
+            return "boolean {item} Returns whether the given item is a boolean. Note that all datatypes can be used as booleans, however"
+                    + " null and arrays always return false. Essentially, this mean that this function ALWAYS returns true. Really, you"
+                    + " probably shouldn't ever use it.";
+        }
+
+        public ExceptionType[] thrown() {
+            return null;
+        }
+
+        public boolean isRestricted() {
+            return false;
+        }
+
+        public void varList(IVariableList varList) {}
+
+        public boolean preResolveVariables() {
+            return true;
+        }
+
+        public String since() {
+            return "3.1.2";
+        }
+
+        public Boolean runAsync() {
+            return null;
+        }
+
+        public Construct exec(int line_num, File f, Env env, Construct... args) throws ConfigRuntimeException {
+            return new CBoolean(true, line_num, f);
+        }
+        
+    }
+    
+    @api public static class is_null implements Function{
+
+        public String getName() {
+            return "is_null";
+        }
+
+        public Integer[] numArgs() {
+            return new Integer[]{1};
+        }
+
+        public String docs() {
+            return "boolean {item} Returns whether or not the given item is null.";
+        }
+
+        public ExceptionType[] thrown() {
+            return null;
+        }
+
+        public boolean isRestricted() {
+            return false;
+        }
+
+        public void varList(IVariableList varList) {}
+
+        public boolean preResolveVariables() {
+            return true;
+        }
+
+        public String since() {
+            return "3.1.2";
+        }
+
+        public Boolean runAsync() {
+            return null;
+        }
+
+        public Construct exec(int line_num, File f, Env env, Construct... args) throws ConfigRuntimeException {
+            return new CBoolean(args[0] instanceof CNull, line_num, f);
+        }
+        
+    }
+    //TODO: proc
+    @api public static class proc implements Function{
+
+        public String getName() {
+            return "proc";
+        }
+
+        public Integer[] numArgs() {
+            return new Integer[]{Integer.MAX_VALUE};
+        }
+
+        public String docs() {
+            return "void {[name], [ivar...], procCode} Creates a new user defined procedure (also known as \"function\") that can be called later in code. Please see the more detailed"
+                    + " documentation on procedures for more information.";
+        }
+
+        public ExceptionType[] thrown() {
+            return new ExceptionType[]{ExceptionType.FormatException};
+        }
+
+        public boolean isRestricted() {
+            return true;
+        }
+
+        public boolean preResolveVariables() {
+            return false;
+        }
+
+        public String since() {
+            return "3.1.3";
+        }
+
+        public Boolean runAsync() {
+            return null;
+        }
+        
+        public Construct exec(int line_num, File f, Env env, Construct... args) throws ConfigRuntimeException {
+            return new CVoid(line_num, f);
+        }
+        
+    }
+
+    @api public static class _return implements Function{
+
+        public String getName() {
+            return "return";
+        }
+
+        public Integer[] numArgs() {
+            return new Integer[]{0, 1};
+        }
+
+        public String docs() {
+            return "nothing {mixed} Returns the specified value from this procedure. It cannot be called outside a procedure.";
+        }
+
+        public ExceptionType[] thrown() {
+            return null;
+        }
+
+        public boolean isRestricted() {
+            return false;
+        }
+
+        public void varList(IVariableList varList) {}
+
+        public boolean preResolveVariables() {
+            return true;
+        }
+
+        public String since() {
+            return "3.2.0";
+        }
+
+        public Boolean runAsync() {
+            return null;
+        }
+
+        public Construct exec(int line_num, File f, Env env, Construct... args) throws ConfigRuntimeException {
+            Construct ret = (args.length == 1?args[0]:new CVoid(line_num, f));
+            throw new FunctionReturnException(ret);
+        }
+        
+    }
+    
+    @api public static class include implements Function{
+
+        public String getName() {
+            return "include";
+        }
+
+        public Integer[] numArgs() {
+            return new Integer[]{1};
+        }
+
+        public String docs() {
+            return "void {path} Includes external code at the specified path.";
+        }
+
+        public ExceptionType[] thrown() {
+            return new ExceptionType[]{ExceptionType.IncludeException};
+        }
+
+        public boolean isRestricted() {
+            return true;
+        }
+
+        public void varList(IVariableList varList) {}
+
+        public boolean preResolveVariables() {
+            return true;
+        }
+
+        public String since() {
+            return "3.2.0";
+        }
+
+        public Boolean runAsync() {
+            return true;
+        }
+
+        public Construct exec(int line_num, File f, Env env, Construct... args) throws ConfigRuntimeException {
+            return new CVoid(line_num, f);
+        }
+        
+        public Construct execs(int line_num, File f, Env env, List<GenericTreeNode<Construct>> children, Script parent){
+            GenericTreeNode<Construct> tree = children.get(0);
+            Construct arg = parent.eval(tree, env);
+            arg = parent.preResolveVariables(new Construct[]{arg})[0];
+            String location = arg.val();
+            GenericTreeNode<Construct> include = IncludeCache.get(new File(location), line_num, f);
+            parent.eval(include.getChildAt(0), env);
+            return new CVoid(line_num, f);
+        }
+        
+    }
+    
+    @api public static class call_proc implements Function{
+
+        public String getName() {
+            return "call_proc";
+        }
+
+        public Integer[] numArgs() {
+            return new Integer[]{Integer.MAX_VALUE};
+        }
+
+        public String docs() {
+            return "mixed {proc_name, [var1...]} Dynamically calls a user defined procedure. call_proc(_myProc, 'var1') is the equivalent of"
+                    + " _myProc('var1'), except you could dynamically build the procedure name if need be. This is useful for having callbacks"
+                    + " in procedures. Throws an InvalidProcedureException if the procedure isn't defined.";
+        }
+
+        public ExceptionType[] thrown() {
+            return new ExceptionType[]{ExceptionType.InvalidProcedureException};
+        }
+
+        public boolean isRestricted() {
+            return true;
+        }
+
+        public void varList(IVariableList varList) {}
+
+        public boolean preResolveVariables() {
+            return true;
+        }
+
+        public String since() {
+            return "3.2.0";
+        }
+
+        public Boolean runAsync() {
+            return null;
+        }
+
+        public Construct exec(int line_num, File f, Env env, Construct... args) throws ConfigRuntimeException {
+            return new CVoid(line_num, f);
+        }
+        
+        public Construct execs(int line_num, File f, Env env, Construct ... args){
+            Procedure proc = env.GetProcs().get(args[0].val());
+            if(proc != null){
+                List<Construct> vars = new ArrayList<Construct>(Arrays.asList(args));
+                vars.remove(0);                
+                return proc.execute(vars, env);
+            }            
+            throw new ConfigRuntimeException("Unknown procedure \"" + args[0].val() + "\"", 
+                    ExceptionType.InvalidProcedureException, line_num, f);
+        }
+        
+    }
+    
+    @api public static class is_proc implements Function{
+
+        public String getName() {
+            return "is_proc";
+        }
+
+        public Integer[] numArgs() {
+            return new Integer[]{1};
+        }
+
+        public String docs() {
+            return "boolean {procName} Returns whether or not the given procName is currently defined, i.e. if calling this proc wouldn't"
+                    + " throw an exception.";
+        }
+
+        public ExceptionType[] thrown() {
+            return null;
+        }
+
+        public boolean isRestricted() {
+            return true;
+        }
+
+        public void varList(IVariableList varList) {}
+
+        public boolean preResolveVariables() {
+            return true;
+        }
+
+        public String since() {
+            return "3.2.0";
+        }
+
+        public Boolean runAsync() {
+            return null;
+        }
+        
+        public Construct exec(int line_num, File f, Env env, Construct ... args){
+            return new CBoolean(env.GetProcs().get(args[0].val())==null?false:true, line_num, f);
+        }
+        
+    }
+    
+    @api public static class is_associative implements Function{
+
+        public String getName() {
+            return "is_associative";
+        }
+
+        public Integer[] numArgs() {
+            return new Integer[]{1};
+        }
+
+        public String docs() {
+            return "boolean {array} Returns whether or not the array is associative. If the parameter is not an array, throws a CastException.";
+        }
+
+        public ExceptionType[] thrown() {
+            return new ExceptionType[]{ExceptionType.CastException};
+        }
+
+        public boolean isRestricted() {
+            return false;
+        }
+
+        public void varList(IVariableList varList) {}
+
+        public boolean preResolveVariables() {
+            return true;
+        }
+
+        public String since() {
+            return "3.3.0";
+        }
+
+        public Boolean runAsync() {
+            return null;
+        }
+
+        public Construct exec(int line_num, File f, Env env, Construct... args) throws ConfigRuntimeException {
+            if(args[0] instanceof CArray){
+                return new CBoolean(((CArray)args[0]).inAssociativeMode(), line_num, f);
+            } else {
+                throw new ConfigRuntimeException(this.getName() + " expects argument 1 to be an array", ExceptionType.CastException, line_num, f);
+            }
+        }
+        
+    }   
+    
+    @api public static class _import implements Function{
+
+        public String getName() {
+            return "import";
+        }
+
+        public Integer[] numArgs() {
+            return new Integer[]{1};
+        }
+
+        public String docs() {
+            return "mixed {ivar | string} This function imports a value from the global value"
+                    + " register. In the first mode, it looks for an ivariable with the specified"
+                    + " name, and stores the value in the variable, and returns void. In the"
+                    + " second mode, it looks for a value stored with the specified key, and"
+                    + " returns that value. Items can be stored with the export function. If"
+                    + " the specified ivar doesn't exist, the ivar will be assigned an empty"
+                    + " string, and if the specified string key doesn't exist, null is returned."
+                    + " See the documentation on [[CommandHelper/import-export|imports/exports]]"
+                    + " for more information.";
+        }
+
+        public ExceptionType[] thrown() {
+            return new ExceptionType[]{};
+        }
+
+        public boolean isRestricted() {
+            return true;
+        }
+
+        public boolean preResolveVariables() {
+            return false;
+        }
+
+        public String since() {
+            return "3.3.0";
+        }
+
+        public Boolean runAsync() {
+            return null;
+        }
+
+        public Construct exec(int line_num, File f, Env environment, Construct... args) throws ConfigRuntimeException {
+            if(args[0] instanceof IVariable){
+                //Mode 1     
+                IVariable var = (IVariable)args[0];
+                environment.GetVarList().set(Globals.GetGlobalIVar(var));
+                return new CVoid(line_num, f);
+            } else {
+                //Mode 2
+                return Globals.GetGlobalConstruct(args[0].val());
+            }
+        }
+        
+    }
+    
+    @api public static class _export implements Function{
+
+        public String getName() {
+            return "export";
+        }
+
+        public Integer[] numArgs() {
+            return new Integer[]{1, 2};
+        }
+
+        public String docs() {
+            return "void {ivar | name, value} Stores a value in the global storage register."
+                    + " When using the first mode, the ivariable is stored so it can be imported"
+                    + " later, and when using the second mode, an arbitrary value is stored with"
+                    + " the give key, and can be retreived using the secode mode of import. If"
+                    + " the value is already stored, it is overwritten. See import() and"
+                    + " [[CommandHelper/import-export|importing/exporting]]";
+        }
+
+        public ExceptionType[] thrown() {
+            return new ExceptionType[]{ExceptionType.InsufficientArgumentsException};
+        }
+
+        public boolean isRestricted() {
+            return true;
+        }
+
+        public boolean preResolveVariables() {
+            return false;
+        }
+
+        public String since() {
+            return "3.3.0";
+        }
+
+        public Boolean runAsync() {
+            return null;
+        }
+
+        public Construct exec(int line_num, File f, Env environment, Construct... args) throws ConfigRuntimeException {
+            if(args.length == 1){
+                if(args[0] instanceof IVariable){
+                    Globals.SetGlobal(environment.GetVarList().get(((IVariable)args[0]).getName()));
+                } else { 
+                    throw new ConfigRuntimeException("Expecting a IVariable when only one parameter is specified", ExceptionType.InsufficientArgumentsException, line_num, f);
+                }
+            } else {
+                Globals.SetGlobal(args[0].val(), args[1]);
+            }         
+            return new CVoid(line_num, f);
+        }
+        
+    }
+    
+    @api public static class closure implements Function{
+
+        public String getName() {
+            return "closure";
+        }
+
+        public Integer[] numArgs() {
+            return new Integer[]{1};
+        }
+
+        public String docs() {
+            return "closure {code} Returns a closure on the provided code. A closure is"
+                    + " a datatype that represents some code as code, not the results of some"
+                    + " code after it is run. Code placed in a closure can be used as"
+                    + " a string, or executed by other functions using the eval() function."
+                    + " If a closure is \"to string'd\" it will not necessarily look like"
+                    + " the original code, but will be functionally equivalent. The environment"
+                    + " is not inherently stored with the closure, however, specific functions"
+                    + " may choose to store the environment in addition to the closure.";
+        }
+
+        public ExceptionType[] thrown() {
+            return new ExceptionType[]{};
+        }
+
+        public boolean isRestricted() {
+            return true;
+        }
+
+        public boolean preResolveVariables() {
+            return false;
+        }
+
+        public Boolean runAsync() {
+            return null;
+        }
+
+        public Construct exec(int line_num, File f, Env environment, Construct... args) throws ConfigRuntimeException {
+            return new CVoid(line_num, f);
+        }
+        
+        public Construct execs(int line_num, File f, Env env, List<GenericTreeNode<Construct>> nodes){
+            CClosure closure = new CClosure(f.toString(), nodes.get(0), env, line_num, f);
+            return closure;
+        }
+
+        public String since() {
+            return "3.3.0";
+        }
+        
+    }
+    
+}
diff --git a/src/main/java/com/laytonsmith/core/functions/Debug.java b/src/main/java/com/laytonsmith/core/functions/Debug.java
new file mode 100644
index 0000000..cb3b4f4
--- /dev/null
+++ b/src/main/java/com/laytonsmith/core/functions/Debug.java
@@ -0,0 +1,430 @@
+/*
+ * To change this template, choose Tools | Templates
+ * and open the template in the editor.
+ */
+package com.laytonsmith.core.functions;
+
+import com.laytonsmith.core.AliasCore;
+import com.laytonsmith.core.Env;
+import com.laytonsmith.core.Static;
+import com.laytonsmith.core.api;
+import com.laytonsmith.core.constructs.*;
+import com.laytonsmith.core.exceptions.ConfigRuntimeException;
+import com.laytonsmith.core.functions.Exceptions.ExceptionType;
+import java.io.File;
+import java.io.IOException;
+import java.lang.reflect.Field;
+import java.lang.reflect.Method;
+import java.util.*;
+import java.util.logging.Level;
+import java.util.logging.Logger;
+import org.bukkit.event.Event;
+import org.bukkit.event.Listener;
+import org.bukkit.plugin.Plugin;
+import org.bukkit.plugin.RegisteredListener;
+import org.bukkit.plugin.SimplePluginManager;
+
+/**
+ * TODO: Remove bukkit references
+ * @author Layton
+ */
+public class Debug {
+
+    public static boolean EVENT_LOGGING = false;
+    public static int EVENT_LOGGING_LEVEL = 1;
+    public static final Set<Event.Type> EVENT_LOGGING_FILTER = new HashSet<Event.Type>();
+    public static final Set<String> EVENT_PLUGIN_FILTER = new HashSet<String>();
+    public static boolean LOG_TO_SCREEN = false;
+
+    public static void DoLog(Event.Type filter, int verbosity, String message) {
+        synchronized (EVENT_LOGGING_FILTER) {
+            if (EVENT_LOGGING && EVENT_LOGGING_FILTER.contains(filter) && EVENT_LOGGING_LEVEL >= verbosity) {
+                try {
+                    Static.LogDebug(message);
+                } catch (IOException ex) {
+                    Logger.getLogger(Debug.class.getName()).log(Level.SEVERE, null, ex);
+                }
+            }
+        }
+    }
+
+    public static boolean IsFiltered(Plugin plugin) {
+        if (EVENT_PLUGIN_FILTER.isEmpty()) {
+            return true;
+        } else {
+            return EVENT_PLUGIN_FILTER.contains(plugin.getClass().getSimpleName().toUpperCase());
+        }
+    }
+
+    public static String docs() {
+        return "Provides methods for viewing data about both CommandHelper and the other plugins in your server. Though not meant to"
+                + " be called by normal scripts, these methods are available everywhere other methods are available. Note that for"
+                + " some of these functions to even work, play-dirty mode must set to on. These are most useful in conjuction with"
+                + " interpreter mode.";
+    }
+
+    @api
+    public static class dump_listeners implements Function {
+
+        public String getName() {
+            return "dump_listeners";
+        }
+
+        public Integer[] numArgs() {
+            return new Integer[]{0, 1, 2};
+        }
+
+        public String docs() {
+            return " {[typeFilter], [verboseLevel]} Send null as the typeFilter to see possibilities. VerboseLevel can be 1-4";
+        }
+
+        public ExceptionType[] thrown() {
+            return new ExceptionType[]{ExceptionType.CastException, ExceptionType.SecurityException};
+        }
+
+        public boolean isRestricted() {
+            return true;
+        }
+
+        public boolean preResolveVariables() {
+            return true;
+        }
+
+        public String since() {
+            return "0.0.0";
+        }
+
+        public Boolean runAsync() {
+            return false;
+        }
+
+        public Construct exec(int line_num, File f, Env environment, Construct... args) throws ConfigRuntimeException {
+            if (!(Boolean) Static.getPreferences().getPreference("allow-debug-logging")) {
+                throw new ConfigRuntimeException("allow-debug-logging is currently set to false. To use " + this.getName() + ", enable it in your preferences.", ExceptionType.SecurityException, line_num, f);
+            }
+            StringBuilder b = new StringBuilder("\n");
+            if (args.length >= 1 && args[0] instanceof CNull) {
+                b.append("You can sort the listeners further by specifying one of the options:\n");
+                for (Event.Type t : Event.Type.values()) {
+                    b.append(t.name()).append("\n");
+                }
+                return new CString(b.toString(), 0, null);
+            }
+            int verbosity = 1;
+            if (args.length == 2) {
+                verbosity = (int) Static.getInt(args[1]);
+            }
+            try {
+                SimplePluginManager pm = (SimplePluginManager) AliasCore.parent.getServer().getPluginManager();
+                Field fListener = SimplePluginManager.class.getDeclaredField("listeners");
+                //set it to public
+                fListener.setAccessible(true);
+                EnumMap<Event.Type, SortedSet<RegisteredListener>> listeners =
+                        (EnumMap<Event.Type, SortedSet<RegisteredListener>>) fListener.get(pm);
+
+                if (args.length >= 1) {
+                    for (RegisteredListener l : listeners.get(Event.Type.valueOf(args[0].val().toUpperCase()))) {
+                        b.append(Build(l, verbosity));
+                    }
+                } else {
+                    for (Event.Type type : listeners.keySet()) {
+                        b.append("Type: ").append(type.name()).append("\n");
+                        for (RegisteredListener l : listeners.get(type)) {
+                            b.append(Build(l, verbosity));
+                        }
+                    }
+                }
+            } catch (Exception e) {
+                e.printStackTrace();
+            }
+            return new CString(b.toString(), 0, null);
+        }
+
+        public String Build(RegisteredListener l, int verbosity) {
+            StringBuilder b = new StringBuilder();
+            switch (Static.Normalize(verbosity, 1, 5)) {
+                case 1:
+                    b.append("Plugin: ").append(l.getPlugin().getClass().getSimpleName()).append("; Priority: ").append(l.getPriority().toString()).append("\n");
+                    break;
+                case 2:
+                    b.append("Plugin: ").append(l.getPlugin().getClass().getSimpleName()).append(":").append(l.getListener().getClass().getSimpleName()).append("; Priority: ").append(l.getPriority().toString()).append("\n");
+                    break;
+                case 3:
+                    b.append("Plugin: ").append(l.getPlugin().getClass().getSimpleName()).append(":").append(l.getListener().getClass().getCanonicalName()).append("; Priority: ").append(l.getPriority().toString()).append("\n");
+                    break;
+                case 4:
+                    b.append("Plugin: ").append(l.getPlugin().getClass().getSimpleName()).append(":").append(l.getListener().getClass().getCanonicalName()).append("\n\t").append("; Priority: ").append(l.getPriority().toString()).append("\n");
+                    break;
+                case 5:
+                    b.append("Plugin: ").append(l.getPlugin().getClass().getSimpleName()).append(":").append(l.getListener().getClass().getCanonicalName()).append("; Priority: ").append(l.getPriority().toString()).append("\n");
+                    b.append("\tMethods defined in listener that override ");
+                    try {
+                        Class<? extends Listener> parent = (Class<? extends Listener>) l.getListener().getClass().getSuperclass();
+                        while (parent.getSuperclass() != null && parent.getSuperclass().equals(Listener.class)) {
+                            parent = (Class<? extends Listener>) parent.getSuperclass();
+                        }
+                        b.append(parent.getSimpleName()).append(":\n");
+                        Set<Method> parentSet = new HashSet(Arrays.asList(parent.getDeclaredMethods()));
+                        for (Method m : l.getListener().getClass().getDeclaredMethods()) {
+                            for (Method pm : parentSet) {
+                                if (pm.getName().equals(m.getName()) && Arrays.equals(pm.getParameterTypes(), m.getParameterTypes())) {
+                                    b.append("\t\t").append(m.getReturnType().getSimpleName()).append(" ").append(m.getName()).append("(").append(Static.strJoin(m.getParameterTypes(), ", ")).append(");\n");
+                                }
+                            }
+                        }
+                    } catch (NoClassDefFoundError e) {
+                        b.append("Could not get methods for ").append(l.getListener().getClass());
+                    }
+                    break;
+            }
+            return b.toString();
+        }
+
+        public String BuildClassList(Class[] list) {
+            StringBuilder b = new StringBuilder();
+            ArrayList<String> l = new ArrayList<String>();
+            for (Class c : list) {
+                try {
+                    l.add(c.getSimpleName());
+                } catch (NoClassDefFoundError e) {
+                }
+            }
+            return Static.strJoin(list, ", ");
+        }
+    }
+
+    @api
+    public static class debug implements Function {
+
+        public String getName() {
+            return "debug";
+        }
+
+        public Integer[] numArgs() {
+            return new Integer[]{1};
+        }
+
+        public String docs() {
+            return "void {message} Manually logs a timestamped message to the debug log and the console, if debug-mode is set to true in the preferences";
+        }
+
+        public ExceptionType[] thrown() {
+            return new ExceptionType[]{ExceptionType.IOException};
+        }
+
+        public boolean isRestricted() {
+            return true;
+        }
+
+        public boolean preResolveVariables() {
+            return true;
+        }
+
+        public String since() {
+            return "3.3.0";
+        }
+
+        public Boolean runAsync() {
+            return true;
+        }
+
+        public Construct exec(int line_num, File f, Env environment, Construct... args) throws ConfigRuntimeException {
+            if ((Boolean) Static.getPreferences().getPreference("debug-mode")) {
+                try {
+                    Static.LogDebug(args[0].val());
+                } catch (IOException ex) {
+                    throw new ConfigRuntimeException(ex.getMessage(), ExceptionType.IOException, line_num, f, ex);
+                }
+            }
+            return new CVoid(line_num, f);
+        }
+    }
+
+    @api
+    public static class debug_log_events implements Function {
+
+        public String getName() {
+            return "debug_log_events";
+        }
+
+        public Integer[] numArgs() {
+            return new Integer[]{1, 2, 3};
+        }
+
+        public String docs() {
+            return "void {boolean, [level, [logToScreen]]} Turns the event logging on or off. Event logging may be useful in determining the problem if CommandHelper isn't"
+                    + " able to receive events, you can track what's actually happening. play-dirty mode must be enabled for this to work properly however."
+                    + " This feature may also be useful in diagnosing other problems with other plugins as well. Level varies from 1-5, and shows more"
+                    + " information as it increases. You must also set at least one filter with the set_debug_event_filter function before anything"
+                    + " will happen. logToScreen defaults to false. This should only be turned on when you are testing, or have very strict filters set.";
+        }
+
+        public ExceptionType[] thrown() {
+            return new ExceptionType[]{ExceptionType.CastException, ExceptionType.SecurityException};
+        }
+
+        public boolean isRestricted() {
+            return true;
+        }
+
+        public boolean preResolveVariables() {
+            return true;
+        }
+
+        public String since() {
+            return "3.3.0";
+        }
+
+        public Boolean runAsync() {
+            return false;
+        }
+
+        public Construct exec(int line_num, File f, Env environment, Construct... args) throws ConfigRuntimeException {
+            if (!(Boolean) Static.getPreferences().getPreference("allow-debug-logging")) {
+                throw new ConfigRuntimeException("allow-debug-logging is currently set to false. To use " + this.getName() + ", enable it in your preferences.", ExceptionType.SecurityException, line_num, f);
+            }
+            boolean on = Static.getBoolean(args[0]);
+            int level = 1;
+            if(args.length >= 2){
+                level = Static.Normalize((int) Static.getInt(args[1]), 1, 5);
+            }
+            Debug.EVENT_LOGGING = on;
+            Debug.EVENT_LOGGING_LEVEL = level;
+            if(args.length >= 3){
+                Debug.LOG_TO_SCREEN = Static.getBoolean(args[2]);
+            }
+            return new CVoid(line_num, f);
+        }
+    }
+
+    @api
+    public static class set_debug_event_filter implements Function {
+
+        public String getName() {
+            return "set_debug_event_filter";
+        }
+
+        public Integer[] numArgs() {
+            return new Integer[]{1};
+        }
+
+        public String docs() {
+            return "void {array} Logs the specified event types as they occur, assuming that logging is currently enabled. For a list of"
+                    + " available filters, you can run dump_listeners(null). As these events occur, they will be logged according to the logging level.";
+        }
+
+        public ExceptionType[] thrown() {
+            return new ExceptionType[]{ExceptionType.CastException, ExceptionType.FormatException, ExceptionType.SecurityException};
+        }
+
+        public boolean isRestricted() {
+            return true;
+        }
+
+        public boolean preResolveVariables() {
+            return true;
+        }
+
+        public String since() {
+            return "3.3.0";
+        }
+
+        public Boolean runAsync() {
+            return true;
+        }
+
+        public Construct exec(int line_num, File f, Env environment, Construct... args) throws ConfigRuntimeException {
+            if (!(Boolean) Static.getPreferences().getPreference("allow-debug-logging")) {
+                throw new ConfigRuntimeException("allow-debug-logging is currently set to false. To use " + this.getName() + ", enable it in your preferences.", ExceptionType.SecurityException, line_num, f);
+            }
+            Set<Event.Type> set = new HashSet<Event.Type>();
+            if (args[0] instanceof CString) {
+                if (args[0].val().equals("*")) {
+                    for (Event.Type t : Event.Type.values()) {
+                        set.add(t);
+                    }
+                } else {
+                    try {
+                        Event.Type t = Event.Type.valueOf(args[0].val().toUpperCase());
+                        set.add(t);
+                    } catch (IllegalArgumentException e) {
+                        throw new ConfigRuntimeException(args[0].val() + " is not a valid filter type. The filter log has not been changed.", ExceptionType.FormatException, line_num, f);
+                    }
+                }
+            } else if (args[0] instanceof CArray) {
+                for (String c : ((CArray) args[0]).keySet()) {
+                    try {
+                        set.add(Event.Type.valueOf(((CArray) args[0]).get(c, line_num, f).val().toUpperCase()));
+                    } catch (IllegalArgumentException e) {
+                        throw new ConfigRuntimeException(c + " is not a valid filter type. The filter log has not been changed.", ExceptionType.FormatException, line_num, f);
+                    }
+                }
+            } else {
+                throw new ConfigRuntimeException("The parameter specified to " + this.getName() + " must be an array (or a single string). The filter array has not been changed.", ExceptionType.CastException, line_num, f);
+            }
+            synchronized (EVENT_LOGGING_FILTER) {
+                EVENT_LOGGING_FILTER.clear();
+                for (Event.Type t : set) {
+                    EVENT_LOGGING_FILTER.add(t);
+                }
+            }
+            return new CVoid(line_num, f);
+        }
+    }
+
+    @api
+    public static class set_debug_plugin_filter implements Function {
+
+        public String getName() {
+            return "set_debug_plugin_filter";
+        }
+
+        public Integer[] numArgs() {
+            return new Integer[]{1};
+        }
+
+        public String docs() {
+            return "void {array} Often times you just are interested in the events a particular plugin is outputting. If the plugin filter"
+                    + " is empty, all plugins are reported (assuming their event types are not filtered out) otherwise, only the ones in"
+                    + " the list are logged. The name of the plugin is the field \"Called from Plugin: \" in the output, not the name"
+                    + " it may be commonly referred to as.";
+        }
+
+        public ExceptionType[] thrown() {
+            return new ExceptionType[]{ExceptionType.CastException, ExceptionType.SecurityException};
+        }
+
+        public boolean isRestricted() {
+            return true;
+        }
+
+        public boolean preResolveVariables() {
+            return true;
+        }
+
+        public String since() {
+            return "3.3.0";
+        }
+
+        public Boolean runAsync() {
+            return false;
+        }
+
+        public Construct exec(int line_num, File f, Env environment, Construct... args) throws ConfigRuntimeException {
+            if (!(Boolean) Static.getPreferences().getPreference("allow-debug-logging")) {
+                throw new ConfigRuntimeException("allow-debug-logging is currently set to false. To use " + this.getName() + ", enable it in your preferences.", ExceptionType.SecurityException, line_num, f);
+            }
+            if (args[0] instanceof CString) {
+                EVENT_PLUGIN_FILTER.clear();
+                EVENT_PLUGIN_FILTER.add(args[0].val().toUpperCase());
+            } else if (args[0] instanceof CArray) {
+                for (String c : ((CArray) args[0]).keySet()) {
+                    EVENT_PLUGIN_FILTER.add(((CArray) args[0]).get(c, line_num, f).val().toUpperCase());
+                }
+            } else {
+                throw new ConfigRuntimeException(this.getName() + " expects the argument to be a single string, or an array of strings.", ExceptionType.CastException, line_num, f);
+            }
+            return new CVoid(line_num, f);
+        }
+    }
+}
diff --git a/src/main/java/com/laytonsmith/core/functions/Echoes.java b/src/main/java/com/laytonsmith/core/functions/Echoes.java
new file mode 100644
index 0000000..3de2de1
--- /dev/null
+++ b/src/main/java/com/laytonsmith/core/functions/Echoes.java
@@ -0,0 +1,494 @@
+/*
+ * To change this template, choose Tools | Templates
+ * and open the template in the editor.
+ */
+
+package com.laytonsmith.core.functions;
+
+import com.laytonsmith.PureUtilities.fileutility.LineCallback;
+import com.laytonsmith.abstraction.MCChatColor;
+import com.laytonsmith.abstraction.MCPlayer;
+import com.laytonsmith.abstraction.MCServer;
+import com.laytonsmith.core.Env;
+import com.laytonsmith.core.Static;
+import com.laytonsmith.core.api;
+import com.laytonsmith.core.constructs.CNull;
+import com.laytonsmith.core.constructs.CString;
+import com.laytonsmith.core.constructs.CVoid;
+import com.laytonsmith.core.constructs.Construct;
+import com.laytonsmith.core.exceptions.CancelCommandException;
+import com.laytonsmith.core.exceptions.ConfigRuntimeException;
+import com.laytonsmith.core.functions.Exceptions.ExceptionType;
+import com.sk89q.util.StringUtil;
+import java.io.File;
+import java.util.logging.Level;
+
+/**
+ *
+ * @author layton
+ */
+public class Echoes {
+    public static String docs(){
+        return "These functions allow you to echo information to the screen";
+    }
+    @api public static class die implements Function{
+        public Integer []numArgs() {
+            return new Integer[] {0,1};
+        }
+
+        public Construct exec(int line_num, File f, Env env, Construct... args) throws CancelCommandException{
+            if(args.length == 0){
+                throw new CancelCommandException("");
+            } else if(args.length == 1){
+                try{
+                    Static.SendMessage(env.GetCommandSender(), args[0].val(), line_num, f);
+                } finally{
+                    throw new CancelCommandException("");
+                }
+            } else{
+                return null;
+            }
+        }
+        
+        public ExceptionType[] thrown(){
+            return new ExceptionType[]{};
+        }
+
+        public String getName(){ return "die"; }
+        public String docs(){
+            return "nothing {[var1]} Kills the command immediately, without completing it. A message is optional, but if provided, displayed to the user.";
+        }
+
+        public boolean isRestricted() {
+            return false;
+        }
+
+        public void varList(IVariableList varList) {}
+
+        public boolean preResolveVariables() {
+            return true;
+        }
+        public String since() {
+            return "3.0.1";
+        }
+        public Boolean runAsync(){
+            return false;
+        }
+    }
+    
+    @api public static class msg implements Function{
+
+        public String getName() {
+            return "msg";
+        }
+
+        public Integer[] numArgs() {
+            return new Integer[]{Integer.MAX_VALUE};
+        }
+
+        public Construct exec(int line_num, File f, Env env, Construct... args) throws CancelCommandException, ConfigRuntimeException {
+            StringBuilder b = new StringBuilder();
+            for(int i = 0; i < args.length; i++){
+                b.append(args[i].val());
+            }
+            Static.SendMessage(env.GetCommandSender(), b.toString(), line_num, f);
+//            int start = 0;
+//            String s = b.toString();
+//            while(true){
+//                if(start >= s.length()) break;
+//                p.sendMessage(s.substring(start, start + 100 >= s.length()?s.length():start + 100));
+//                start += 100;
+//            }
+            return new CVoid(line_num, f);
+        }
+        
+        public ExceptionType[] thrown(){
+            return new ExceptionType[]{ExceptionType.PlayerOfflineException};
+        }
+
+        public String docs() {
+            return "void {var1, [var2...]} Echoes a message to the player running the command";
+        }
+
+        public boolean isRestricted() {
+            return false;
+        }
+
+        public void varList(IVariableList varList) {}
+
+        public boolean preResolveVariables() {
+            return true;
+        }
+        public String since() {
+            return "3.0.1";
+        }
+        public Boolean runAsync(){
+            return false;
+        }
+    
+    }
+    
+    @api public static class tmsg implements Function{
+
+        public String getName() {
+            return "tmsg";
+        }
+
+        public Integer[] numArgs() {
+            return new Integer[]{Integer.MAX_VALUE};
+        }
+
+        public Construct exec(int line_num, File f, Env env, Construct... args) throws CancelCommandException, ConfigRuntimeException {
+            if(args.length < 2){
+                throw new ConfigRuntimeException("You must send at least 2 arguments to tmsg", ExceptionType.InsufficientArgumentsException, line_num, f);
+            }
+            MCPlayer p = Static.getServer().getPlayer(args[0].val());
+            if(p == null){
+                throw new ConfigRuntimeException("The player " + args[0].val() + " is not online", ExceptionType.PlayerOfflineException, line_num, f);
+            }
+            StringBuilder b = new StringBuilder();
+            for(int i = 1; i < args.length; i++){
+                b.append(args[i].val());
+            }
+            Static.SendMessage(p, b.toString(), line_num, f);
+//            int start = 0;
+//            String s = b.toString();
+//            while(true){
+//                if(start >= s.length()) break;
+//                p.sendMessage(s.substring(start, start + 100 >= s.length()?s.length():start + 100));
+//                start += 100;
+//            }
+            return new CVoid(line_num, f);
+        }
+
+        public String docs() {
+            return "void {player, msg, [...]} Displays a message on the specified players screen, similar to msg, but targets a specific user.";
+        }
+        public ExceptionType[] thrown(){
+            return new ExceptionType[]{ExceptionType.PlayerOfflineException, ExceptionType.InsufficientArgumentsException};
+        }
+
+        public boolean isRestricted() {
+            return true;
+        }
+
+        public void varList(IVariableList varList) {}
+
+        public boolean preResolveVariables() {
+            return true;
+        }
+        public String since() {
+            return "3.0.1";
+        }
+        public Boolean runAsync(){
+            return false;
+        }
+    }
+    
+    @api public static class color implements Function{
+
+        public String getName() {
+            return "color";
+        }
+
+        public Integer[] numArgs() {
+            return new Integer[]{1};
+        }
+
+        public Construct exec(int line_num, File f, Env env, Construct... args) throws CancelCommandException, ConfigRuntimeException {
+            String color = MCChatColor.WHITE.toString();
+            
+            try{
+                color = MCChatColor.valueOf(args[0].val().toUpperCase()).toString();
+            } catch(IllegalArgumentException e){}
+            String a = args[0].val().toUpperCase();
+            if(a.equals("A")){
+                a = "10";
+            } else if(a.equals("B")){
+                a = "11";
+            } else if(a.equals("C")){
+                a = "12";
+            } else if(a.equals("D")){
+                a = "13";
+            } else if(a.equals("E")){
+                a = "14";
+            } else if(a.equals("F")){
+                a = "15";
+            }
+            try{
+                Integer p = Integer.parseInt(a);
+                color = MCChatColor.getByCode(p).toString();
+            } catch(NumberFormatException e){}
+            
+            return new CString(color, line_num, f);
+        }
+
+        public String docs() {
+            return "string {name} Returns the color modifier given a color name. If the given color name isn't valid, white is used instead."
+                    + " The list of valid color names can be found in the MCChatColor class, and case doesn't matter. For your reference,"
+                    + " here is the list of valid colors: " + StringUtil.joinString(MCChatColor.values(), ", ", 0) + ", in addition the integers 0-15 will work, or the hex numbers from 0-F.";
+        }
+        
+        public ExceptionType[] thrown(){
+            return new ExceptionType[]{};
+        }
+
+        public boolean isRestricted() {
+            return true;
+        }
+
+        public void varList(IVariableList varList) {}
+
+        public boolean preResolveVariables() {
+            return true;
+        }
+        public String since() {
+            return "3.0.1";
+        }
+        public Boolean runAsync(){
+            return null;
+        }
+    }
+    
+    @api public static class strip_colors implements Function{
+
+        public String getName() {
+            return "strip_colors";
+        }
+
+        public Integer[] numArgs() {
+            return new Integer[]{1};
+        }
+
+        public String docs() {
+            return "string {toStrip} Strips all the color codes from a given string";
+        }
+
+        public ExceptionType[] thrown() {
+            return new ExceptionType[]{};
+        }
+
+        public boolean isRestricted() {
+            return false;
+        }
+
+        public boolean preResolveVariables() {
+            return true;
+        }
+
+        public String since() {
+            return "3.3.0";
+        }
+
+        public Boolean runAsync() {
+            return false;
+        }
+
+        public Construct exec(int line_num, File f, Env environment, Construct... args) throws ConfigRuntimeException {
+            return new CString(MCChatColor.stripColor(args[0].val()), line_num, f);
+        }
+        
+    }
+    
+    @api public static class chat implements Function{
+
+        public String getName() {
+            return "chat";
+        }
+
+        public Integer[] numArgs() {
+            return new Integer[]{1};
+        }
+
+        public Construct exec(final int line_num, final File f, final Env env, Construct... args) throws CancelCommandException, ConfigRuntimeException {
+            Static.SendMessage(new LineCallback() {
+
+                public void run(String line) {
+                    if(!(env.GetCommandSender() instanceof MCPlayer)){
+                        throw new ConfigRuntimeException("The current player is not online, or this is being run from the console", ExceptionType.PlayerOfflineException, line_num, f);
+                    }
+                    (env.GetPlayer()).chat(line);
+                }
+            }, args[0].val());
+
+            return new CVoid(line_num, f);
+        }
+
+        public String docs() {
+            return "void {string} Echoes string to the chat, as if the user simply typed something into the chat bar.";
+        }
+        
+        public ExceptionType[] thrown(){
+            return new ExceptionType[]{ExceptionType.PlayerOfflineException};
+        }
+
+        public boolean isRestricted() {
+            return true;
+        }
+
+        public void varList(IVariableList varList) {}
+
+        public boolean preResolveVariables() {
+            return true;
+        }
+        public String since() {
+            return "3.0.1";
+        }
+        public Boolean runAsync(){
+            return false;
+        }
+        
+    }
+    
+    @api public static class chatas implements Function{
+
+        public String getName() {
+            return "chatas";
+        }
+
+        public Integer[] numArgs() {
+            return new Integer[]{2};
+        }
+
+        public String docs() {
+            return "void {player, msg} Sends a chat message to the server, as the given player. Otherwise the same as the chat"
+                    + " function";
+        }
+        
+        public ExceptionType[] thrown(){
+            return new ExceptionType[]{};
+        }
+
+        public boolean isRestricted() {
+            return true;
+        }
+
+        public void varList(IVariableList varList) {}
+
+        public boolean preResolveVariables() {
+            return true;
+        }
+
+        public String since() {
+            return "3.0.2";
+        }
+
+        public Construct exec(int line_num, File f, Env env, Construct... args) throws CancelCommandException, ConfigRuntimeException {
+            final MCPlayer player = Static.getServer().getPlayer(args[0].val());
+            Static.SendMessage(new LineCallback() {
+
+                public void run(String line) {
+                    if(player != null){
+                        player.chat(line);
+                    }
+                }
+            }, args[1].val());
+            
+            return new CVoid(line_num, f);
+        }
+        public Boolean runAsync(){
+            return false;
+        }
+        
+    }
+    
+    @api public static class broadcast implements Function{
+
+        public String getName() {
+            return "broadcast";
+        }
+
+        public Integer[] numArgs() {
+            return new Integer[]{1};
+        }
+
+        public String docs() {
+            return "void {message} Broadcasts a message to all players on the server";
+        }
+        
+        public ExceptionType[] thrown(){
+            return new ExceptionType[]{ExceptionType.CastException};
+        }
+
+        public boolean isRestricted() {
+            return true;
+        }
+
+        public void varList(IVariableList varList) {}
+
+        public boolean preResolveVariables() {
+            return true;
+        }
+
+        public String since() {
+            return "3.0.1";
+        }
+
+        public Construct exec(int line_num, File f, Env env, Construct... args) throws CancelCommandException, ConfigRuntimeException {
+            if(args[0] instanceof CNull){
+                throw new ConfigRuntimeException("Trying to broadcast null won't work", ExceptionType.CastException, line_num, f);
+            }
+            final MCServer server = Static.getServer();
+            Static.SendMessage(new LineCallback() {
+
+                public void run(String line) {
+                    server.broadcastMessage(line);
+                }
+            }, args[0].val());
+            return new CVoid(line_num, f);
+        }
+        public Boolean runAsync(){
+            return false;
+        }
+        
+    }
+    
+    @api public static class console implements Function{
+
+        public String getName() {
+            return "console";
+        }
+
+        public Integer[] numArgs() {
+            return new Integer[]{1, 2};
+        }
+
+        public String docs() {
+            return "void {message, [prefix]} Logs a message to the console. If prefix is true, prepends \"CommandHelper:\""
+                    + " to the message. Default is true.";
+        }
+        
+        public ExceptionType[] thrown(){
+            return new ExceptionType[]{ExceptionType.CastException};
+        }
+
+        public boolean isRestricted() {
+            return true;
+        }
+
+        public void varList(IVariableList varList) {}
+
+        public boolean preResolveVariables() {
+            return true;
+        }
+
+        public String since() {
+            return "3.0.2";
+        }
+
+        public Construct exec(int line_num, File f, Env env, Construct... args) throws CancelCommandException, ConfigRuntimeException {
+            String mes = args[0].val();
+            boolean prefix = true;
+            if(args.length > 1){
+                prefix = Static.getBoolean(args[1]);
+            }
+            mes = Static.MCToANSIColors(mes);
+            com.laytonsmith.core.Static.getLogger().log(Level.INFO, (prefix?"CommandHelper: ":"") + mes);
+            return new CVoid(line_num, f);
+        }
+        public Boolean runAsync(){
+            return null;
+        }
+        
+    }
+}
diff --git a/src/main/java/com/laytonsmith/core/functions/Economy.java b/src/main/java/com/laytonsmith/core/functions/Economy.java
new file mode 100644
index 0000000..e39665a
--- /dev/null
+++ b/src/main/java/com/laytonsmith/core/functions/Economy.java
@@ -0,0 +1,698 @@
+/*
+ * To change this template, choose Tools | Templates
+ * and open the template in the editor.
+ */
+package com.laytonsmith.core.functions;
+
+import com.laytonsmith.abstraction.bukkit.BukkitMCPluginManager;
+import com.laytonsmith.core.Env;
+import com.laytonsmith.core.Static;
+import com.laytonsmith.core.api;
+import com.laytonsmith.core.constructs.CDouble;
+import com.laytonsmith.core.constructs.CVoid;
+import com.laytonsmith.core.constructs.Construct;
+import com.laytonsmith.core.exceptions.ConfigRuntimeException;
+import com.laytonsmith.core.functions.Exceptions.ExceptionType;
+import com.nijikokun.register.payment.Method;
+import com.nijikokun.register.payment.Method.MethodAccount;
+import com.nijikokun.register.payment.Method.MethodBankAccount;
+import com.nijikokun.register.payment.Methods;
+import java.io.File;
+
+/**
+ *
+ * @author Layton
+ */
+public class Economy {
+    
+    public static String docs(){
+        return "Provides functions to hook into the server's economy plugin. To use any of these functions, you must have one of the"
+                + " following economy plugins installed: iConomy 4, 5, & 6+, BOSEconomy 6 & 7, Essentials Economy 2.2.17+, MultiCurrency."
+                + " No special installation is required beyond simply getting the economy plugin working by itself. Using any of these functions"
+                + " without one of the economy plugins will cause it to throw a InvalidPluginException at runtime.";
+    }
+    
+    @api public static class acc_balance implements Function{
+
+        public String getName() {
+            return "acc_balance";
+        }
+
+        public Integer[] numArgs() {
+            return new Integer[]{1};
+        }
+
+        public String docs() {
+            return "double {account_name} Returns the balance of the given account name.";
+        }
+
+        public ExceptionType[] thrown() {
+            return new ExceptionType[]{ExceptionType.PluginInternalException, ExceptionType.InvalidPluginException};
+        }
+
+        public boolean isRestricted() {
+            return true;
+        }
+
+        public boolean preResolveVariables() {
+            return true;
+        }
+
+        public String since() {
+            return "3.2.0";
+        }
+
+        public Boolean runAsync() {
+            return null;
+        }
+
+        public Construct exec(int line_num, File f, Env env, Construct... args) throws ConfigRuntimeException {
+            MethodAccount ma = GetAccount(this.getName(), line_num, f, args);
+            return new CDouble(ma.balance(), line_num, f);
+        }
+        
+    }
+    @api public static class acc_set implements Function{
+
+        public String getName() {
+            return "acc_set";
+        }
+
+        public Integer[] numArgs() {
+            return new Integer[]{2};
+        }
+
+        public String docs() {
+            return "void {account_name, value} Sets the account's balance to the given amount";
+        }
+
+        public ExceptionType[] thrown() {
+            return new ExceptionType[]{ExceptionType.PluginInternalException, ExceptionType.InvalidPluginException, ExceptionType.CastException};
+        }
+
+        public boolean isRestricted() {
+            return true;
+        }
+
+        public void varList(IVariableList varList) {}
+
+        public boolean preResolveVariables() {
+            return true;
+        }
+
+        public String since() {
+            return "3.2.0";
+        }
+
+        public Boolean runAsync() {
+            return null;
+        }
+
+        public Construct exec(int line_num, File f, Env env, Construct... args) throws ConfigRuntimeException {
+            if(GetAccount(this.getName(), line_num, f, args).set(Static.getNumber(args[1]))){
+                return new CVoid(line_num, f);
+            } else {
+                throw new ConfigRuntimeException("An error occured when trying to set the balance on account " + args[0].val(), ExceptionType.PluginInternalException, line_num, f);
+            }
+        }
+        
+    }
+    @api public static class acc_add implements Function{
+
+        public String getName() {
+            return "acc_add";
+        }
+
+        public Integer[] numArgs() {
+            return new Integer[]{2};
+        }
+
+        public String docs() {
+            return "void {account_name, to_add} Adds an amount to the specified account";
+        }
+
+        public ExceptionType[] thrown() {
+            return new ExceptionType[]{ExceptionType.PluginInternalException, ExceptionType.InvalidPluginException, ExceptionType.CastException};
+        }
+
+        public boolean isRestricted() {
+            return true;
+        }
+
+        public void varList(IVariableList varList) {}
+
+        public boolean preResolveVariables() {
+            return true;
+        }
+
+        public String since() {
+            return "3.2.0";
+        }
+
+        public Boolean runAsync() {
+            return null;
+        }
+
+        public Construct exec(int line_num, File f, Env env, Construct... args) throws ConfigRuntimeException {
+            if(GetAccount(this.getName(), line_num, f, args).add(Static.getNumber(args[1]))){
+                return new CVoid(line_num, f);
+            } else {
+                throw new ConfigRuntimeException("An error occured when trying to add to the balance on account " + args[0].val(), ExceptionType.PluginInternalException, line_num, f);
+            }
+        }
+        
+    }
+    @api public static class acc_subtract implements Function{
+
+        public String getName() {
+            return "acc_subtract";
+        }
+
+        public Integer[] numArgs() {
+            return new Integer[]{2};
+        }
+
+        public String docs() {
+            return "void {account_name, to_subtract} Subtracts the given amount from the specified account";
+        }
+
+        public ExceptionType[] thrown() {
+            return new ExceptionType[]{ExceptionType.PluginInternalException, ExceptionType.InvalidPluginException, ExceptionType.CastException};
+        }
+
+        public boolean isRestricted() {
+            return true;
+        }
+
+        public void varList(IVariableList varList) {}
+
+        public boolean preResolveVariables() {
+            return true;
+        }
+
+        public String since() {
+            return "3.2.0";
+        }
+
+        public Boolean runAsync() {
+            return null;
+        }
+
+        public Construct exec(int line_num, File f, Env env, Construct... args) throws ConfigRuntimeException {
+            if(GetAccount(this.getName(), line_num, f, args).subtract(Static.getNumber(args[1]))){
+                return new CVoid(line_num, f);
+            } else {
+                throw new ConfigRuntimeException("An error occured when trying to subtract from the balance on account " + args[0].val(), ExceptionType.PluginInternalException, line_num, f);
+            }
+        }
+        
+    }
+    @api public static class acc_multiply implements Function{
+
+        public String getName() {
+            return "acc_multiply";
+        }
+
+        public Integer[] numArgs() {
+            return new Integer[]{2};
+        }
+
+        public String docs() {
+            return "void {account_name, to_multiply} Multiplies the account balance by the given amount";
+        }
+
+        public ExceptionType[] thrown() {
+            return new ExceptionType[]{ExceptionType.PluginInternalException, ExceptionType.InvalidPluginException, ExceptionType.CastException};
+        }
+
+        public boolean isRestricted() {
+            return true;
+        }
+
+        public void varList(IVariableList varList) {}
+
+        public boolean preResolveVariables() {
+            return true;
+        }
+
+        public String since() {
+            return "3.2.0";
+        }
+
+        public Boolean runAsync() {
+            return null;
+        }
+
+        public Construct exec(int line_num, File f, Env env, Construct... args) throws ConfigRuntimeException {
+            if(GetAccount(this.getName(), line_num, f, args).multiply(Static.getNumber(args[1]))){
+                return new CVoid(line_num, f);
+            } else {
+                throw new ConfigRuntimeException("An error occured when trying to multiply the balance on account " + args[0].val(), ExceptionType.PluginInternalException, line_num, f);
+            }
+        }
+        
+    }
+    @api public static class acc_divide implements Function{
+
+        public String getName() {
+            return "acc_divide";
+        }
+
+        public Integer[] numArgs() {
+            return new Integer[]{2};
+        }
+
+        public String docs() {
+            return "void {account_name, to_divide} Divides the account by the given amount";
+        }
+
+        public ExceptionType[] thrown() {
+            return new ExceptionType[]{ExceptionType.PluginInternalException, ExceptionType.InvalidPluginException, ExceptionType.CastException};
+        }
+
+        public boolean isRestricted() {
+            return true;
+        }
+
+        public void varList(IVariableList varList) {}
+
+        public boolean preResolveVariables() {
+            return true;
+        }
+
+        public String since() {
+            return "3.2.0";
+        }
+
+        public Boolean runAsync() {
+            return null;
+        }
+
+        public Construct exec(int line_num, File f, Env env, Construct... args) throws ConfigRuntimeException {
+            if(GetAccount(this.getName(), line_num, f, args).divide(Static.getNumber(args[1]))){
+                return new CVoid(line_num, f);
+            } else {
+                throw new ConfigRuntimeException("An error occured when trying to divide the balance on account " + args[0].val(), ExceptionType.PluginInternalException, line_num, f);
+            }
+        }
+        
+    }
+    @api public static class acc_remove implements Function{
+
+        public String getName() {
+            return "acc_remove";
+        }
+
+        public Integer[] numArgs() {
+            return new Integer[]{1};
+        }
+
+        public String docs() {
+            return "void {account_name} Removes the specified account from the game";
+        }
+
+        public ExceptionType[] thrown() {
+            return new ExceptionType[]{ExceptionType.PluginInternalException, ExceptionType.InvalidPluginException};
+        }
+
+        public boolean isRestricted() {
+            return true;
+        }
+
+        public void varList(IVariableList varList) {}
+
+        public boolean preResolveVariables() {
+            return true;
+        }
+
+        public String since() {
+            return "3.2.0";
+        }
+
+        public Boolean runAsync() {
+            return null;
+        }
+
+        public Construct exec(int line_num, File f, Env env, Construct... args) throws ConfigRuntimeException {
+            if(GetAccount(this.getName(), line_num, f, args).remove()){
+                return new CVoid(line_num, f);
+            } else {
+                throw new ConfigRuntimeException("An error occured when trying to set the balance on account " + args[0].val(), ExceptionType.PluginInternalException, line_num, f);
+            }
+        }
+        
+    }
+    @api public static class bacc_balance implements Function{
+
+        public String getName() {
+            return "bacc_balance";
+        }
+
+        public Integer[] numArgs() {
+            return new Integer[]{2};
+        }
+
+        public String docs() {
+            return "void {bank_name, account_name} Gets the specified bank account's balance";
+        }
+
+        public ExceptionType[] thrown() {
+            return new ExceptionType[]{ExceptionType.PluginInternalException, ExceptionType.InvalidPluginException};
+        }
+
+        public boolean isRestricted() {
+            return true;
+        }
+
+        public void varList(IVariableList varList) {}
+
+        public boolean preResolveVariables() {
+            return true;
+        }
+
+        public String since() {
+            return "3.2.0";
+        }
+
+        public Boolean runAsync() {
+            return null;
+        }
+
+        public Construct exec(int line_num, File f, Env env, Construct... args) throws ConfigRuntimeException {
+            return new CDouble(GetBankAccount(this.getName(), line_num, f, args).balance(), line_num, f);
+        }
+        
+    }
+    @api public static class bacc_set implements Function{
+
+        public String getName() {
+            return "bacc_set";
+        }
+
+        public Integer[] numArgs() {
+            return new Integer[]{3};
+        }
+
+        public String docs() {
+            return "void {bank_name, account_name, value} Sets the bank account's balance to the given amount";
+        }
+
+        public ExceptionType[] thrown() {
+            return new ExceptionType[]{ExceptionType.PluginInternalException, ExceptionType.InvalidPluginException, ExceptionType.CastException};
+        }
+
+        public boolean isRestricted() {
+            return true;
+        }
+
+        public void varList(IVariableList varList) {}
+
+        public boolean preResolveVariables() {
+            return true;
+        }
+
+        public String since() {
+            return "3.2.0";
+        }
+
+        public Boolean runAsync() {
+            return null;
+        }
+
+        public Construct exec(int line_num, File f, Env env, Construct... args) throws ConfigRuntimeException {
+            if(GetBankAccount(this.getName(), line_num, f, args).set(Static.getNumber(args[2]))){
+                return new CVoid(line_num, f);
+            } else {
+                throw new ConfigRuntimeException("An error occured when trying to set the balance on bank account " + args[0].val() + ":" + args[1].val(), ExceptionType.PluginInternalException, line_num, f);
+            }
+        }
+        
+    }
+    @api public static class bacc_add implements Function{
+
+        public String getName() {
+            return "bacc_add";
+        }
+
+        public Integer[] numArgs() {
+            return new Integer[]{3};
+        }
+
+        public String docs() {
+            return "void {bank_name, account_name, value} Adds the specified amount to the bank account's balance";
+        }
+
+        public ExceptionType[] thrown() {
+            return new ExceptionType[]{ExceptionType.PluginInternalException, ExceptionType.InvalidPluginException, ExceptionType.CastException};
+        }
+
+        public boolean isRestricted() {
+            return true;
+        }
+
+        public void varList(IVariableList varList) {}
+
+        public boolean preResolveVariables() {
+            return true;
+        }
+
+        public String since() {
+            return "3.2.0";
+        }
+
+        public Boolean runAsync() {
+            return null;
+        }
+
+        public Construct exec(int line_num, File f, Env env, Construct... args) throws ConfigRuntimeException {
+            if(GetBankAccount(this.getName(), line_num, f, args).add(Static.getNumber(args[2]))){
+                return new CVoid(line_num, f);
+            } else {
+                throw new ConfigRuntimeException("An error occured when trying to add to the balance on bank account " + args[0].val() + ":" + args[1].val(), ExceptionType.PluginInternalException, line_num, f);
+            }
+        }
+        
+    }
+    @api public static class bacc_subtract implements Function{
+
+        public String getName() {
+            return "bacc_subtract";
+        }
+
+        public Integer[] numArgs() {
+            return new Integer[]{3};
+        }
+
+        public String docs() {
+            return "void {bank_name, account_name, value} Subtracts the specified amount from the bank account's balance";
+        }
+
+        public ExceptionType[] thrown() {
+            return new ExceptionType[]{ExceptionType.PluginInternalException, ExceptionType.InvalidPluginException, ExceptionType.CastException};
+        }
+
+        public boolean isRestricted() {
+            return true;
+        }
+
+        public void varList(IVariableList varList) {}
+
+        public boolean preResolveVariables() {
+            return true;
+        }
+
+        public String since() {
+            return "3.2.0";
+        }
+
+        public Boolean runAsync() {
+            return null;
+        }
+
+        public Construct exec(int line_num, File f, Env env, Construct... args) throws ConfigRuntimeException {
+            if(GetBankAccount(this.getName(), line_num, f, args).subtract(Static.getNumber(args[2]))){
+                return new CVoid(line_num, f);
+            } else {
+                throw new ConfigRuntimeException("An error occured when trying to subtract from the balance on bank account " + args[0].val() + ":" + args[1].val(), ExceptionType.PluginInternalException, line_num, f);
+            }
+        }
+        
+    }
+    @api public static class bacc_multiply implements Function{
+
+        public String getName() {
+            return "bacc_multiply";
+        }
+
+        public Integer[] numArgs() {
+            return new Integer[]{3};
+        }
+
+        public String docs() {
+            return "void {bank_name, account_name, value} Multiplies the given bank account's balance by the given value";
+        }
+
+        public ExceptionType[] thrown() {
+            return new ExceptionType[]{ExceptionType.PluginInternalException, ExceptionType.InvalidPluginException, ExceptionType.CastException};
+        }
+
+        public boolean isRestricted() {
+            return true;
+        }
+
+        public void varList(IVariableList varList) {}
+
+        public boolean preResolveVariables() {
+            return true;
+        }
+
+        public String since() {
+            return "3.2.0";
+        }
+
+        public Boolean runAsync() {
+            return null;
+        }
+
+        public Construct exec(int line_num, File f, Env env, Construct... args) throws ConfigRuntimeException {
+            if(GetBankAccount(this.getName(), line_num, f, args).multiply(Static.getNumber(args[2]))){
+                return new CVoid(line_num, f);
+            } else {
+                throw new ConfigRuntimeException("An error occured when trying to multiply the balance on bank account " + args[0].val() + ":" + args[1].val(), ExceptionType.PluginInternalException, line_num, f);
+            }
+        }
+        
+    }
+    @api public static class bacc_divide implements Function{
+
+        public String getName() {
+            return "bacc_divide";
+        }
+
+        public Integer[] numArgs() {
+            return new Integer[]{3};
+        }
+
+        public String docs() {
+            return "void {bank_name, account_name, value} Divides the bank account's balance by the given value";
+        }
+
+        public ExceptionType[] thrown() {
+            return new ExceptionType[]{ExceptionType.PluginInternalException, ExceptionType.InvalidPluginException, ExceptionType.CastException};
+        }
+
+        public boolean isRestricted() {
+            return true;
+        }
+
+        public void varList(IVariableList varList) {}
+
+        public boolean preResolveVariables() {
+            return true;
+        }
+
+        public String since() {
+            return "3.2.0";
+        }
+
+        public Boolean runAsync() {
+            return null;
+        }
+
+        public Construct exec(int line_num, File f, Env env, Construct... args) throws ConfigRuntimeException {
+            if(GetBankAccount(this.getName(), line_num, f, args).divide(Static.getNumber(args[2]))){
+                return new CVoid(line_num, f);
+            } else {
+                throw new ConfigRuntimeException("An error occured when trying to divide the balance on bank account " + args[0].val() + ":" + args[1].val(), ExceptionType.PluginInternalException, line_num, f);
+            }
+        }
+        
+    }
+    @api public static class bacc_remove implements Function{
+
+        public String getName() {
+            return "bacc_remove";
+        }
+
+        public Integer[] numArgs() {
+            return new Integer[]{2};
+        }
+
+        public String docs() {
+            return "void {bank_name, account_name} Removes the given bank account from the game";
+        }
+
+        public ExceptionType[] thrown() {
+            return new ExceptionType[]{ExceptionType.PluginInternalException, ExceptionType.InvalidPluginException};
+        }
+
+        public boolean isRestricted() {
+            return true;
+        }
+
+        public void varList(IVariableList varList) {}
+
+        public boolean preResolveVariables() {
+            return true;
+        }
+
+        public String since() {
+            return "3.2.0";
+        }
+
+        public Boolean runAsync() {
+            return null;
+        }
+
+        public Construct exec(int line_num, File f, Env env, Construct... args) throws ConfigRuntimeException {
+            if(GetBankAccount(this.getName(), line_num, f, args).remove()){
+                return new CVoid(line_num, f);
+            } else {
+                throw new ConfigRuntimeException("An error occured when trying to remove the bank account " + args[0].val() + ":" + args[1].val(), ExceptionType.PluginInternalException, line_num, f);
+            }
+        }
+        
+    }
+    
+    public static Method GetMethod(int line_num, File file){
+        com.nijikokun.register.payment.Methods m = new Methods();
+        if(!Methods.hasMethod()){
+            //Register only works with Bukkit for now anyways.
+            Methods.setMethod(((BukkitMCPluginManager)Static.getServer().getPluginManager()).__PluginManager());
+            //initialize our plugin if it isn't already
+//            Plugin [] plugins = Static.getServer().getPluginManager().getPlugins();
+//            for(Plugin plugin : plugins){
+//                if(m.setMethod(plugin)){
+//                    break;
+//                }
+//            }
+        }
+        if(Methods.getMethod() == null){
+            throw new ConfigRuntimeException("No Economy plugins appear to be loaded", ExceptionType.InvalidPluginException, line_num, file);
+        } else {
+            return Methods.getMethod();
+        }
+    }
+    
+    public static MethodAccount GetAccount(String fname, int line_num, File file, Construct ... args){
+        String name = args[0].val();
+        MethodAccount m = GetMethod(line_num, file).getAccount(name);
+        if(m == null){
+            throw new ConfigRuntimeException("Could not access an account by that name (" + args[0].val() + ")", ExceptionType.PluginInternalException, line_num, file);
+        } else {
+            return m;
+        }
+    }
+    
+    public static MethodBankAccount GetBankAccount(String fname, int line_num, File file, Construct ... args){
+        String bank_name = args[0].val();
+        String account_name = args[1].val();
+        MethodBankAccount m = GetMethod(line_num, file).getBankAccount(bank_name, account_name);
+        if(m == null){
+            throw new ConfigRuntimeException("Could not access a bank account by that name (" + args[0].val() + ":" + args[1].val() + ")", ExceptionType.PluginInternalException, line_num, file);
+        } else {
+            return m;
+        }
+    }
+
+}
diff --git a/src/main/java/com/laytonsmith/core/functions/Enchantments.java b/src/main/java/com/laytonsmith/core/functions/Enchantments.java
new file mode 100644
index 0000000..605038a
--- /dev/null
+++ b/src/main/java/com/laytonsmith/core/functions/Enchantments.java
@@ -0,0 +1,521 @@
+/*
+ * To change this template, choose Tools | Templates
+ * and open the template in the editor.
+ */
+package com.laytonsmith.core.functions;
+
+import com.laytonsmith.abstraction.MCEnchantment;
+import com.laytonsmith.abstraction.MCItemStack;
+import com.laytonsmith.abstraction.MCPlayer;
+import com.laytonsmith.abstraction.StaticLayer;
+import com.laytonsmith.core.Env;
+import com.laytonsmith.core.Static;
+import com.laytonsmith.core.api;
+import com.laytonsmith.core.constructs.*;
+import com.laytonsmith.core.exceptions.ConfigRuntimeException;
+import com.laytonsmith.core.functions.Exceptions.ExceptionType;
+import java.io.File;
+import java.util.HashMap;
+import java.util.Map;
+
+/**
+ *
+ * @author Layton
+ */
+public class Enchantments {
+
+    public static String docs() {
+        return "Provides methods for dealing with enchanted items";
+    }
+    
+    /**
+     * Converts the wiki version string to the bukkit version string. If the specified string isn't
+     * in the wiki, the string is returned unchanged.
+     * @param wikiVersion
+     * @return 
+     */
+    public static String ConvertName(String wikiVersion){
+        String lc = wikiVersion.toLowerCase().trim();
+        if(lc.equals("protection")){
+            return "PROTECTION_ENVIRONMENTAL";
+        } else if(lc.equals("fire protection")){
+            return "PROTECTION_FIRE";
+        } else if(lc.equals("feather falling")){
+            return "PROTECTION_FALL";
+        } else if(lc.equals("blast protection")){
+            return "PROTECTION_EXPLOSIONS";
+        } else if(lc.equals("projectile protection")){
+            return "PROTECTION_PROJECTILE";
+        } else if(lc.equals("respiration")){
+            return "OXYGEN";
+        } else if(lc.equals("aqua affinity")){
+            return "WATER_WORKER";
+        } else if(lc.equals("sharpness")){
+            return "DAMAGE_ALL";
+        } else if(lc.equals("smite")){
+            return "DAMAGE_UNDEAD";
+        } else if(lc.equals("bane of arthropods")){
+            return "DAMAGE_ARTHROPODS";
+        } else if(lc.equals("knockback")){
+            return "KNOCKBACK";
+        } else if(lc.equals("fire aspect")){
+            return "FIRE_ASPECT";
+        } else if(lc.equals("looting")){
+            return "LOOT_BONUS_MOBS";
+        } else if(lc.equals("efficiency")){
+            return "DIG_SPEED";
+        } else if(lc.equals("silk touch")){
+            return "SILK_TOUCH";
+        } else if(lc.equals("unbreaking")){
+            return "DURABILITY";
+        } else if(lc.equals("fortune")){
+            return "LOOT_BONUS_BLOCKS";
+        } else {
+            return wikiVersion;
+        }
+    }
+    
+    /**
+     * Converts the roman numeral into an integer (as a string). If the value
+     * passed in is already an integer, it is returned as is.
+     * @param romanNumeral
+     * @return 
+     */
+    public static String ConvertLevel(String romanNumeral){
+        String lc = romanNumeral.toLowerCase().trim();
+        int i = 0;
+        if(lc.equals("i")){
+            i = 1;
+        } else if(lc.equals("ii")){
+            i = 2;
+        } else if(lc.equals("iii")){
+            i = 3;
+        } else if(lc.equals("iv")){
+            i = 4;
+        } else if(lc.equals("v")){
+            i = 5;
+        } else {
+            return romanNumeral;
+        }
+        return Integer.toString(i);
+    }
+
+    @api
+    public static class enchant_inv implements Function {
+
+        public String getName() {
+            return "enchant_inv";
+        }
+
+        public Integer[] numArgs() {
+            return new Integer[]{3, 4};
+        }
+
+        public String docs() {
+            return "void {[player], slot, type, level} Adds an enchantment to an item in the player's inventory. Type can be a single string,"
+                    + " or an array of enchantment names. If slot is null, the currently selected slot is used. If the enchantment cannot be applied"
+                    + " to the specified item, an EnchantmentException is thrown, and if the level specified is not valid, a RangeException is thrown."
+                    + " If type is an array, level must also be an array, with equal number of values in it, with each int corresponding to the appropriate"
+                    + " type. You may use either the bukkit names for enchantments, or the name shown on the wiki: [http://www.minecraftwiki.net/wiki/Enchanting#Enchantment_Types],"
+                    + " and level may be a roman numeral as well.";
+        }
+
+        public ExceptionType[] thrown() {
+            return new ExceptionType[]{ExceptionType.CastException, ExceptionType.EnchantmentException, ExceptionType.PlayerOfflineException};
+        }
+
+        public boolean isRestricted() {
+            return true;
+        }
+
+        public boolean preResolveVariables() {
+            return true;
+        }
+
+        public String since() {
+            return "3.3.0";
+        }
+
+        public Boolean runAsync() {
+            return false;
+        }
+
+        public Construct exec(int line_num, File f, Env environment, Construct... args) throws ConfigRuntimeException {
+            MCPlayer m = environment.GetPlayer();
+            int offset = 1;
+            if (args.length == 4) {
+                m = Static.GetPlayer(args[0].val(), line_num, f);
+                offset = 0;
+            }
+            MCItemStack is = null;
+            if (args[1 - offset] instanceof CNull) {
+                is = m.getItemInHand();
+            } else {
+                int slot = (int) Static.getInt(args[1 - offset]);
+                is = m.getInventory().getItem(slot);
+            }
+            CArray enchantArray = new CArray(line_num, f);
+            if (!(args[2 - offset] instanceof CArray)) {
+                enchantArray.push(args[2 - offset]);
+            } else {
+                enchantArray = (CArray) args[2 - offset];
+            }
+
+            CArray levelArray = new CArray(line_num, f);
+            if (!(args[3 - offset] instanceof CArray)) {
+                levelArray.push(args[3 - offset]);
+            } else {
+                levelArray = (CArray) args[3 - offset];
+            }
+            for (String key : enchantArray.keySet()) {
+                MCEnchantment e = StaticLayer.GetEnchantmentByName(Enchantments.ConvertName(enchantArray.get(key, line_num, f).val()).toUpperCase());
+                if(e == null){
+                    throw new ConfigRuntimeException(enchantArray.get(key, line_num, f).val().toUpperCase() + " is not a valid enchantment type", ExceptionType.EnchantmentException, line_num, f);
+                }
+                if (e.canEnchantItem(is)) {
+                    int level = (int) Static.getInt(new CString(Enchantments.ConvertLevel(levelArray.get(key, line_num, f).val()), line_num, f));
+                    if (e.getMaxLevel() >= level && level > 0) {
+                        is.addEnchantment(e, level);
+                    } else {
+                        throw new ConfigRuntimeException(level + " is too high for the " + e.getName() + " enchantment. The range is 1-" + e.getMaxLevel(), ExceptionType.RangeException, line_num, f);
+                    }
+                } else {
+                    throw new ConfigRuntimeException(enchantArray.get(key, line_num, f).val().toUpperCase() + " cannot be applied to this item", ExceptionType.EnchantmentException, line_num, f);
+                }
+            }
+            return new CVoid(line_num, f);
+        }
+    }
+
+    @api
+    public static class enchant_rm_inv implements Function {
+
+        public String getName() {
+            return "enchant_rm_inv";
+        }
+
+        public Integer[] numArgs() {
+            return new Integer[]{2, 3};
+        }
+
+        public String docs() {
+            return "void {[player], slot, type} Removes an enchantment from an item. type may be a valid enchantment, or an array of enchantment names. It"
+                    + " can also be null, and all enchantments will be removed. If an enchantment is specified, and the item is not enchanted with that,"
+                    + " it is simply ignored.";
+        }
+
+        public ExceptionType[] thrown() {
+            return new ExceptionType[]{ExceptionType.CastException, ExceptionType.EnchantmentException, ExceptionType.PlayerOfflineException};
+        }
+
+        public boolean isRestricted() {
+            return true;
+        }
+
+        public boolean preResolveVariables() {
+            return true;
+        }
+
+        public String since() {
+            return "3.3.0";
+        }
+
+        public Boolean runAsync() {
+            return false;
+        }
+
+        public Construct exec(int line_num, File f, Env environment, Construct... args) throws ConfigRuntimeException {
+            MCPlayer m = environment.GetPlayer();
+            int offset = 1;
+            if (args.length == 3) {
+                m = Static.GetPlayer(args[0].val(), line_num, f);
+                offset = 0;
+            }
+            MCItemStack is = null;
+            if (args[1 - offset] instanceof CNull) {
+                is = m.getItemInHand();
+            } else {
+                int slot = (int) Static.getInt(args[1 - offset]);
+                is = m.getInventory().getItem(slot);
+            }
+
+            CArray enchantArray = new CArray(line_num, f);
+            if (!(args[2 - offset] instanceof CArray) && !(args[2 - offset] instanceof CNull)) {
+                enchantArray.push(args[2 - offset]);
+            } else if (args[2 - offset] instanceof CNull) {
+                for (MCEnchantment e : is.getEnchantments().keySet()) {
+                    is.removeEnchantment(e);
+                }
+            } else {
+                enchantArray = (CArray) args[2 - offset];
+            }
+            for (String key : enchantArray.keySet()) {
+                MCEnchantment e = StaticLayer.GetEnchantmentByName(enchantArray.get(key, line_num, f).val().toUpperCase());
+                is.removeEnchantment(e);
+            }
+            return new CVoid(line_num, f);
+        }
+    }
+    
+    @api public static class get_enchant_inv implements Function{
+
+        public String getName() {
+            return "get_enchant_inv";
+        }
+
+        public Integer[] numArgs() {
+            return new Integer[]{1, 2};
+        }
+
+        public String docs() {
+            return "array {[player], slot} Returns an array of arrays of the enchantments and their levels on the given"
+                    + " item. For example: array(array(DAMAGE_ALL, DAMAGE_UNDEAD), array(1, 2))";
+        }
+
+        public ExceptionType[] thrown() {
+            return new ExceptionType[]{ExceptionType.PlayerOfflineException, ExceptionType.CastException};
+        }
+
+        public boolean isRestricted() {
+            return true;
+        }
+
+        public boolean preResolveVariables() {
+            return true;
+        }
+
+        public String since() {
+            return "3.3.0";
+        }
+
+        public Boolean runAsync() {
+            return false;
+        }
+
+        public Construct exec(int line_num, File f, Env environment, Construct... args) throws ConfigRuntimeException {
+            MCPlayer m = environment.GetPlayer();
+            Construct slot;
+            if(args.length == 2){
+                m = Static.GetPlayer(args[0].val(), line_num, f);
+                slot = args[1];
+            } else {
+                slot = args[0];
+            }            
+            MCItemStack is;
+            if(slot instanceof CNull){
+                is = m.getItemInHand();
+            } else {
+                int slotID = (int) Static.getInt(slot);
+                is = m.getInventory().getItem(slotID);
+            }
+            CArray enchants = new CArray(line_num, f);
+            CArray levels = new CArray(line_num, f);
+            for(Map.Entry<MCEnchantment, Integer> entry : is.getEnchantments().entrySet()){
+                MCEnchantment e = entry.getKey();
+                Integer l = entry.getValue();
+                enchants.push(new CString(e.getName(), line_num, f));
+                levels.push(new CInt(l, line_num, f));
+            }
+            
+            return new CArray(line_num, f, enchants, levels);
+        }
+        
+    }
+    
+    @api public static class can_enchant_target implements Function{
+
+        public String getName() {
+            return "can_enchant_target";
+        }
+
+        public Integer[] numArgs() {
+            return new Integer[]{2};
+        }
+
+        public String docs() {
+            return "boolean {name, targetItem} Given an enchantment name, and target item id,"
+                    + " returns wether or not that item can be enchanted with that enchantment."
+                    + " Throws an EnchantmentException if the name is not a valid enchantment"
+                    + " type.";
+        }
+
+        public ExceptionType[] thrown() {
+            return new ExceptionType[]{ExceptionType.EnchantmentException, ExceptionType.CastException};
+        }
+
+        public boolean isRestricted() {
+            return false;
+        }
+
+        public boolean preResolveVariables() {
+            return true;
+        }
+
+        public String since() {
+            return "3.3.0";
+        }
+
+        public Boolean runAsync() {
+            return false;
+        }
+
+        public Construct exec(int line_num, File f, Env environment, Construct... args) throws ConfigRuntimeException {
+            String name = Enchantments.ConvertName(args[0].val().toUpperCase());
+            MCEnchantment e = StaticLayer.GetEnchantmentByName(name);
+            MCItemStack is = Static.ParseItemNotation(this.getName(), args[1].val(), 1, line_num, f);
+            return new CBoolean(e.canEnchantItem(is), line_num, f);
+        }
+        
+    }
+    
+    @api public static class get_enchant_max implements Function{
+
+        public String getName() {
+            return "get_enchant_max";
+        }
+
+        public Integer[] numArgs() {
+            return new Integer[]{1};
+        }
+
+        public String docs() {
+            return "int {name} Given an enchantment name, returns the max level it can be."
+                    + " If name is not a valid enchantment, an EnchantException is thrown.";
+        }
+
+        public ExceptionType[] thrown() {
+            return new ExceptionType[]{ExceptionType.EnchantmentException};
+        }
+
+        public boolean isRestricted() {
+            return false;
+        }
+
+        public boolean preResolveVariables() {
+            return true;
+        }
+
+        public String since() {
+            return "3.3.0";
+        }
+
+        public Boolean runAsync() {
+            return null;
+        }
+
+        public Construct exec(int line_num, File f, Env environment, Construct... args) throws ConfigRuntimeException {
+            String name = Enchantments.ConvertName(args[0].val().toUpperCase());
+            MCEnchantment e = StaticLayer.GetEnchantmentByName(name);
+            return new CInt(e.getMaxLevel(), line_num, f);
+        }
+        
+    }
+    
+    @api public static class get_enchants implements Function{
+        
+        private static Map<String, CArray> cache = new HashMap<String, CArray>();
+
+        public String getName() {
+            return "get_enchants";
+        }
+
+        public Integer[] numArgs() {
+            return new Integer[]{1};
+        }
+
+        public String docs() {
+            return "array {item} Given an item id, returns the enchantments that can"
+                    + " be validly added to this item. This may return an empty array.";
+        }
+
+        public ExceptionType[] thrown() {
+            return new ExceptionType[]{ExceptionType.CastException};
+        }
+
+        public boolean isRestricted() {
+            return false;
+        }
+
+        public boolean preResolveVariables() {
+            return true;
+        }
+
+        public String since() {
+            return "3.3.0";
+        }
+
+        public Boolean runAsync() {
+            return false;
+        }
+
+        public Construct exec(int line_num, File f, Env environment, Construct... args) throws ConfigRuntimeException {
+            MCItemStack is = Static.ParseItemNotation(this.getName(), args[0].val(), 1, line_num, f);
+            /**
+             * Because enchantment types won't change from run to run, we can
+             * cache here, and save time on duplicate lookups.
+             */
+            if(cache.containsKey(args[0].val())){
+                try {
+                    return cache.get(args[0].val()).clone();
+                } catch (CloneNotSupportedException ex) {
+                    throw new ConfigRuntimeException(ex.getMessage(), null, line_num, f, ex);
+                }
+            }
+            CArray ca = new CArray(line_num, f);
+            for(MCEnchantment e : StaticLayer.GetEnchantmentValues()){
+                if(e.canEnchantItem(is)){
+                    ca.push(new CString(e.getName(), line_num, f));
+                }
+            }
+            cache.put(args[0].val(), ca);
+            try {
+                return ca.clone();
+            } catch (CloneNotSupportedException ex) {
+                throw new ConfigRuntimeException(ex.getMessage(), null, line_num, f, ex);
+            }
+        }
+        
+    }
+    
+    @api public static class is_enchantment implements Function{
+
+        public String getName() {
+            return "is_enchantment";
+        }
+
+        public Integer[] numArgs() {
+            return new Integer[]{1};
+        }
+
+        public String docs() {
+            return "boolean {name} Returns true if this name is a valid enchantment type. Note"
+                    + " that either the bukkit names or the wiki names are valid.";
+        }
+
+        public ExceptionType[] thrown() {
+            return new ExceptionType[]{};
+        }
+
+        public boolean isRestricted() {
+            return false;
+        }
+
+        public boolean preResolveVariables() {
+            return true;
+        }
+
+        public String since() {
+            return "3.3.0";
+        }
+
+        public Boolean runAsync() {
+            return false;
+        }
+
+        public Construct exec(int line_num, File f, Env environment, Construct... args) throws ConfigRuntimeException {
+            MCEnchantment e = StaticLayer.GetEnchantmentByName(args[0].val());
+            return new CBoolean(e != null, line_num, f);
+        }
+        
+    }
+}
diff --git a/src/main/java/com/laytonsmith/core/functions/Environment.java b/src/main/java/com/laytonsmith/core/functions/Environment.java
new file mode 100644
index 0000000..bf5a4c7
--- /dev/null
+++ b/src/main/java/com/laytonsmith/core/functions/Environment.java
@@ -0,0 +1,471 @@
+/*
+ * To change this template, choose Tools | Templates
+ * and open the template in the editor.
+ */
+package com.laytonsmith.core.functions;
+
+import com.laytonsmith.abstraction.MCLocation;
+import com.laytonsmith.abstraction.MCPlayer;
+import com.laytonsmith.abstraction.MCWorld;
+import com.laytonsmith.abstraction.blocks.MCBlock;
+import com.laytonsmith.abstraction.blocks.MCSign;
+import com.laytonsmith.abstraction.bukkit.BukkitMCServer;
+import com.laytonsmith.core.Env;
+import com.laytonsmith.core.ObjectGenerator;
+import com.laytonsmith.core.Static;
+import com.laytonsmith.core.api;
+import com.laytonsmith.core.constructs.*;
+import com.laytonsmith.core.exceptions.CancelCommandException;
+import com.laytonsmith.core.exceptions.ConfigRuntimeException;
+import com.laytonsmith.core.functions.Exceptions.ExceptionType;
+import java.io.File;
+import net.minecraft.server.Packet0KeepAlive;
+import org.bukkit.craftbukkit.CraftServer;
+import org.bukkit.craftbukkit.CraftWorld;
+
+/**
+ *
+ * @author Layton
+ */
+public class Environment {
+
+    public static String docs() {
+        return "Allows you to manipulate the environment around the player";
+    }
+
+    @api
+    public static class get_block_at implements Function {
+
+        public String getName() {
+            return "get_block_at";
+        }
+
+        public Integer[] numArgs() {
+            return new Integer[]{1, 2, 3, 4};
+        }
+
+        public String docs() {
+            return "string {x, y, z, [world] | xyzArray, [world]} Gets the id of the block at x, y, z. This function expects "
+                    + "either 1 or 3 arguments. If 1 argument is passed, it should be an array with the x, y, z"
+                    + " coordinates. The format of the return will be x:y where x is the id of the block, and"
+                    + " y is the meta data for the block. All blocks will return in this format, but blocks"
+                    + " that don't have meta data normally will return 0 in y. If world isn't specified, the current"
+                    + " player's world is used.";
+        }
+
+        public ExceptionType[] thrown() {
+            return new ExceptionType[]{ExceptionType.FormatException, ExceptionType.CastException, ExceptionType.LengthException, ExceptionType.InvalidWorldException};
+        }
+
+        public boolean isRestricted() {
+            return true;
+        }
+
+        public void varList(IVariableList varList) {
+        }
+
+        public boolean preResolveVariables() {
+            return true;
+        }
+
+        public String since() {
+            return "3.0.2";
+        }
+
+        public Construct exec(int line_num, File f, Env env, Construct... args) throws CancelCommandException, ConfigRuntimeException {
+            double x = 0;
+            double y = 0;
+            double z = 0;
+            MCWorld w = null;
+            String world = null;
+            if (env.GetPlayer() instanceof MCPlayer) {
+                w = env.GetPlayer().getWorld();
+            }
+            if (args.length == 1 || args.length == 2) {
+                if (args[0] instanceof CArray) {
+                    MCLocation loc = ObjectGenerator.GetGenerator().location(args[0], w, line_num, f);
+                    x = loc.getX();
+                    y = loc.getY();
+                    z = loc.getZ();
+                    world = loc.getWorld().getName();
+                } else {
+                    throw new ConfigRuntimeException("get_block_at expects param 1 to be an array", ExceptionType.CastException, line_num, f);
+                }
+                if (args.length == 2) {
+                    world = args[1].val();
+                }
+            } else if (args.length == 3 || args.length == 4) {
+                x = Static.getDouble(args[0]);
+                y = Static.getDouble(args[1]);
+                z = Static.getDouble(args[2]);
+                if (args.length == 4) {
+                    world = args[3].val();
+                }
+            }
+            if (world != null) {
+                w = Static.getServer().getWorld(world);
+            }
+            if (w == null) {
+                throw new ConfigRuntimeException("The specified world " + world + " doesn't exist", ExceptionType.InvalidWorldException, line_num, f);
+            }
+            x = java.lang.Math.floor(x);
+            y = java.lang.Math.floor(y);
+            z = java.lang.Math.floor(z);
+            MCBlock b = w.getBlockAt((int) x, (int) y, (int) z);
+            return new CString(b.getTypeId() + ":" + b.getData(), line_num, f);
+        }
+
+        public Boolean runAsync() {
+            return false;
+        }
+    }
+
+    @api
+    public static class set_block_at implements Function {
+
+        public String getName() {
+            return "set_block_at";
+        }
+
+        public Integer[] numArgs() {
+            return new Integer[]{2, 3, 4, 5};
+        }
+
+        public String docs() {
+            return "void {x, y, z, id, [world] | xyzArray, id, [world]} Sets the id of the block at the x y z coordinates specified. If the"
+                    + " first argument passed is an array, it should be x y z coordinates. id must"
+                    + " be a blocktype identifier similar to the type returned from get_block_at, except if the meta"
+                    + " value is not specified, 0 is used. If world isn't specified, the current player's world"
+                    + " is used.";
+        }
+
+        public ExceptionType[] thrown() {
+            return new ExceptionType[]{ExceptionType.CastException, ExceptionType.LengthException, ExceptionType.FormatException, ExceptionType.InvalidWorldException};
+        }
+
+        public boolean isRestricted() {
+            return true;
+        }
+
+        public void varList(IVariableList varList) {
+        }
+
+        public boolean preResolveVariables() {
+            return true;
+        }
+
+        public String since() {
+            return "3.0.2";
+        }
+
+        public Construct exec(int line_num, File f, Env env, Construct... args) throws CancelCommandException, ConfigRuntimeException {
+            double x = 0;
+            double y = 0;
+            double z = 0;
+            String id = null;
+            String world = null;
+            MCWorld w = null;
+            if (env.GetPlayer() instanceof MCPlayer) {
+                w = env.GetPlayer().getWorld();
+            }
+            if ((args.length == 2 || args.length == 3) && args[0] instanceof CArray) {
+                MCLocation l = ObjectGenerator.GetGenerator().location(args[0], env.GetPlayer().getWorld(), line_num, f);
+                x = l.getBlockX();
+                y = l.getBlockY();
+                z = l.getBlockZ();
+                world = l.getWorld().getName();
+                id = args[1].val();
+                if (args.length == 3) {
+                    world = args[2].val();
+                }
+
+            } else {
+                x = Static.getNumber(args[0]);
+                y = Static.getNumber(args[1]);
+                z = Static.getNumber(args[2]);
+                id = args[3].val();
+                if (args.length == 5) {
+                    world = args[4].val();
+                }
+            }
+            if (world != null) {
+                w = Static.getServer().getWorld(world);
+            }
+            if (w == null) {
+                throw new ConfigRuntimeException("The specified world " + world + " doesn't exist", ExceptionType.InvalidWorldException, line_num, f);
+            }
+            x = java.lang.Math.floor(x);
+            y = java.lang.Math.floor(y);
+            z = java.lang.Math.floor(z);
+            int ix = (int) x;
+            int iy = (int) y;
+            int iz = (int) z;
+            System.out.println("Setting block at " + ix + "," + iy + "," + iz);
+            MCBlock b = w.getBlockAt(ix, iy, iz);
+            StringBuilder data = new StringBuilder();
+            StringBuilder meta = new StringBuilder();
+            boolean inMeta = false;
+            for (int i = 0; i < id.length(); i++) {
+                Character c = id.charAt(i);
+                if (!inMeta) {
+                    if (!Character.isDigit(c) && c != ':') {
+                        throw new ConfigRuntimeException("id must be formatted as such: 'x:y' where x and y are integers", ExceptionType.FormatException,
+                                line_num, f);
+                    }
+                    if (c == ':') {
+                        inMeta = true;
+                        continue;
+                    }
+                    data.append(c);
+                } else {
+                    meta.append(c);
+                }
+            }
+            if (meta.length() == 0) {
+                meta.append("0");
+            }
+
+            int idata = Integer.parseInt(data.toString());
+            byte imeta = Byte.parseByte(meta.toString());
+            b.setTypeId(idata);
+            b.setData(imeta);
+
+            return new CVoid(line_num, f);
+        }
+
+        public Boolean runAsync() {
+            return false;
+        }
+    }
+
+    @api
+    public static class set_sign_text implements Function {
+
+        public String getName() {
+            return "set_sign_text";
+        }
+
+        public Integer[] numArgs() {
+            return new Integer[]{2, 3, 4, 5};
+        }
+
+        public String docs() {
+            return "void {xyzLocation, lineArray | xyzLocation, line1, [line2, [line3, [line4]]]}"
+                    + " Sets the text of the sign at the given location. If the block at x,y,z isn't a sign,"
+                    + " a RangeException is thrown. If the text on a line overflows 15 characters, it is simply"
+                    + " truncated.";
+        }
+
+        public ExceptionType[] thrown() {
+            return new ExceptionType[]{ExceptionType.RangeException, ExceptionType.FormatException};
+        }
+
+        public boolean isRestricted() {
+            return true;
+        }
+
+        public boolean preResolveVariables() {
+            return true;
+        }
+
+        public String since() {
+            return "3.3.0";
+        }
+
+        public Boolean runAsync() {
+            return false;
+        }
+
+        public Construct exec(int line_num, File f, Env environment, Construct... args) throws ConfigRuntimeException {
+            MCLocation l = ObjectGenerator.GetGenerator().location(args[0], environment.GetPlayer() == null ? null : environment.GetPlayer().getWorld(), line_num, f);
+            if (l.getBlock().isSign()) {
+                String line1 = "";
+                String line2 = "";
+                String line3 = "";
+                String line4 = "";
+                if (args.length == 2 && args[1] instanceof CArray) {
+                    CArray ca = (CArray) args[1];
+                    if (ca.size() >= 1) {
+                        line1 = ca.get(0, line_num, f).val();
+                    }
+                    if (ca.size() >= 2) {
+                        line2 = ca.get(1, line_num, f).val();
+                    }
+                    if (ca.size() >= 3) {
+                        line3 = ca.get(2, line_num, f).val();
+                    }
+                    if (ca.size() >= 4) {
+                        line4 = ca.get(3, line_num, f).val();
+                    }
+
+                } else {
+                    if (args.length >= 2) {
+                        line1 = args[1].val();
+                    }
+                    if (args.length >= 3) {
+                        line2 = args[2].val();
+                    }
+                    if (args.length >= 4) {
+                        line3 = args[3].val();
+                    }
+                    if (args.length >= 5) {
+                        line4 = args[4].val();
+                    }
+                }               
+                MCSign s = l.getBlock().getSign();
+                s.setLine(0, line1);
+                s.setLine(1, line2);
+                s.setLine(2, line3);
+                s.setLine(3, line4);
+                return new CVoid(line_num, f);
+            } else {
+                throw new ConfigRuntimeException("The block at the specified location is not a sign", ExceptionType.RangeException, line_num, f);
+            }
+        }
+    }
+
+    @api
+    public static class get_sign_text implements Function {
+
+        public String getName() {
+            return "get_sign_text";
+        }
+
+        public Integer[] numArgs() {
+            return new Integer[]{1};
+        }
+
+        public String docs() {
+            return "array {xyzLocation} Given a location array, returns an array of 4 strings of the text in the sign at that"
+                    + " location. If the location given isn't a sign, then a RangeException is thrown.";
+        }
+
+        public ExceptionType[] thrown() {
+            return new ExceptionType[]{ExceptionType.RangeException, ExceptionType.FormatException};
+        }
+
+        public boolean isRestricted() {
+            return true;
+        }
+
+        public boolean preResolveVariables() {
+            return true;
+        }
+
+        public String since() {
+            return "3.3.0";
+        }
+
+        public Boolean runAsync() {
+            return false;
+        }
+
+        public Construct exec(int line_num, File f, Env environment, Construct... args) throws ConfigRuntimeException {
+            MCLocation l = ObjectGenerator.GetGenerator().location(args[0], environment.GetPlayer() == null ? null : environment.GetPlayer().getWorld(), line_num, f);
+            if (l.getBlock().isSign()) {
+                MCSign s = l.getBlock().getSign();
+                CString line1 = new CString(s.getLine(0), line_num, f);
+                CString line2 = new CString(s.getLine(1), line_num, f);
+                CString line3 = new CString(s.getLine(2), line_num, f);
+                CString line4 = new CString(s.getLine(3), line_num, f);
+                return new CArray(line_num, f, line1, line2, line3, line4);
+            } else {
+                throw new ConfigRuntimeException("The block at the specified location is not a sign", ExceptionType.RangeException, line_num, f);
+            }
+        }
+    }
+
+    @api
+    public static class is_sign_at implements Function {
+
+        public String getName() {
+            return "is_sign_at";
+        }
+
+        public Integer[] numArgs() {
+            return new Integer[]{1};
+        }
+
+        public String docs() {
+            return "boolean {xyzLocation} Returns true if the block at this location is a sign.";
+        }
+
+        public ExceptionType[] thrown() {
+            return new ExceptionType[]{ExceptionType.FormatException};
+        }
+
+        public boolean isRestricted() {
+            return true;
+        }
+
+        public boolean preResolveVariables() {
+            return true;
+        }
+
+        public String since() {
+            return "3.3.0";
+        }
+
+        public Boolean runAsync() {
+            return false;
+        }
+
+        public Construct exec(int line_num, File f, Env environment, Construct... args) throws ConfigRuntimeException {
+            MCLocation l = ObjectGenerator.GetGenerator().location(args[0], environment.GetPlayer() == null ? null : environment.GetPlayer().getWorld(), line_num, f);
+            return new CBoolean(l.getBlock().isSign(), line_num, f);
+        }
+    }
+
+    @api
+    public static class break_block implements Function {
+
+        public String getName() {
+            return "break_block";
+        }
+
+        public Integer[] numArgs() {
+            return new Integer[]{1};
+        }
+
+        public String docs() {
+            return "void {locationObject} Mostly simulates a block break at a location. (Does not trigger an event)";
+        }
+
+        public ExceptionType[] thrown() {
+            return new ExceptionType[]{ExceptionType.FormatException};
+        }
+
+        public boolean isRestricted() {
+            return true;
+        }
+
+        public boolean preResolveVariables() {
+            return true;
+        }
+
+        public String since() {
+            return "3.3.0";
+        }
+
+        public Boolean runAsync() {
+            return false;
+        }
+
+        public Construct exec(int line_num, File f, Env environment, Construct... args) throws ConfigRuntimeException {
+            MCLocation l;
+            MCPlayer p;
+            p = environment.GetPlayer();
+            MCWorld w = (p != null ? p.getWorld() : null);
+            l = ObjectGenerator.GetGenerator().location(args[0], w, line_num, f);
+            if (l.getWorld() instanceof CraftWorld) {
+                CraftWorld cw = (CraftWorld) l.getWorld();
+                net.minecraft.server.Block.byId[l.getBlock().getTypeId()].dropNaturally(cw.getHandle(), l.getBlockX(), l.getBlockY(), l.getBlockZ(), l.getBlock().getData(), 1.0f, 0);
+            }
+            l.getBlock().setTypeId(0);
+            CraftServer cs = (CraftServer)((BukkitMCServer)Static.getServer()).__Server();
+            cs.getHandle().a(new Packet0KeepAlive(), 0);
+            return new CVoid(line_num, f);
+            
+        }
+    }
+}
diff --git a/src/main/java/com/laytonsmith/core/functions/EventBinding.java b/src/main/java/com/laytonsmith/core/functions/EventBinding.java
new file mode 100644
index 0000000..ceb08aa
--- /dev/null
+++ b/src/main/java/com/laytonsmith/core/functions/EventBinding.java
@@ -0,0 +1,704 @@
+/*
+ * To change this template, choose Tools | Templates
+ * and open the template in the editor.
+ */
+package com.laytonsmith.core.functions;
+
+import com.laytonsmith.core.Env;
+import com.laytonsmith.core.GenericTreeNode;
+import com.laytonsmith.core.Static;
+import com.laytonsmith.core.api;
+import com.laytonsmith.core.constructs.*;
+import com.laytonsmith.core.events.BoundEvent;
+import com.laytonsmith.core.events.BoundEvent.ActiveEvent;
+import com.laytonsmith.core.events.BoundEvent.Priority;
+import com.laytonsmith.core.events.Event;
+import com.laytonsmith.core.events.EventUtils;
+import com.laytonsmith.core.exceptions.ConfigRuntimeException;
+import com.laytonsmith.core.exceptions.EventException;
+import com.laytonsmith.core.functions.Exceptions.ExceptionType;
+import java.io.File;
+import java.util.ArrayList;
+import java.util.List;
+
+/**
+ *
+ * @author Layton
+ */
+public class EventBinding {
+    public static String docs(){
+        return "This class of functions provide methods to hook deep into the server's event architecture";
+    }
+    
+    @api public static class bind implements Function{
+
+        public String getName() {
+            return "bind";
+        }
+
+        public Integer[] numArgs() {
+            return new Integer[]{Integer.MAX_VALUE};
+        }
+
+        public String docs() {
+            return "string {event_name, options, prefilter, event_obj, [custom_params], &lt;code&gt;} Binds some functionality to an event, so that"
+                    + " when said event occurs, the event handler will fire. Returns the id of this event, so it can be unregistered"
+                    + " later, if need be.";
+        }
+
+        public ExceptionType[] thrown() {
+            return new ExceptionType[]{ExceptionType.BindException};
+        }
+
+        public boolean isRestricted() {
+            return true;
+        }
+
+        public void varList(IVariableList varList) {}
+
+        public boolean preResolveVariables() {
+            return false;
+        }
+
+        public String since() {
+            return "3.3.0";
+        }
+
+        public Boolean runAsync() {
+            return false;
+        }
+
+        public Construct exec(int line_num, File f, Env env, Construct... args) throws ConfigRuntimeException {
+            return new CVoid(line_num, f);
+        }
+        
+        public Construct execs(Construct name, Construct options, Construct prefilter, 
+                Construct event_obj, GenericTreeNode<Construct> tree, Env env, int line_num, File f){
+            //Check to see if our arguments are correct
+            if(!(options instanceof CNull || options instanceof CArray)){
+                throw new ConfigRuntimeException("The options must be an array or null", ExceptionType.CastException, line_num, f);
+            }
+            if(!(prefilter instanceof CNull || prefilter instanceof CArray)){
+                throw new ConfigRuntimeException("The prefilters must be an array or null", ExceptionType.CastException, line_num, f);                
+            }
+            if(!(event_obj instanceof IVariable)){                
+                throw new ConfigRuntimeException("The event object must be an IVariable", ExceptionType.CastException, line_num, f);                
+            }
+            CString id;
+            if(options instanceof CNull){
+                options = null;
+            }
+            if(prefilter instanceof CNull){
+                prefilter = null;
+            }
+            try {
+                BoundEvent be = new BoundEvent(name.val(), (CArray)options, (CArray)prefilter, 
+                        ((IVariable)event_obj).getName(), env, tree, line_num, f);
+                EventUtils.RegisterEvent(be);
+                id = new CString(be.getId(), line_num, f);
+            } catch (EventException ex) {
+                throw new ConfigRuntimeException(ex.getMessage(), ExceptionType.BindException, line_num, f);
+            }
+            
+            return id;
+        }
+        
+    }
+    
+    @api public static class dump_events implements Function{
+
+        public String getName() {
+            return "dump_events";
+        }
+
+        public Integer[] numArgs() {
+            return new Integer[]{0};
+        }
+
+        public String docs() {
+            return "array {} Returns an array of all the events currently registered on the server. Mostly meant for debugging,"
+                    + " however it would be possible to parse this response to cherry pick events to unregister.";
+        }
+
+        public ExceptionType[] thrown() {
+            return new ExceptionType[]{};
+        }
+
+        public boolean isRestricted() {
+            return true;
+        }
+
+        public void varList(IVariableList varList) {}
+
+        public boolean preResolveVariables() {
+            return true;
+        }
+
+        public String since() {
+            return "3.3.0";
+        }
+
+        public Boolean runAsync() {
+            return null;
+        }
+
+        public Construct exec(int line_num, File f, Env env, Construct... args) throws ConfigRuntimeException {
+            return EventUtils.DumpEvents();
+        }
+        
+    }
+    
+    @api public static class unbind implements Function{
+
+        public String getName() {
+            return "unbind";
+        }
+
+        public Integer[] numArgs() {
+            return new Integer[]{0, 1};
+        }
+
+        public String docs() {
+            return "void {[eventID]} Unbinds an event, which causes it to not run anymore. If called from within an event handler, eventID is"
+                    + " optional, and defaults to the current event id.";
+        }
+
+        public ExceptionType[] thrown() {
+            return new ExceptionType[]{ExceptionType.BindException};
+        }
+
+        public boolean isRestricted() {
+            return true;
+        }
+
+        public boolean preResolveVariables() {
+            return true;
+        }
+
+        public String since() {
+            return "3.3.0";
+        }
+
+        public Boolean runAsync() {
+            return null;
+        }
+
+        public Construct exec(int line_num, File f, Env environment, Construct... args) throws ConfigRuntimeException {
+            String id = null;
+            if(args.length == 1){
+                //We are cancelling an arbitrary event
+                id = args[0].val();
+            } else {
+                //We are cancelling this event. If we are not in an event, throw an exception
+                if(environment.GetEvent() == null){
+                    throw new ConfigRuntimeException("No event ID specified, and not running inside an event", ExceptionType.BindException, line_num, f);
+                }
+                id = environment.GetEvent().getBoundEvent().getId();
+            }
+            EventUtils.UnregisterEvent(id);
+            return new CVoid(line_num, f);
+        }
+        
+    }
+    
+    @api public static class cancel implements Function{
+
+        public String getName() {
+            return "cancel";
+        }
+
+        public Integer[] numArgs() {
+            return new Integer[]{0, 1};
+        }
+
+        public String docs() {
+            return "void {[state]} Cancels the event (if applicable). If the event is not cancellable, or is already cancelled, nothing happens."
+                    + " If called from outside an event handler, a BindException is thrown. By default, state is true, but you can"
+                    + " uncancel an event (if possible) by calling cancel(false)";
+        }
+
+        public ExceptionType[] thrown() {
+            return new ExceptionType[]{ExceptionType.BindException};
+        }
+
+        public boolean isRestricted() {
+            return true;
+        }
+
+        public boolean preResolveVariables() {
+            return true;
+        }
+
+        public String since() {
+            return "3.3.0";
+        }
+
+        public Boolean runAsync() {
+            return null;
+        }
+
+        public Construct exec(int line_num, File f, Env environment, Construct... args) throws ConfigRuntimeException {
+            BoundEvent.ActiveEvent original = environment.GetEvent();
+            if(original == null){
+                throw new ConfigRuntimeException("cancel cannot be called outside an event handler", ExceptionType.BindException, line_num, f);
+            }
+            if(original.getUnderlyingEvent() != null && original.isCancellable()){
+                if(args.length == 1){
+                    original.setCancelled(Static.getBoolean(args[0]));
+                } else {
+                    original.setCancelled(true);
+                }
+            }
+            environment.GetEvent().setCancelled(true);
+            return new CVoid(line_num, f);
+        }
+        
+    }
+    
+    @api public static class is_cancelled implements Function{
+
+        public String getName() {
+            return "is_cancelled";
+        }
+
+        public Integer[] numArgs() {
+            return new Integer[]{0};
+        }
+
+        public String docs() {
+            return "boolean {} Returns whether or not the underlying event is cancelled or not. If the event is not cancellable in the first place,"
+                    + " false is returned. If called from outside an event, a BindException is thrown";
+        }
+
+        public ExceptionType[] thrown() {
+            return new ExceptionType[]{ExceptionType.BindException};
+        }
+
+        public boolean isRestricted() {
+            return true;
+        }
+
+        public boolean preResolveVariables() {
+            return true;
+        }
+
+        public String since() {
+            return "3.3.0";
+        }
+
+        public Boolean runAsync() {
+            return false;
+        }
+
+        public Construct exec(int line_num, File f, Env environment, Construct... args) throws ConfigRuntimeException {
+            BoundEvent.ActiveEvent original = environment.GetEvent();
+            if(original == null){
+                throw new ConfigRuntimeException("is_cancelled cannot be called outside an event handler", ExceptionType.BindException, line_num, f);
+            }
+            boolean result = false;
+            if(original.getUnderlyingEvent() != null && original.isCancellable()){
+                result = original.isCancelled();
+            }
+            return new CBoolean(result, line_num, f);
+        }
+        
+    }
+    
+    @api public static class trigger implements Function{
+
+        public String getName() {
+            return "trigger";
+        }
+
+        public Integer[] numArgs() {
+            return new Integer[]{2, 3};
+        }
+
+        public String docs() {
+            return "void {eventName, eventObject, [serverWide]} Manually triggers bound events. The event object passed to this function is "
+                    + " sent directly as-is to the bound events. Check the documentation for each event to see what is required."
+                    + " No checks will be done on the data here, but it is not recommended to fail to send all parameters required."
+                    + " If serverWide is true, the event is triggered directly in the server, unless it is a CommandHelper specific"
+                    + " event, in which case, serverWide is irrelevant. Defaults to false, which means that only CommandHelper code"
+                    + " will receive the event.";
+        }
+
+        public ExceptionType[] thrown() {
+            return new ExceptionType[]{ExceptionType.CastException};
+        }
+
+        public boolean isRestricted() {
+            return true;
+        }
+
+        public boolean preResolveVariables() {
+            return true;
+        }
+
+        public String since() {
+            return "3.3.0";
+        }
+
+        public Boolean runAsync() {
+            return false;
+        }
+
+        public Construct exec(int line_num, File f, Env environment, Construct... args) throws ConfigRuntimeException {
+            CArray obj = null;
+            if(args[1] instanceof CNull){
+                obj = new CArray(line_num, f);
+            } else if(args[1] instanceof CArray){
+                obj = (CArray)args[1];
+            } else {
+                throw new ConfigRuntimeException("The eventObject must be null, or an array", ExceptionType.CastException, line_num, f);
+            }
+            boolean serverWide = false;
+            if(args.length == 3){
+                serverWide = Static.getBoolean(args[2]);
+            }
+            EventUtils.ManualTrigger(args[0].val(), obj, serverWide);
+            return new CVoid(line_num, f);
+        }
+        
+    }
+    
+    @api public static class modify_event implements Function{
+
+        public String getName() {
+            return "modify_event";
+        }
+
+        public Integer[] numArgs() {
+            return new Integer[]{2};
+        }
+
+        public String docs() {
+            return "boolean {parameter, value, [throwOnFailure]} Modifies the underlying event object, if applicable."
+                    + " The documentation for each event will explain what parameters can be modified,"
+                    + " and what their expected values are. If an invalid parameter name is passed in,"
+                    + " nothing will happen. If this function is called from outside an event"
+                    + " handler, a BindException is thrown. Note that modifying the underlying event"
+                    + " will NOT update the event object passed in to the event handler. The function returns"
+                    + " whether or not the parameter was updated successfully. It could fail to modify the"
+                    + " event if a higher priority handler has locked this parameter, or if updating the underlying"
+                    + " event failed. If throwOnFailure is true, instead of returning false, it will throw"
+                    + " a BindException. The default for throwOnFailure is false. If a monitor level handler"
+                    + " even attempts to modify an event, an exception will be thrown.";
+        }
+
+        public ExceptionType[] thrown() {
+            return new ExceptionType[]{ExceptionType.CastException, ExceptionType.BindException};
+        }
+
+        public boolean isRestricted() {
+            return true;
+        }
+
+        public boolean preResolveVariables() {
+            return true;
+        }
+
+        public String since() {
+            return "3.3.0";
+        }
+
+        public Boolean runAsync() {
+            return false;
+        }
+
+        public Construct exec(int line_num, File f, Env environment, Construct... args) throws ConfigRuntimeException {
+            String parameter = args[0].val();
+            Construct value = args[1];
+            boolean throwOnFailure = false;
+            if(args.length == 3){
+                throwOnFailure = Static.getBoolean(args[3]);
+            }
+            if(environment.GetEvent() == null){
+                throw new ConfigRuntimeException(this.getName() + " must be called from within an event handler", ExceptionType.BindException, line_num, f);
+            }
+            Event e = environment.GetEvent().getEventDriver();
+            if(environment.GetEvent().getBoundEvent().getPriority().equals(Priority.MONITOR)){
+                throw new ConfigRuntimeException("Monitor level handlers may not modify an event!", ExceptionType.BindException, line_num, f);
+            }
+            ActiveEvent active = environment.GetEvent();
+            boolean success = false;
+            if(!active.isLocked(parameter)){
+                try{
+                    success = e.modifyEvent(parameter, value, environment.GetEvent().getUnderlyingEvent());
+                } catch(ConfigRuntimeException ex){
+                    ex.setFile(f);
+                    ex.setLineNum(line_num);
+                    throw ex;
+                }
+            } else {
+                success = false;
+            }
+            if(throwOnFailure && !success){
+                throw new ConfigRuntimeException("Event parameter is already locked!", ExceptionType.BindException, line_num, f);
+            }
+            return new CBoolean(success, line_num, f);
+        }
+        
+    }
+    
+    @api public static class lock implements Function{
+
+        public String getName() {
+            return "lock";
+        }
+
+        public Integer[] numArgs() {
+            return new Integer[]{Integer.MAX_VALUE};
+        }
+
+        public String docs() {
+            return "void {<none> | parameterArray | parameter, [parameter...]} Locks the specified event parameter(s), or all of them,"
+                    + " if specified with no arguments. Locked parameters become read only for lower priority event handlers.";
+        }
+
+        public ExceptionType[] thrown() {
+            return new ExceptionType[]{ExceptionType.BindException};
+        }
+
+        public boolean isRestricted() {
+            return true;
+        }
+
+        public boolean preResolveVariables() {
+            return true;
+        }
+
+        public Boolean runAsync() {
+            return false;
+        }
+
+        public Construct exec(int line_num, File f, Env environment, Construct... args) throws ConfigRuntimeException {
+            if(environment.GetEvent() == null){
+                throw new ConfigRuntimeException("lock must be called from within an event handler", ExceptionType.BindException, line_num, f);
+            }
+            
+            BoundEvent.ActiveEvent e = environment.GetEvent();
+            Priority p = e.getBoundEvent().getPriority();
+            List<String> params = new ArrayList<String>();
+            if(args.length == 0){
+                e.lock(null);
+            } else {                
+                if(args[0] instanceof CArray){
+                    CArray ca = (CArray)args[1];
+                    for(int i = 0; i < ca.size(); i++){
+                        params.add(ca.get(i, line_num, f).val());
+                    }
+                } else {
+                    for(int i = 0; i < args.length; i++){
+                        params.add(args[i].val());
+                    }
+                }
+            }
+            for(String param : params){
+                e.lock(param);
+            }
+            return new CVoid(line_num, f);
+        }
+
+        public String since() {
+            return "3.3.0";
+        }
+        
+    }
+    
+    @api public static class is_locked implements Function{
+
+        public String getName() {
+            return "is_locked";
+        }
+
+        public Integer[] numArgs() {
+            return new Integer[]{1};
+        }
+
+        public String docs() {
+            return "boolean {parameter} Returns whether or not a call to modify_event() would fail, based on"
+                    + " the parameter being locked by a higher priority handler. If this returns false, it"
+                    + " is still not a guarantee that the event would be successfully modified, just that"
+                    + " it isn't locked.";
+        }
+
+        public ExceptionType[] thrown() {
+            return new ExceptionType[]{ExceptionType.BindException};
+        }
+
+        public boolean isRestricted() {
+            return true;
+        }
+
+        public boolean preResolveVariables() {
+            return true;
+        }
+
+        public Boolean runAsync() {
+            return false;
+        }
+
+        public Construct exec(int line_num, File f, Env environment, Construct... args) throws ConfigRuntimeException {
+            if(environment.GetEvent() == null){
+                throw new ConfigRuntimeException("is_locked may only be called from inside an event handler", ExceptionType.BindException, line_num, f);
+            }
+            boolean locked = environment.GetEvent().isLocked(args[0].val());
+            return new CBoolean(locked, line_num, f);
+        }
+
+        public String since() {
+            return "3.3.0";
+        }
+        
+    }
+    
+    @api public static class consume implements Function{
+
+        public String getName() {
+            return "consume";
+        }
+
+        public Integer[] numArgs() {
+            return new Integer[]{0};
+        }
+
+        public String docs() {
+            return "void {} Consumes an event, so that lower priority handlers don't even"
+                    + " recieve the event. Monitor level handlers will still recieve it, however,"
+                    + " and they can check to see if the event was consumed.";
+        }
+
+        public ExceptionType[] thrown() {
+            return new ExceptionType[]{ExceptionType.BindException};
+        }
+
+        public boolean isRestricted() {
+            return true;
+        }
+
+        public boolean preResolveVariables() {
+            return true;
+        }
+
+        public Boolean runAsync() {
+            return false;
+        }
+
+        public Construct exec(int line_num, File f, Env environment, Construct... args) throws ConfigRuntimeException {
+            if(environment.GetEvent() == null){
+                throw new ConfigRuntimeException("consume may only be called from an event handler!", ExceptionType.BindException, line_num, f);
+            }
+            environment.GetEvent().consume();
+            return new CVoid(line_num, f);
+        }
+
+        public String since() {
+            return "3.3.0";
+        }
+        
+    }
+    
+    @api public static class is_consumed implements Function{
+
+        public String getName() {
+            return "is_consumed";
+        }
+
+        public Integer[] numArgs() {
+            return new Integer[]{0};
+        }
+
+        public String docs() {
+            return "boolean {} Returns whether or not this event has been consumed. Usually only useful"
+                    + " for Monitor level handlers, it could also be used for highly robust code,"
+                    + " as an equal priority handler could have consumed the event, but this handler"
+                    + " would still recieve it.";
+        }
+
+        public ExceptionType[] thrown() {
+            return new ExceptionType[]{ExceptionType.BindException};
+        }
+
+        public boolean isRestricted() {
+            return true;
+        }
+
+        public boolean preResolveVariables() {
+            return true;
+        }
+
+        public Boolean runAsync() {
+            return false;
+        }
+
+        public Construct exec(int line_num, File f, Env environment, Construct... args) throws ConfigRuntimeException {
+            if(environment.GetEvent() == null){
+                throw new ConfigRuntimeException("is_consumed must be called from within an event handler", ExceptionType.BindException, line_num, f);
+            }
+            return new CBoolean(environment.GetEvent().isConsumed(), line_num, f);
+        }
+
+        public String since() {
+            return "3.3.0";
+        }
+        
+    }
+  
+//    @api public static class when_triggered implements Function{
+//        
+//    }
+    
+//    @api public static class when_cancelled implements Function{
+//        
+//    }
+    
+    @api public static class event_meta implements Function{
+
+        public String getName() {
+            return "event_meta";
+        }
+
+        public Integer[] numArgs() {
+            return new Integer[]{0};
+        }
+
+        public String docs() {
+            return "array {} Returns meta information about the activity in regards to this event. This"
+                    + " is meant as a debug tool.";
+        }
+
+        public ExceptionType[] thrown() {
+            return new ExceptionType[]{ExceptionType.BindException};
+        }
+
+        public boolean isRestricted() {
+            return true;
+        }
+
+        public boolean preResolveVariables() {
+            return true;
+        }
+
+        public Boolean runAsync() {
+            return false;
+        }
+
+        public Construct exec(int line_num, File f, Env environment, Construct... args) throws ConfigRuntimeException {
+            if(environment.GetEvent() == null){
+                throw new ConfigRuntimeException("event_meta must be called from within an event handler!", ExceptionType.BindException, line_num, f);
+            }
+            CArray history = new CArray(line_num, f);
+            for(String entry : environment.GetEvent().getHistory()){
+                history.push(new CString(entry, line_num, f));
+            }
+            return history;
+        }
+
+        public String since() {
+            return "3.3.0";
+        }
+        
+    }
+    
+}
diff --git a/src/main/java/com/laytonsmith/core/functions/Exceptions.java b/src/main/java/com/laytonsmith/core/functions/Exceptions.java
new file mode 100644
index 0000000..854cd32
--- /dev/null
+++ b/src/main/java/com/laytonsmith/core/functions/Exceptions.java
@@ -0,0 +1,262 @@
+/*
+ * To change this template, choose Tools | Templates
+ * and open the template in the editor.
+ */
+package com.laytonsmith.core.functions;
+
+import com.laytonsmith.core.*;
+import com.laytonsmith.core.constructs.*;
+import com.laytonsmith.core.exceptions.CancelCommandException;
+import com.laytonsmith.core.exceptions.ConfigRuntimeException;
+import java.io.File;
+import java.util.ArrayList;
+import java.util.List;
+
+/**
+ *
+ * @author Layton
+ */
+public class Exceptions {
+    public static String docs(){
+        return "This class contains functions related to Exception handling in MScript";
+    }
+    public enum ExceptionType{
+        /**
+         * This exception is thrown if a value cannot be cast into an appropriate type. Functions that require
+         * a numeric value, for instance, would throw this if the string "hi" were passed in.
+         */
+        CastException,
+        /**
+         * This exception is thrown if a value is requested from an array that is above the highest index of the array,
+         * or a negative number.
+         */
+        IndexOverflowException,
+        /**
+         * This exception is thrown if a function expected a numeric value to be in a particular range, and it wasn't
+         */
+        RangeException,
+        /**
+         * This exception is thrown if a function expected the length of something to be a particular value, but it was not.
+         */
+        LengthException,
+        /**
+         * This exception is thrown if the user running the command does not have permission to run the function
+         */
+        InsufficientPermissionException,
+        /**
+         * This exception is thrown if a function expected an online player, but that player was offline, or the
+         * command is being run from somewhere not in game, and the function was trying to use the current player.
+         */
+        PlayerOfflineException, 
+        /**
+         * Some var arg functions may require at least a certain number of arguments to be passed to the function
+         */
+        InsufficientArgumentsException, 
+        /**
+         * This exception is thrown if a function expected a string to be formatted in a particular way, but it could not interpret the 
+         * given value.
+         */
+        FormatException,
+        /**
+         * This exception is thrown if a procedure is used without being defined, or if a procedure name does not follow proper naming
+         * conventions.
+         */
+        InvalidProcedureException, 
+        /**
+         * This exception is thrown if there is a problem with an include. This is thrown if there is
+         * a compile error in the included script.
+         */
+        IncludeException,
+        /**
+         * This exception is thrown if a script tries to read or write to a location of the filesystem that is not allowed.
+         */
+        SecurityException, 
+        /**
+         * This exception is thrown if a file cannot be read or written to.
+         */
+        IOException, 
+        /**
+         * This exception is thrown if a function uses an external plugin, and that plugin is not loaded, 
+         * or otherwise unusable.
+         */
+        InvalidPluginException,
+        /**
+         * This exception is thrown when a plugin is loaded, but a call to the plugin failed, usually
+         * for some reason specific to the plugin. Check the error message for more details about this
+         * error.
+         */
+        PluginInternalException,
+        /**
+         * If a function requests a world, and the world given doesn't exist, this is thrown
+         */
+        InvalidWorldException,
+        /**
+         * This exception is thrown if an error occurs when trying to bind() an event, or if a event framework
+         * related error occurs.
+         */
+        BindException,
+        /**
+         * If an enchantment is added to an item that isn't supported, this is thrown.
+         */
+        EnchantmentException,
+        /**
+         * If an untameable mob is attempted to be tamed, this exception is thrown
+         */
+        UntameableMobException,
+    }
+    @api public static class _try implements Function{      
+        
+        public String getName() {
+            
+            return "try";
+        }
+
+        public Integer[] numArgs() {
+            return new Integer[]{3,4};
+        }
+
+        public String docs() {
+            return "void {tryCode, varName, catchCode, [exceptionTypes]} This function works similar to a try-catch block in most languages. If the code in"
+                    + " tryCode throws an exception, instead of killing the whole script, it stops running, and begins running the catchCode."
+                    + " var should be an ivariable, and it is set to an array containing the following information about the exception:"
+                    + " 0 - The class of the exception; 1 - The message generated by the exception; 2 - The file the exception was generated from; 3 - The line the exception"
+                    + " occured on. If exceptionTypes is provided, it should be an array of exception types, or a single string that this try function is interested in."
+                    + " If the exception type matches one of the values listed, the exception will be caught, otherwise, the exception will continue up the stack."
+                    + " If exceptionTypes is missing, it will catch all exceptions."
+                    + " PLEASE NOTE! This function will not catch exceptions thrown by CommandHelper, only built in exceptions. "
+                    + " Please see the wiki for more information about what possible exceptions can be thrown and where.";
+        }
+        
+        public ExceptionType[] thrown(){
+            return new ExceptionType[]{ExceptionType.CastException, ExceptionType.FormatException};
+        }
+
+        public boolean isRestricted() {
+            return false;
+        }
+
+        public boolean preResolveVariables() {
+            return false;
+        }
+
+        public String since() {
+            return "3.1.2";
+        }
+
+        public Boolean runAsync() {
+            return null;
+        }
+        public Construct execs(int line_num, File f, Env env, Script that, GenericTreeNode<Construct> tryCode,
+                GenericTreeNode<Construct> varName, GenericTreeNode<Construct> catchCode, GenericTreeNode<Construct> types) throws CancelCommandException{
+            Construct pivar = that.eval(varName, env);
+            IVariable ivar;
+            if(pivar instanceof IVariable){
+                ivar = (IVariable)pivar;
+            } else {
+                throw new ConfigRuntimeException("Expected argument 2 to be an IVariable", ExceptionType.CastException, line_num, f);
+            }
+            List<String> interest = new ArrayList<String>();
+            if(types != null){
+            Construct ptypes = that.eval(types, env);
+                if(ptypes instanceof CString){
+                    interest.add(ptypes.val());
+                } else if(ptypes instanceof CArray){
+                    CArray ca = (CArray)ptypes;
+                    for(int i = 0; i < ca.size(); i++){
+                        interest.add(ca.get(i, line_num, f).val());
+                    }
+                } else {
+                    throw new ConfigRuntimeException("Expected argument 4 to be a string, or an array of strings.", 
+                            ExceptionType.CastException, line_num, f);
+                }
+            }
+            
+            for(String in : interest){
+                try{
+                    ExceptionType.valueOf(in);
+                } catch(IllegalArgumentException e){
+                    throw new ConfigRuntimeException("Invalid exception type passed to try():" + in, 
+                            ExceptionType.FormatException, line_num, f);
+                }
+            }
+            
+            try{
+                that.eval(tryCode, env);
+            } catch (ConfigRuntimeException e){
+                if((Boolean)Static.getPreferences().getPreference("debug-mode")){
+                    System.out.println("[CommandHelper]: Exception thrown -> " + e.getMessage() + " :: " + e.getExceptionType() + ":" + e.getFile() + ":" + e.getLineNum());
+                }
+                if(e.getExceptionType() != null  && (interest.isEmpty() || interest.contains(e.getExceptionType().toString()))){
+                    CArray ex = new CArray(line_num, f);
+                    ex.push(new CString(e.getExceptionType().toString(), line_num, f));
+                    ex.push(new CString(e.getMessage(), line_num, f));
+                    ex.push(new CString((e.getFile()!=null?e.getFile().getAbsolutePath():"null"), line_num, f));
+                    ex.push(new CInt(e.getLineNum(), line_num, f));
+                    ivar.setIval(ex);
+                    env.GetVarList().set(ivar);
+                    that.eval(catchCode, env);
+                } else {
+                    throw e;
+                }
+            }
+            
+            
+            return new CVoid(line_num, f);
+        }
+        public Construct exec(int line_num, File f, Env env, Construct... args) throws CancelCommandException, ConfigRuntimeException {
+            throw new UnsupportedOperationException("Not supported yet.");
+        }
+        
+    }
+    
+    @api public static class _throw implements Function{
+
+        public String getName() {
+            return "throw";
+        }
+
+        public Integer[] numArgs() {
+            return new Integer[]{2};
+        }
+
+        public String docs() {
+            return "nothing {exceptionType, msg} This function causes an exception to be thrown. If the exception type is null,"
+                    + " it will be uncatchable. Otherwise, exceptionType may be any valid exception type.";
+        }
+        
+        public ExceptionType[] thrown(){
+            return new ExceptionType[]{ExceptionType.FormatException};
+        }
+
+        public boolean isRestricted() {
+            return false;
+        }
+
+        public void varList(IVariableList varList) {}
+
+        public boolean preResolveVariables() {
+            return true;
+        }
+
+        public String since() {
+            return "3.1.2";
+        }
+
+        public Boolean runAsync() {
+            return null;
+        }
+
+        public Construct exec(int line_num, File f, Env env, Construct... args) throws CancelCommandException, ConfigRuntimeException {
+            try{
+                ExceptionType c = null;
+                if(!(args[0] instanceof CNull)){
+                    c = ExceptionType.valueOf(args[0].val());
+                }
+                throw new ConfigRuntimeException(args[1].val(), c, line_num, f);
+            } catch(IllegalArgumentException e){
+                throw new ConfigRuntimeException("Expected a valid exception type", ExceptionType.FormatException, line_num, f);
+            }
+        }
+        
+    }
+}
diff --git a/src/main/java/com/laytonsmith/core/functions/Function.java b/src/main/java/com/laytonsmith/core/functions/Function.java
new file mode 100644
index 0000000..482b9cd
--- /dev/null
+++ b/src/main/java/com/laytonsmith/core/functions/Function.java
@@ -0,0 +1,110 @@
+/*
+ * To change this template, choose Tools | Templates
+ * and open the template in the editor.
+ */
+package com.laytonsmith.core.functions;
+
+import com.laytonsmith.core.Documentation;
+import com.laytonsmith.core.Env;
+import com.laytonsmith.core.constructs.Construct;
+import com.laytonsmith.core.exceptions.CancelCommandException;
+import com.laytonsmith.core.exceptions.ConfigRuntimeException;
+import com.laytonsmith.core.functions.Exceptions.ExceptionType;
+import java.io.File;
+
+/**
+ * Note that to "activate" this class as a function, you must prefix the '@api' annotation
+ * to it.
+ * @author layton
+ */
+public interface Function extends Documentation {
+
+    /**
+     * The name of this function, exactly as should be used in a script. Note that the name of
+     * the function must match the regex:
+     * <pre>
+     * [a-zA-Z_][a-zA-Z_0-9]*
+     * </pre>
+     * In other words, it must start with a letter or underscore, and may have any number of
+     * letters, numbers, or underscores after it.
+     * @return 
+     */
+    public String getName();
+
+    /**
+     * The number of arguments this function can accept. Some functions may be able to accept multiple numbers
+     * of arguments, so this function returns an array. If you return Integer.MAX_VALUE as one of the
+     * items in the array, then any number of arguments may be sent.
+     * @return 
+     */
+    public Integer[] numArgs();
+
+    /**
+     * If a user asks for information about a particular function, this method is called to obtain the functions
+     * usage. The returned string must follow the following format:
+     * @return A string with the documentation, or null, which will give a standard message to the user telling them there
+     * is no documentation for this function yet.
+     */
+    public String docs();
+
+    /**
+     * Returns the types of catchable exceptions this function can throw. (Uncatchable exceptions need not be listed)
+     * @return An array of the exception enums, or null, if the function throws no catchable exceptions.
+     */
+    public ExceptionType[] thrown();
+
+    /**
+     * Whether or not a function needs to be checked against the permissions file, if there are possible security concerns
+     * with a user compiling, or running this function. If this function returns true, the permissions file will be checked for
+     * commandhelper.func.compile.&lt;function name&gt; upon compilation, and commandhelper.func.use.&lt;function name&gt; upon
+     * usage in game. Note that the config script is never barred from compiling any function.
+     * @return 
+     */
+    public boolean isRestricted();
+
+    /**
+     * Most functions don't care that a construct is a variable, they simply care about the value stored in the variable.
+     * If the function is concerned with the variable listing however, then it has direct access to the variable list for
+     * this command.
+     * @param varList 
+     */
+    //public void varList(IVariableList varList);
+    /**
+     * If a function doesn't want to have to deal with a variable as a variable, but instead wants to recieve it as
+     * an atomic, resolved value, the function can return true from this function. This will signal the interpreter
+     * to go ahead and resolve the variable into one of the atomic Constructs. If it returns false, it is possible
+     * the exec function will receive an IVariable Construct.
+     * @return 
+     */
+    public boolean preResolveVariables();
+
+    /**
+     * Whether or not to run this function asynchronously from the main server thread. If you 
+     * return true, you may NOT have any interaction with the bukkit api, other than
+     * bukkit thread safe methods. Returning true WILL run this function in the CH thread, returning
+     * false WILL run this function in the main server thread, and returning null will run this
+     * function in whatever context the script is currently running in.
+     * @return 
+     */
+    public Boolean runAsync();
+
+    /**
+     * This function is invoked when the alias is run. The line number is provided so that if there is an error,
+     * the function can provide a more specific error message for the user. The function can throw a CancelCommandException
+     * which indicates that the command was purposefully canceled. If the command was canceled due to a fatal error
+     * in the syntax of the user input or some similar situation, it is better to throw a ConfigRuntimeException instead.
+     * Throwing either Exception will prevent the command from completing, however functions that had been run earlier will
+     * may have already completed successfully, so there is no guarantee of atomicity. All parameters sent to the
+     * function have already been resolved into an atomic value though, so functions do not have to worry about
+     * resolving parameters. There is an explicit check made before calling exec to ensure that Construct ... args
+     * will only be one of the following:
+     * CBoolean, CDouble, CInt, CNull, CString, CVoid, or IVariable. If you care, you'll need to do further checks
+     * on the datatype to verify what the type actually is.
+     * @param line_num The line that this function call is being run from
+     * @param f The file that this function call is being run from
+     * @param args An array of evaluated Constructs
+     * @return
+     * @throws CancelCommandException 
+     */
+    public Construct exec(int line_num, File f, Env environment, Construct... args) throws ConfigRuntimeException;
+}
diff --git a/src/main/java/com/laytonsmith/core/functions/FunctionList.java b/src/main/java/com/laytonsmith/core/functions/FunctionList.java
new file mode 100644
index 0000000..13cb99d
--- /dev/null
+++ b/src/main/java/com/laytonsmith/core/functions/FunctionList.java
@@ -0,0 +1,178 @@
+/*
+ * To change this template, choose Tools | Templates
+ * and open the template in the editor.
+ */
+package com.laytonsmith.core.functions;
+
+import com.laytonsmith.PureUtilities.ClassDiscovery;
+import com.laytonsmith.core.api;
+import com.laytonsmith.core.constructs.CFunction;
+import com.laytonsmith.core.constructs.Construct;
+import com.laytonsmith.core.exceptions.ConfigCompileException;
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+import java.util.logging.Level;
+import java.util.logging.Logger;
+
+/**
+ *
+ * @author layton
+ */
+public class FunctionList {
+
+    private static Map<String, Function> functions = new HashMap<String, Function>();
+    static {
+        //Initialize all our functions as soon as we start up
+        initFunctions();
+    }
+
+    private static void initFunctions() {
+        //Register internal classes first, so they can't be overridden
+        Class[] classes = ClassDiscovery.GetClassesWithAnnotation(api.class);
+        for(Class c : classes){
+            String apiClass = (c.getEnclosingClass() != null
+                    ? c.getEnclosingClass().getName().split("\\.")[c.getEnclosingClass().getName().split("\\.").length - 1]
+                    : "<global>");
+            if (Function.class.isAssignableFrom(c)) {
+                try {
+                    Function f = (Function) c.newInstance();
+                    registerFunction(f, apiClass);
+                    //System.out.println("Loaded " + apiClass + "." + f.getName());
+                } catch (InstantiationException ex) {
+                    Logger.getLogger(FunctionList.class.getName()).log(Level.SEVERE, null, ex);
+                } catch (IllegalAccessException ex) {
+                    Logger.getLogger(FunctionList.class.getName()).log(Level.SEVERE, null, ex);
+                } catch(Throwable t){
+                    if(t.getCause() != null){
+                        System.err.println("Something when wrong while trying to load up " + c.getSimpleName() + ":");
+                        t.getCause().printStackTrace();
+                    } else {
+                        t.printStackTrace();
+                    }
+                }
+            } else {
+                System.out.println("@api functions must implement " + FunctionList.class.getPackage().getName() + ".Function! " + c.getSimpleName() + " cannot be loaded.");
+            }
+        }
+//        for (int i = 0; i < classes.length; i++) {
+//            Annotation[] a = classes[i].getAnnotations();
+//            for (int j = 0; j < a.length; j++) {
+//                Annotation ann = a[j];
+//                if (ann.annotationType().equals(api.class)) {
+//                    Class api = classes[i];
+//                    String apiClass = (api.getEnclosingClass() != null
+//                            ? api.getEnclosingClass().getName().split("\\.")[api.getEnclosingClass().getName().split("\\.").length - 1]
+//                            : "<global>");
+//                    if (Function.class.isAssignableFrom(api)) {
+//                        try {
+//                            Function f = (Function) api.newInstance();
+//                            registerFunction(f, apiClass);
+//                            //System.out.println("Loaded " + apiClass + "." + f.getName());
+//                        } catch (InstantiationException ex) {
+//                            Logger.getLogger(FunctionList.class.getName()).log(Level.SEVERE, null, ex);
+//                        } catch (IllegalAccessException ex) {
+//                            Logger.getLogger(FunctionList.class.getName()).log(Level.SEVERE, null, ex);
+//                        }
+//                    } else {
+//                        System.out.println("@api functions must implement " + FunctionList.class.getPackage().getName() + ".Function! " + api.getSimpleName() + " cannot be loaded.");
+//                    }
+//                }
+//            }
+//        }
+        
+        if((Boolean)com.laytonsmith.core.Static.getPreferences().getPreference("debug-mode")){
+            System.out.println("CommandHelper: Loaded " + functions.size() + " function" + (functions.size()==1?"":"s"));
+        }
+        
+        
+
+        //Now pull all the jars from plugins/CommandHelper/functions
+        //TODO Finishing this has been defered until a later date
+        //        File f = new File("plugins/CommandHelper/functions");
+        //        f.mkdirs();
+        //        PluginLoader.loadJars(f.getAbsolutePath());
+        //        for(File file : f.listFiles()){
+        //            try {
+        //                Yaml yaml = new Yaml(new SafeConstructor());
+        //                JarFile jar = new JarFile(file);
+        //                JarEntry entry = jar.getJarEntry("main.yml");
+        //                if (entry == null) {
+        //                    throw new InvalidPluginException(new FileNotFoundException("Jar does not contain main.yml"));
+        //                }
+        //                InputStream stream = jar.getInputStream(entry);
+        //                Map<String, Object> map = (Map<String, Object>)yaml.load(stream);
+        //                System.out.println(map);
+        //                stream.close();
+        //                jar.close();
+        //            } catch(InvalidPluginException ex){
+        //                Logger.getLogger(FunctionList.class.getName()).log(Level.SEVERE, null, ex);
+        //            } catch (IOException ex) {
+        //                Logger.getLogger(FunctionList.class.getName()).log(Level.SEVERE, null, ex);
+        //        }
+        //        }
+
+    }
+
+    
+    public static void registerFunction(Function f, String apiClass) {
+        if(!apiClass.equals("Sandbox")){
+            if((Boolean)com.laytonsmith.core.Static.getPreferences().getPreference("debug-mode")){
+                System.out.println("CommandHelper: Loaded function \"" + f.getName() + "\"");
+            }
+        }
+        try{
+            functions.put(f.getName(), f);
+        } catch(UnsupportedOperationException e){
+            //This function isn't done yet, and during production this is a serious problem,
+            //but it will be caught when we test all the functions, so for now just ignore it,
+            //since this function is called during initial initialization
+        }
+    }
+
+    public static Function getFunction(Construct c) throws ConfigCompileException {
+        if (c instanceof CFunction) {
+            if(!functions.containsKey(c.val())){
+                throw new ConfigCompileException("The function \"" + c.val() + "\" does not exist");
+            } else {
+                return functions.get(c.val());
+            }              
+        }
+        throw new ConfigCompileException("Excpecting CFunction type");
+    }
+
+//    public FunctionList(User u) {
+//        this.u = u;
+//        if (functions.isEmpty()) {
+//            initFunctions();
+//        }
+//    }
+
+//    public Construct exec(String name, int line_num, Player p, Construct... args) throws ConfigCompileException, CancelCommandException {
+//        for (Function f : functions) {
+//            if (f.getName().equals(name)) {
+//                return f.exec(line_num, p, args);
+//            }
+//        }
+//        throw new ConfigCompileException("Function " + name + " is not defined");
+//    }
+//
+//    public Integer[] numArgs(String name) throws ConfigCompileException {
+//        for (Function f : functions) {
+//            if (f.getName().equals(name)) {
+//                return f.numArgs();
+//            }
+//        }
+//        throw new ConfigCompileException("Function " + name + " is not defined");
+//    }
+
+    public static List<Function> getFunctionList() {
+        List<Function> f = new ArrayList<Function>();
+        for(String name : functions.keySet()){
+            f.add(functions.get(name));
+        }
+        return f;
+    }
+    
+}
diff --git a/src/main/java/com/laytonsmith/core/functions/IVariableList.java b/src/main/java/com/laytonsmith/core/functions/IVariableList.java
new file mode 100644
index 0000000..0dfe254
--- /dev/null
+++ b/src/main/java/com/laytonsmith/core/functions/IVariableList.java
@@ -0,0 +1,55 @@
+/*
+ * To change this template, choose Tools | Templates
+ * and open the template in the editor.
+ */
+package com.laytonsmith.core.functions;
+
+import com.laytonsmith.core.constructs.IVariable;
+import java.util.HashMap;
+import java.util.Map;
+
+/**
+ *
+ * @author Layton
+ */
+public class IVariableList {
+    Map<String, IVariable> varList = new HashMap<String, IVariable>();
+    
+    public void set(IVariable v){
+        varList.put(v.getName(), v);
+    }
+    
+    public IVariable get(String name){
+        if(!varList.containsKey(name)){
+            this.set(new IVariable(name, 0, null));
+        }
+        return varList.get(name);
+    }
+
+    @Override
+    public String toString() {
+        StringBuilder b = new StringBuilder();
+        b.append("[");
+        boolean first = true;
+        for(Map.Entry<String, IVariable> entry : varList.entrySet()){
+            IVariable iv = entry.getValue();
+            if(first){
+                first = false;
+            } else {
+                b.append(", ");
+            }
+            b.append(iv.getName()).append(":").append("(").append(iv.ival().getClass().getSimpleName()).append(")").append(iv.ival().val());
+        }
+        b.append("]");
+        return b.toString();
+    }
+    
+    @Override
+    public IVariableList clone(){
+        IVariableList clone = new IVariableList();
+        clone.varList = new HashMap<String, IVariable>(varList);
+        return clone;
+    }
+    
+    
+}
diff --git a/src/main/java/com/laytonsmith/core/functions/IncludeCache.java b/src/main/java/com/laytonsmith/core/functions/IncludeCache.java
new file mode 100644
index 0000000..3e79720
--- /dev/null
+++ b/src/main/java/com/laytonsmith/core/functions/IncludeCache.java
@@ -0,0 +1,56 @@
+/*
+ * To change this template, choose Tools | Templates
+ * and open the template in the editor.
+ */
+package com.laytonsmith.core.functions;
+
+import com.laytonsmith.PureUtilities.fileutility.FileUtility;
+import com.laytonsmith.core.GenericTreeNode;
+import com.laytonsmith.core.MScriptCompiler;
+import com.laytonsmith.core.Static;
+import com.laytonsmith.core.constructs.Construct;
+import com.laytonsmith.core.exceptions.ConfigCompileException;
+import com.laytonsmith.core.exceptions.ConfigRuntimeException;
+import java.io.File;
+import java.io.FileNotFoundException;
+import java.util.HashMap;
+
+/**
+ *
+ * @author Layton
+ */
+public class IncludeCache {
+    private static HashMap<File, GenericTreeNode<Construct>> cache = new HashMap<File, GenericTreeNode<Construct>>();
+    
+    public static void add(File file, GenericTreeNode<Construct> tree){
+        cache.put(file, tree);
+    }
+    
+    public static GenericTreeNode<Construct> get(File file, int line_num, File myFile){
+        if(!cache.containsKey(file)){
+            //We have to pull the file from the FS, and compile it.
+            if(Static.CheckSecurity(file.getAbsolutePath())){
+                try {
+                    String s = FileUtility.read(file);
+                    GenericTreeNode<Construct> tree = MScriptCompiler.compile(MScriptCompiler.lex("g(\n" + s + "\n)", file));
+                    IncludeCache.add(file, tree);
+                } catch (ConfigCompileException ex) {
+                    throw new ConfigRuntimeException("There was a compile error when trying to include the script at " + file
+                            + "\n" + ex.getMessage() + " :: " + file.getName() + ":" + ex.getLineNum(), 
+                            Exceptions.ExceptionType.IncludeException, line_num, myFile);
+                } catch (FileNotFoundException ex) {
+                    throw new ConfigRuntimeException("The script at " + file + " could not be found.", 
+                            Exceptions.ExceptionType.IOException, line_num, myFile);
+                }
+            } else {
+                throw new ConfigRuntimeException("The script cannot access " + file + " due to restrictions imposed by the base-dir setting.", 
+                        Exceptions.ExceptionType.SecurityException, line_num, myFile);
+            }
+        }
+        return cache.get(file);
+    }
+    
+    public static void clearCache(){
+        cache.clear();
+    }
+}
diff --git a/src/main/java/com/laytonsmith/core/functions/Math.java b/src/main/java/com/laytonsmith/core/functions/Math.java
new file mode 100644
index 0000000..237cece
--- /dev/null
+++ b/src/main/java/com/laytonsmith/core/functions/Math.java
@@ -0,0 +1,1305 @@
+/*
+ * To change this template, choose Tools | Templates
+ * and open the template in the editor.
+ */
+package com.laytonsmith.core.functions;
+
+import com.laytonsmith.core.Env;
+import com.laytonsmith.core.Static;
+import com.laytonsmith.core.api;
+import com.laytonsmith.core.constructs.*;
+import com.laytonsmith.core.exceptions.CancelCommandException;
+import com.laytonsmith.core.exceptions.ConfigRuntimeException;
+import com.laytonsmith.core.functions.Exceptions.ExceptionType;
+import com.sk89q.worldedit.expression.Expression;
+import com.sk89q.worldedit.expression.ExpressionException;
+import java.io.File;
+import java.util.ArrayList;
+import java.util.List;
+import java.util.Random;
+
+/**
+ *
+ * @author Layton
+ */
+public class Math {
+    public static String docs(){
+        return "Provides mathematical functions to scripts";
+    }
+    @api public static class add implements Function{
+
+        public String getName() {
+            return "add";
+        }
+
+        public Integer[] numArgs() {
+            return new Integer[]{Integer.MAX_VALUE};
+        }
+
+        public Construct exec(int line_num, File f, Env env, Construct... args) throws CancelCommandException, ConfigRuntimeException {
+            double tally = Static.getNumber(args[0]);
+            for(int i = 1; i < args.length; i++){
+                tally += Static.getNumber(args[i]);
+            }
+            if(Static.anyDoubles(args)){
+                return new CDouble(tally, line_num, f);
+            } else {
+                return new CInt((long)tally, line_num, f);
+            }
+        }
+        
+        public ExceptionType[] thrown(){
+            return new ExceptionType[]{ExceptionType.CastException};
+        }
+
+        public String docs() {
+            return "mixed {var1, [var2...]} Adds all the arguments together, and returns either a double or an integer";
+        }
+
+        public boolean isRestricted() {
+            return false;
+        }
+
+        public boolean preResolveVariables() {
+            return true;
+        }
+        public String since() {
+            return "3.0.1";
+        }
+        public Boolean runAsync(){
+            return null;
+        }
+    }
+    
+    @api public static class subtract implements Function{
+
+        public String getName() {
+            return "subtract";
+        }
+
+        public Integer[] numArgs() {
+            return new Integer[]{Integer.MAX_VALUE};
+        }
+
+        public Construct exec(int line_num, File f, Env env, Construct... args) throws CancelCommandException, ConfigRuntimeException {
+            double tally = Static.getNumber(args[0]);
+            for(int i = 1; i < args.length; i++){
+                tally -= Static.getNumber(args[i]);
+            }
+            if(Static.anyDoubles(args)){
+                return new CDouble(tally, line_num, f);
+            } else {
+                return new CInt((long)tally, line_num, f);
+            }
+        }
+        
+        public ExceptionType[] thrown(){
+            return new ExceptionType[]{ExceptionType.CastException};
+        }
+
+        public String docs() {
+            return "mixed {var1, [var2...]} Subtracts the arguments from left to right, and returns either a double or an integer";
+        }
+
+        public boolean isRestricted() {
+            return false;
+        }
+
+        public void varList(IVariableList varList) {}
+
+        public boolean preResolveVariables() {
+            return true;
+        }
+        public String since() {
+            return "3.0.1";
+        }
+        public Boolean runAsync(){
+            return null;
+        }
+    }
+    
+    @api public static class multiply implements Function{
+
+        public String getName() {
+            return "multiply";
+        }
+
+        public Integer[] numArgs() {
+            return new Integer[]{Integer.MAX_VALUE};
+        }
+
+        public Construct exec(int line_num, File f, Env env, Construct... args) throws CancelCommandException, ConfigRuntimeException {
+            double tally = Static.getNumber(args[0]);
+            for(int i = 1; i < args.length; i++){
+                tally *= Static.getNumber(args[i]);
+            }
+            if(Static.anyDoubles(args)){
+                return new CDouble(tally, line_num, f);
+            } else {
+                return new CInt((long)tally, line_num, f);
+            }
+        }
+        
+        public ExceptionType[] thrown(){
+            return new ExceptionType[]{ExceptionType.CastException};
+        }
+
+        public String docs() {
+            return "mixed {var1, [var2...]} Multiplies the arguments together, and returns either a double or an integer";
+        }
+
+        public boolean isRestricted() {
+            return false;
+        }
+
+        public void varList(IVariableList varList) {}
+
+        public boolean preResolveVariables() {
+            return true;
+        }
+        public String since() {
+            return "3.0.1";
+        }
+        public Boolean runAsync(){
+            return null;
+        }
+    }
+    
+    @api public static class divide implements Function{
+
+        public String getName() {
+            return "divide";
+        }
+
+        public Integer[] numArgs() {
+            return new Integer[]{Integer.MAX_VALUE};
+        }
+
+        public Construct exec(int line_num, File f, Env env, Construct... args) throws CancelCommandException, ConfigRuntimeException {
+            double tally = Static.getNumber(args[0]);
+            for(int i = 1; i < args.length; i++){
+                tally /= Static.getNumber(args[i]);
+            }
+            if(tally == (int)tally){
+                return new CInt((long)tally, line_num, f);
+            } else {
+                return new CDouble(tally, line_num, f);
+            }
+        }
+        
+        public ExceptionType[] thrown(){
+            return new ExceptionType[]{ExceptionType.CastException};
+        }
+
+        public String docs() {
+            return "mixed {var1, [var2...]} Divides the arguments from left to right, and returns either a double or an integer";
+        }
+
+        public boolean isRestricted() {
+            return false;
+        }
+
+        public void varList(IVariableList varList) {}
+
+        public boolean preResolveVariables() {
+            return true;
+        }
+        public String since() {
+            return "3.0.1";
+        }
+        public Boolean runAsync(){
+            return null;
+        }
+    }
+    
+    @api public static class mod implements Function{
+
+        public String getName() {
+            return "mod";
+        }
+
+        public Integer[] numArgs() {
+            return new Integer[]{2};
+        }
+
+        public Construct exec(int line_num, File f, Env env, Construct... args) throws CancelCommandException, ConfigRuntimeException {
+            long arg1 = Static.getInt(args[0]);
+            long arg2 = Static.getInt(args[1]);
+            return new CInt(arg1 % arg2, line_num, f);
+        }
+        
+        public ExceptionType[] thrown(){
+            return new ExceptionType[]{ExceptionType.CastException};
+        }
+
+        public String docs() {
+            return "int {x, n} Returns x modulo n";
+        }
+
+        public boolean isRestricted() {
+            return false;
+        }
+
+        public void varList(IVariableList varList) {}
+
+        public boolean preResolveVariables() {
+            return true;
+        }
+        public String since() {
+            return "3.0.1";
+        }
+        public Boolean runAsync(){
+            return null;
+        }
+    }
+    
+    @api public static class pow implements Function{
+
+        public String getName() {
+            return "pow";
+        }
+
+        public Integer[] numArgs() {
+            return new Integer[]{2};
+        }
+
+        public Construct exec(int line_num, File f, Env env, Construct... args) throws CancelCommandException, ConfigRuntimeException {
+            double arg1 = Static.getNumber(args[0]);
+            double arg2 = Static.getNumber(args[1]);
+            return new CDouble(java.lang.Math.pow(arg1, arg2), line_num, f);
+        }
+
+        public String docs() {
+            return "double {x, n} Returns x to the power of n";
+        }
+        
+        public ExceptionType[] thrown(){
+            return new ExceptionType[]{ExceptionType.CastException};
+        }
+
+        public boolean isRestricted() {
+            return false;
+        }
+
+        public void varList(IVariableList varList) {}
+
+        public boolean preResolveVariables() {
+            return true;
+        }
+        public String since() {
+            return "3.0.1";
+        }
+        public Boolean runAsync(){
+            return null;
+        }
+    }
+    
+    @api public static class inc implements Function{
+        
+        public String getName() {
+            return "inc";
+        }
+
+        public Integer[] numArgs() {
+            return new Integer[]{1, 2};
+        }
+
+        public Construct exec(int line_num, File f, Env env, Construct... args) throws CancelCommandException, ConfigRuntimeException {
+            if(args[0] instanceof IVariable){
+                IVariable v = env.GetVarList().get(((IVariable)args[0]).getName());
+                Construct newVal;
+                long value = 1;
+                if(args.length == 2){
+                    if(args[1] instanceof IVariable){
+                        args[1] = env.GetVarList().get(((IVariable)args[1]).getName());
+                    }
+                    value = Static.getInt(args[1]);
+                }
+                if(Static.anyDoubles(v.ival())){
+                    newVal = new CDouble(Static.getDouble(v.ival()) + value, line_num, f);
+                } else {
+                    newVal = new CInt(Static.getInt(v.ival()) + value, line_num, f);
+                }
+                v = new IVariable(v.getName(), newVal, line_num, f);
+                env.GetVarList().set(v);
+                return v;
+            }
+            throw new ConfigRuntimeException("inc expects argument 1 to be an ivar", 
+                    ExceptionType.CastException, line_num, f);
+        }
+
+        public String docs() {
+            return "ivar {var} Adds 1 to var, and stores the new value. Equivalent to ++var in other languages. Expects ivar to be a variable, then"
+                    + " returns the ivar.";
+        }
+        
+        public ExceptionType[] thrown(){
+            return new ExceptionType[]{ExceptionType.CastException};
+        }
+
+        public boolean isRestricted() {
+            return false;
+        }
+
+        public boolean preResolveVariables() {
+            return false;
+        }
+        public String since() {
+            return "3.0.1";
+        }
+        public Boolean runAsync(){
+            return null;
+        }
+    }
+    
+    @api public static class dec implements Function{
+        
+        public String getName() {
+            return "dec";
+        }
+
+        public Integer[] numArgs() {
+            return new Integer[]{1, 2};
+        }
+
+        public Construct exec(int line_num, File f, Env env, Construct... args) throws CancelCommandException, ConfigRuntimeException {
+            if(args[0] instanceof IVariable){
+                IVariable v = env.GetVarList().get(((IVariable)args[0]).getName());
+                long value = 1;
+                if(args.length == 2){
+                    if(args[1] instanceof IVariable){
+                        args[1] = env.GetVarList().get(((IVariable)args[1]).getName());
+                    }
+                    value = Static.getInt(args[1]);
+                }
+                Construct newVal;
+                if(Static.anyDoubles(v.ival())){
+                    newVal = new CDouble(Static.getDouble(v.ival()) - value, line_num, f);
+                } else {
+                    newVal = new CInt(Static.getInt(v.ival()) - value, line_num, f);
+                }
+                v = new IVariable(v.getName(), newVal, line_num, f);
+                env.GetVarList().set(v);
+                return v;
+            }
+            throw new ConfigRuntimeException("dec expects argument 1 to be an ivar", 
+                    ExceptionType.CastException, line_num, f);
+        }
+
+        public String docs() {
+            return "ivar {var, [value]} Subtracts value from var, and stores the new value. Value defaults to 1. Equivalent to --var (or var -= value) in other languages. Expects ivar to be a variable, then"
+                    + " returns the ivar.";
+        }
+        
+        public ExceptionType[] thrown(){
+            return new ExceptionType[]{ExceptionType.CastException};
+        }
+
+        public boolean isRestricted() {
+            return false;
+        }
+
+        public boolean preResolveVariables() {
+            return false;
+        }
+        public String since() {
+            return "3.0.1";
+        }
+        public Boolean runAsync(){
+            return null;
+        }
+    }
+    
+    @api public static class rand implements Function{
+        
+        Random r = new Random();
+
+        public String getName() {
+            return "rand";
+        }
+
+        public Integer[] numArgs() {
+            return new Integer[]{1, 2};
+        }
+
+        public String docs() {
+            return "int {min/max, [max]} Returns a random number from 0 to max, or min to max, depending on usage. Max is exclusive. Min must"
+                    + " be less than max, and both numbers must be >= 0";
+        }
+        
+        public ExceptionType[] thrown(){
+            return new ExceptionType[]{ExceptionType.RangeException, ExceptionType.CastException};
+        }
+
+        public boolean isRestricted() {
+            return false;
+        }
+
+        public void varList(IVariableList varList) {}
+
+        public boolean preResolveVariables() {
+            return true;
+        }
+
+        public String since() {
+            return "3.0.1";
+        }
+
+        public Construct exec(int line_num, File f, Env env, Construct... args) throws CancelCommandException, ConfigRuntimeException {
+            long min = 0;
+            long max = 0;
+            if(args.length == 1){
+                max = Static.getInt(args[0]);
+            } else {
+                min = Static.getInt(args[0]);
+                max = Static.getInt(args[1]);
+            }
+            if(max > Integer.MAX_VALUE || min > Integer.MAX_VALUE){
+                throw new ConfigRuntimeException("max and min must be below int max, defined as " + Integer.MAX_VALUE, 
+                        ExceptionType.RangeException,
+                        line_num, f);
+            }
+           
+            long range = max - min;
+            if(range <= 0){
+                throw new ConfigRuntimeException("max - min must be greater than 0", 
+                        ExceptionType.RangeException, line_num, f);
+            }
+            long rand = java.lang.Math.abs(r.nextLong());
+            long i = (rand % (range)) + min;
+
+            return new CInt(i, line_num, f);
+        }
+        public Boolean runAsync(){
+            return null;
+        }
+    }
+    
+    @api
+    public static class abs implements Function{
+
+        public String getName() {
+            return "abs";
+        }
+
+        public Integer[] numArgs() {
+            return new Integer[]{1};
+        }
+
+        public String docs() {
+            return "double {arg} Returns the absolute value of the argument.";
+        }
+
+        public ExceptionType[] thrown() {
+            return new ExceptionType[]{ExceptionType.CastException};
+        }
+
+        public boolean isRestricted() {
+            return false;
+        }
+
+        public void varList(IVariableList varList) {}
+
+        public boolean preResolveVariables() {
+            return true;
+        }
+
+        public String since() {
+            return "3.1.2";
+        }
+
+        public Boolean runAsync() {
+            return null;
+        }
+
+        public Construct exec(int line_num, File f, Env env, Construct... args) throws ConfigRuntimeException {
+            double d = Static.getDouble(args[0]);
+            return new CDouble(java.lang.Math.abs(d), line_num, f);
+        }
+        
+    }
+    
+    @api public static class floor implements Function{
+
+        public String getName() {
+            return "floor";
+        }
+
+        public Integer[] numArgs() {
+            return new Integer[]{1};
+        }
+
+        public String docs() {
+            return "int {number} Returns the floor of any given number. For example, floor(3.8) returns 3, and floor(-1.1) returns 2";
+        }
+
+        public ExceptionType[] thrown() {
+            return new ExceptionType[]{ExceptionType.CastException};
+        }
+
+        public boolean isRestricted() {
+            return false;
+        }
+
+        public void varList(IVariableList varList) {}
+
+        public boolean preResolveVariables() {
+            return true;
+        }
+
+        public String since() {
+            return "3.1.3";
+        }
+
+        public Boolean runAsync() {
+            return null;
+        }
+
+        public Construct exec(int line_num, File f, Env env, Construct... args) throws ConfigRuntimeException {
+            return new CInt((long)java.lang.Math.floor(Static.getNumber(args[0])), line_num, f);
+        }
+        
+    }
+    
+    @api public static class ceil implements Function{
+
+        public String getName() {
+            return "ceil";
+        }
+
+        public Integer[] numArgs() {
+            return new Integer[]{1};
+        }
+
+        public String docs() {
+            return "int {number} Returns the ceiling of any given number. For example, ceil(3.2) returns 4, and ceil(-1.1) returns -1";
+        }
+
+        public ExceptionType[] thrown() {
+            return new ExceptionType[]{ExceptionType.CastException};
+        }
+
+        public boolean isRestricted() {
+            return false;
+        }
+
+        public void varList(IVariableList varList) {}
+
+        public boolean preResolveVariables() {
+            return true;
+        }
+
+        public String since() {
+            return "3.1.3";
+        }
+
+        public Boolean runAsync() {
+            return null;
+        }
+
+        public Construct exec(int line_num, File f, Env env, Construct... args) throws ConfigRuntimeException {
+            return new CInt((long)java.lang.Math.ceil(Static.getNumber(args[0])), line_num, f);
+        }
+        
+    }
+    
+    @api public static class sqrt implements Function{
+
+        public String getName() {
+            return "sqrt";
+        }
+
+        public Integer[] numArgs() {
+            return new Integer[]{1};
+        }
+
+        public String docs() {
+            return "number {number} Returns the square root of a number. Note that this is mathematically equivalent to pow(number, .5)."
+                    + " Imaginary numbers are not supported at this time, so number must be positive.";
+        }
+
+        public ExceptionType[] thrown() {
+            return new ExceptionType[]{ExceptionType.RangeException, ExceptionType.CastException};
+        }
+
+        public boolean isRestricted() {
+            return false;
+        }
+
+        public void varList(IVariableList varList) {
+            
+        }
+
+        public boolean preResolveVariables() {
+            return true;
+        }
+
+        public String since() {
+            return "3.2.0";
+        }
+
+        public Boolean runAsync() {
+            return null;
+        }
+
+        public Construct exec(int line_num, File f, Env env, Construct... args) throws ConfigRuntimeException {
+            double d = Static.getNumber(args[0]);
+            if(d < 0){
+               throw new ConfigRuntimeException("sqrt expects a number >= 0", ExceptionType.RangeException, line_num, f); 
+            }
+            double m = java.lang.Math.sqrt(d);
+            if(m == (int)m){
+                return new CInt((long) m, line_num, f);
+            } else {
+                return new CDouble(m, line_num, f);
+            }
+        }
+        
+    }
+    
+    @api public static class min implements Function{
+
+        public String getName() {
+            return "min";
+        }
+
+        public Integer[] numArgs() {
+            return new Integer[]{Integer.MAX_VALUE};
+        }
+
+        public String docs() {
+            return "number {num1, [num2...]} Returns the lowest number in a given list of numbers. If any of the arguments"
+                    + " are arrays, they are expanded into individual numbers, and also compared.";
+        }
+
+        public ExceptionType[] thrown() {
+            return new ExceptionType[]{ExceptionType.CastException, ExceptionType.InsufficientArgumentsException};
+        }
+
+        public boolean isRestricted() {
+            return false;
+        }
+
+        public void varList(IVariableList varList) {}
+
+        public boolean preResolveVariables() {
+            return true;
+        }
+
+        public String since() {
+            return "3.2.0";
+        }
+
+        public Boolean runAsync() {
+            return null;
+        }
+
+        public Construct exec(int line_num, File f, Env env, Construct... args) throws ConfigRuntimeException {
+            if(args.length == 0){
+                throw new ConfigRuntimeException("You must send at least one parameter to min", 
+                        ExceptionType.InsufficientArgumentsException, line_num, f);
+            }
+            double lowest = Double.POSITIVE_INFINITY;
+            List<Construct> list = new ArrayList<Construct>();
+            recList(list, args);
+            for(Construct c : list){
+                double d = Static.getNumber(c);
+                if(d < lowest){
+                    lowest = d;
+                }
+            }
+            if(lowest == (long)lowest){
+                return new CInt((long)lowest, line_num, f);
+            } else {
+                return new CDouble(lowest, line_num, f);
+            }
+        }
+        
+        public List<Construct> recList(List<Construct> list, Construct ... args){
+            for(Construct c : args){
+                if(c instanceof CArray){
+                    for(int i = 0; i < ((CArray)c).size(); i++){
+                        recList(list, ((CArray)c).get(i, 0, null));
+                    }
+                } else {
+                    list.add(c);
+                }
+            }
+            return list;
+        }
+        
+    }
+    
+    @api public static class max implements Function{
+
+        public String getName() {
+            return "max";
+        }
+
+        public Integer[] numArgs() {
+            return new Integer[]{Integer.MAX_VALUE};
+        }
+
+        public String docs() {
+            return "number {num1, [num2...]} Returns the highest number in a given list of numbers. If any of the arguments"
+                    + " are arrays, they are expanded into individual numbers, and also compared.";
+        }
+
+        public ExceptionType[] thrown() {
+            return new ExceptionType[]{ExceptionType.CastException, ExceptionType.InsufficientArgumentsException};
+        }
+
+        public boolean isRestricted() {
+            return false;
+        }
+
+        public void varList(IVariableList varList) {}
+
+        public boolean preResolveVariables() {
+            return true;
+        }
+
+        public String since() {
+            return "3.2.0";
+        }
+
+        public Boolean runAsync() {
+            return null;
+        }
+
+        public Construct exec(int line_num, File f, Env env, Construct... args) throws ConfigRuntimeException {
+            if(args.length == 0){
+                throw new ConfigRuntimeException("You must send at least one parameter to max", 
+                        ExceptionType.InsufficientArgumentsException, line_num, f);
+            }
+            double highest = Double.NEGATIVE_INFINITY;
+            List<Construct> list = new ArrayList<Construct>();
+            recList(list, args);
+            for(Construct c : list){
+                double d = Static.getNumber(c);
+                if(d > highest){
+                    highest = d;
+                }
+            }
+            if(highest == (long)highest){
+                return new CInt((long)highest, line_num, f);
+            } else {
+                return new CDouble(highest, line_num, f);
+            }
+        }
+        
+        public List<Construct> recList(List<Construct> list, Construct ... args){
+            for(Construct c : args){
+                if(c instanceof CArray){
+                    for(int i = 0; i < ((CArray)c).size(); i++){
+                        recList(list, ((CArray)c).get(i, 0, null));
+                    }
+                } else {
+                    list.add(c);
+                }
+            }
+            return list;
+        }
+        
+    }
+    
+    @api public static class sin implements Function{
+
+        public String getName() {
+            return "sin";
+        }
+
+        public Integer[] numArgs() {
+            return new Integer[]{1};
+        }
+
+        public String docs() {
+            return "double {number} Returns the sin of the number";
+        }
+
+        public ExceptionType[] thrown() {
+            return new ExceptionType[]{ExceptionType.CastException};
+        }
+
+        public boolean isRestricted() {
+            return false;
+        }
+
+        public void varList(IVariableList varList) {}
+
+        public boolean preResolveVariables() {
+            return true;
+        }
+
+        public String since() {
+            return "3.3.0";
+        }
+
+        public Boolean runAsync() {
+            return null;
+        }
+
+        public Construct exec(int line_num, File f, Env env, Construct... args) throws ConfigRuntimeException {
+            return new CDouble(java.lang.Math.sin(Static.getNumber(args[0])), line_num, f);
+        }
+        
+    }
+    
+    @api public static class cos implements Function{
+
+        public String getName() {
+            return "cos";
+        }
+
+        public Integer[] numArgs() {
+            return new Integer[]{1};
+        }
+
+        public String docs() {
+            return "double {number} Returns the cos of the number";
+        }
+
+        public ExceptionType[] thrown() {
+            return new ExceptionType[]{ExceptionType.CastException};
+        }
+
+        public boolean isRestricted() {
+            return false;
+        }
+
+        public void varList(IVariableList varList) {}
+
+        public boolean preResolveVariables() {
+            return true;
+        }
+
+        public String since() {
+            return "3.3.0";
+        }
+
+        public Boolean runAsync() {
+            return null;
+        }
+
+        public Construct exec(int line_num, File f, Env env, Construct... args) throws ConfigRuntimeException {
+            return new CDouble(java.lang.Math.cos(Static.getNumber(args[0])), line_num, f);
+        }
+        
+    }
+    
+    @api public static class tan implements Function{
+
+        public String getName() {
+            return "tan";
+        }
+
+        public Integer[] numArgs() {
+            return new Integer[]{1};
+        }
+
+        public String docs() {
+            return "double {number} Returns the tan of the number";
+        }
+
+        public ExceptionType[] thrown() {
+            return new ExceptionType[]{ExceptionType.CastException};
+        }
+
+        public boolean isRestricted() {
+            return false;
+        }
+
+        public void varList(IVariableList varList) {}
+
+        public boolean preResolveVariables() {
+            return true;
+        }
+
+        public String since() {
+            return "3.3.0";
+        }
+
+        public Boolean runAsync() {
+            return null;
+        }
+
+        public Construct exec(int line_num, File f, Env env, Construct... args) throws ConfigRuntimeException {
+            return new CDouble(java.lang.Math.tan(Static.getNumber(args[0])), line_num, f);
+        }
+        
+    }
+    
+    @api public static class asin implements Function{
+
+        public String getName() {
+            return "asin";
+        }
+
+        public Integer[] numArgs() {
+            return new Integer[]{1};
+        }
+
+        public String docs() {
+            return "double {number} Returns the arc sin of the number";
+        }
+
+        public ExceptionType[] thrown() {
+            return new ExceptionType[]{ExceptionType.CastException};
+        }
+
+        public boolean isRestricted() {
+            return false;
+        }
+
+        public void varList(IVariableList varList) {}
+
+        public boolean preResolveVariables() {
+            return true;
+        }
+
+        public String since() {
+            return "3.3.0";
+        }
+
+        public Boolean runAsync() {
+            return null;
+        }
+
+        public Construct exec(int line_num, File f, Env env, Construct... args) throws ConfigRuntimeException {
+            return new CDouble(java.lang.Math.asin(Static.getNumber(args[0])), line_num, f);
+        }
+        
+    }
+    
+    @api public static class acos implements Function{
+
+        public String getName() {
+            return "acos";
+        }
+
+        public Integer[] numArgs() {
+            return new Integer[]{1};
+        }
+
+        public String docs() {
+            return "double {number} Returns the arc cos of the number";
+        }
+
+        public ExceptionType[] thrown() {
+            return new ExceptionType[]{ExceptionType.CastException};
+        }
+
+        public boolean isRestricted() {
+            return false;
+        }
+
+        public void varList(IVariableList varList) {}
+
+        public boolean preResolveVariables() {
+            return true;
+        }
+
+        public String since() {
+            return "3.3.0";
+        }
+
+        public Boolean runAsync() {
+            return null;
+        }
+
+        public Construct exec(int line_num, File f, Env env, Construct... args) throws ConfigRuntimeException {
+            return new CDouble(java.lang.Math.acos(Static.getNumber(args[0])), line_num, f);
+        }
+        
+    }
+    
+    @api public static class atan implements Function{
+
+        public String getName() {
+            return "atan";
+        }
+
+        public Integer[] numArgs() {
+            return new Integer[]{1};
+        }
+
+        public String docs() {
+            return "double {number} Returns the arc tan of the number";
+        }
+
+        public ExceptionType[] thrown() {
+            return new ExceptionType[]{ExceptionType.CastException};
+        }
+
+        public boolean isRestricted() {
+            return false;
+        }
+
+        public void varList(IVariableList varList) {}
+
+        public boolean preResolveVariables() {
+            return true;
+        }
+
+        public String since() {
+            return "3.3.0";
+        }
+
+        public Boolean runAsync() {
+            return null;
+        }
+
+        public Construct exec(int line_num, File f, Env env, Construct... args) throws ConfigRuntimeException {
+            return new CDouble(java.lang.Math.atan(Static.getNumber(args[0])), line_num, f);
+        }
+        
+    }
+    
+    @api public static class to_radians implements Function{
+
+        public String getName() {
+            return "to_radians";
+        }
+
+        public Integer[] numArgs() {
+            return new Integer[]{1};
+        }
+
+        public String docs() {
+            return "double {number} Converts the number to radians (which is assumed to have been in degrees)";
+        }
+
+        public ExceptionType[] thrown() {
+            return new ExceptionType[]{ExceptionType.CastException};
+        }
+
+        public boolean isRestricted() {
+            return false;
+        }
+
+        public void varList(IVariableList varList) {}
+
+        public boolean preResolveVariables() {
+            return true;
+        }
+
+        public String since() {
+            return "3.3.0";
+        }
+
+        public Boolean runAsync() {
+            return null;
+        }
+
+        public Construct exec(int line_num, File f, Env env, Construct... args) throws ConfigRuntimeException {
+            return new CDouble(java.lang.Math.toRadians(Static.getNumber(args[0])), line_num, f);
+        }
+        
+    }
+    
+    @api public static class to_degrees implements Function{
+
+        public String getName() {
+            return "to_degrees";
+        }
+
+        public Integer[] numArgs() {
+            return new Integer[]{1};
+        }
+
+        public String docs() {
+            return "double {number} Converts the number to degrees (which is assumed to have been in radians)";
+        }
+
+        public ExceptionType[] thrown() {
+            return new ExceptionType[]{ExceptionType.CastException};
+        }
+
+        public boolean isRestricted() {
+            return false;
+        }
+
+        public void varList(IVariableList varList) {}
+
+        public boolean preResolveVariables() {
+            return true;
+        }
+
+        public String since() {
+            return "3.3.0";
+        }
+
+        public Boolean runAsync() {
+            return null;
+        }
+
+        public Construct exec(int line_num, File f, Env env, Construct... args) throws ConfigRuntimeException {
+            return new CDouble(java.lang.Math.toDegrees(Static.getNumber(args[0])), line_num, f);
+        }
+        
+    }
+    
+    @api public static class atan2 implements Function{
+
+        public String getName() {
+            return "atan2";
+        }
+
+        public Integer[] numArgs() {
+            return new Integer[]{2};
+        }
+
+        public String docs() {
+            //lolcopypaste
+            return "double {number} Returns the angle theta from the conversion"
+                    + " of rectangular coordinates (x,y) to polar coordinates"
+                    + " (r,theta). This method computes the phase theta by"
+                    + " computing an arc tangent of y/x in the range of -pi to pi.";
+        }
+
+        public ExceptionType[] thrown() {
+            return new ExceptionType[]{ExceptionType.CastException};
+        }
+
+        public boolean isRestricted() {
+            return false;
+        }
+
+        public void varList(IVariableList varList) {}
+
+        public boolean preResolveVariables() {
+            return true;
+        }
+
+        public String since() {
+            return "3.3.0";
+        }
+
+        public Boolean runAsync() {
+            return null;
+        }
+
+        public Construct exec(int line_num, File f, Env env, Construct... args) throws ConfigRuntimeException {
+            return new CDouble(java.lang.Math.atan2(Static.getNumber(args[0]), Static.getNumber(args[1])), line_num, f);
+        }
+        
+    }
+    
+    @api public static class round implements Function{
+
+        public String getName() {
+            return "round";
+        }
+
+        public Integer[] numArgs() {
+            return new Integer[]{1};
+        }
+
+        public String docs() {
+            return "int {number} Unlike floor and ceil, rounds the number to the nearest integer.";
+        }
+
+        public ExceptionType[] thrown() {
+            return new ExceptionType[]{ExceptionType.CastException};
+        }
+
+        public boolean isRestricted() {
+            return false;
+        }
+
+        public void varList(IVariableList varList) {}
+
+        public boolean preResolveVariables() {
+            return true;
+        }
+
+        public String since() {
+            return "3.3.0";
+        }
+
+        public Boolean runAsync() {
+            return null;
+        }
+
+        public Construct exec(int line_num, File f, Env env, Construct... args) throws ConfigRuntimeException {
+            return new CInt(java.lang.Math.round(Static.getNumber(args[0])), line_num, f);
+        }
+        
+    }
+    
+    @api public static class expr implements Function{
+
+        public String getName() {
+            return "expr";
+        }
+
+        public Integer[] numArgs() {
+            return new Integer[]{1, 2};
+        }
+
+        public String docs() {
+            return "double {expression, [valueArray]} Sometimes, when you need to calculate an advanced"
+                    + " mathematical expression, it is messy to write out everything in terms of functions."
+                    + " This function will allow you to evaluate a mathematical expression as a string, using"
+                    + " common mathematical notation. For example, (2 + 3) * 4 would return 20. Variables can"
+                    + " also be included, and their values given as an associative array. expr('(x + y) * z',"
+                    + " array(x: 2, y: 3, z: 4)) would be the same thing as the above example.";
+        }
+
+        public ExceptionType[] thrown() {
+            return new ExceptionType[]{ExceptionType.CastException, ExceptionType.PluginInternalException};
+        }
+
+        public boolean isRestricted() {
+            return false;
+        }
+
+        public boolean preResolveVariables() {
+            return true;
+        }
+
+        public String since() {
+            return "3.3.0";
+        }
+
+        public Boolean runAsync() {
+            return null;
+        }
+
+        public Construct exec(int line_num, File f, Env environment, Construct... args) throws ConfigRuntimeException {            
+            String expr = args[0].val();
+            CArray vars = null;
+            if(args.length == 2 && args[1] instanceof CArray){
+                vars = (CArray)args[1];
+            } else if(args.length == 2 && !(args[1] instanceof CArray)){
+                throw new ConfigRuntimeException("The second argument of expr() should be an array", ExceptionType.CastException, line_num, f);
+            }
+            if(vars != null && !vars.inAssociativeMode()){
+                throw new ConfigRuntimeException("The array provided to expr() must be an associative array", ExceptionType.CastException, line_num, f);
+            }
+            double[] da;
+            String[] varNames;
+            if(vars != null){
+                int i = 0;
+                da = new double[vars.size()];
+                varNames = new String[vars.size()];
+                for(String key : vars.keySet()){
+                    varNames[i] = key;
+                    da[i] = Static.getDouble(vars.get(key, line_num, f));
+                    i++;
+                }
+            } else {
+                da = new double[0];
+                varNames = new String[0];
+            }
+            try {
+                Expression e = Expression.compile(expr, varNames);
+                return new CDouble(e.evaluate(da), line_num, f);
+            } catch (ExpressionException ex) {
+                throw new ConfigRuntimeException("Your expression was invalidly formatted", ExceptionType.PluginInternalException, line_num, f, ex);
+            }
+        }
+        
+    }
+    
+}
diff --git a/src/main/java/com/laytonsmith/core/functions/Meta.java b/src/main/java/com/laytonsmith/core/functions/Meta.java
new file mode 100644
index 0000000..941ce63
--- /dev/null
+++ b/src/main/java/com/laytonsmith/core/functions/Meta.java
@@ -0,0 +1,587 @@
+/*
+ * To change this template, choose Tools | Templates
+ * and open the template in the editor.
+ */
+package com.laytonsmith.core.functions;
+
+import com.laytonsmith.abstraction.MCCommandSender;
+import com.laytonsmith.abstraction.MCPlayer;
+import com.laytonsmith.core.Env;
+import com.laytonsmith.core.GenericTreeNode;
+import com.laytonsmith.core.Static;
+import com.laytonsmith.core.api;
+import com.laytonsmith.core.constructs.*;
+import com.laytonsmith.core.exceptions.CancelCommandException;
+import com.laytonsmith.core.exceptions.ConfigRuntimeException;
+import com.laytonsmith.core.functions.Exceptions.ExceptionType;
+import com.sk89q.bukkit.migration.PermissionsResolverManager;
+import java.io.File;
+import java.lang.reflect.InvocationHandler;
+import java.lang.reflect.Method;
+import java.lang.reflect.Proxy;
+import java.util.List;
+import java.util.logging.Level;
+
+/**
+ * I'm So Meta, Even This Acronym
+ * @author Layton
+ */
+public class Meta {
+
+    public static String docs() {
+        return "These functions provide a way to run other commands";
+    }
+
+    @api
+    public static class runas implements Function {
+
+        public String getName() {
+            return "runas";
+        }
+
+        public Integer[] numArgs() {
+            return new Integer[]{2};
+        }
+
+        public Construct exec(int line_num, File f, final Env env, Construct... args) throws CancelCommandException, ConfigRuntimeException {
+            if (args[1].val() == null || args[1].val().length() <= 0 || args[1].val().charAt(0) != '/') {
+                throw new ConfigRuntimeException("The first character of the command must be a forward slash (i.e. '/give')",
+                        ExceptionType.FormatException, line_num, f);
+            }
+            String cmd = args[1].val().substring(1);
+            if (args[0] instanceof CArray) {
+                CArray u = (CArray) args[0];
+                for (int i = 0; i < u.size(); i++) {
+                    exec(line_num, f, env, new Construct[]{new CString(u.get(i, line_num, f).val(), line_num, f), args[1]});
+                }
+                return new CVoid(line_num, f);
+            }
+            if (args[0].val().equals("~op")) {
+                //Store their current op status
+                Boolean isOp = env.GetCommandSender().isOp();
+
+                if ((Boolean) Static.getPreferences().getPreference("debug-mode")) {
+                    if (env.GetCommandSender() instanceof MCPlayer) {
+                        Static.getLogger().log(Level.INFO, "[CommandHelper]: Executing command on " + env.GetPlayer().getName() + ": " + args[1].val().trim());
+                    } else {
+                        Static.getLogger().log(Level.INFO, "[CommandHelper]: Executing command from console equivalent: " + args[1].val().trim());
+                    }
+                }
+
+                //If they aren't op, op them now
+                if (!isOp) {
+                    this.setOp(env.GetCommandSender(), true);
+                }
+
+                try {
+                    Static.getServer().dispatchCommand(this.getOPCommandSender(env.GetCommandSender()), cmd);
+                } finally {
+                    //If they just opped themselves, or deopped themselves in the command
+                    //don't undo what they just did. Otherwise, set their op status back
+                    //to their original status
+                    if(env.GetPlayer() != null && !cmd.equalsIgnoreCase("op " + env.GetPlayer().getName()) && !cmd.equalsIgnoreCase("deop " + env.GetPlayer().getName())){
+                        this.setOp(env.GetCommandSender(), isOp);
+                    }
+                }
+            } else {
+                MCPlayer m = Static.getServer().getPlayer(args[0].val());
+                if (m != null && m.isOnline()) {
+                    if (env.GetCommandSender() instanceof MCPlayer) {
+                        Static.getLogger().log(Level.INFO, "[CommandHelper]: Executing command on " + env.GetPlayer().getName() + ": " + args[0].val().trim());
+                    } else {
+                        Static.getLogger().log(Level.INFO, "[CommandHelper]: Executing command from console equivalent: " + args[0].val().trim());
+                    }
+                    //m.chat(cmd);
+                    Static.getServer().dispatchCommand(m, cmd);
+                } else {
+                    throw new ConfigRuntimeException("The player " + args[0].val() + " is not online",
+                            ExceptionType.PlayerOfflineException, line_num, f);
+                }
+            }
+            return new CVoid(line_num, f);
+        }
+
+        public ExceptionType[] thrown() {
+            return new ExceptionType[]{ExceptionType.FormatException, ExceptionType.PlayerOfflineException};
+        }
+
+        public String docs() {
+            return "void {player, command} Runs a command as a particular user. The special user '~op' is a user that runs as op. Be careful with this very powerful function."
+                    + " Commands cannot be run as an offline player. Returns void. If the first argument is an array of usernames, the command"
+                    + " will be run in the context of each user in the array.";
+        }
+
+        public boolean isRestricted() {
+            return true;
+        }
+
+        public void varList(IVariableList varList) {
+        }
+
+        public boolean preResolveVariables() {
+            return true;
+        }
+
+        public String since() {
+            return "3.0.1";
+        }
+
+        public Boolean runAsync() {
+            return false;
+        }
+
+        /**
+         * Set OP status for player without saving to ops.txt
+         * 
+         * @param player
+         * @param value 
+         */
+        protected void setOp(MCCommandSender player, Boolean value) {
+            if (!(player instanceof MCPlayer) || player.isOp() == value) {
+                return;
+            }
+            
+            try {
+                ((MCPlayer)player).setTempOp(value);                                                
+            } catch (ClassNotFoundException e) {
+            } catch (IllegalStateException e) {
+            } catch (Throwable e) {
+                Static.getLogger().log(Level.WARNING, "[CommandHelper]: Failed to OP player " + player.getName());
+            }
+        }
+
+        protected MCCommandSender getOPCommandSender(final MCCommandSender sender) {
+            if (sender.isOp()) {
+                return sender;
+            }
+
+            return (MCCommandSender) Proxy.newProxyInstance(sender.getClass().getClassLoader(),
+                    new Class[] { (sender instanceof MCPlayer) ? MCPlayer.class : MCCommandSender.class },
+                    new InvocationHandler() {
+                        public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
+                            String methodName = method.getName();
+                            if ("isOp".equals(methodName) || "hasPermission".equals(methodName) || "isPermissionSet".equals(methodName)) {
+                                return true;
+                            } else {
+                                return method.invoke(sender, args);
+                            }
+                        }
+                    });            
+        }
+    }
+
+    @api
+    public static class run implements Function {
+
+        public String getName() {
+            return "run";
+        }
+
+        public Integer[] numArgs() {
+            return new Integer[]{1};
+        }
+
+        public Construct exec(int line_num, File f, Env env, Construct... args) throws CancelCommandException, ConfigRuntimeException {
+            if (args[0].val() == null || args[0].val().length() <= 0 || args[0].val().charAt(0) != '/') {
+                throw new ConfigRuntimeException("The first character of the command must be a forward slash (i.e. '/give')",
+                        ExceptionType.FormatException, line_num, f);
+            }
+            String cmd = args[0].val().substring(1);
+            if ((Boolean) Static.getPreferences().getPreference("debug-mode")) {
+                if (env.GetCommandSender() instanceof MCPlayer) {
+                    Static.getLogger().log(Level.INFO, "[CommandHelper]: Executing command on " + env.GetPlayer().getName() + ": " + args[0].val().trim());
+                } else {
+                    Static.getLogger().log(Level.INFO, "[CommandHelper]: Executing command from console equivalent: " + args[0].val().trim());
+                }
+            }
+            //p.chat(cmd);
+            Static.getServer().dispatchCommand(env.GetCommandSender(), cmd);
+            return new CVoid(line_num, f);
+        }
+
+        public String docs() {
+            return "void {var1} Runs a command as the current player. Useful for running commands in a loop. Note that this accepts commands like from the "
+                    + "chat; with a forward slash in front.";
+        }
+
+        public ExceptionType[] thrown() {
+            return new ExceptionType[]{ExceptionType.FormatException};
+        }
+
+        public boolean isRestricted() {
+            return false;
+        }
+
+        public void varList(IVariableList varList) {
+        }
+
+        public boolean preResolveVariables() {
+            return true;
+        }
+
+        public String since() {
+            return "3.0.1";
+        }
+
+        public Boolean runAsync() {
+            return false;
+        }
+    }
+
+    @api
+    public static class g implements Function {
+
+        public String getName() {
+            return "g";
+        }
+
+        public Integer[] numArgs() {
+            return new Integer[]{Integer.MAX_VALUE};
+        }
+
+        public Construct exec(int line_num, File f, Env env, Construct... args) throws CancelCommandException, ConfigRuntimeException {
+            for (int i = 0; i < args.length; i++) {
+                args[i].val();
+            }
+            return new CVoid(line_num, f);
+        }
+
+        public String docs() {
+            return "string {func1, [func2...]} Groups any number of functions together, and returns void. ";
+        }
+
+        public ExceptionType[] thrown() {
+            return new ExceptionType[]{};
+        }
+
+        public boolean isRestricted() {
+            return false;
+        }
+
+        public void varList(IVariableList varList) {
+        }
+
+        public boolean preResolveVariables() {
+            return true;
+        }
+
+        public String since() {
+            return "3.0.1";
+        }
+
+        public Boolean runAsync() {
+            return null;
+        }
+    }
+
+    @api
+    public static class p implements Function {
+
+        public String getName() {
+            return "p";
+        }
+
+        public Integer[] numArgs() {
+            return new Integer[]{1};
+        }
+
+        public String docs() {
+            return "mixed {c} Used internally by the compiler.";
+        }
+
+        public ExceptionType[] thrown() {
+            return null;
+        }
+
+        public boolean isRestricted() {
+            return false;
+        }
+
+        public void varList(IVariableList varList) {
+        }
+
+        public boolean preResolveVariables() {
+            return true;
+        }
+
+        public String since() {
+            return "3.1.2";
+        }
+
+        public Boolean runAsync() {
+            return null;
+        }
+
+        public Construct exec(int line_num, File f, Env env, Construct... args) throws ConfigRuntimeException {
+            return Static.resolveConstruct(args[0].val(), line_num, f);
+        }
+    }
+
+    @api
+    public static class eval implements Function {
+
+        public String getName() {
+            return "eval";
+        }
+
+        public Integer[] numArgs() {
+            return new Integer[]{1};
+        }
+
+        public String docs() {
+            return "string {script_string} Executes arbitrary MScript. Note that this function is very experimental, and is subject to changing or "
+                    + "removal.";
+        }
+
+        public ExceptionType[] thrown() {
+            return new ExceptionType[]{};
+        }
+
+        public boolean isRestricted() {
+            return true;
+        }
+
+        public void varList(IVariableList varList) {
+        }
+
+        public boolean preResolveVariables() {
+            return true;
+        }
+
+        public String since() {
+            return "3.1.0";
+        }
+
+        public Construct exec(int line_num, File f, Env env, Construct... args) throws CancelCommandException, ConfigRuntimeException {
+            return new CVoid(line_num, f);
+        }
+        //Doesn't matter, run out of state anyways
+
+        public Boolean runAsync() {
+            return null;
+        }
+    }
+
+    @api
+    public static class call_alias implements Function {
+
+        public String getName() {
+            return "call_alias";
+        }
+
+        public Integer[] numArgs() {
+            return new Integer[]{1};
+        }
+
+        public String docs() {
+            return "void {cmd} Allows a CommandHelper alias to be called from within another alias. Typically this is not possible, as"
+                    + " a script that runs \"/jail = /jail\" for instance, would simply be calling whatever plugin that actually"
+                    + " provides the jail functionality's /jail command. However, using this function makes the command loop back"
+                    + " to CommandHelper only.";
+        }
+
+        public ExceptionType[] thrown() {
+            return new ExceptionType[]{};
+        }
+
+        public boolean isRestricted() {
+            return false;
+        }
+
+        public void varList(IVariableList varList) {
+        }
+
+        public boolean preResolveVariables() {
+            return true;
+        }
+
+        public String since() {
+            return "3.2.0";
+        }
+
+        public Boolean runAsync() {
+            return null;
+        }
+
+        public Construct exec(int line_num, File f, Env env, Construct... args) throws ConfigRuntimeException {
+            boolean doRemoval = true;
+            if(!Static.getAliasCore().hasPlayerReference(env.GetCommandSender())){
+                doRemoval = false;
+            }
+            if(doRemoval){
+                Static.getAliasCore().removePlayerReference(env.GetCommandSender());
+            }
+            Static.getAliasCore().alias(args[0].val(), env.GetCommandSender(), null);
+            if(doRemoval){
+                Static.getAliasCore().addPlayerReference(env.GetCommandSender());
+            }
+            return new CVoid(line_num, f);
+        }
+    }
+    
+    @api public static class scriptas implements Function{
+
+        public String getName() {
+            return "scriptas";
+        }
+
+        public Integer[] numArgs() {
+            return new Integer[]{2, 3};
+        }
+
+        public String docs() {
+            return "void {player, [label], script} Runs the specified script in the context of a given player."
+                    + " A script that runs player() for instance, would return the specified player's name,"
+                    + " not the player running the command. Setting the label allows you to dynamically set the label"
+                    + " this script is run under as well (in regards to permission checking)";
+        }
+
+        public ExceptionType[] thrown() {
+            return new ExceptionType[]{ExceptionType.PlayerOfflineException};
+        }
+
+        public boolean isRestricted() {
+            return true;
+        }
+
+        public boolean preResolveVariables() {
+            return false;
+        }
+
+        public String since() {
+            return "3.3.0";
+        }
+
+        public Boolean runAsync() {
+            return null;
+        }
+        
+        public Construct exec(int line_num, File f, Env environment, Construct... args){
+            return null;
+        }
+
+        public Construct execs(int line_num, File f, Env environment, List<GenericTreeNode<Construct>> args) throws ConfigRuntimeException {
+            MCPlayer p = Static.GetPlayer(environment.GetScript().seval(args.get(0), environment).val(), line_num, f);
+            MCCommandSender originalPlayer = environment.GetCommandSender();
+            int offset = 0;
+            String originalLabel = environment.GetLabel();
+            if(args.size() == 3){
+                offset++;
+                String label = environment.GetScript().seval(args.get(1), environment).val();
+                environment.SetLabel(label);
+            }
+            environment.SetPlayer(p);
+            GenericTreeNode<Construct> tree = args.get(1 + offset);
+            environment.GetScript().eval(tree, environment);
+            environment.SetCommandSender(originalPlayer);
+            environment.SetLabel(originalLabel);
+            return new CVoid(line_num, f);
+        }
+        
+    }
+    
+    @api public static class has_permission implements Function{
+
+        public String getName() {
+            return "has_permission";
+        }
+
+        public Integer[] numArgs() {
+            return new Integer[]{1, 2};
+        }
+
+        public String docs() {
+            return "boolean {[player], permissionName} Using the built in permissions system, checks to see if the player has a particular permission."
+                    + " This is simply passed through to the permissions system. This function does not throw a PlayerOfflineException, because"
+                    + " it works with offline players, but that means that names must be an exact match. If you notice, this function isn't"
+                    + " restricted. However, it IS restricted if the player attempts to check another player's permissions.";
+        }
+
+        public ExceptionType[] thrown() {
+            return new ExceptionType[]{};
+        }
+
+        public boolean isRestricted() {
+            return false;
+        }
+
+        public boolean preResolveVariables() {
+            return true;
+        }
+
+        public String since() {
+            return "3.3.0";
+        }
+
+        public Boolean runAsync() {
+            return false;
+        }
+
+        public Construct exec(int line_num, File f, Env environment, Construct... args) throws ConfigRuntimeException {
+            String player = null;
+            String permission = null;
+            if(args.length == 1){
+                player = environment.GetPlayer().getName();
+                permission = args[0].val();
+            } else {
+                player = args[0].val();
+                permission = args[1].val();
+            }
+            if(environment.GetPlayer() != null && !environment.GetPlayer().getName().equals(player)){
+                if(!Static.hasCHPermission(this.getName(), environment)){
+                    throw new ConfigRuntimeException("You do not have permission to use the " + f.getName() + " function.",
+                                ExceptionType.InsufficientPermissionException, line_num, f);
+                }
+            }
+            PermissionsResolverManager perms = Static.getPermissionsResolverManager();
+            return new CBoolean(perms.hasPermission(player, permission), line_num, f);
+        }
+        
+    }
+    
+    @api public static class get_cmd implements Function{
+
+        public String getName() {
+            return "get_cmd";
+        }
+
+        public Integer[] numArgs() {
+            return new Integer[]{0};
+        }
+
+        public String docs() {
+            return "mixed {} Gets the command (as a string) that ended up triggering this script, exactly"
+                    + " how it was entered by the player. This could be null, if for instance"
+                    + " it is called from within an event.";
+        }
+
+        public ExceptionType[] thrown() {
+            return new ExceptionType[]{};
+        }
+
+        public boolean isRestricted() {
+            return false;
+        }
+
+        public boolean preResolveVariables() {
+            return true;
+        }
+
+        public Boolean runAsync() {
+            return null;
+        }
+
+        public Construct exec(int line_num, File f, Env environment, Construct... args) throws ConfigRuntimeException {
+            if(environment.GetCommand() == null){
+                return new CNull(line_num, f);
+            } else {
+                return new CString(environment.GetCommand(), line_num, f);
+            }
+        }
+
+        public String since() {
+            return "3.3.0";
+        }
+        
+    }
+}
diff --git a/src/main/java/com/laytonsmith/core/functions/Minecraft.java b/src/main/java/com/laytonsmith/core/functions/Minecraft.java
new file mode 100644
index 0000000..5cbfca3
--- /dev/null
+++ b/src/main/java/com/laytonsmith/core/functions/Minecraft.java
@@ -0,0 +1,634 @@
+/*
+ * To change this template, choose Tools | Templates
+ * and open the template in the editor.
+ */
+package com.laytonsmith.core.functions;
+
+import com.laytonsmith.abstraction.*;
+import com.laytonsmith.core.Env;
+import com.laytonsmith.core.ObjectGenerator;
+import com.laytonsmith.core.Static;
+import com.laytonsmith.core.api;
+import com.laytonsmith.core.constructs.*;
+import com.laytonsmith.core.exceptions.CancelCommandException;
+import com.laytonsmith.core.exceptions.ConfigRuntimeException;
+import com.laytonsmith.core.functions.Exceptions.ExceptionType;
+import java.io.File;
+import java.io.IOException;
+import java.util.*;
+import java.util.logging.Level;
+import java.util.logging.Logger;
+import org.bukkit.OfflinePlayer;
+import org.bukkit.entity.HumanEntity;
+import org.bukkit.entity.LivingEntity;
+
+/**
+ *
+ * @author Layton
+ */
+public class Minecraft {
+
+    public static String docs() {
+        return "These functions provide a hook into game functionality.";
+    }
+    private static final SortedMap<String, Construct> DataLookup = new TreeMap<String, Construct>();
+    static{
+        Properties p = new Properties();
+        try {
+            p.load(Minecraft.class.getResourceAsStream("/data_values.txt"));
+            Enumeration e = p.propertyNames();
+            while(e.hasMoreElements()){
+                String name = e.nextElement().toString();
+                DataLookup.put(name, new CString(p.getProperty(name).toString(), 0, null));
+            }
+        } catch (IOException ex) {
+            Logger.getLogger(Minecraft.class.getName()).log(Level.SEVERE, null, ex);
+        }
+    }
+    @api
+    public static class data_values implements Function {
+
+        public String getName() {
+            return "data_values";
+        }
+
+        public Integer[] numArgs() {
+            return new Integer[]{1};
+        }
+
+        public Construct exec(int line_num, File f, Env env, Construct... args) throws CancelCommandException, ConfigRuntimeException {
+            if (args[0] instanceof CInt) {
+                return new CInt(Static.getInt(args[0]), line_num, f);
+            } else {
+                String c = args[0].val();
+                int number = StaticLayer.LookupItemId(c);
+                if(number != -1){
+                    return new CInt(number, line_num, f);
+                }
+                String changed = c;
+                if(changed.contains(":")){
+                    //Split on that, and reverse. Change wool:red to redwool
+                    String split[] = changed.split(":");
+                    if(split.length == 2){
+                        changed = split[1] + split[0];
+                    }
+                }
+                //Remove anything that isn't a letter or a number
+                changed = changed.replaceAll("[^a-zA-Z0-9]", "").toLowerCase();
+                //Do a lookup in the DataLookup table
+                if(DataLookup.containsKey(changed)){
+                    String split[] = DataLookup.get(changed).toString().split(":");
+                    if(split[1].equals("0")){
+                        return new CInt(split[0], line_num, f);
+                    }
+                    return new CString(split[0] + ":" + split[1], line_num, f);
+                }
+                return new CNull(line_num, f);
+            }
+        }
+
+        public String docs() {
+            return "int {var1} Does a lookup to return the data value of a name. For instance, returns 1 for 'stone'. If an integer is given,"
+                    + " simply returns that number. If the data value cannot be found, null is returned.";
+        }
+
+        public ExceptionType[] thrown() {
+            return new ExceptionType[]{};
+        }
+
+        public boolean isRestricted() {
+            return false;
+        }
+
+        public void varList(IVariableList varList) {
+        }
+
+        public boolean preResolveVariables() {
+            return true;
+        }
+
+        public String since() {
+            return "3.0.1";
+        }
+
+        public Boolean runAsync() {
+            return false;
+        }
+    }
+    
+    @api public static class data_name implements Function{
+
+        public String getName() {
+            return "data_name";
+        }
+
+        public Integer[] numArgs() {
+            return new Integer[]{1};
+        }
+
+        public String docs() {
+            return "string {int} Performs the reverse functionality as data_values. Given 1, returns 'STONE'. Note that the enum value"
+                    + " given in bukkit's Material class is what is returned.";
+        }
+
+        public ExceptionType[] thrown() {
+            return new ExceptionType[]{ExceptionType.CastException};
+        }
+
+        public boolean isRestricted() {
+            return false;
+        }
+
+        public boolean preResolveVariables() {
+            return true;
+        }
+
+        public String since() {
+            return "3.3.0";
+        }
+
+        public Boolean runAsync() {
+            return false;
+        }
+
+        public Construct exec(int line_num, File f, Env environment, Construct... args) throws ConfigRuntimeException {
+            int i = -1;
+            if(args[0] instanceof CString){
+                //We also accept item notation
+                if(args[0].val().contains(":")){
+                    String[] split = args[0].val().split(":");
+                    try{
+                        i = Integer.parseInt(split[0]);
+                    } catch(NumberFormatException e){}
+                }
+            }
+            if(i == -1){
+                i = (int)Static.getInt(args[0]);
+            }            
+            return new CString(StaticLayer.LookupMaterialName(i), line_num, f);
+        }
+        
+    }
+
+    @api
+    public static class get_worlds implements Function {
+
+        public String getName() {
+            return "get_worlds";
+        }
+
+        public Integer[] numArgs() {
+            return new Integer[]{0};
+        }
+
+        public String docs() {
+            return "array {} Returns the names of the worlds available in this server";
+        }
+
+        public ExceptionType[] thrown() {
+            return new ExceptionType[]{};
+        }
+
+        public boolean isRestricted() {
+            return false;
+        }
+
+        public void varList(IVariableList varList) {
+        }
+
+        public boolean preResolveVariables() {
+            return true;
+        }
+
+        public String since() {
+            return "3.1.0";
+        }
+
+        public Boolean runAsync() {
+            return true;
+        }
+
+        public Construct exec(int line_num, File f, Env env, Construct... args) throws CancelCommandException, ConfigRuntimeException {
+            List<MCWorld> worlds = env.GetCommandSender().getServer().getWorlds();
+            CArray c = new CArray(line_num, f);
+            for (MCWorld w : worlds) {
+                c.push(new CString(w.getName(), line_num, f));
+            }
+            return c;
+        }
+    }
+
+    @api
+    public static class spawn_mob implements Function {
+
+        public String getName() {
+            return "spawn_mob";
+        }
+
+        public Integer[] numArgs() {
+            return new Integer[]{1, 2, 3};
+        }
+
+        public String docs() {
+            return "array {mobType, [qty], [location]} (Currently only works with Bukkit) Spawns qty mob of one of the following types at location. qty defaults to 1, and location defaults"
+                    + " to the location of the player. mobType can be one of: BLAZE, CAVESPIDER, CHICKEN, COW, CREEPER, ENDERDRAGON, ENDERMAN, GHAST,"
+                    + " MAGMACUBE, MOOSHROOM, PIG, PIGZOMBIE, SHEEP, SILVERFISH, SKELETON, SLIME, SPIDER, SPIDERJOCKEY, SQUID, VILLAGER, WOLF, ZOMBIE. Spelling matters, but capitalization doesn't. At this"
+                    + " time, the function is limited to spawning a maximum of 50 at a time. Further, SHEEP can be spawned as any color, by specifying"
+                    + " SHEEP:COLOR, where COLOR is any of the dye colors: BLACK RED GREEN BROWN BLUE PURPLE CYAN SILVER GRAY PINK LIME YELLOW LIGHT_BLUE MAGENTA ORANGE WHITE. COLOR defaults to white if not"
+                    + " specified. An array of the entity IDs spawned is returned."
+                    + ""
+                    + " <p><small>GIANTs can also be spawned, if you are running craftbukkit. This is an experimental feature. Only one GIANT can be spawned at a time</small></p>";
+        }
+
+        public ExceptionType[] thrown() {
+            return new ExceptionType[]{ExceptionType.CastException, ExceptionType.RangeException, ExceptionType.FormatException};
+        }
+
+        public boolean isRestricted() {
+            return true;
+        }
+
+        public void varList(IVariableList varList) {
+        }
+
+        public boolean preResolveVariables() {
+            return true;
+        }
+
+        public String since() {
+            return "3.1.2";
+        }
+
+        public Boolean runAsync() {
+            return false;
+        }
+
+        
+
+        public Construct exec(int line_num, File f, Env env, Construct... args) throws CancelCommandException, ConfigRuntimeException {
+            String mob = args[0].val();
+            String sheepColor = "WHITE";
+            if (mob.toUpperCase().startsWith("SHEEP:")) {
+                sheepColor = mob.substring(6);
+                mob = "SHEEP";
+            }
+            int qty = 1;
+            if (args.length > 1) {
+                qty = (int) Static.getInt(args[1]);
+            }
+            if (qty > 50) {
+                throw new ConfigRuntimeException("A bit excessive, don't you think? Let's scale that back some, huh?",
+                        ExceptionType.RangeException, line_num, f);
+            }
+            MCLocation l = null;
+            if (env.GetCommandSender() instanceof MCPlayer) {
+                l = env.GetPlayer().getLocation();
+            }
+            if (args.length > 2) {
+                if (args[2] instanceof CArray) {
+                    CArray ca = (CArray) args[2];
+                    l = ObjectGenerator.GetGenerator().location(ca, (l != null?l.getWorld():null), line_num, f);
+                } else {
+                    throw new ConfigRuntimeException("Expected argument 3 to spawn_mob to be an array",
+                            ExceptionType.CastException, line_num, f);
+                }
+            }
+            if(l.getWorld() != null){
+                return l.getWorld().spawnMob(mob, sheepColor, qty, l, line_num, f);
+            } else {
+                throw new ConfigRuntimeException("World was not specified", ExceptionType.InvalidWorldException, line_num, f);
+            }
+        }
+    }
+    
+    @api public static class tame_mob implements Function{
+
+        public String getName() {
+            return "tame_mob";
+        }
+
+        public Integer[] numArgs() {
+            return new Integer[]{1, 2};
+        }
+
+        public String docs() {
+            return "void {[player], entityID} Tames the entity specified to the player. Currently only wolves are supported. Offline players"
+                    + " are supported, but this means that partial matches are NOT supported. You must type the players name exactly. Setting"
+                    + " the player to null will untame the mob. If the entity doesn't exist, nothing happens.";
+        }
+
+        public ExceptionType[] thrown() {
+            return new ExceptionType[]{ExceptionType.UntameableMobException, ExceptionType.CastException};
+        }
+
+        public boolean isRestricted() {
+            return true;
+        }
+
+        public boolean preResolveVariables() {
+            return true;
+        }
+
+        public String since() {
+            return "3.3.0";
+        }
+
+        public Boolean runAsync() {
+            return false;
+        }
+
+        public Construct exec(int line_num, File f, Env environment, Construct... args) throws ConfigRuntimeException {
+            String player = environment.GetPlayer().getName();
+            Construct entityID = null;
+            if(args.length == 2){
+                if(args[0] instanceof CNull){
+                    player = null;
+                } else {
+                    player = args[0].val();
+                }
+                entityID = args[1];
+            } else {
+                entityID = args[0];
+            }
+            int id = (int) Static.getInt(entityID);
+            MCEntity e = Static.getEntity(id);
+            if(e == null){
+                return new CVoid(line_num, f);
+            } else if(e.isTameable()){                
+                MCTameable t = e.getMCTameable();
+                if(player != null){
+                    t.setOwner(Static.getServer().getOfflinePlayer(player));
+                } else {
+                    t.setOwner(null);
+                }
+                return new CVoid(line_num, f);
+            } else {
+                throw new ConfigRuntimeException("The specified entity is not tameable", ExceptionType.UntameableMobException, line_num, f);
+            }
+        }
+        
+    }
+    
+    @api public static class get_mob_owner implements Function{
+
+        public String getName() {
+            return "get_mob_owner";
+        }
+
+        public Integer[] numArgs() {
+            return new Integer[]{1};
+        }
+
+        public String docs() {
+            return "string {entityID} Returns the owner's name, or null if the mob is unowned. An UntameableMobException is thrown if"
+                    + " mob isn't tameable to begin with.";
+        }
+
+        public ExceptionType[] thrown() {
+            return new ExceptionType[]{ExceptionType.UntameableMobException, ExceptionType.CastException};
+        }
+
+        public boolean isRestricted() {
+            return true;
+        }
+
+        public boolean preResolveVariables() {
+            return true;
+        }
+
+        public String since() {
+            return "3.3.0";
+        }
+
+        public Boolean runAsync() {
+            return false;
+        }
+
+        public Construct exec(int line_num, File f, Env environment, Construct... args) throws ConfigRuntimeException {
+            int id = (int)Static.getInt(args[0]);
+            MCEntity e = Static.getEntity(id);
+            if(e == null){
+                return new CNull(line_num, f);
+            } else if(e instanceof MCTameable){
+                MCAnimalTamer at = ((MCTameable)e).getOwner();
+                if(at instanceof HumanEntity){
+                    return new CString(((HumanEntity)at).getName(), line_num, f);
+                } else if(at instanceof OfflinePlayer){
+                    return new CString(((OfflinePlayer)at).getName(), line_num, f);
+                } else {
+                    return new CNull(line_num, f);
+                }
+            } else {
+                throw new ConfigRuntimeException("The specified entity is not tameable", ExceptionType.UntameableMobException, line_num, f);
+            }
+        }
+        
+    }
+    
+    @api public static class is_tameable implements Function{
+
+        public String getName() {
+            return "is_tameable";
+        }
+
+        public Integer[] numArgs() {
+            return new Integer[]{1};
+        }
+
+        public String docs() {
+            return "boolean {entityID} Returns true or false if the specified entity is tameable";
+        }
+
+        public ExceptionType[] thrown() {
+            return new ExceptionType[]{ExceptionType.CastException};
+        }
+
+        public boolean isRestricted() {
+            return true;
+        }
+
+        public boolean preResolveVariables() {
+            return true;
+        }
+
+        public String since() {
+            return "3.3.0";
+        }
+
+        public Boolean runAsync() {
+            return false;
+        }
+
+        public Construct exec(int line_num, File f, Env environment, Construct... args) throws ConfigRuntimeException {
+            int id = (int)Static.getInt(args[0]);
+            MCEntity e = Static.getEntity(id);
+            boolean ret = false;
+            if(e == null){
+                ret = false;
+            } else if(e instanceof MCTameable){
+                ret = true;
+            } else {
+                ret = false;
+            }
+            return new CBoolean(ret, line_num, f);
+        }
+        
+    }
+    
+    @api public static class make_effect implements Function{
+
+        public String getName() {
+            return "make_effect";
+        }
+
+        public Integer[] numArgs() {
+            return new Integer[]{2, 3};
+        }
+
+        public String docs() {
+            return "void {xyzArray, effect, [radius]} Plays the specified effect (sound effect) at the given location, for all players within"
+                    + " the radius (or 64 by default). The effect can be one of the following:"
+                    + " BOW_FIRE, CLICK1, CLICK2, DOOR_TOGGLE, EXTINGUISH.";
+        }
+
+        public ExceptionType[] thrown() {
+            return new ExceptionType[]{ExceptionType.CastException, ExceptionType.FormatException};
+        }
+
+        public boolean isRestricted() {
+            return true;
+        }
+
+        public void varList(IVariableList varList) {}
+
+        public boolean preResolveVariables() {
+            return true;
+        }
+
+        public String since() {
+            return "3.1.3";
+        }
+
+        public Boolean runAsync() {
+            return false;
+        }
+
+        public Construct exec(int line_num, File f, Env env, Construct... args) throws ConfigRuntimeException {
+            MCLocation l = ObjectGenerator.GetGenerator().location(args[0], (env.GetCommandSender() instanceof MCPlayer?env.GetPlayer().getWorld():null), line_num, f);
+            MCEffect e = null;
+            try{
+                e = MCEffect.valueOf(args[1].val().toUpperCase());
+                if(e.equals(MCEffect.RECORD_PLAY) || e.equals(MCEffect.SMOKE) || e.equals(MCEffect.STEP_SOUND)){
+                    throw new IllegalArgumentException();
+                }
+            } catch(IllegalArgumentException ex){
+                throw new ConfigRuntimeException("The effect type " + args[1].val() + " is not valid", ExceptionType.FormatException, line_num, f);
+            }
+            int data = 0;
+            int radius = 64;
+            if(args.length == 3){
+                radius = (int) Static.getInt(args[2]);
+            }
+            l.getWorld().playEffect(l, e, data, radius);
+            return new CVoid(line_num, f);
+        }
+        
+    }
+    
+    @api public static class set_entity_health implements Function{
+
+        public String getName() {
+            return "set_entity_health";
+        }
+
+        public Integer[] numArgs() {
+            return new Integer[]{2};
+        }
+
+        public String docs() {
+            return "void {entityID, healthPercent} Sets the specified entity's health (0 kills it), or ignores this call if the entityID doesn't exist or isn't"
+                    + "a LivingEntity.";
+        }
+
+        public ExceptionType[] thrown() {
+            return new ExceptionType[]{ExceptionType.CastException};
+        }
+
+        public boolean isRestricted() {
+            return true;
+        }
+
+        public boolean preResolveVariables() {
+            return true;
+        }
+
+        public String since() {
+            return "3.3.0";
+        }
+
+        public Boolean runAsync() {
+            return false;
+        }
+
+        public Construct exec(int line_num, File f, Env environment, Construct... args) throws ConfigRuntimeException {
+            MCEntity e = Static.getEntity((int)Static.getInt(args[0]));
+            if(e instanceof MCLivingEntity){
+                int health = (int)((double)Static.getInt(args[1])/100.0*(double)((LivingEntity)e).getMaxHealth());
+                if(health != 0){
+                    ((MCLivingEntity)e).setHealth(health);
+                } else {
+                    ((MCLivingEntity)e).damage(9001); //His power level is over 9000!
+                }
+            }
+            return new CVoid(line_num, f);
+        }
+        
+    }
+    
+    @api public static class get_entity_health implements Function{
+
+        public String getName() {
+            return "get_entity_health";
+        }
+
+        public Integer[] numArgs() {
+            return new Integer[]{1};
+        }
+
+        public String docs() {
+            return "int {entityID} Returns the entity's health, as a percentage. If the specified entity doesn't exist, or is not"
+                    + " a LivingEntity, a format exception is thrown.";
+        }
+
+        public ExceptionType[] thrown() {
+            return new ExceptionType[]{ExceptionType.CastException, ExceptionType.FormatException};
+        }
+
+        public boolean isRestricted() {
+            return true;
+        }
+
+        public boolean preResolveVariables() {
+            return true;
+        }
+
+        public String since() {
+            return "3.3.0";
+        }
+
+        public Boolean runAsync() {
+            return false;
+        }
+
+        public Construct exec(int line_num, File f, Env environment, Construct... args) throws ConfigRuntimeException {
+            MCEntity e = Static.getEntity((int)Static.getInt(args[0]));
+            if(e instanceof MCLivingEntity){
+                int h = (int)(((double)((MCLivingEntity)e).getHealth()/(double)((MCLivingEntity)e).getMaxHealth())*100);
+                return new CInt(h, line_num, f);
+            } else {
+                throw new ConfigRuntimeException("Not a valid entity id", ExceptionType.FormatException, line_num, f);
+            }
+        }
+        
+    }    
+}
diff --git a/src/main/java/com/laytonsmith/core/functions/Performance.java b/src/main/java/com/laytonsmith/core/functions/Performance.java
new file mode 100644
index 0000000..736e804
--- /dev/null
+++ b/src/main/java/com/laytonsmith/core/functions/Performance.java
@@ -0,0 +1,87 @@
+/*
+ * To change this template, choose Tools | Templates
+ * and open the template in the editor.
+ */
+package com.laytonsmith.core.functions;
+
+import com.laytonsmith.core.Env;
+import com.laytonsmith.core.Static;
+import com.laytonsmith.core.api;
+import com.laytonsmith.core.constructs.CVoid;
+import com.laytonsmith.core.constructs.Construct;
+import com.laytonsmith.core.exceptions.ConfigRuntimeException;
+import com.laytonsmith.core.functions.Exceptions.ExceptionType;
+import java.io.File;
+import java.io.IOException;
+import java.util.logging.Level;
+import java.util.logging.Logger;
+import org.perf4j.StopWatch;
+
+/**
+ *
+ * @author Layton
+ */
+public class Performance {
+    public static boolean PERFORMANCE_LOGGING = false;
+    public static String docs(){
+        return "This class provides functions for hooking into CommandHelper's powerful Performance measuring. To use the functions, you must have"
+                + " allow-profiling option set to true in your preferences file.";
+    }
+
+    public static void DoLog(StopWatch stopWatch) {
+        try {            
+            Static.QuickAppend(Static.profilingLogFile(), "start[" + stopWatch.getStartTime() + "] time[" + stopWatch.getElapsedTime() + "] " 
+                    + "tag[" + stopWatch.getTag() + "]\n");
+        } catch (IOException ex) {
+            Logger.getLogger(Performance.class.getName()).log(Level.SEVERE, null, ex);
+        }
+    }
+    
+    @api public static class enable_performance_logging implements Function{
+
+        public String getName() {
+            return "enable_performance_logging";
+        }
+
+        public Integer[] numArgs() {
+            return new Integer[]{1};
+        }
+
+        public String docs() {
+            return "void {boolean} Enables performance logging. The allow-profiling option must be set to true in your preferences file,"
+                    + " and play-dirty mode must be active. If allow-profiling is set to false, a SecurityException is thrown."
+                    + " The debug filters are used by the performance logger, if you choose to filter through the events."
+                    + " See the documenation"
+                    + " for more details on performance logging.";
+        }
+
+        public ExceptionType[] thrown() {
+            return new ExceptionType[]{ExceptionType.SecurityException};
+        }
+
+        public boolean isRestricted() {
+            return true;
+        }
+
+        public boolean preResolveVariables() {
+            return true;
+        }
+
+        public String since() {
+            return "3.3.0";
+        }
+
+        public Boolean runAsync() {
+            return null;
+        }
+
+        public Construct exec(int line_num, File f, Env environment, Construct... args) throws ConfigRuntimeException {
+            if(!(Boolean)Static.getPreferences().getPreference("allow-profiling")){
+                throw new ConfigRuntimeException("allow-profiling is currently off, you must set it to true in your preferences.", ExceptionType.SecurityException, line_num, f);
+            }
+            PERFORMANCE_LOGGING = Static.getBoolean(args[0]);
+            return new CVoid(line_num, f);
+        }
+        
+    }
+}
diff --git a/src/main/java/com/laytonsmith/core/functions/Permissions.java b/src/main/java/com/laytonsmith/core/functions/Permissions.java
new file mode 100644
index 0000000..17a0510
--- /dev/null
+++ b/src/main/java/com/laytonsmith/core/functions/Permissions.java
@@ -0,0 +1,16 @@
+/*
+ * To change this template, choose Tools | Templates
+ * and open the template in the editor.
+ */
+package com.laytonsmith.core.functions;
+
+/**
+ *
+ * @author Layton
+ */
+public class Permissions {
+    public String docs(){
+        return "Provides access to the server's underlying permissions system. Permissions functionality is only as good as the management"
+                + " system in place, however, and so not all functions may be supported on a given system.";
+    }
+}
diff --git a/src/main/java/com/laytonsmith/core/functions/Persistance.java b/src/main/java/com/laytonsmith/core/functions/Persistance.java
new file mode 100644
index 0000000..05a7506
--- /dev/null
+++ b/src/main/java/com/laytonsmith/core/functions/Persistance.java
@@ -0,0 +1,306 @@
+/*
+ * To change this template, choose Tools | Templates
+ * and open the template in the editor.
+ */
+package com.laytonsmith.core.functions;
+
+import com.laytonsmith.core.Env;
+import com.laytonsmith.core.Static;
+import com.laytonsmith.core.api;
+import com.laytonsmith.core.constructs.*;
+import com.laytonsmith.core.exceptions.CancelCommandException;
+import com.laytonsmith.core.exceptions.ConfigRuntimeException;
+import com.laytonsmith.core.exceptions.MarshalException;
+import com.laytonsmith.core.functions.Exceptions.ExceptionType;
+import java.io.File;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.List;
+import java.util.Map;
+import java.util.logging.Level;
+import java.util.logging.Logger;
+
+/**
+ *
+ * @author Layton
+ */
+public class Persistance {
+    public static String docs(){
+        return "Allows scripts to store data from execution to execution. See the guide on [[CommandHelper/Persistance|persistance]] for more information.";
+    }
+    
+    @api public static class store_value implements Function{
+
+        public String getName() {
+            return "store_value";
+        }
+
+        public Integer[] numArgs() {
+            return new Integer[]{2};
+        }
+
+        public String docs() {
+            return "void {key, value} Allows you to store a value, which can then be retrieved later. key must be a string containing"
+                    + " only letters, numbers, underscores. Periods may also be used, but they form a namespace, and have special meaning."
+                    + " (See get_values())";
+        }
+        
+        public ExceptionType[] thrown(){
+            return new ExceptionType[]{ExceptionType.FormatException};
+        }
+
+        public boolean isRestricted() {
+            return true;
+        }
+
+        public void varList(IVariableList varList) {}
+
+        public boolean preResolveVariables() {
+            return true;
+        }
+
+        public String since() {
+            return "3.0.2";
+        }
+
+        public Construct exec(int line_num, File f, Env env, Construct... args) throws CancelCommandException, ConfigRuntimeException {
+            String key = args[0].val();
+            String value = null;
+            try{
+                value = Construct.json_encode(args[1], line_num, f);
+            } catch(MarshalException e){
+                throw new ConfigRuntimeException(e.getMessage(), line_num, f);
+            }
+            char pc = '.';
+            for(int i = 0; i < key.length(); i++){
+                Character c = key.charAt(i);
+                if(i != 0){
+                    pc = key.charAt(i - 1);
+                }
+                if((i == 0 || i == key.length() - 1 || pc == '.') && c == '.'){
+                    throw new ConfigRuntimeException("Periods may only be used as seperators between namespaces.", ExceptionType.FormatException, line_num, f);
+                }
+                if(c != '_' && c != '.' && !Character.isLetterOrDigit(c)){
+                    throw new ConfigRuntimeException("Param 1 in store_value must only contain letters, digits, or underscores.",
+                            ExceptionType.FormatException, line_num, f);
+                }
+            }
+            Static.getPersistance().setValue(new String[]{"storage", key}, value);
+            try {
+                Static.getPersistance().save();
+            } catch (Exception ex) {
+                Logger.getLogger(Persistance.class.getName()).log(Level.SEVERE, null, ex);
+                throw new ConfigRuntimeException(ex.getMessage(), null, line_num, f, ex);
+            }
+            return new CVoid(line_num, f);
+        }
+        
+        public Boolean runAsync(){
+            //Because we do IO
+            return true;
+        }
+        
+    }
+    
+    @api public static class get_value implements Function{
+
+        public String getName() {
+            return "get_value";
+        }
+
+        public Integer[] numArgs() {
+            return new Integer[]{1};
+        }
+
+        public String docs() {
+            return "Mixed {key} Returns a stored value stored with store_value. If the key doesn't exist in storage, null"
+                    + " is returned. On a more detailed note: If the value stored in the persistance database is not actually a construct,"
+                    + " then null is also returned.";
+        }
+        
+        public ExceptionType[] thrown(){
+            return new ExceptionType[]{};
+        }
+
+        public boolean isRestricted() {
+            return true;
+        }
+
+        public void varList(IVariableList varList) {}
+
+        public boolean preResolveVariables() {
+            return true;
+        }
+
+        public String since() {
+            return "3.0.2";
+        }
+
+        public Construct exec(int line_num, File f, Env env, Construct... args) throws CancelCommandException, ConfigRuntimeException {            
+            Object o;
+            try {
+                Object obj = Static.getPersistance().getValue(new String[]{"storage", args[0].val()});
+                if(obj == null){
+                    return new CNull(line_num, f);
+                }
+                o = Construct.json_decode(obj.toString(), line_num, f);
+            } catch (MarshalException ex) {
+                throw new ConfigRuntimeException(ex.getMessage(), line_num, f);
+            }
+            try{
+                return (Construct)o;
+            } catch(ClassCastException e){
+                return new CNull(line_num, f);
+            }
+        }
+        public Boolean runAsync(){
+            //Because we do IO
+            return true;
+        }
+        
+    }
+    
+    @api public static class get_values implements Function{
+
+        public String getName() {
+            return "get_values";
+        }
+
+        public Integer[] numArgs() {
+            return new Integer[]{1};
+        }
+
+        public String docs() {
+            return "array {name.space} Returns all the values in a particular namespace"
+                    + " as an associative"
+                    + " array(key: value, key: value). Only full namespace matches are considered,"
+                    + " so if the key 'users.data.username.hi' existed in the database, and you tried"
+                    + " get_values('users.data.user'), nothing would be returned. The last segment in"
+                    + " a key is also considered a namespace, so 'users.data.username.hi' would return"
+                    + " a single value (in this case).";
+        }
+
+        public ExceptionType[] thrown() {
+            return new ExceptionType[]{};
+        }
+
+        public boolean isRestricted() {
+            return true;
+        }
+
+        public boolean preResolveVariables() {
+            return true;
+        }
+
+        public Boolean runAsync() {
+            return true;
+        }
+
+        public Construct exec(int line_num, File f, Env environment, Construct... args) throws ConfigRuntimeException {
+            com.laytonsmith.PureUtilities.Persistance p = Static.getPersistance();
+            List<String> keyChain = new ArrayList<String>();
+            keyChain.add("storage");
+            keyChain.addAll(Arrays.asList(args[0].val().split("\\.")));
+            List<Map.Entry<String, Object>> list = p.getNamespaceValues(keyChain.toArray(new String[]{}));
+            CArray ca = new CArray(line_num, f);
+            for(Map.Entry<String, Object> e : list){
+                try {
+                    String key = ((String)e.getKey()).replaceFirst("storage\\.", ""); //Get that junk out of here
+                    ca.set(new CString(key, line_num, f), 
+                            Construct.json_decode(e.getValue().toString(), line_num, f));
+                } catch (MarshalException ex) {
+                    Logger.getLogger(Persistance.class.getName()).log(Level.SEVERE, null, ex);
+                }
+            }
+            return ca;
+        }
+
+        public String since() {
+            return "3.3.0";
+        }
+        
+    }
+    
+    @api public static class has_value implements Function{
+
+        public String getName() {
+            return "has_value";
+        }
+
+        public Integer[] numArgs() {
+            return new Integer[]{1};
+        }
+
+        public String docs() {
+            return "boolean {key} Returns whether or not there is data stored at the specified key in the Persistance database.";
+        }
+
+        public ExceptionType[] thrown() {
+            return null;
+        }
+
+        public boolean isRestricted() {
+            return true;
+        }
+
+        public void varList(IVariableList varList) {}
+
+        public boolean preResolveVariables() {
+            return true;
+        }
+
+        public String since() {
+            return "3.1.2";
+        }
+
+        public Boolean runAsync() {
+            return true;
+        }
+
+        public Construct exec(int line_num, File f, Env env, Construct... args) throws ConfigRuntimeException {
+            return new CBoolean(Static.getPersistance().isKeySet(new String[]{"storage", args[0].val()}), line_num, f);
+        }
+        
+    }
+    
+    @api public static class clear_value implements Function{
+
+        public String getName() {
+            return "clear_value";
+        }
+
+        public Integer[] numArgs() {
+            return new Integer[]{1};
+        }
+
+        public String docs() {
+            return "void {key} Completely removes a value from storage. Calling has_value(key) after this call will return false.";
+        }
+
+        public ExceptionType[] thrown() {
+            return new ExceptionType[]{};
+        }
+
+        public boolean isRestricted() {
+            return true;
+        }
+
+        public boolean preResolveVariables() {
+            return true;
+        }
+
+        public String since() {
+            return "3.3.0";
+        }
+
+        public Boolean runAsync() {
+            return null;
+        }
+
+        public Construct exec(int line_num, File f, Env environment, Construct... args) throws ConfigRuntimeException {
+            Static.getPersistance().setValue(new String[]{"storage", args[0].val()}, null);
+            return new CVoid(line_num, f);
+        }
+        
+    }
+}
diff --git a/src/main/java/com/laytonsmith/core/functions/PlayerManagement.java b/src/main/java/com/laytonsmith/core/functions/PlayerManagement.java
new file mode 100644
index 0000000..fe6925e
--- /dev/null
+++ b/src/main/java/com/laytonsmith/core/functions/PlayerManagement.java
@@ -0,0 +1,2844 @@
+/*
+ * To change this template, choose Tools | Templates
+ * and open the template in the editor.
+ */
+package com.laytonsmith.core.functions;
+
+import com.laytonsmith.abstraction.*;
+import com.laytonsmith.abstraction.blocks.MCBlock;
+import com.laytonsmith.core.Env;
+import com.laytonsmith.core.ObjectGenerator;
+import com.laytonsmith.core.Static;
+import com.laytonsmith.core.api;
+import com.laytonsmith.core.constructs.*;
+import com.laytonsmith.core.exceptions.CancelCommandException;
+import com.laytonsmith.core.exceptions.ConfigRuntimeException;
+import com.laytonsmith.core.functions.Exceptions.ExceptionType;
+import java.io.File;
+import java.util.ArrayList;
+
+
+/**
+ *
+ * @author Layton
+ */
+public class PlayerManagement {
+
+    public static String docs() {
+        return "This class of functions allow players to be managed";
+    }
+
+    @api
+    public static class player implements Function {
+
+        public String getName() {
+            return "player";
+        }
+
+        public Integer[] numArgs() {
+            return new Integer[]{0, 1};
+        }
+
+        public Construct exec(int line_num, File f, Env env, Construct... args) throws CancelCommandException, ConfigRuntimeException {
+            MCCommandSender p = env.GetCommandSender();
+            if(p == null){
+                return new CNull(line_num, f);
+            }
+            
+            if (args.length == 1) {
+                p = Static.getServer().getPlayer(args[0].val());
+            }
+            
+            if (p.instanceofPlayer()) {
+                return new CString(((MCPlayer) p).getName(), line_num, f);
+            } else if (p.instanceofMCConsoleCommandSender()) {
+                return new CString("~console", line_num, f);
+            } else {
+                return new CNull(line_num, f);
+            }
+        }
+
+        public String docs() {
+            return "string {[playerName]} Returns the full name of the partial Player name specified or the Player running the command otherwise. If the command is being run from"
+                    + " the console, then the string '~console' is returned. If the command is coming from elsewhere, null is returned, and the behavior is undefined."
+                    + " Note that most functions won't support the user '~console' (they'll throw a PlayerOfflineException), but you can use this to determine"
+                    + " where a command is being run from.";
+        }
+
+        public ExceptionType[] thrown() {
+            return new ExceptionType[]{};
+        }
+
+        public boolean isRestricted() {
+            return false;
+        }
+
+        public void varList(IVariableList varList) {
+        }
+
+        public boolean preResolveVariables() {
+            return true;
+        }
+
+        public String since() {
+            return "3.0.1";
+        }
+
+        public Boolean runAsync() {
+            return false;
+        }
+    }
+
+    @api
+    public static class all_players implements Function {
+
+        public String getName() {
+            return "all_players";
+        }
+
+        public Integer[] numArgs() {
+            return new Integer[]{0};
+        }
+
+        public Construct exec(int line_num, File f, Env env, Construct... args) throws CancelCommandException, ConfigRuntimeException {
+            MCPlayer[] pa = Static.getServer().getOnlinePlayers();
+            CString[] sa = new CString[pa.length];
+            for (int i = 0; i < pa.length; i++) {
+                sa[i] = new CString(pa[i].getName(), line_num, f);
+            }
+            return new CArray(line_num, f, sa);
+        }
+
+        public String docs() {
+            return "array {} Returns an array of all the player names of all the online players on the server";
+        }
+
+        public ExceptionType[] thrown() {
+            return new ExceptionType[]{};
+        }
+
+        public boolean isRestricted() {
+            return true;
+        }
+
+        public void varList(IVariableList varList) {
+        }
+
+        public boolean preResolveVariables() {
+            return true;
+        }
+
+        public String since() {
+            return "3.0.1";
+        }
+
+        public Boolean runAsync() {
+            return false;
+        }
+    }
+
+    @api
+    public static class ploc implements Function {
+
+        public String getName() {
+            return "ploc";
+        }
+
+        public Integer[] numArgs() {
+            return new Integer[]{0, 1};
+        }
+
+        public Construct exec(int line_num, File f, Env env, Construct... args) throws CancelCommandException, ConfigRuntimeException {
+            MCCommandSender p = env.GetCommandSender();
+            MCPlayer m = null;
+            if (p instanceof MCPlayer) {
+                m = (MCPlayer) p;
+            }
+            if (args.length == 1) {
+                m = Static.getServer().getPlayer(args[0].val());
+                if (m == null || !m.isOnline()) {
+                    throw new ConfigRuntimeException("The player is not online",
+                            ExceptionType.PlayerOfflineException, line_num, f);
+                }
+            }
+            if (m == null) {
+                throw new ConfigRuntimeException("player was not specified", ExceptionType.PlayerOfflineException, line_num, f);
+            }
+            MCLocation l = m.getLocation();
+            MCWorld w = m.getWorld();
+            return new CArray(line_num, f,
+                    new CDouble(l.getX(), line_num, f),
+                    new CDouble(l.getY() - 1, line_num, f),
+                    new CDouble(l.getZ(), line_num, f),
+                    new CString(w.getName(), line_num, f));
+        }
+
+        public String docs() {
+            return "array {[playerName]} Returns an array of x, y, z coords of the player specified, or the player running the command otherwise. Note that the y coordinate is"
+                    + " in relation to the block the player is standing on. The array returned will also include the player's world in index 3 of the array.";
+        }
+
+        public ExceptionType[] thrown() {
+            return new ExceptionType[]{ExceptionType.PlayerOfflineException};
+        }
+
+        public boolean isRestricted() {
+            return true;
+        }
+
+        public void varList(IVariableList varList) {
+        }
+
+        public boolean preResolveVariables() {
+            return true;
+        }
+
+        public String since() {
+            return "3.0.1";
+        }
+
+        public Boolean runAsync() {
+            return false;
+        }
+    }
+
+    @api
+    public static class set_ploc implements Function {
+
+        public String getName() {
+            return "set_ploc";
+        }
+
+        public Integer[] numArgs() {
+            return new Integer[]{1, 2, 3, 4};
+        }
+
+        public String docs() {
+            return "boolean {[player], locationArray | [player], x, y, z} Sets the location of the player to the specified coordinates. If the coordinates"
+                    + " are not valid, or the player was otherwise prevented from moving, false is returned, otherwise true. If player is omitted, "
+                    + " the current player is used. Note that 1 is automatically added to the y component, which means that sending a player to"
+                    + " x, y, z coordinates shown with F3 will work as expected, instead of getting them stuck inside the floor. ";
+        }
+
+        public ExceptionType[] thrown() {
+            return new ExceptionType[]{ExceptionType.CastException, ExceptionType.LengthException, ExceptionType.PlayerOfflineException, ExceptionType.FormatException};
+        }
+
+        public boolean isRestricted() {
+            return true;
+        }
+
+        public void varList(IVariableList varList) {
+        }
+
+        public boolean preResolveVariables() {
+            return true;
+        }
+
+        public String since() {
+            return "3.1.0";
+        }
+
+        public Boolean runAsync() {
+            return false;
+        }
+
+        public Construct exec(int line_num, File f, Env env, Construct... args) throws CancelCommandException, ConfigRuntimeException {
+            MCCommandSender p = env.GetCommandSender();
+            String MCPlayer = null;
+            double x;
+            double y;
+            double z;
+            MCPlayer m = null;
+            MCLocation l = null;
+            if (args.length == 1) {
+                if (args[0] instanceof CArray) {
+                    CArray ca = (CArray) args[0];
+                    l = ObjectGenerator.GetGenerator().location(ca, (p instanceof MCPlayer ? ((MCPlayer) p).getWorld() : null), line_num, f);
+                    x = Static.getNumber(ca.get(0, line_num, f));
+                    y = Static.getNumber(ca.get(1, line_num, f));
+                    z = Static.getNumber(ca.get(2, line_num, f));
+                    if (p instanceof MCPlayer) {
+                        m = ((MCPlayer) p);
+                    }
+
+                } else {
+                    throw new ConfigRuntimeException("Expecting an array at parameter 1 of set_ploc",
+                            ExceptionType.CastException, line_num, f);
+                }
+            } else if (args.length == 2) {
+                if (args[1] instanceof CArray) {
+                    CArray ca = (CArray) args[1];
+                    MCPlayer = args[0].val();
+                    l = ObjectGenerator.GetGenerator().location(ca, Static.getServer().getPlayer(MCPlayer).getWorld(), line_num, f);
+                    x = l.getX();
+                    y = l.getY();
+                    z = l.getZ();
+                } else {
+                    throw new ConfigRuntimeException("Expecting parameter 2 to be an array in set_ploc",
+                            ExceptionType.CastException, line_num, f);
+                }
+            } else if (args.length == 3) {
+                if (p instanceof MCPlayer) {
+                    m = (MCPlayer) p;
+                }
+                x = Static.getNumber(args[0]);
+                y = Static.getNumber(args[1]);
+                z = Static.getNumber(args[2]);
+                l = m.getLocation();
+            } else {
+                MCPlayer = args[0].val();
+                x = Static.getNumber(args[1]);
+                y = Static.getNumber(args[2]);
+                z = Static.getNumber(args[3]);
+                l = StaticLayer.GetLocation(Static.getServer().getPlayer(MCPlayer).getWorld(), x, y, z, 0, 0);
+            }
+            if (m == null && MCPlayer != null) {
+                m = Static.getServer().getPlayer(MCPlayer);
+            }
+            if (m == null || !m.isOnline()) {
+                throw new ConfigRuntimeException("That player is not online",
+                        ExceptionType.PlayerOfflineException, line_num, f);
+            }
+            return new CBoolean(m.teleport(StaticLayer.GetLocation(l.getWorld(), x, y + 1, z, m.getLocation().getYaw(), m.getLocation().getPitch())), line_num, f);
+        }
+    }
+
+    @api
+    public static class pcursor implements Function {
+
+        public String getName() {
+            return "pcursor";
+        }
+
+        public Integer[] numArgs() {
+            return new Integer[]{0, 1};
+        }
+
+        public String docs() {
+            return "array {[player]} Returns an array with the (x, y, z, world) coordinates of the block the player has highlighted"
+                    + " in their crosshairs. If player is omitted, the current player is used. If the block is too far, a"
+                    + " RangeException is thrown.";
+        }
+
+        public ExceptionType[] thrown() {
+            return new ExceptionType[]{ExceptionType.PlayerOfflineException, ExceptionType.RangeException};
+        }
+
+        public boolean isRestricted() {
+            return true;
+        }
+
+        public void varList(IVariableList varList) {
+        }
+
+        public boolean preResolveVariables() {
+            return true;
+        }
+
+        public String since() {
+            return "3.0.2";
+        }
+
+        public Construct exec(int line_num, File f, Env env, Construct... args) throws CancelCommandException, ConfigRuntimeException {
+            MCCommandSender p = env.GetCommandSender();
+            MCPlayer m = null;
+            if (args.length == 0) {
+                if (p instanceof MCPlayer) {
+                    m = (MCPlayer) p;
+                }
+            } else {
+                m = Static.getServer().getPlayer(args[0].val());
+                if (m == null || !m.isOnline()) {
+                    throw new ConfigRuntimeException("That player is not online",
+                            ExceptionType.PlayerOfflineException, line_num, f);
+                }
+            }
+            if (m != null) {
+                MCBlock b = m.getTargetBlock(null, 200);
+                if (b == null) {
+                    throw new ConfigRuntimeException("No block in sight, or block too far",
+                            ExceptionType.RangeException, line_num, f);
+                }
+                return new CArray(line_num, f, new CInt(b.getX(), line_num, f),
+                        new CInt(b.getY(), line_num, f),
+                        new CInt(b.getZ(), line_num, f),
+                        new CString(b.getWorld().getName(), line_num, f));
+            } else {
+                throw new ConfigRuntimeException("player was not specified", ExceptionType.PlayerOfflineException, line_num, f);
+            }
+        }
+
+        public Boolean runAsync() {
+            return false;
+        }
+    }
+
+    @api
+    public static class kill implements Function {
+
+        public String getName() {
+            return "kill";
+        }
+
+        public Integer[] numArgs() {
+            return new Integer[]{0, 1};
+        }
+
+        public Construct exec(int line_num, File f, Env env, Construct... args) throws CancelCommandException, ConfigRuntimeException {
+            MCCommandSender p = env.GetCommandSender();
+            MCPlayer m = null;
+            if (args.length == 1) {
+                m = Static.getServer().getPlayer(args[0].val());
+            } else {
+                if (p instanceof MCPlayer) {
+                    m = (MCPlayer) p;
+                }
+            }
+            if (m == null || !m.isOnline()) {
+                throw new ConfigRuntimeException("The player is not online",
+                        ExceptionType.PlayerOfflineException, line_num, f);
+            }
+            m.setHealth(0);
+            return new CVoid(line_num, f);
+        }
+
+        public String docs() {
+            return "void {[playerName]} Kills the specified player, or the current player if it is omitted";
+        }
+
+        public ExceptionType[] thrown() {
+            return new ExceptionType[]{ExceptionType.PlayerOfflineException};
+        }
+
+        public boolean isRestricted() {
+            return true;
+        }
+
+        public void varList(IVariableList varList) {
+        }
+
+        public boolean preResolveVariables() {
+            return true;
+        }
+
+        public String since() {
+            return "3.0.1";
+        }
+
+        public Boolean runAsync() {
+            return false;
+        }
+    }
+
+    @api
+    public static class pgroup implements Function {
+
+        public String getName() {
+            return "pgroup";
+        }
+
+        public Integer[] numArgs() {
+            return new Integer[]{0, 1};
+        }
+
+        public Construct exec(int line_num, File f, Env env, Construct... args) throws CancelCommandException, ConfigRuntimeException {
+            MCCommandSender p = env.GetCommandSender();
+            MCPlayer m = null;
+            if (args.length == 0) {
+                if (p instanceof MCPlayer) {
+                    m = (MCPlayer) p;
+                }
+            } else {
+                m = Static.getServer().getPlayer(args[0].val());
+            }
+
+            if (m == null) {
+                throw new ConfigRuntimeException("player was not specified, or is offline", ExceptionType.PlayerOfflineException, line_num, f);
+            }
+            if (m == null || !m.isOnline()) {
+                throw new ConfigRuntimeException("That player is not online.",
+                        ExceptionType.PlayerOfflineException, line_num, f);
+            }
+            String[] sa = Static.getPermissionsResolverManager().getGroups(m.getName());
+            Construct[] ca = new Construct[sa.length];
+            for (int i = 0; i < sa.length; i++) {
+                ca[i] = new CString(sa[i], line_num, f);
+            }
+            CArray a = new CArray(line_num, f, ca);
+            return a;
+        }
+
+        public String docs() {
+            return "array {[playerName]} Returns an array of the groups a player is in. If playerName is omitted, the current player is used.";
+        }
+
+        public ExceptionType[] thrown() {
+            return new ExceptionType[]{ExceptionType.PlayerOfflineException};
+        }
+
+        public boolean isRestricted() {
+            return true;
+        }
+
+        public void varList(IVariableList varList) {
+        }
+
+        public boolean preResolveVariables() {
+            return true;
+        }
+
+        public String since() {
+            return "3.0.1";
+        }
+
+        public Boolean runAsync() {
+            return false;
+        }
+    }
+
+    @api
+    public static class pinfo implements Function {
+
+        public String getName() {
+            return "pinfo";
+        }
+
+        public Integer[] numArgs() {
+            return new Integer[]{0, 1, 2};
+        }
+
+        public String docs() {
+            return "mixed {[pName], [value]} Returns various information about the player specified, or the current player if no argument was given."
+                    + "If value is set, it should be an integer of one of the following indexes, and only that information for that index"
+                    + " will be returned. Otherwise if value is not specified (or is -1), it returns an array of"
+                    + " information with the following pieces of information in the specified index: "
+                    + "<ul><li>0 - player's name; This will return the player's exact name, "
+                    + " even if called with a partial match.</li><li>1 - player's location; an array of the player's xyz coordinates</li><li>2 - player's cursor; an array of the "
+                    + "location of the player's cursor, or null if the block is out of sight.</li><li>3 - player's IP; Returns the IP address of this player.</li><li>4 - Display name; The name that is used when the"
+                    + " player's name is displayed on screen typically. </li><li>5 - player's health; Gets the current health of the player, which will be an int"
+                    + " from 0-20.</li><li>6 - Item in hand; The value returned by this will be similar to the value returned by get_block_at()</li><li>7 - "
+                    + "World name; Gets the name of the world this player is in.</li><li>8 - Is Op; true or false if this player is an op.</li><li>9 - player groups;"
+                    + " An array of the permissions groups the player is in.</li><li>10 - The player's hostname (or IP if a hostname can't be found)</li>"
+                    + " <li>11 - Is sneaking?</li></ul>";
+        }
+
+        public ExceptionType[] thrown() {
+            return new ExceptionType[]{ExceptionType.PlayerOfflineException, ExceptionType.RangeException, ExceptionType.CastException};
+        }
+
+        public boolean isRestricted() {
+            return true;
+        }
+
+        public void varList(IVariableList varList) {
+        }
+
+        public boolean preResolveVariables() {
+            return true;
+        }
+
+        public String since() {
+            return "3.1.0";
+        }
+
+        public Boolean runAsync() {
+            return false;
+        }
+
+        public Construct exec(int line_num, File f, Env env, Construct... args) throws CancelCommandException, ConfigRuntimeException {
+            MCCommandSender m = env.GetCommandSender();
+            String MCPlayer = "";
+            int index = -1;
+            if (args.length == 0) {
+                MCPlayer = (m instanceof MCPlayer ? ((MCPlayer) m).getName() : null);
+                index = -1;
+            } else if (args.length == 1) {
+                MCPlayer = args[0].val();
+                index = -1;
+            } else {
+                MCPlayer = args[0].val();
+                index = (int) Static.getInt(args[1]);
+            }
+            if (MCPlayer == null) {
+                throw new ConfigRuntimeException("player was not specified", ExceptionType.PlayerOfflineException, line_num, f);
+            }
+            MCPlayer p = Static.getServer().getPlayer(MCPlayer);
+            if (p == null || !p.isOnline()) {
+                throw new ConfigRuntimeException("The specified player is not online",
+                        ExceptionType.PlayerOfflineException, line_num, f);
+            }
+            if (index < -1 || index > 11) {
+                throw new ConfigRuntimeException("pinfo expects the index to be between -1 and 11",
+                        ExceptionType.RangeException, line_num, f);
+            }
+            assert index >= -1 && index <= 11;
+            ArrayList<Construct> retVals = new ArrayList<Construct>();
+            if (index == 0 || index == -1) {
+                //MCPlayer name 
+                retVals.add(new CString(p.getName(), line_num, f));
+            }
+            if (index == 1 || index == -1) {
+                //MCPlayer location
+                retVals.add(new CArray(line_num, f, new CDouble(p.getLocation().getX(), line_num, f),
+                        new CDouble(p.getLocation().getY() - 1, line_num, f), new CDouble(p.getLocation().getZ(), line_num, f)));
+            }
+            if (index == 2 || index == -1) {
+                //MCPlayer cursor
+                MCBlock b = p.getTargetBlock(null, 200);
+                if (b == null) {
+                    retVals.add(new CNull(line_num, f));
+                } else {
+                    retVals.add(new CArray(line_num, f, new CInt(b.getX(), line_num, f), new CInt(b.getY(), line_num, f), new CInt(b.getZ(), line_num, f)));
+                }
+            }
+            if (index == 3 || index == -1) {
+                //MCPlayer IP                
+                retVals.add(new CString(p.getAddress().getAddress().getHostAddress(), line_num, f));
+            }
+            if (index == 4 || index == -1) {
+                //Display name
+                retVals.add(new CString(p.getDisplayName(), line_num, f));
+            }
+            if (index == 5 || index == -1) {
+                //MCPlayer health
+                retVals.add(new CInt((long) p.getHealth(), line_num, f));
+            }
+            if (index == 6 || index == -1) {
+                //Item in hand
+                MCItemStack is = p.getItemInHand();
+                byte data = 0;
+                if (is.getData() != null) {
+                    data = is.getData().getData();
+                }
+                retVals.add(new CString(is.getTypeId() + ":" + data, line_num, f));
+            }
+            if (index == 7 || index == -1) {
+                //World name
+                retVals.add(new CString(p.getWorld().getName(), line_num, f));
+            }
+            if (index == 8 || index == -1) {
+                //Is op
+                retVals.add(new CBoolean(p.isOp(), line_num, f));
+            }
+            if (index == 9 || index == -1) {
+                //MCPlayer groups
+                String[] sa = Static.getPermissionsResolverManager().getGroups(p.getName());
+                Construct[] ca = new Construct[sa.length];
+                for (int i = 0; i < sa.length; i++) {
+                    ca[i] = new CString(sa[i], line_num, f);
+                }
+                CArray a = new CArray(line_num, f, ca);
+                retVals.add(a);
+            }
+            if (index == 10 || index == -1) {
+                retVals.add(new CString(p.getAddress().getHostName(), line_num, f));
+            }
+            if(index == 11 || index == -1){
+                retVals.add(new CBoolean(p.isSneaking(), line_num, f));
+            }
+            if (retVals.size() == 1) {
+                return retVals.get(0);
+            } else {
+                CArray ca = new CArray(line_num, f);
+                for (Construct c : retVals) {
+                    ca.push(c);
+                }
+                return ca;
+            }
+        }
+    }
+
+    @api
+    public static class pworld implements Function {
+
+        public String getName() {
+            return "pworld";
+        }
+
+        public Integer[] numArgs() {
+            return new Integer[]{0, 1};
+        }
+
+        public String docs() {
+            return "string {[playerName]} Gets the world of the player specified, or the current player, if playerName isn't specified.";
+        }
+
+        public ExceptionType[] thrown() {
+            return new ExceptionType[]{ExceptionType.PlayerOfflineException};
+        }
+
+        public boolean isRestricted() {
+            return true;
+        }
+
+        public void varList(IVariableList varList) {
+        }
+
+        public boolean preResolveVariables() {
+            return true;
+        }
+
+        public String since() {
+            return "3.1.0";
+        }
+
+        public Boolean runAsync() {
+            return true;
+        }
+
+        public Construct exec(int line_num, File f, Env env, Construct... args) throws CancelCommandException, ConfigRuntimeException {
+            MCCommandSender p = env.GetCommandSender();
+            MCPlayer m = null;
+            if (args.length == 0) {
+                if (p instanceof MCPlayer) {
+                    m = (MCPlayer) p;
+                }
+            } else {
+                m = Static.getServer().getPlayer(args[0].val());
+                if (m == null || !m.isOnline()) {
+                    throw new ConfigRuntimeException("That player is not online",
+                            ExceptionType.PlayerOfflineException, line_num, f);
+                }
+            }
+            return new CString(m.getWorld().getName(), line_num, f);
+        }
+    }
+
+    @api
+    public static class kick implements Function {
+
+        public String getName() {
+            return "kick";
+        }
+
+        public Integer[] numArgs() {
+            return new Integer[]{0, 1, 2};
+        }
+
+        public String docs() {
+            return "void {[playerName], [message]} Kicks the specified player, with an optional message. If no message is specified, "
+                    + "\"You have been kicked\" is used. If no player is specified, the current player is used, with the default message.";
+        }
+
+        public ExceptionType[] thrown() {
+            return new ExceptionType[]{ExceptionType.PlayerOfflineException};
+        }
+
+        public boolean isRestricted() {
+            return true;
+        }
+
+        public void varList(IVariableList varList) {
+        }
+
+        public boolean preResolveVariables() {
+            return true;
+        }
+
+        public String since() {
+            return "3.1.0";
+        }
+
+        public Boolean runAsync() {
+            return false;
+        }
+
+        public Construct exec(int line_num, File f, Env env, Construct... args) throws CancelCommandException, ConfigRuntimeException {
+            MCCommandSender p = env.GetCommandSender();
+            String message = "You have been kicked";
+            MCPlayer m = null;
+            if (args.length == 0) {
+                if (p instanceof MCPlayer) {
+                    m = (MCPlayer) p;
+                }
+            }
+            if (args.length >= 1) {
+                m = Static.getServer().getPlayer(args[0].val());
+            }
+            if (args.length >= 2) {
+                message = args[1].val();
+            }
+            MCPlayer ptok = m;
+            if (ptok != null && ptok.isOnline()) {
+                ptok.kickPlayer(message);
+                return new CVoid(line_num, f);
+            } else {
+                throw new ConfigRuntimeException("The specified player does not seem to be online",
+                        ExceptionType.PlayerOfflineException, line_num, f);
+            }
+        }
+    }
+
+    @api
+    public static class set_display_name implements Function {
+
+        public String getName() {
+            return "set_display_name";
+        }
+
+        public Integer[] numArgs() {
+            return new Integer[]{1, 2};
+        }
+
+        public String docs() {
+            return "void {playerName, newDisplayName | newDisplayName} Sets a player's display name. If the second usage is used,"
+                    + " it sets the display name of the player running the command. See reset_display_name also. playerName, as well"
+                    + " as all CommandHelper commands expect the player's real name, not their display name.";
+        }
+
+        public ExceptionType[] thrown() {
+            return new ExceptionType[]{ExceptionType.PlayerOfflineException};
+        }
+
+        public boolean isRestricted() {
+            return true;
+        }
+
+        public void varList(IVariableList varList) {
+        }
+
+        public boolean preResolveVariables() {
+            return true;
+        }
+
+        public String since() {
+            return "3.1.2";
+        }
+
+        public Boolean runAsync() {
+            return false;
+        }
+
+        public Construct exec(int line_num, File f, Env env, Construct... args) throws CancelCommandException, ConfigRuntimeException {
+            MCCommandSender p = env.GetCommandSender();
+            MCPlayer MCPlayer = null;
+            String name;
+            if (args.length == 1) {
+                if (p instanceof MCPlayer) {
+                    MCPlayer = (MCPlayer) p;
+                }
+                name = args[0].val();
+            } else {
+                MCPlayer = p.getServer().getPlayer(args[0].val());
+                name = args[1].val();
+            }
+            if (MCPlayer == null || !MCPlayer.isOnline()) {
+                throw new ConfigRuntimeException("That player is not online",
+                        ExceptionType.PlayerOfflineException, line_num, f);
+            }
+            MCPlayer.setDisplayName(name);
+            return new CVoid(line_num, f);
+        }
+    }
+
+    @api
+    public static class reset_display_name implements Function {
+
+        public String getName() {
+            return "reset_display_name";
+        }
+
+        public Integer[] numArgs() {
+            return new Integer[]{0, 1};
+        }
+
+        public String docs() {
+            return "void {[playerName]} Resets a player's display name to their real name. If playerName isn't specified, defaults to the"
+                    + " player running the command.";
+        }
+
+        public ExceptionType[] thrown() {
+            return new ExceptionType[]{ExceptionType.PlayerOfflineException};
+        }
+
+        public boolean isRestricted() {
+            return true;
+        }
+
+        public void varList(IVariableList varList) {
+        }
+
+        public boolean preResolveVariables() {
+            return true;
+        }
+
+        public String since() {
+            return "3.1.2";
+        }
+
+        public Boolean runAsync() {
+            return false;
+        }
+
+        public Construct exec(int line_num, File f, Env env, Construct... args) throws CancelCommandException, ConfigRuntimeException {
+            MCCommandSender p = env.GetCommandSender();
+            MCPlayer MCPlayer = null;
+            if (args.length == 0) {
+                if (p instanceof MCPlayer) {
+                    MCPlayer = (MCPlayer) p;
+                }
+            } else {
+                MCPlayer = p.getServer().getPlayer(args[0].val());
+            }
+            if (MCPlayer == null || !MCPlayer.isOnline()) {
+                throw new ConfigRuntimeException("That player is not online",
+                        ExceptionType.PlayerOfflineException, line_num, f);
+            }
+            MCPlayer.setDisplayName(MCPlayer.getName());
+            return new CVoid(line_num, f);
+        }
+    }
+
+    @api
+    public static class pfacing implements Function {
+
+        public String getName() {
+            return "pfacing";
+        }
+
+        public Integer[] numArgs() {
+            return new Integer[]{0, 1, 2, 3};
+        }
+
+        public String docs() {
+            return "mixed {F | yaw, pitch | player, F | player, yaw, pitch | player | &lt;none&gt;} Sets the direction the player is facing. When using the first variation, expects an integer 0-3, which will"
+                    + " set the direction the player faces using their existing pitch (up and down) but sets their yaw (left and right) to one of the"
+                    + " cardinal directions, as follows: 0 - West, 1 - South, 2 - East, 3 - North, which corresponds to the directions given by F when"
+                    + " viewed with F3. In the second variation, specific yaw and pitches can be provided. If the player is not specified, the current player"
+                    + " is used. If just the player is specified, that player's yaw and pitch are returned as an array, or if no arguments are given, the"
+                    + " player running the command's yaw and pitch are returned as an array. The function returns void when setting the values. (Note that while this"
+                    + " function looks like it has ambiguous arguments, players cannot be named numbers.) A note on numbers: The values returned by the getter will always be"
+                    + " as such: pitch will always be a number between 90 and -90, with -90 being the player looking up, and 90 being the player looking down. Yaw will"
+                    + " always be a number between 0 and 359.9~. When using it as a setter, pitch must be a number between -90 and 90, and yaw may be any number."
+                    + " If the number given is not between 0 and 359.9~, it will be normalized first. 0 is dead west, 90 is north, etc.";
+        }
+
+        public ExceptionType[] thrown() {
+            return new ExceptionType[]{ExceptionType.PlayerOfflineException, ExceptionType.RangeException, ExceptionType.CastException};
+        }
+
+        public boolean isRestricted() {
+            return true;
+        }
+
+        public void varList(IVariableList varList) {
+        }
+
+        public boolean preResolveVariables() {
+            return true;
+        }
+
+        public String since() {
+            return "3.1.3";
+        }
+
+        public Boolean runAsync() {
+            return false;
+        }
+
+        public Construct exec(int line_num, File f, Env env, Construct... args) throws ConfigRuntimeException {
+            MCCommandSender p = env.GetCommandSender();
+            //Getter
+            if (args.length == 0 || args.length == 1) {
+                MCLocation l = null;
+                if (args.length == 0) {
+                    if (p instanceof MCPlayer) {
+                        l = ((MCPlayer) p).getLocation();
+                    }
+                } else if (args.length == 1) {
+                    //if it's a number, we are setting F. Otherwise, it's a getter for the MCPlayer specified.
+                    try {
+                        Integer.parseInt(args[0].val());
+                    } catch (NumberFormatException e) {
+                        MCPlayer p2 = p.getServer().getPlayer(args[0].val());
+                        if (p2 == null || !p2.isOnline()) {
+                            throw new ConfigRuntimeException("The specified player is offline",
+                                    ExceptionType.PlayerOfflineException, line_num, f);
+                        } else {
+                            l = p2.getLocation();
+                        }
+                    }
+                }
+                if (l != null) {
+                    float yaw = l.getYaw();
+                    float pitch = l.getPitch();
+                    //normalize yaw
+                    if (yaw < 0) {
+                        yaw = (((yaw) % 360) + 360);
+                    }
+                    return new CArray(line_num, f, new CDouble(yaw, line_num, f), new CDouble(pitch, line_num, f));
+                }
+            }
+            //Setter
+            MCPlayer toSet = null;
+            float yaw = 0;
+            float pitch = 0;
+            if (args.length == 1) {
+                //We are setting F for this MCPlayer
+                if (p instanceof MCPlayer) {
+                    toSet = (MCPlayer) p;
+                    pitch = toSet.getLocation().getPitch();
+                }
+                int g = (int) Static.getInt(args[0]);
+                if (g < 0 || g > 3) {
+                    throw new ConfigRuntimeException("The F specifed must be from 0 to 3",
+                            ExceptionType.RangeException, line_num, f);
+                }
+                yaw = g * 90;
+            } else if (args.length == 2) {
+                //Either we are setting this MCPlayer's pitch and yaw, or we are setting the specified MCPlayer's F.
+                //Check to see if args[0] is a number
+                try {
+                    Float.parseFloat(args[0].val());
+                    //It's the yaw, pitch variation
+                    if (p instanceof MCPlayer) {
+                        toSet = (MCPlayer) p;
+                    }
+                    yaw = (float) Static.getNumber(args[0]);
+                    pitch = (float) Static.getNumber(args[1]);
+                } catch (NumberFormatException e) {
+                    //It's the MCPlayer, F variation
+                    toSet = Static.getServer().getPlayer(args[0].val());
+                    pitch = toSet.getLocation().getPitch();
+                    int g = (int) Static.getInt(args[1]);
+                    if (g < 0 || g > 3) {
+                        throw new ConfigRuntimeException("The F specifed must be from 0 to 3",
+                                ExceptionType.RangeException, line_num, f);
+                    }
+                    yaw = g * 90;
+                }
+            } else if (args.length == 3) {
+                //It's the MCPlayer, yaw, pitch variation
+                toSet = Static.getServer().getPlayer(args[0].val());
+                yaw = (float) Static.getNumber(args[1]);
+                pitch = (float) Static.getNumber(args[2]);
+            }
+
+            //Error check our data
+            if (toSet == null || !toSet.isOnline()) {
+                throw new ConfigRuntimeException("The specified player is not online",
+                        ExceptionType.PlayerOfflineException, line_num, f);
+            }
+            if (pitch > 90 || pitch < -90) {
+                throw new ConfigRuntimeException("pitch must be between -90 and 90",
+                        ExceptionType.RangeException, line_num, f);
+            }
+            MCLocation l = toSet.getLocation().clone();
+            l.setPitch(pitch);
+            l.setYaw(yaw);
+            toSet.teleport(l);
+            return new CVoid(line_num, f);
+        }
+    }
+
+    @api
+    public static class pinv implements Function {
+
+        public String getName() {
+            return "pinv";
+        }
+
+        public Integer[] numArgs() {
+            return new Integer[]{0, 1, 2};
+        }
+
+        public String docs() {
+            return "mixed {[player, [index]]} Gets the inventory information for the specified player, or the current player if none specified. If the index is specified, only the slot "
+                    + " given will be returned."
+                    + " The index of the array in the array is 0 - 35, 100 - 103, which corresponds to the slot in the players inventory. To access armor"
+                    + " slots, you may also specify the index. (100 - 103). The quick bar is 0 - 8. If index is null, the item in the player's hand is returned, regardless"
+                    + " of what slot is selected. If there is no item at the slot specified, null is returned."
+                    + " If all slots are requested, an associative array of item objects is returned, and if"
+                    + " only one item is requested, just that single item object is returned. An item object"
+                    + " consists of the following associative array(type: The id of the item, data: The data value of the item,"
+                    + " or the damage if a damagable item, qty: The number of items in their inventory, enchants: An array"
+                    + " of enchant objects, with 0 or more associative arrays which look like:"
+                    + " array(etype: The type of enchantment, elevel: The strength of the enchantment))";
+        }
+
+        public ExceptionType[] thrown() {
+            return new ExceptionType[]{ExceptionType.PlayerOfflineException, ExceptionType.CastException, ExceptionType.RangeException};
+        }
+
+        public boolean isRestricted() {
+            return true;
+        }
+
+        public void varList(IVariableList varList) {
+        }
+
+        public boolean preResolveVariables() {
+            return true;
+        }
+
+        public String since() {
+            return "3.1.3";
+        }
+
+        public Boolean runAsync() {
+            return false;
+        }
+
+        public Construct exec(int line_num, File f, Env env, Construct... args) throws ConfigRuntimeException {
+            MCCommandSender p = env.GetCommandSender();
+            Integer index = -1;
+            boolean all = false;
+            MCPlayer m = null;
+            if (args.length == 0) {
+                all = true;
+                if (p instanceof MCPlayer) {
+                    m = (MCPlayer) p;
+                }
+            } else if (args.length == 1) {
+                all = true;
+                m = p.getServer().getPlayer(args[0].val());
+            } else if (args.length == 2) {
+                if (args[1] instanceof CNull) {
+                    index = null;
+                } else {
+                    index = (int) Static.getInt(args[1]);
+                }
+                all = false;
+                m = p.getServer().getPlayer(args[0].val());
+            }
+            if (m == null || !m.isOnline()) {
+                throw new ConfigRuntimeException("The specified player is not online",
+                        ExceptionType.PlayerOfflineException, line_num, f);
+            }
+            if(all){
+                CArray ret = new CArray(line_num, f);
+                ret.forceAssociativeMode();
+                for(int i = 0; i < 36; i++){
+                    ret.set(i, getInvSlot(m, i, line_num, f));
+                }
+                for(int i = 100; i < 104; i++){
+                    ret.set(i, getInvSlot(m, i, line_num, f));
+                }
+                return ret;
+            } else {
+                return getInvSlot(m, index, line_num, f);
+            }
+        }
+
+        private Construct getInvSlot(MCPlayer m, Integer slot, int line_num, File f) {
+            if(slot == null){
+                return ObjectGenerator.GetGenerator().item(m.getItemInHand(), line_num, f);
+            }
+            MCInventory inv = m.getInventory();
+            if(slot.equals(36)){
+                slot = 100;
+            }
+            if(slot.equals(37)){
+                slot = 101;
+            }
+            if(slot.equals(38)){
+                slot = 102;
+            }
+            if(slot.equals(39)){
+                slot = 103;
+            }
+            MCItemStack is;
+            if(slot >= 0 && slot <= 35){
+                is = inv.getItem(slot);
+            } else if(slot.equals(100)){
+                is = inv.getBoots();
+            } else if(slot.equals(101)){
+                is = inv.getLeggings();
+            } else if(slot.equals(102)){
+                is = inv.getChestplate();
+            } else if(slot.equals(103)){
+                is = inv.getHelmet();
+            } else {
+                throw new ConfigRuntimeException("Slot index must be 0-35, or 100-103", ExceptionType.RangeException, line_num, f);
+            }
+            return ObjectGenerator.GetGenerator().item(is, line_num, f);
+        }
+    }
+
+    @api
+    public static class set_pinv implements Function {
+
+        public String getName() {
+            return "set_pinv";
+        }
+
+        public Integer[] numArgs() {
+            return new Integer[]{1, 2, 3, 4, 5, 7};
+        }
+
+        public String docs() {
+            return "void {[player], pinvArray} Sets a player's inventory to the specified inventory object."
+                    + " An inventory object is one that matches what is returned by pinv(), so set_pinv(pinv()),"
+                    + " while pointless, would be a correct call. The array must be associative, "
+                    + " however, it may skip items, in which case, only the specified values will be changed. If"
+                    + " a key is out of range, or otherwise improper, a warning is emitted, and it is skipped,"
+                    + " but the function will not fail as a whole. A simple way to set one item in a player's"
+                    + " inventory would be: set_pinv(array(2: array(type: 1, qty: 64))) This sets the player's second slot"
+                    + " to be a stack of stone. set_pinv(array(103: array(type: 298))) gives them a hat.";
+
+        }
+
+        public ExceptionType[] thrown() {
+            return new ExceptionType[]{ExceptionType.PlayerOfflineException, ExceptionType.CastException, ExceptionType.FormatException};
+        }
+
+        public boolean isRestricted() {
+            return true;
+        }
+
+        public void varList(IVariableList varList) {
+        }
+
+        public boolean preResolveVariables() {
+            return true;
+        }
+
+        public String since() {
+            return "3.2.0";
+        }
+
+        public Boolean runAsync() {
+            return false;
+        }
+
+        public Construct exec(int line_num, File f, Env env, Construct... args) throws ConfigRuntimeException {
+            MCCommandSender p = env.GetCommandSender();
+            MCPlayer m = null;
+            if (p instanceof MCPlayer) {
+                m = (MCPlayer) p;
+            }
+            Construct arg;
+            if(args.length == 2){
+                m = Static.GetPlayer(args[0]);
+                arg = args[1];
+            } else if(args.length == 1){
+                arg = args[0];
+            } else {
+                throw new ConfigRuntimeException("The old format for set_pinv has been deprecated. Please update your script.", line_num, f);
+            }
+            if(!(arg instanceof CArray)){
+                throw new ConfigRuntimeException("Expecting an array as argument " + (args.length==1?"1":"2"), ExceptionType.CastException, line_num, f);
+            }
+            CArray array = (CArray)arg;
+            for(String key : array.keySet()){
+                try{
+                    int index = Integer.parseInt(key);
+                    MCItemStack is = ObjectGenerator.GetGenerator().item(array.get(index), line_num, f);
+                    if(index >= 0 && index <= 35){
+                        m.getInventory().setItem(index, is);
+                    } else if(index == 100){
+                        m.getInventory().setBoots(is);
+                    } else if(index == 101){
+                        m.getInventory().setLeggings(is);
+                    } else if(index == 102){
+                        m.getInventory().setChestplate(is);
+                    } else if(index == 103){
+                        m.getInventory().setHelmet(is);
+                    } else {
+                        ConfigRuntimeException.DoWarning("Out of range value (" + index + ") found in array passed to set_pinv(), so ignoring.");
+                    }
+                } catch(NumberFormatException e){
+                    ConfigRuntimeException.DoWarning("Expecting integer value for key in array passed to set_pinv(), but \"" + key + "\" was found. Ignoring.");
+                }
+            }
+            return new CVoid(line_num, f);
+//            int slot = 0;
+//            int offset = 0;
+//            int qty = 1;
+//            short damage = -1;
+//            if (args.length == 1 && args[0] instanceof CArray || args.length == 2 && args[1] instanceof CArray) {
+//                //we are using the set_pinv(pinv()) method
+//                CArray ca = null;
+//                if (args.length == 1) {
+//                    ca = (CArray) args[0];
+//                }
+//                if (args.length == 2) {
+//                    m = Static.GetPlayer(args[0].val(), line_num, f);
+//                    ca = (CArray) args[1];
+//                }
+//
+//                for (String key : ca.keySet()) {
+//                    int i = 0;
+//                    if (Integer.valueOf(key) != null) {
+//                        i = Integer.parseInt(key);
+//                    } else {
+//                        continue; //Ignore this key
+//                    }
+//                    if (!ca.contains(key)) {
+//                        continue; //Ignore this key too
+//                    }
+//                    Construct item = ca.get(key);
+//                    if (item instanceof CNull) {
+//                        this.exec(line_num, f, env, new CString(m.getName(), line_num, f),
+//                                new CInt(i, line_num, f),
+//                                new CInt(0, line_num, f));
+//                    } else {
+//                        if (item instanceof CArray && (((CArray) item).size() == 2) || ((CArray) item).size() == 4) {
+//                            
+//                            CArray citem = (CArray) item;
+//                            Construct enchantArray = new CArray(line_num, f);
+//                            Construct levelArray = new CArray(line_num, f);
+//                            if (citem.size() == 4) {
+//                                enchantArray = citem.get(2, line_num, f);
+//                                levelArray = citem.get(3, line_num, f);
+//                            }
+//                            this.exec(line_num, f, env, new CString(m.getName(), line_num, f),
+//                                    new CInt(i, line_num, f),
+//                                    new CString(citem.get(0, line_num, f).val(), line_num, f),
+//                                    new CInt(Static.getInt(citem.get(1, line_num, f)), line_num, f),
+//                                    enchantArray, levelArray);
+//                        } else {
+//                            throw new ConfigRuntimeException("Expecting internal values of the array to be 2 or 4 element arrays", ExceptionType.CastException, line_num, f);
+//                        }
+//                    }
+//                }
+//                return new CVoid(line_num, f);
+//            }
+//            //else we are using the first method
+//            if (args[0].val().matches("\\d*(:\\d*)?") || Static.isNull(args[0])) {
+//                //We're using the slot as arg 1
+//                if (Static.isNull(args[0])) {
+//                    slot = -1;
+//                } else {
+//                    slot = (int) Static.getInt(args[0]);
+//                }
+//            } else {
+//                m = Static.GetPlayer(args[0].val(), line_num, f);
+//                if (Static.isNull(args[1])) {
+//                    slot = -1;
+//                } else {
+//                    slot = (int) Static.getInt(args[1]);
+//                }
+//                offset = 1;
+//            }
+//            if (slot < -1 || slot > 35 && slot < 100 || slot > 103) {
+//                throw new ConfigRuntimeException("Slot number must be from 0-35 or 100-103", ExceptionType.RangeException, line_num, f);
+//            }
+//            if (args.length > 2 + offset) {
+//                qty = (int) Static.getInt(args[2 + offset]);
+//            }
+//            qty = Static.Normalize(qty, 0, Integer.MAX_VALUE);
+//            MCItemStack is = Static.ParseItemNotation(this.getName(), args[1 + offset].val(), qty, line_num, f);
+//            if (args.length > 3 + offset) {
+//                damage = (short) Static.getInt(args[3 + offset]);
+//            }
+//
+//
+//            if (damage != -1) {
+//                damage = (short) java.lang.Math.max(0, java.lang.Math.min(100, damage));
+//                short max = is.getType().getMaxDurability();
+//                is.setDurability((short) ((max * damage) / 100));
+//            }
+//
+//            if (is.getTypeId() == 0) {
+//                qty = 0; //Giving the MCPlayer air crashes their client, so just remove the item
+//                is.setTypeId(1);
+//            }
+//
+//            if (qty == 0) {
+//                is = null;
+//            }
+//            if (slot == -1) {
+//                m.setItemInHand(is);
+//            } else {
+//                if (slot == 103) {
+//                    m.getInventory().setHelmet(is);
+//                } else if (slot == 102) {
+//                    m.getInventory().setChestplate(is);
+//                } else if (slot == 101) {
+//                    m.getInventory().setLeggings(is);
+//                } else if (slot == 100) {
+//                    m.getInventory().setBoots(is);
+//                } else {
+//                    m.getInventory().setItem(slot, is);
+//                }
+//            }
+//            if (args.length > 4 + offset) {
+//                //We want to enchant this item also
+//                Enchantments.enchant_inv ei = new Enchantments.enchant_inv();
+//                ei.exec(line_num, f, env, new CString(m.getName(), line_num, f),
+//                        new CInt(slot, line_num, f),
+//                        args[4 + offset],
+//                        args[5 + offset]);
+//            }
+//            return new CVoid(line_num, f);
+        }
+    }
+
+    @api
+    public static class pmode implements Function {
+
+        public String getName() {
+            return "pmode";
+        }
+
+        public Integer[] numArgs() {
+            return new Integer[]{0, 1};
+        }
+
+        public String docs() {
+            return "string {[player]} Returns the player's game mode. It will be one of \"CREATIVE\" or \"SURVIVAL\".";
+        }
+
+        public ExceptionType[] thrown() {
+            return new ExceptionType[]{ExceptionType.PlayerOfflineException};
+        }
+
+        public boolean isRestricted() {
+            return true;
+        }
+
+        public void varList(IVariableList varList) {
+        }
+
+        public boolean preResolveVariables() {
+            return true;
+        }
+
+        public String since() {
+            return "3.1.3";
+        }
+
+        public Boolean runAsync() {
+            return false;
+        }
+
+        public Construct exec(int line_num, File f, Env env, Construct... args) throws ConfigRuntimeException {
+            MCCommandSender p = env.GetCommandSender();
+            MCPlayer m = null;
+            if (p instanceof MCPlayer) {
+                m = (MCPlayer) p;
+            }
+            if (args.length == 1) {
+                m = Static.getServer().getPlayer(args[0].val());
+            }
+            if (m == null || !m.isOnline()) {
+                throw new ConfigRuntimeException("The specified player is offline", ExceptionType.PlayerOfflineException, line_num, f);
+            }
+            String mode = m.getGameMode().name();
+            return new CString(mode, line_num, f);
+        }
+    }
+
+    @api
+    public static class set_pmode implements Function {
+
+        public String getName() {
+            return "set_pmode";
+        }
+
+        public Integer[] numArgs() {
+            return new Integer[]{1, 2};
+        }
+
+        public String docs() {
+            return "void {[player], mode} Sets the player's game mode. mode must be either \"CREATIVE\" or \"SURVIVAL\""
+                    + " (case doesn't matter)";
+        }
+
+        public ExceptionType[] thrown() {
+            return new ExceptionType[]{ExceptionType.PlayerOfflineException};
+        }
+
+        public boolean isRestricted() {
+            return true;
+        }
+
+        public void varList(IVariableList varList) {
+        }
+
+        public boolean preResolveVariables() {
+            return true;
+        }
+
+        public String since() {
+            return "3.1.3";
+        }
+
+        public Boolean runAsync() {
+            return false;
+        }
+
+        public Construct exec(int line_num, File f, Env env, Construct... args) throws ConfigRuntimeException {
+            MCCommandSender p = env.GetCommandSender();
+            MCPlayer m = null;
+            String mode = "";
+            MCGameMode gm;
+            if (p instanceof MCPlayer) {
+                m = (MCPlayer) p;
+            }
+            if (args.length == 2) {
+                m = Static.getServer().getPlayer(args[0].val());
+                mode = args[1].val();
+            } else {
+                mode = args[0].val();
+            }
+            if (m == null || !m.isOnline()) {
+                throw new ConfigRuntimeException("That player is not online", ExceptionType.PlayerOfflineException, line_num, f);
+            }
+
+            try {
+                gm = MCGameMode.valueOf(mode.toUpperCase());
+            } catch (IllegalArgumentException e) {
+                throw new ConfigRuntimeException("Mode must be either 'CREATIVE' or 'SURVIVAL'", ExceptionType.FormatException, line_num, f);
+            }
+            m.setGameMode(gm);
+            return new CVoid(line_num, f);
+        }
+    }
+
+    @api
+    public static class pexp implements Function {
+
+        public String getName() {
+            return "pexp";
+        }
+
+        public Integer[] numArgs() {
+            return new Integer[]{0, 1};
+        }
+
+        public String docs() {
+            return "int {[player]} Gets the experience of a player within this level, as a percentage, from 0 to 99. (100 would be next level,"
+                    + " therefore, 0.)";
+        }
+
+        public ExceptionType[] thrown() {
+            return new ExceptionType[]{ExceptionType.CastException, ExceptionType.PlayerOfflineException};
+        }
+
+        public boolean isRestricted() {
+            return true;
+        }
+
+        public void varList(IVariableList varList) {
+        }
+
+        public boolean preResolveVariables() {
+            return true;
+        }
+
+        public String since() {
+            return "3.1.3";
+        }
+
+        public Boolean runAsync() {
+            return false;
+        }
+
+        public Construct exec(int line_num, File f, Env env, Construct... args) throws ConfigRuntimeException {
+            MCCommandSender p = env.GetCommandSender();
+            MCPlayer m = null;
+            if (p instanceof MCPlayer) {
+                m = (MCPlayer) p;
+            }
+            if (args.length == 1) {
+                m = Static.GetPlayer(args[0].val(), line_num, f);
+            }
+            if (m == null || !m.isOnline()) {
+                throw new ConfigRuntimeException("The specified player is not online", ExceptionType.PlayerOfflineException, line_num, f);
+            }
+            return new CInt((int) (m.getExp() * 100), line_num, f);
+        }
+    }
+
+    @api
+    public static class set_pexp implements Function {
+
+        public String getName() {
+            return "set_pexp";
+        }
+
+        public Integer[] numArgs() {
+            return new Integer[]{1, 2};
+        }
+
+        public String docs() {
+            return "void {[player], xp} Sets the experience of a player within the current level, as a percentage, from 0 to 100.";
+        }
+
+        public ExceptionType[] thrown() {
+            return new ExceptionType[]{ExceptionType.CastException, ExceptionType.PlayerOfflineException};
+        }
+
+        public boolean isRestricted() {
+            return true;
+        }
+
+        public void varList(IVariableList varList) {
+        }
+
+        public boolean preResolveVariables() {
+            return true;
+        }
+
+        public String since() {
+            return "3.1.3";
+        }
+
+        public Boolean runAsync() {
+            return false;
+        }
+
+        public Construct exec(int line_num, File f, Env env, Construct... args) throws ConfigRuntimeException {
+            MCCommandSender p = env.GetCommandSender();
+            MCPlayer m = null;
+            int xp = 0;
+            if (p instanceof MCPlayer) {
+                m = (MCPlayer) p;
+            }
+            if (args.length == 2) {
+                m = Static.GetPlayer(args[0].val(), line_num, f);
+                xp = (int) Static.getInt(args[1]);
+            } else {
+                xp = (int) Static.getInt(args[0]);
+            }
+            if (m == null || !m.isOnline()) {
+                throw new ConfigRuntimeException("The specified player is not online", ExceptionType.PlayerOfflineException, line_num, f);
+            }
+            m.setExp(((float) xp) / 100.0F);
+            return new CVoid(line_num, f);
+        }
+    }
+
+    @api
+    public static class give_pexp implements Function {
+
+        public String getName() {
+            return "give_pexp";
+        }
+
+        public Integer[] numArgs() {
+            return new Integer[]{1, 2};
+        }
+
+        public String docs() {
+            return "void {[player], exp} Gives the player the specified amount of xp.";
+        }
+
+        public ExceptionType[] thrown() {
+            return new ExceptionType[]{ExceptionType.PlayerOfflineException, ExceptionType.CastException};
+        }
+
+        public boolean isRestricted() {
+            return true;
+        }
+
+        public boolean preResolveVariables() {
+            return true;
+        }
+
+        public String since() {
+            return "3.3.0";
+        }
+
+        public Boolean runAsync() {
+            return true;
+        }
+
+        public Construct exec(int line_num, File f, Env environment, Construct... args) throws ConfigRuntimeException {
+            MCCommandSender p = environment.GetCommandSender();
+            MCPlayer m = null;
+            int xp = 0;
+            if (p instanceof MCPlayer) {
+                m = (MCPlayer) p;
+            }
+            if (args.length == 2) {
+                m = Static.GetPlayer(args[0].val(), line_num, f);
+                xp = (int) Static.getInt(args[1]);
+            } else {
+                xp = (int) Static.getInt(args[0]);
+            }
+            if (m == null || !m.isOnline()) {
+                throw new ConfigRuntimeException("The specified player is not online", ExceptionType.PlayerOfflineException, line_num, f);
+            }
+
+            m.giveExp(xp);
+
+            return new CVoid(line_num, f);
+        }
+    }
+
+    @api
+    public static class plevel implements Function {
+
+        public String getName() {
+            return "plevel";
+        }
+
+        public Integer[] numArgs() {
+            return new Integer[]{0, 1};
+        }
+
+        public String docs() {
+            return "int {[player]} Gets the player's level.";
+        }
+
+        public ExceptionType[] thrown() {
+            return new ExceptionType[]{ExceptionType.CastException, ExceptionType.PlayerOfflineException};
+        }
+
+        public boolean isRestricted() {
+            return true;
+        }
+
+        public void varList(IVariableList varList) {
+        }
+
+        public boolean preResolveVariables() {
+            return true;
+        }
+
+        public String since() {
+            return "3.1.3";
+        }
+
+        public Boolean runAsync() {
+            return false;
+        }
+
+        public Construct exec(int line_num, File f, Env env, Construct... args) throws ConfigRuntimeException {
+            MCCommandSender p = env.GetCommandSender();
+            MCPlayer m = null;
+            if (p instanceof MCPlayer) {
+                m = (MCPlayer) p;
+            }
+            if (args.length == 1) {
+                m = Static.GetPlayer(args[0].val(), line_num, f);
+            }
+            if (m == null || !m.isOnline()) {
+                throw new ConfigRuntimeException("The specified player is not online", ExceptionType.PlayerOfflineException, line_num, f);
+            }
+            return new CInt(m.getLevel(), line_num, f);
+        }
+    }
+
+    @api
+    public static class set_plevel implements Function {
+
+        public String getName() {
+            return "set_plevel";
+        }
+
+        public Integer[] numArgs() {
+            return new Integer[]{1, 2};
+        }
+
+        public String docs() {
+            return "void {[player], level} Sets the level of a player.";
+        }
+
+        public ExceptionType[] thrown() {
+            return new ExceptionType[]{ExceptionType.CastException, ExceptionType.PlayerOfflineException};
+        }
+
+        public boolean isRestricted() {
+            return true;
+        }
+
+        public void varList(IVariableList varList) {
+        }
+
+        public boolean preResolveVariables() {
+            return true;
+        }
+
+        public String since() {
+            return "3.1.3";
+        }
+
+        public Boolean runAsync() {
+            return false;
+        }
+
+        public Construct exec(int line_num, File f, Env env, Construct... args) throws ConfigRuntimeException {
+            MCCommandSender p = env.GetCommandSender();
+            MCPlayer m = null;
+            int level = 0;
+            if (p instanceof MCPlayer) {
+                m = (MCPlayer) p;
+            }
+            if (args.length == 2) {
+                m = Static.GetPlayer(args[0].val(), line_num, f);
+                level = (int) Static.getInt(args[1]);
+            } else {
+                level = (int) Static.getInt(args[0]);
+            }
+            if (m == null || !m.isOnline()) {
+                throw new ConfigRuntimeException("The specified player is not online", ExceptionType.PlayerOfflineException, line_num, f);
+            }
+            m.setLevel(level);
+//            float portion = m.getExp();
+//            m.setLevel(0);
+//            m.setExp(0);
+//            m.setTotalExperience(0);
+//            m.giveExp(7 + (level * 7 >> 1));
+            return new CVoid(line_num, f);
+        }
+    }
+
+    @api
+    public static class ptexp implements Function {
+
+        public String getName() {
+            return "ptexp";
+        }
+
+        public Integer[] numArgs() {
+            return new Integer[]{0, 1};
+        }
+
+        public String docs() {
+            return "int {[player]} Gets the total experience of a player.";
+        }
+
+        public ExceptionType[] thrown() {
+            return new ExceptionType[]{ExceptionType.CastException, ExceptionType.PlayerOfflineException};
+        }
+
+        public boolean isRestricted() {
+            return true;
+        }
+
+        public void varList(IVariableList varList) {
+        }
+
+        public boolean preResolveVariables() {
+            return true;
+        }
+
+        public String since() {
+            return "3.1.3";
+        }
+
+        public Boolean runAsync() {
+            return false;
+        }
+
+        public Construct exec(int line_num, File f, Env env, Construct... args) throws ConfigRuntimeException {
+            MCCommandSender p = env.GetCommandSender();
+            MCPlayer m = null;
+            if (p instanceof MCPlayer) {
+                m = (MCPlayer) p;
+            }
+            if (args.length == 1) {
+                m = Static.GetPlayer(args[0].val(), line_num, f);
+            }
+            if (m == null || !m.isOnline()) {
+                throw new ConfigRuntimeException("The specified player is not online", ExceptionType.PlayerOfflineException, line_num, f);
+            }
+            return new CInt(m.getTotalExperience(), line_num, f);
+        }
+    }
+
+    @api
+    public static class set_ptexp implements Function {
+
+        public String getName() {
+            return "set_ptexp";
+        }
+
+        public Integer[] numArgs() {
+            return new Integer[]{1, 2};
+        }
+
+        public String docs() {
+            return "void {[player], xp} Sets the total experience of a player.";
+        }
+
+        public ExceptionType[] thrown() {
+            return new ExceptionType[]{ExceptionType.CastException, ExceptionType.PlayerOfflineException};
+        }
+
+        public boolean isRestricted() {
+            return true;
+        }
+
+        public void varList(IVariableList varList) {
+        }
+
+        public boolean preResolveVariables() {
+            return true;
+        }
+
+        public String since() {
+            return "3.1.3";
+        }
+
+        public Boolean runAsync() {
+            return false;
+        }
+
+        public Construct exec(int line_num, File f, Env env, Construct... args) throws ConfigRuntimeException {
+            MCCommandSender p = env.GetCommandSender();
+            MCPlayer m = null;
+            int xp = 0;
+            if (p instanceof MCPlayer) {
+                m = (MCPlayer) p;
+            }
+            if (args.length == 2) {
+                m = Static.GetPlayer(args[0].val(), line_num, f);
+                xp = (int) Static.getInt(args[1]);
+            } else {
+                xp = (int) Static.getInt(args[0]);
+            }
+            if (m == null || !m.isOnline()) {
+                throw new ConfigRuntimeException("The specified player is not online", ExceptionType.PlayerOfflineException, line_num, f);
+            }
+            m.setTotalExperience(xp);
+//            m.setLevel(0);
+//            m.setExp(0);
+//            m.setTotalExperience(0);
+//            m.giveExp(xp);
+            return new CVoid(line_num, f);
+        }
+    }
+
+    @api
+    public static class pfood implements Function {
+
+        public String getName() {
+            return "pfood";
+        }
+
+        public Integer[] numArgs() {
+            return new Integer[]{0, 1};
+        }
+
+        public String docs() {
+            return "int {[player]} Returns the player's current food level.";
+        }
+
+        public ExceptionType[] thrown() {
+            return new ExceptionType[]{ExceptionType.PlayerOfflineException};
+        }
+
+        public boolean isRestricted() {
+            return true;
+        }
+
+        public void varList(IVariableList varList) {
+        }
+
+        public boolean preResolveVariables() {
+            return true;
+        }
+
+        public String since() {
+            return "3.1.3";
+        }
+
+        public Boolean runAsync() {
+            return false;
+        }
+
+        public Construct exec(int line_num, File f, Env env, Construct... args) throws ConfigRuntimeException {
+            MCCommandSender p = env.GetCommandSender();
+            MCPlayer m = null;
+            if (p instanceof MCPlayer) {
+                m = (MCPlayer) p;
+            }
+            if (args.length == 1) {
+                m = Static.GetPlayer(args[0].val(), line_num, f);
+            }
+            if (m == null || !m.isOnline()) {
+                throw new ConfigRuntimeException("The specified player is not online", ExceptionType.PlayerOfflineException, line_num, f);
+            }
+            return new CInt(m.getFoodLevel(), line_num, f);
+        }
+    }
+
+    @api
+    public static class set_pfood implements Function {
+
+        public String getName() {
+            return "set_pfood";
+        }
+
+        public Integer[] numArgs() {
+            return new Integer[]{1, 2};
+        }
+
+        public String docs() {
+            return "void {[player], level} Sets the player's food level. This is an integer from 0-?";
+        }
+
+        public ExceptionType[] thrown() {
+            return new ExceptionType[]{ExceptionType.PlayerOfflineException, ExceptionType.CastException};
+        }
+
+        public boolean isRestricted() {
+            return true;
+        }
+
+        public void varList(IVariableList varList) {
+        }
+
+        public boolean preResolveVariables() {
+            return true;
+        }
+
+        public String since() {
+            return "3.1.3";
+        }
+
+        public Boolean runAsync() {
+            return false;
+        }
+
+        public Construct exec(int line_num, File f, Env env, Construct... args) throws ConfigRuntimeException {
+            MCCommandSender p = env.GetCommandSender();
+            MCPlayer m = null;
+            int level = 0;
+            if (p instanceof MCPlayer) {
+                m = (MCPlayer) p;
+            }
+            if (args.length == 2) {
+                m = Static.GetPlayer(args[0].val(), line_num, f);
+                level = (int) Static.getInt(args[1]);
+            } else {
+                level = (int) Static.getInt(args[0]);
+            }
+            if (m == null || !m.isOnline()) {
+                throw new ConfigRuntimeException("The specified player is not online", ExceptionType.PlayerOfflineException, line_num, f);
+            }
+            m.setFoodLevel(level);
+            return new CVoid(line_num, f);
+        }
+    }
+
+    @api
+    public static class set_peffect implements Function {
+
+        public String getName() {
+            return "set_peffect";
+        }
+
+        public Integer[] numArgs() {
+            return new Integer[]{3, 4};
+        }
+
+        public String docs() {
+            return "void {player, potionID, strength, [seconds]} Not all potions work of course, but effect is 1-19. Seconds defaults to 30."
+                    + " If the potionID is out of range, a RangeException is thrown, because out of range potion effects"
+                    + " cause the client to crash, fairly hardcore.";
+        }
+
+        public ExceptionType[] thrown() {
+            return new ExceptionType[]{ExceptionType.PlayerOfflineException, ExceptionType.CastException,
+            ExceptionType.RangeException};
+        }
+
+        public boolean isRestricted() {
+            return true;
+        }
+
+        public void varList(IVariableList varList) {
+        }
+
+        public boolean preResolveVariables() {
+            return true;
+        }
+
+        public String since() {
+            return "0.0.0";
+        }
+
+        public Boolean runAsync() {
+            return false;
+        }
+
+        public Construct exec(int line_num, File f, Env env, Construct... args) throws ConfigRuntimeException {
+            MCPlayer m = Static.GetPlayer(args[0].val(), line_num, f);
+            if (m == null || !m.isOnline()) {
+                throw new ConfigRuntimeException("That player is not online", ExceptionType.PlayerOfflineException, line_num, f);
+            }
+            int effect = (int) Static.getInt(args[1]);
+            //To work around a bug in bukkit/vanilla, if the effect is invalid, throw an exception
+            //otherwise the client crashes, and requires deletion of
+            //player data to fix.
+            if(effect < 1 || effect > 19){
+                throw new ConfigRuntimeException("Invalid effect ID recieved, must be from 1-19", ExceptionType.RangeException, line_num, f);
+            }
+            int strength = (int) Static.getInt(args[2]);
+            int seconds = 30;
+            if (args.length == 4) {
+                seconds = (int) Static.getInt(args[3]);
+            }
+            m.addEffect(effect, strength, seconds);
+            return new CVoid(line_num, f);
+        }
+    }
+
+    @api
+    public static class set_phealth implements Function {
+
+        public String getName() {
+            return "set_phealth";
+        }
+
+        public Integer[] numArgs() {
+            return new Integer[]{1, 2};
+        }
+
+        public String docs() {
+            return "void {[player], health} Sets the player's health. health should be an integer from 0-20.";
+        }
+
+        public ExceptionType[] thrown() {
+            return new ExceptionType[]{ExceptionType.CastException, ExceptionType.RangeException, ExceptionType.PlayerOfflineException};
+        }
+
+        public boolean isRestricted() {
+            return true;
+        }
+
+        public void varList(IVariableList varList) {
+        }
+
+        public boolean preResolveVariables() {
+            return true;
+        }
+
+        public String since() {
+            return "3.2.0";
+        }
+
+        public Boolean runAsync() {
+            return false;
+        }
+
+        public Construct exec(int line_num, File f, Env env, Construct... args) throws ConfigRuntimeException {
+            MCCommandSender p = env.GetCommandSender();
+            MCPlayer m = null;
+            if (p instanceof MCPlayer) {
+                m = (MCPlayer) p;
+            }
+            int health = 0;
+            if (args.length == 2) {
+                m = Static.GetPlayer(args[0].val(), line_num, f);
+                health = (int) Static.getInt(args[1]);
+            } else {
+                health = (int) Static.getInt(args[0]);
+            }
+            if (health < 0 || health > 20) {
+                throw new ConfigRuntimeException("Health must be between 0 and 20", ExceptionType.RangeException, line_num, f);
+            }
+            m.setHealth(health);
+            return new CVoid(line_num, f);
+        }
+    }
+
+    @api
+    public static class ponline implements Function {
+
+        public String getName() {
+            return "ponline";
+        }
+
+        public Integer[] numArgs() {
+            return new Integer[]{1};
+        }
+
+        public String docs() {
+            return "boolean {player} Returns whether or not the specified player is online. Note"
+                    + " that the name must match exactly, but it will not throw a PlayerOfflineException"
+                    + " if the player is not online, or if the player doesn't even exist.";
+        }
+
+        public ExceptionType[] thrown() {
+            return new ExceptionType[]{};
+        }
+
+        public boolean isRestricted() {
+            return true;
+        }
+
+        public void varList(IVariableList varList) {
+        }
+
+        public boolean preResolveVariables() {
+            return true;
+        }
+
+        public String since() {
+            return "3.3.0";
+        }
+
+        public Boolean runAsync() {
+            return false;
+        }
+
+        public Construct exec(int line_num, File f, Env env, Construct... args) throws ConfigRuntimeException {
+            return new CBoolean(Static.getServer().getOfflinePlayer(args[0].val()).isOnline(), line_num, f);
+        }
+    }
+
+    @api
+    public static class pwhitelisted implements Function {
+
+        public String getName() {
+            return "pwhitelisted";
+        }
+
+        public Integer[] numArgs() {
+            return new Integer[]{1};
+        }
+
+        public String docs() {
+            return "boolean {player} Returns whether or not this player is whitelisted. Note that"
+                    + " this will work with offline players, but the name must be exact.";
+        }
+
+        public ExceptionType[] thrown() {
+            return new ExceptionType[]{};
+        }
+
+        public boolean isRestricted() {
+            return true;
+        }
+
+        public void varList(IVariableList varList) {
+        }
+
+        public boolean preResolveVariables() {
+            return true;
+        }
+
+        public String since() {
+            return "3.3.0";
+        }
+
+        public Boolean runAsync() {
+            return false;
+        }
+
+        public Construct exec(int line_num, File f, Env env, Construct... args) throws ConfigRuntimeException {
+            MCOfflinePlayer pl = Static.getServer().getOfflinePlayer(args[0].val());
+            return new CBoolean(pl.isWhitelisted(), line_num, f);
+        }
+    }
+
+    @api
+    public static class set_pwhitelisted implements Function {
+
+        public String getName() {
+            return "set_pwhitelisted";
+        }
+
+        public Integer[] numArgs() {
+            return new Integer[]{2};
+        }
+
+        public String docs() {
+            return "void {player, isWhitelisted} Sets the whitelist flag of the specified player. Note that"
+                    + " this will work with offline players, but the name must be exact.";
+        }
+
+        public ExceptionType[] thrown() {
+            return new ExceptionType[]{};
+        }
+
+        public boolean isRestricted() {
+            return true;
+        }
+
+        public void varList(IVariableList varList) {
+        }
+
+        public boolean preResolveVariables() {
+            return true;
+        }
+
+        public String since() {
+            return "3.3.0";
+        }
+
+        public Boolean runAsync() {
+            return false;
+        }
+
+        public Construct exec(int line_num, File f, Env env, Construct... args) throws ConfigRuntimeException {
+            MCOfflinePlayer pl = Static.getServer().getOfflinePlayer(args[0].val());
+            boolean whitelist = Static.getBoolean(args[1]);
+            pl.setWhitelisted(whitelist);
+            return new CVoid(line_num, f);
+        }
+    }
+
+    @api
+    public static class pbanned implements Function {
+
+        public String getName() {
+            return "pbanned";
+        }
+
+        public Integer[] numArgs() {
+            return new Integer[]{1};
+        }
+
+        public String docs() {
+            return "boolean {player} Returns whether or not this player is banned. Note that"
+                    + " this will work with offline players, but the name must be exact. At this"
+                    + " time, this function only works with the vanilla ban system. If you use"
+                    + " a third party ban system, you should instead run the command for that"
+                    + " plugin instead.";
+        }
+
+        public ExceptionType[] thrown() {
+            return new ExceptionType[]{};
+        }
+
+        public boolean isRestricted() {
+            return true;
+        }
+
+        public void varList(IVariableList varList) {
+        }
+
+        public boolean preResolveVariables() {
+            return true;
+        }
+
+        public String since() {
+            return "3.3.0";
+        }
+
+        public Boolean runAsync() {
+            return false;
+        }
+
+        public Construct exec(int line_num, File f, Env env, Construct... args) throws ConfigRuntimeException {
+            MCOfflinePlayer pl = Static.getServer().getOfflinePlayer(args[0].val());
+            return new CBoolean(pl.isBanned(), line_num, f);
+        }
+    }
+
+    @api
+    public static class set_pbanned implements Function {
+
+        public String getName() {
+            return "set_pbanned";
+        }
+
+        public Integer[] numArgs() {
+            return new Integer[]{2};
+        }
+
+        public String docs() {
+            return "void {player, isBanned} Sets the ban flag of the specified player. Note that"
+                    + " this will work with offline players, but the name must be exact. At this"
+                    + " time, this function only works with the vanilla ban system. If you use"
+                    + " a third party ban system, you should instead run the command for that"
+                    + " plugin instead.";
+        }
+
+        public ExceptionType[] thrown() {
+            return new ExceptionType[]{};
+        }
+
+        public boolean isRestricted() {
+            return true;
+        }
+
+        public void varList(IVariableList varList) {
+        }
+
+        public boolean preResolveVariables() {
+            return true;
+        }
+
+        public String since() {
+            return "3.3.0";
+        }
+
+        public Boolean runAsync() {
+            return false;
+        }
+
+        public Construct exec(int line_num, File f, Env env, Construct... args) throws ConfigRuntimeException {
+            MCOfflinePlayer pl = Static.getServer().getOfflinePlayer(args[0].val());
+            boolean ban = Static.getBoolean(args[1]);
+            pl.setBanned(ban);
+            return new CVoid(line_num, f);
+        }
+    }
+
+    @api
+    public static class pisop implements Function {
+
+        public String getName() {
+            return "pisop";
+        }
+
+        public Integer[] numArgs() {
+            return new Integer[]{0, 1};
+        }
+
+        public String docs() {
+            return "boolean {[player]} Returns whether or not the specified player (or the current"
+                    + " player if not specified) is op";
+        }
+
+        public ExceptionType[] thrown() {
+            return new ExceptionType[]{ExceptionType.PlayerOfflineException};
+        }
+
+        public boolean isRestricted() {
+            return true;
+        }
+
+        public boolean preResolveVariables() {
+            return true;
+        }
+
+        public String since() {
+            return "3.3.0";
+        }
+
+        public Boolean runAsync() {
+            return false;
+        }
+
+        public Construct exec(int line_num, File f, Env environment, Construct... args) throws ConfigRuntimeException {
+            MCPlayer m = environment.GetPlayer();
+            if (args.length == 1) {
+                m = Static.GetPlayer(args[0].val(), line_num, f);
+            }
+            if (m == null) {
+                throw new ConfigRuntimeException("That player is not online", ExceptionType.PlayerOfflineException, line_num, f);
+            }
+            return new CBoolean(m.isOp(), line_num, f);
+        }
+    }
+    
+    @api public static class set_compass_target implements Function{
+
+        public String getName() {
+            return "set_compass_target";
+        }
+
+        public Integer[] numArgs() {
+            return new Integer[]{1, 2};
+        }
+
+        public String docs() {
+            return "array {[player], locationArray} Sets the player's compass target, and returns the old location.";
+        }
+
+        public ExceptionType[] thrown() {
+            return new ExceptionType[]{ExceptionType.PlayerOfflineException, ExceptionType.FormatException};
+        }
+
+        public boolean isRestricted() {
+            return true;
+        }
+
+        public boolean preResolveVariables() {
+            return true;
+        }
+
+        public String since() {
+            return "3.3.0";
+        }
+
+        public Boolean runAsync() {
+            return false;
+        }
+
+        public Construct exec(int line_num, File f, Env environment, Construct... args) throws ConfigRuntimeException {
+            MCPlayer m = null;
+            MCLocation l;
+            if(args.length == 1){
+                l = ObjectGenerator.GetGenerator().location(args[0], null, line_num, f);
+            } else {
+                m = Static.GetPlayer(args[0].val(), line_num, f);
+                l = ObjectGenerator.GetGenerator().location(args[1], null, line_num, f);
+            }
+            if (m == null) {
+                throw new ConfigRuntimeException("That player is not online", ExceptionType.PlayerOfflineException, line_num, f);
+            }
+            MCLocation old = m.getCompassTarget();
+            m.setCompassTarget(l);
+            return ObjectGenerator.GetGenerator().location(old);
+        }
+        
+    }
+    
+    @api public static class get_compass_target implements Function{
+
+        public String getName() {
+            return "get_compass_target";
+        }
+
+        public Integer[] numArgs() {
+            return new Integer[]{0, 1};
+        }
+
+        public String docs() {
+            return "array {[player]} Gets the compass target of the specified player";
+        }
+
+        public ExceptionType[] thrown() {
+            return new ExceptionType[]{ExceptionType.PlayerOfflineException};
+        }
+
+        public boolean isRestricted() {
+            return true;
+        }
+
+        public boolean preResolveVariables() {
+            return true;
+        }
+
+        public String since() {
+            return "3.3.0";
+        }
+
+        public Boolean runAsync() {
+            return false;
+        }
+
+        public Construct exec(int line_num, File f, Env environment, Construct... args) throws ConfigRuntimeException {
+            MCPlayer m = environment.GetPlayer();
+            if(args.length == 1){
+                m = Static.GetPlayer(args[0].val(), line_num, f);
+            }
+            if (m == null) {
+                throw new ConfigRuntimeException("That player is not online", ExceptionType.PlayerOfflineException, line_num, f);
+            }
+            return ObjectGenerator.GetGenerator().location(m.getCompassTarget());
+        }
+        
+    }
+    
+    @api public static class ponfire implements Function{
+
+        public String getName() {
+            return "ponfire";
+        }
+
+        public Integer[] numArgs() {
+            return new Integer[]{0, 1};
+        }
+
+        public String docs() {
+            return "int {[player]} Returns the number of ticks remaining that this player will"
+                    + " be on fire for. If the player is not on fire, 0 is returned, which incidentally"
+                    + " is false.";
+        }
+
+        public ExceptionType[] thrown() {
+            return new ExceptionType[]{ExceptionType.PlayerOfflineException};
+        }
+
+        public boolean isRestricted() {
+            return true;
+        }
+
+        public boolean preResolveVariables() {
+            return true;
+        }
+
+        public String since() {
+            return "3.3.0";
+        }
+
+        public Boolean runAsync() {
+            return false;
+        }
+
+        public Construct exec(int line_num, File f, Env environment, Construct... args) throws ConfigRuntimeException {
+            MCPlayer p = environment.GetPlayer();
+            if(args.length == 1){
+                p = Static.GetPlayer(args[0]);
+            }
+            int left = p.getRemainingFireTicks();
+            return new CInt(left, line_num, f);
+        }
+        
+    }
+    
+    @api public static class set_ponfire implements Function{
+
+        public String getName() {
+            return "set_ponfire";
+        }
+
+        public Integer[] numArgs() {
+            return new Integer[]{1, 2};
+        }
+
+        public String docs() {
+            return "void {[player], ticks} Sets the player on fire for the specified number of"
+                    + " ticks. If a boolean is given for ticks, false is 0, and true is 20.";
+        }
+
+        public ExceptionType[] thrown() {
+            return new ExceptionType[]{ExceptionType.PlayerOfflineException, ExceptionType.CastException};
+        }
+
+        public boolean isRestricted() {
+            return true;
+        }
+
+        public boolean preResolveVariables() {
+            return true;
+        }
+
+        public String since() {
+            return "3.3.0";
+        }
+
+        public Boolean runAsync() {
+            return false;
+        }
+
+        public Construct exec(int line_num, File f, Env environment, Construct... args) throws ConfigRuntimeException {
+            MCPlayer p = environment.GetPlayer();
+            Construct ticks;
+            if(args.length == 2){
+                p = Static.GetPlayer(args[0]);
+                ticks = args[1];
+            } else {
+                ticks = args[0];
+            }
+            int tick = 0;
+            if(ticks instanceof CBoolean){
+                boolean value = ((CBoolean)ticks).getBoolean();
+                if(value){
+                    tick = 20;
+                }
+            } else {
+                tick = (int) Static.getInt(ticks);
+            }
+            p.setRemainingFireTicks(tick);
+            return new CVoid(line_num, f);
+        }
+        
+    }
+    
+//    @api public static class phas_item implements Function{
+//
+//        public String getName() {
+//            return "phas_item";
+//        }
+//
+//        public Integer[] numArgs() {
+//            return new Integer[]{1, 2};
+//        }
+//
+//        public String docs() {
+//            return "int {[player], itemId} Returns the quantity of the specified item"
+//                    + " that the player is carrying. This counts across all slots in"
+//                    + " inventory. Recall that 0 is false, and anything else is true,"
+//                    + " so this can be used to get the total, or just see if they have"
+//                    + " the item.";
+//        }
+//
+//        public ExceptionType[] thrown() {
+//            return new ExceptionType[]{ExceptionType.PlayerOfflineException, ExceptionType.FormatException};
+//        }
+//
+//        public boolean isRestricted() {
+//            return true;
+//        }
+//
+//        public boolean preResolveVariables() {
+//            return true;
+//        }
+//
+//        public Boolean runAsync() {
+//            return false;
+//        }
+//
+//        public Construct exec(int line_num, File f, Env environment, Construct... args) throws ConfigRuntimeException {
+//            throw new UnsupportedOperationException("Not supported yet.");
+//        }
+//
+//        public String since() {
+//            return "3.3.0";
+//        }
+//        
+//    }
+//    
+//    @api public static class pitem_slot implements Function{
+//
+//        public String getName() {
+//            return "pitem_slot";
+//        }
+//
+//        public Integer[] numArgs() {
+//            return new Integer[]{1, 2};
+//        }
+//
+//        public String docs() {
+//            return "array {[player], itemID} Given an item id, returns the slot numbers"
+//                    + " that the matching item has at least one item in.";
+//        }
+//
+//        public ExceptionType[] thrown() {
+//            return new ExceptionType[]{};
+//        }
+//
+//        public boolean isRestricted() {
+//            return true;
+//        }
+//
+//        public boolean preResolveVariables() {
+//            return true;
+//        }
+//
+//        public Boolean runAsync() {
+//            return false;
+//        }
+//
+//        public Construct exec(int line_num, File f, Env environment, Construct... args) throws ConfigRuntimeException {
+//            throw new UnsupportedOperationException("Not supported yet.");
+//        }
+//
+//        public String since() {
+//            return "3.3.0";
+//        }
+//        
+//    }
+//    
+//    @api public static class pgive_item implements Function{
+//
+//        public String getName() {
+//            return "pgive_item";
+//        }
+//
+//        public Integer[] numArgs() {
+//            return new Integer[]{2, 3};
+//        }
+//
+//        public String docs() {
+//            return "int {[player], itemID, qty} Gives a player the specified item * qty."
+//                    + " Unlike set_pinv(), this does not specify a slot. The qty is distributed"
+//                    + " in the player's inventory, first filling up slots that have the same item"
+//                    + " type, up to the max stack size, then fills up empty slots, until either"
+//                    + " the entire inventory is filled, or the entire amount has been given."
+//                    + " The number of items actually given is returned, which will be less than"
+//                    + " or equal to the quantity provided.";
+//        }
+//
+//        public ExceptionType[] thrown() {
+//            return new ExceptionType[]{};
+//        }
+//
+//        public boolean isRestricted() {
+//            return true;
+//        }
+//
+//        public boolean preResolveVariables() {
+//            return true;
+//        }
+//
+//        public Boolean runAsync() {
+//            return false;
+//        }
+//
+//        public Construct exec(int line_num, File f, Env environment, Construct... args) throws ConfigRuntimeException {
+//            throw new UnsupportedOperationException("Not supported yet.");
+//        }
+//
+//        public String since() {
+//            return "3.3.0";
+//        }
+//        
+//    }
+//    
+//    @api public static class ptake_item implements Function{
+//
+//        public String getName() {
+//            return "ptake_item";
+//        }
+//
+//        public Integer[] numArgs() {
+//            return new Integer[]{2, 3};
+//        }
+//
+//        public String docs() {
+//            return "int {[player], itemID, qty} Works in reverse of pgive_item(), but"
+//                    + " returns the number of items actually taken, which will be"
+//                    + " from 0 to qty.";
+//        }
+//
+//        public ExceptionType[] thrown() {
+//            return new ExceptionType[]{};
+//        }
+//
+//        public boolean isRestricted() {
+//            return true;
+//        }
+//
+//        public boolean preResolveVariables() {
+//            return true;
+//        }
+//
+//        public Boolean runAsync() {
+//            return false;
+//        }
+//
+//        public Construct exec(int line_num, File f, Env environment, Construct... args) throws ConfigRuntimeException {
+//            throw new UnsupportedOperationException("Not supported yet.");
+//        }
+//
+//        public String since() {
+//            return "3.3.0";
+//        }
+//        
+//    }
+//    
+//    @api
+//    public static class pinv_consolidate implements Function {
+//        
+//        public String getName() {
+//            return "pinv_consolidate";
+//        }
+//        
+//        public Integer[] numArgs() {
+//            return new Integer[]{0, 1};
+//        }
+//        
+//        public String docs() {
+//            return "void {[player]} Consolidates a player's inventory as much as possible."
+//                    + " There is no guarantee anything will happen after this function"
+//                    + " is called, and there is no way to specify details about how"
+//                    + " consolidation occurs, however, the following heuristics are followed:"
+//                    + " The hotbar items will not be moved from the hotbar, unless there are"
+//                    + " two+ slots that have the same item. Items in the main inventory area"
+//                    + " will be moved closer to the bottom of the main inventory. No empty slots"
+//                    + " will be filled in the hotbar.";
+//        }
+//        
+//        public ExceptionType[] thrown() {
+//            return new ExceptionType[]{};
+//        }
+//        
+//        public boolean isRestricted() {
+//            return true;
+//        }
+//        
+//        public boolean preResolveVariables() {
+//            return true;
+//        }
+//        
+//        public Boolean runAsync() {
+//            return false;
+//        }
+//        
+//        public Construct exec(int line_num, File f, Env environment, Construct... args) throws ConfigRuntimeException {
+//            throw new UnsupportedOperationException("Not yet supported");
+//        }
+//        
+//        public String since() {
+//            return "3.3.0";
+//        }
+//    }
+    
+    
+    
+}
diff --git a/src/main/java/com/laytonsmith/core/functions/PluginLoader.java b/src/main/java/com/laytonsmith/core/functions/PluginLoader.java
new file mode 100644
index 0000000..9f5c86f
--- /dev/null
+++ b/src/main/java/com/laytonsmith/core/functions/PluginLoader.java
@@ -0,0 +1,67 @@
+package com.laytonsmith.core.functions;
+
+/**
+ * This class handles loading the modules classes. Most of this code was copy-pasted,
+ * so I can't comment too much on it, because I'm still fairly new to what's happening here,
+ * however, I will try to offer some insight. The jar file in which the classes are located
+ * must first be added to the classpath with <code>loadJars</code>. The classes are then
+ * loaded into the classloader, and then when they need to be instantiated, the URLCLassLoader
+ * that is static in this class is used to instatiate them. (Over in frame.java)
+ * @author Layton
+ */
+class PluginLoader {
+//    private static URLClassLoader loader;
+//    private static String baseClassPath;
+//
+//    public static ClassLoader getLoader(){
+//        return loader;
+//    }
+//    private static String parseFile(String dir) {
+//        String tempJars = "";
+//        File file = new File(dir);
+//        File[] tempFiles = file.listFiles();
+//        String tempString = "";
+//        for (int a = 0; a < tempFiles.length; a++) {
+//            tempString = tempFiles[a].toString();
+//            if (tempString.length() > 4) {
+//                if (tempString.substring(tempString.length() - 4, tempString.length()).equals(".jar")) {
+//                    tempJars = tempJars + tempString + ";";
+//                    try {
+//                        if(loader != null){
+//                            URL [] ans = new URL[loader.getURLs().length + 1];
+//                            System.arraycopy(loader.getURLs(), 0, ans, 0, loader.getURLs().length);
+//                            ans[ans.length - 1] = tempFiles[a].toURI().toURL();
+//                            loader = new URLClassLoader(ans);
+//                        }
+//                        else{
+//                            loader = new URLClassLoader(new URL[]{tempFiles[a].toURI().toURL()});
+//                        }
+//                    } catch (MalformedURLException e) {
+//                        e.printStackTrace();
+//                    } catch (Exception e){
+//                        e.printStackTrace();
+//                    }
+//                }
+//            }
+//        }
+//        if(tempJars.length() > 0){
+//            if (tempJars.substring(tempJars.length() - 1, tempJars.length()).equals(";")) {
+//                tempJars = tempJars.substring(0, tempJars.length() - 1);
+//            }
+//        }
+//        else{
+//            return null;
+//        }
+//        return tempJars;
+//    }
+//
+//    public static void loadJars(String dir) {
+//        String jars = parseFile(dir);
+//        if(jars == null){
+//            return;
+//        }
+//        String classPath = baseClassPath + System.getProperty("path.separator") + jars;
+//
+//        System.setProperty("java.class.path", classPath);
+//    }
+}
diff --git a/src/main/java/com/laytonsmith/core/functions/Regex.java b/src/main/java/com/laytonsmith/core/functions/Regex.java
new file mode 100644
index 0000000..cec363a
--- /dev/null
+++ b/src/main/java/com/laytonsmith/core/functions/Regex.java
@@ -0,0 +1,318 @@
+/*
+ * To change this template, choose Tools | Templates
+ * and open the template in the editor.
+ */
+package com.laytonsmith.core.functions;
+
+import com.laytonsmith.core.Env;
+import com.laytonsmith.core.Static;
+import com.laytonsmith.core.api;
+import com.laytonsmith.core.constructs.*;
+import com.laytonsmith.core.exceptions.ConfigRuntimeException;
+import com.laytonsmith.core.functions.Exceptions.ExceptionType;
+import java.io.File;
+import java.util.regex.Matcher;
+import java.util.regex.Pattern;
+
+/**
+ *
+ * @author Layton
+ */
+public class Regex {
+    
+    public static String docs(){
+        return "This class provides regular expression functions. For more details, please see the page on "
+                + "[[CommandHelper/Regex|regular expressions]]";
+    }
+    
+    @api public static class reg_match implements Function{
+
+        public String getName() {
+            return "reg_match";
+        }
+
+        public Integer[] numArgs() {
+            return new Integer[]{2};
+        }
+
+        public String docs() {
+            return "array {pattern, subject} Searches for the given pattern, and returns an array with the results. Captures are supported."
+                    + " If the pattern is not found anywhere in the subject, an empty array is returned. The indexes of the array"
+                    + " follow typical regex fashion; the 0th element is the whole match, and 1-n are the captures specified in"
+                    + " the regex.";
+        }
+
+        public ExceptionType[] thrown() {
+            return new ExceptionType[]{ExceptionType.FormatException};
+        }
+
+        public boolean isRestricted() {
+            return false;
+        }
+
+        public void varList(IVariableList varList) {}
+
+        public boolean preResolveVariables() {
+            return true;
+        }
+
+        public String since() {
+            return "3.2.0";
+        }
+
+        public Boolean runAsync() {
+            return null;
+        }
+
+        public Construct exec(int line_num, File f, Env env, Construct... args) throws ConfigRuntimeException {
+            Pattern pattern = getPattern(args[0], line_num, f);
+            String subject = args[1].val();
+            CArray ret = new CArray(line_num, f);
+            Matcher m = pattern.matcher(subject);
+            if(m.find()){
+                ret.push(new CString(m.group(0), line_num, f));
+
+                for(int i = 1; i <= m.groupCount(); i++){
+                    if(m.group(i) == null){
+                        ret.push(new CNull(line_num, f));
+                    } else {
+                        ret.push(Static.resolveConstruct(m.group(i), line_num, f));
+                    }
+                }
+            }
+            return ret;
+        }
+        
+    }
+    
+    @api public static class reg_match_all implements Function{
+
+        public String getName() {
+            return "reg_match_all";
+        }
+
+        public Integer[] numArgs() {
+            return new Integer[]{2};
+        }
+
+        public String docs() {
+            return "array {pattern, subject} Searches subject for all matches to the regular expression given in pattern, unlike reg_match,"
+                    + " which just returns the first match.";
+        }
+
+        public ExceptionType[] thrown() {
+            return new ExceptionType[]{ExceptionType.FormatException};
+        }
+
+        public boolean isRestricted() {
+            return false;
+        }
+
+        public void varList(IVariableList varList) {}
+
+        public boolean preResolveVariables() {
+            return true;
+        }
+
+        public String since() {
+            return "3.2.0";
+        }
+
+        public Boolean runAsync() {
+            return null;
+        }
+
+        public Construct exec(int line_num, File f, Env env, Construct... args) throws ConfigRuntimeException {
+            Pattern pattern = getPattern(args[0], line_num, f);
+            String subject = args[1].val();
+            CArray fret = new CArray(line_num, f);
+            Matcher m = pattern.matcher(subject);
+            while(m.find()){
+                CArray ret = new CArray(line_num, f);
+                ret.push(new CString(m.group(0), line_num, f));
+
+                for(int i = 1; i <= m.groupCount(); i++){
+                    ret.push(new CString(m.group(i), line_num, f));
+                }
+                fret.push(ret);
+            }
+            return fret;
+        }
+        
+    }
+    
+    @api public static class reg_replace implements Function{
+
+        public String getName() {
+            return "reg_replace";
+        }
+
+        public Integer[] numArgs() {
+            return new Integer[]{3};
+        }
+
+        public String docs() {
+            return "string {pattern, replacement, subject} Replaces any occurances of pattern with the replacement in subject."
+                    + " Back references are allowed.";
+        }
+
+        public ExceptionType[] thrown() {
+            return new ExceptionType[]{ExceptionType.FormatException};
+        }
+
+        public boolean isRestricted() {
+            return false;
+        }
+
+        public void varList(IVariableList varList) {}
+
+        public boolean preResolveVariables() {
+            return true;
+        }
+
+        public String since() {
+            return "3.2.0";
+        }
+
+        public Boolean runAsync() {
+            return null;
+        }
+
+        public Construct exec(int line_num, File f, Env env, Construct... args) throws ConfigRuntimeException {
+            Pattern pattern = getPattern(args[0], line_num, f);
+            String replacement = args[1].val();
+            String subject = args[2].val();
+            String ret = "";
+            
+            ret = pattern.matcher(subject).replaceAll(replacement);
+            
+            return new CString(ret, line_num, f);
+        }
+        
+    }
+    
+    @api public static class reg_split implements Function{
+
+        public String getName() {
+            return "reg_split";
+        }
+
+        public Integer[] numArgs() {
+            return new Integer[]{2};
+        }
+
+        public String docs() {
+            return "array {pattern, subject} Splits a string on the given regex, and returns an array of the parts. If"
+                    + " nothing matched, an array with one element, namely the original subject, is returned.";
+        }
+
+        public ExceptionType[] thrown() {
+            return new ExceptionType[]{ExceptionType.FormatException};
+        }
+
+        public boolean isRestricted() {
+            return false;
+        }
+
+        public void varList(IVariableList varList) {}
+
+        public boolean preResolveVariables() {
+            return true;
+        }
+
+        public String since() {
+            return "3.2.0";
+        }
+
+        public Boolean runAsync() {
+            return null;
+        }
+
+        public Construct exec(int line_num, File f, Env env, Construct... args) throws ConfigRuntimeException {
+            Pattern pattern = getPattern(args[0], line_num, f);
+            String subject = args[1].val();
+            String [] rsplit = pattern.split(subject);
+            CArray ret = new CArray(line_num, f);
+            for(String split : rsplit){
+                ret.push(new CString(split, line_num, f));
+            }
+            return ret;
+        }
+        
+        
+    }  
+    
+    @api public static class reg_count implements Function{
+
+        public String getName() {
+            return "reg_count";
+        }
+
+        public Integer[] numArgs() {
+            return new Integer[]{2};
+        }
+
+        public String docs() {
+            return "int {pattern, subject} Counts the number of occurances in the subject.";
+        }
+
+        public ExceptionType[] thrown() {
+            return new ExceptionType[]{ExceptionType.FormatException};
+        }
+
+        public boolean isRestricted() {
+            return false;
+        }
+
+        public void varList(IVariableList varList) {}
+
+        public boolean preResolveVariables() {
+            return true;
+        }
+
+        public String since() {
+            return "3.2.0";
+        }
+
+        public Boolean runAsync() {
+            return null;
+        }
+
+        public Construct exec(int line_num, File f, Env env, Construct... args) throws ConfigRuntimeException {
+            Pattern pattern = getPattern(args[0], line_num, f);
+            String subject = args[1].val();
+            long ret = 0;
+            Matcher m = pattern.matcher(subject);
+            while(m.find()){
+                ret++;
+            }
+            return new CInt(ret, line_num, f);
+        }
+        
+    }
+    
+    private static Pattern getPattern(Construct c, int line_num, File f){
+        String regex = "";
+        int flags = 0;
+        String sflags = "";
+        if(c instanceof CArray){
+            CArray ca = (CArray)c;
+            regex = ca.get(0, line_num, f).val();
+            sflags = ca.get(1, line_num, f).val();
+            for(int i = 0; i < sflags.length(); i++){
+                if(sflags.toLowerCase().charAt(i) == 'i'){
+                    flags |= Pattern.CASE_INSENSITIVE;
+                } else if(sflags.toLowerCase().charAt(i) == 'm'){
+                    flags |= Pattern.MULTILINE;
+                } else if(sflags.toLowerCase().charAt(i) == 's'){
+                    flags |= Pattern.DOTALL;
+                } else {
+                    throw new ConfigRuntimeException("Unrecognized flag: " + sflags.toLowerCase().charAt(i), ExceptionType.FormatException, line_num, f);
+                }
+            }
+        } else {
+            regex = c.val();
+        }
+        return Pattern.compile(regex, flags);
+    }
+}
diff --git a/src/main/java/com/laytonsmith/core/functions/Sandbox.java b/src/main/java/com/laytonsmith/core/functions/Sandbox.java
new file mode 100644
index 0000000..5e6164f
--- /dev/null
+++ b/src/main/java/com/laytonsmith/core/functions/Sandbox.java
@@ -0,0 +1,332 @@
+package com.laytonsmith.core.functions;
+
+import com.laytonsmith.abstraction.MCItemStack;
+import com.laytonsmith.abstraction.MCLocation;
+import com.laytonsmith.abstraction.MCPlayer;
+import com.laytonsmith.abstraction.bukkit.BukkitMCCommandSender;
+import com.laytonsmith.abstraction.bukkit.BukkitMCPlayer;
+import com.laytonsmith.core.*;
+import com.laytonsmith.core.constructs.CArray;
+import com.laytonsmith.core.constructs.CVoid;
+import com.laytonsmith.core.constructs.Construct;
+import com.laytonsmith.core.events.BoundEvent;
+import com.laytonsmith.core.exceptions.ConfigRuntimeException;
+import com.laytonsmith.core.functions.Exceptions.ExceptionType;
+import java.io.File;
+import java.lang.reflect.Constructor;
+import java.lang.reflect.InvocationTargetException;
+import java.lang.reflect.Method;
+import java.util.Arrays;
+import java.util.List;
+import java.util.SortedSet;
+import java.util.logging.Level;
+import java.util.logging.Logger;
+import org.bukkit.command.Command;
+import org.bukkit.command.ConsoleCommandSender;
+import org.bukkit.command.PluginCommand;
+import org.bukkit.event.Cancellable;
+import org.bukkit.event.Event;
+import org.bukkit.event.player.PlayerCommandPreprocessEvent;
+import org.bukkit.event.server.ServerCommandEvent;
+import org.bukkit.plugin.Plugin;
+import org.bukkit.plugin.RegisteredListener;
+import org.bukkit.plugin.SimplePluginManager;
+
+/**
+ * @author Layton
+ */
+public class Sandbox {
+
+    public static String docs() {
+        return "This class is for functions that are experimental. They don't actually get added"
+                + " to the documentation, and are subject to removal at any point in time, nor are they"
+                + " likely to have good documentation.";
+    }
+
+    @api
+    public static class plugin_cmd implements Function {
+
+        public String getName() {
+            return "plugin_cmd";
+        }
+
+        public Integer[] numArgs() {
+            return new Integer[]{2};
+        }
+
+        public String docs() {
+            return "void {plugin, cmd} ";
+        }
+
+        public ExceptionType[] thrown() {
+            return null;
+        }
+
+        public boolean isRestricted() {
+            return true;
+        }
+
+        public void varList(IVariableList varList) {
+        }
+
+        public boolean preResolveVariables() {
+            return true;
+        }
+
+        public String since() {
+            return "0.0.0";
+        }
+
+        public Boolean runAsync() {
+            return false;
+        }
+
+        public Construct exec(int line_num, File f, Env env, Construct... args) throws ConfigRuntimeException {
+            Object o = AliasCore.parent.getServer().getPluginManager();
+            if (o instanceof SimplePluginManager) {
+                SimplePluginManager spm = (SimplePluginManager) o;
+                try {
+                    Method m = spm.getClass().getDeclaredMethod("getEventListeners", Event.Type.class);
+                    m.setAccessible(true);
+                    SortedSet<RegisteredListener> sl = (SortedSet<RegisteredListener>) m.invoke(spm, Event.Type.SERVER_COMMAND);
+                    for(RegisteredListener l : sl){
+                        if (l.getPlugin().getDescription().getName().equalsIgnoreCase(args[0].val())) {
+                            if(env.GetCommandSender() instanceof ConsoleCommandSender){
+                                l.callEvent(new ServerCommandEvent((ConsoleCommandSender)env.GetCommandSender(), args[1].val()));
+                            }
+                        }
+                    }
+                    SortedSet<RegisteredListener> ss = (SortedSet<RegisteredListener>) m.invoke(spm, Event.Type.PLAYER_COMMAND_PREPROCESS);
+
+                    for (RegisteredListener l : ss) {
+                        if (l.getPlugin().getDescription().getName().equalsIgnoreCase(args[0].val())) {
+                            if(env.GetCommandSender() instanceof MCPlayer){
+                                l.callEvent(new PlayerCommandPreprocessEvent(((BukkitMCPlayer)env.GetPlayer())._Player(), args[1].val()));
+                            }
+                            PluginCommand.class.getDeclaredMethods();
+                            Constructor c = PluginCommand.class.getDeclaredConstructor(String.class, Plugin.class);
+                            c.setAccessible(true);
+                            List<String> argList = Arrays.asList(args[1].val().split(" "));
+                            Command com = (Command) c.newInstance(argList.get(0).substring(1), l.getPlugin());
+                            l.getPlugin().onCommand(((BukkitMCCommandSender)env.GetCommandSender())._CommandSender(), com, argList.get(0).substring(1), argList.subList(1, argList.size()).toArray(new String[]{}));
+                        }
+                    }
+                } catch (InstantiationException ex) {
+                    Logger.getLogger(Sandbox.class.getName()).log(Level.SEVERE, null, ex);
+                } catch (IllegalAccessException ex) {
+                    Logger.getLogger(Sandbox.class.getName()).log(Level.SEVERE, null, ex);
+                } catch (IllegalArgumentException ex) {
+                    Logger.getLogger(Sandbox.class.getName()).log(Level.SEVERE, null, ex);
+                } catch (InvocationTargetException ex) {
+                    Logger.getLogger(Sandbox.class.getName()).log(Level.SEVERE, null, ex);
+                } catch (NoSuchMethodException ex) {
+                    Logger.getLogger(Sandbox.class.getName()).log(Level.SEVERE, null, ex);
+                } catch (SecurityException ex) {
+                    Logger.getLogger(Sandbox.class.getName()).log(Level.SEVERE, null, ex);
+                }
+            }
+
+            return new CVoid(line_num, f);
+        }
+    }
+
+    @api
+    public static class item_drop implements Function {
+
+        public String getName() {
+            return "item_drop";
+        }
+
+        public Integer[] numArgs() {
+            return new Integer[]{1, 2, 3};
+        }
+
+        public String docs() {
+            return "void {[player/LocationArray], item, [qty]} Drops the specified item at the specified quantity at the specified player's feet (or "
+                    + " at an arbitrary Location, if an array is given),"
+                    + " like the vanilla /give command. player defaults to the current player, and qty defaults to 1. item follows the"
+                    + " same type[:data] format used elsewhere.";
+        }
+
+        public ExceptionType[] thrown() {
+            return new ExceptionType[]{ExceptionType.CastException, ExceptionType.FormatException, ExceptionType.PlayerOfflineException};
+        }
+
+        public boolean isRestricted() {
+            return true;
+        }
+
+        public void varList(IVariableList varList) {
+        }
+
+        public boolean preResolveVariables() {
+            return true;
+        }
+
+        public String since() {
+            return "3.2.0";
+        }
+
+        public Boolean runAsync() {
+            return false;
+        }
+
+        public Construct exec(int line_num, File f, Env env, Construct... args) throws ConfigRuntimeException {
+
+            MCLocation l = null;
+            int qty = 1;
+            MCItemStack is = null;
+            boolean natural = false;
+            if (env.GetCommandSender() instanceof MCPlayer) {
+                l = env.GetPlayer().getLocation();
+            }
+            if (args.length == 1) {
+                //It is just the item
+                is = Static.ParseItemNotation(this.getName(), args[0].val(), qty, line_num, f);
+                natural = true;
+            } else if (args.length == 2) {
+                //If args[0] starts with a number, it's the (item, qty) version, otherwise it's
+                //(player, item)
+                if (args[0].val().matches("\\d.*")) {
+                    qty = (int) Static.getInt(args[1]);
+                    is = Static.ParseItemNotation(this.getName(), args[0].val(), qty, line_num, f);
+                    natural = true;
+                } else {
+                    if (args[0] instanceof CArray) {
+                        l = ObjectGenerator.GetGenerator().location(args[0], (l != null ? l.getWorld() : null), line_num, f);
+                        natural = false;
+                    } else {
+                        l = Static.GetPlayer(args[0].val(), line_num, f).getLocation();
+                        natural = true;
+                    }
+                    is = Static.ParseItemNotation(this.getName(), args[1].val(), qty, line_num, f);
+
+                }
+            } else if (args.length == 3) {
+                //We are specifying all 3
+                if (args[0] instanceof CArray) {
+                    l = ObjectGenerator.GetGenerator().location(args[0], (l != null ? l.getWorld() : null), line_num, f);
+                    natural = false;
+                } else {
+                    l = Static.GetPlayer(args[0].val(), line_num, f).getLocation();
+                    natural = true;
+                }
+                qty = (int) Static.getInt(args[2]);
+                is = Static.ParseItemNotation(this.getName(), args[1].val(), qty, line_num, f);
+            }
+            if (l.getWorld() != null) {
+                if (natural) {
+                    l.getWorld().dropItemNaturally(l, is);
+                } else {
+                    l.getWorld().dropItem(l, is);
+                }
+            } else {
+                throw new ConfigRuntimeException("World was not specified", ExceptionType.InvalidWorldException, line_num, f);
+            }
+
+            return new CVoid(line_num, f);
+        }
+    }
+
+    @api
+    public static class npe implements Function {
+
+        public String getName() {
+            return "npe";
+        }
+
+        public Integer[] numArgs() {
+            return new Integer[]{0};
+        }
+
+        public String docs() {
+            return "void {}";
+        }
+
+        public ExceptionType[] thrown() {
+            return null;
+        }
+
+        public boolean isRestricted() {
+            return true;
+        }
+
+        public void varList(IVariableList varList) {
+        }
+
+        public boolean preResolveVariables() {
+            return true;
+        }
+
+        public String since() {
+            return "0.0.0";
+        }
+
+        public Boolean runAsync() {
+            return null;
+        }
+
+        public Construct exec(int line_num, File f, Env env, Construct... args) throws ConfigRuntimeException {
+            Object o = null;
+            o.toString();
+            return new CVoid(line_num, f);
+        }
+    }
+    
+    @api public static class super_cancel implements Function{
+
+        public String getName() {
+            return "super_cancel";
+        }
+
+        public Integer[] numArgs() {
+            return new Integer[]{0};
+        }
+
+        public String docs() {
+            return "void {} \"Super Cancels\" an event. This only will work if play-dirty is set to true. If an event is"
+                    + " super cancelled, not only is the cancelled flag set to true, the event stops propagating down, so"
+                    + " no other plugins (as in other server plugins, not just CH scripts) will receive the event at all "
+                    + " (other than monitor level plugins). This is useful for overridding"
+                    + " event handlers for plugins that don't respect the cancelled flag. This function hooks into the play-dirty"
+                    + " framework that injects custom event handlers into bukkit.";
+        }
+
+        public ExceptionType[] thrown() {
+            return new ExceptionType[]{ExceptionType.BindException};
+        }
+
+        public boolean isRestricted() {
+            return true;
+        }
+
+        public boolean preResolveVariables() {
+            return true;
+        }
+
+        public String since() {
+            return "3.3.0";
+        }
+
+        public Boolean runAsync() {
+            return null;
+        }
+
+        public Construct exec(int line_num, File f, Env environment, Construct... args) throws ConfigRuntimeException {
+            BoundEvent.ActiveEvent original = environment.GetEvent();
+            if(original == null){
+                throw new ConfigRuntimeException("is_cancelled cannot be called outside an event handler", ExceptionType.BindException, line_num, f);
+            }
+            if(original.getUnderlyingEvent() != null && original.getUnderlyingEvent() instanceof Cancellable 
+                    && original.getUnderlyingEvent() instanceof org.bukkit.event.Event){
+                ((Cancellable)original.getUnderlyingEvent()).setCancelled(true);
+                BukkitDirtyRegisteredListener.setCancelled((org.bukkit.event.Event)original.getUnderlyingEvent());
+            }
+            environment.GetEvent().setCancelled(true);
+            return new CVoid(line_num, f);
+        }
+        
+    }
+
+    
+}
diff --git a/src/main/java/com/laytonsmith/core/functions/Scheduling.java b/src/main/java/com/laytonsmith/core/functions/Scheduling.java
new file mode 100644
index 0000000..4c4976b
--- /dev/null
+++ b/src/main/java/com/laytonsmith/core/functions/Scheduling.java
@@ -0,0 +1,172 @@
+/*
+ * To change this template, choose Tools | Templates
+ * and open the template in the editor.
+ */
+package com.laytonsmith.core.functions;
+
+import com.laytonsmith.core.Env;
+import com.laytonsmith.core.Static;
+import com.laytonsmith.core.api;
+import com.laytonsmith.core.constructs.CInt;
+import com.laytonsmith.core.constructs.CVoid;
+import com.laytonsmith.core.constructs.Construct;
+import com.laytonsmith.core.exceptions.CancelCommandException;
+import com.laytonsmith.core.exceptions.ConfigRuntimeException;
+import com.laytonsmith.core.functions.Exceptions.ExceptionType;
+import java.io.File;
+
+/**
+ *
+ * @author Layton
+ */
+public class Scheduling {
+    public static String docs(){
+        return "This class contains methods for dealing with time and server scheduling.";
+    }
+    @api public static class time implements Function{
+
+        public String getName() {
+            return "time";
+        }
+
+        public Integer[] numArgs() {
+            return new Integer[]{0};
+        }
+
+        public String docs() {
+            return "int {} Returns the current unix time stamp, in milliseconds. The resolution of this is not guaranteed to be extremely accurate. If "
+                    + "you need extreme accuracy, use nano_time()";
+        }
+        
+        public ExceptionType[] thrown() {
+            return new ExceptionType[]{};
+        }
+
+        public boolean isRestricted() {
+            return false;
+        }
+
+        public void varList(IVariableList varList) {}
+
+        public boolean preResolveVariables() {
+            return true;
+        }
+
+        public String since() {
+            return "3.1.0";
+        }
+
+        public Boolean runAsync() {
+            return null;
+        }
+
+        public Construct exec(int line_num, File f, Env env, Construct... args) throws CancelCommandException, ConfigRuntimeException {
+            return new CInt(System.currentTimeMillis(), line_num, f);
+        }
+        
+    }
+    
+    @api public static class nano_time implements Function{
+
+        public String getName() {
+            return "nano_time";
+        }
+
+        public Integer[] numArgs() {
+            return new Integer[]{0};
+        }
+
+        public String docs() {
+            return "int {} Returns an arbitrary number based on the most accurate clock available on this system. Only useful when compared to other calls"
+                    + " to nano_time(). The return is in nano seconds. See the Java API on System.nanoTime() for more information on the usage of this function.";
+        }
+        
+        public ExceptionType[] thrown() {
+            return new ExceptionType[]{};
+        }
+
+        public boolean isRestricted() {
+            return false;
+        }
+
+        public void varList(IVariableList varList) {}
+
+        public boolean preResolveVariables() {
+            return true;
+        }
+
+        public String since() {
+            return "3.1.0";
+        }
+
+        public Boolean runAsync() {
+            return null;
+        }
+
+        public Construct exec(int line_num, File f, Env env, Construct... args) throws CancelCommandException, ConfigRuntimeException {
+            return new CInt(System.nanoTime(), line_num, f);
+        }
+        
+    }
+    
+    public static class sleep implements Function {
+
+        public String getName() {
+            return "sleep";
+        }
+
+        public Integer[] numArgs() {
+            return new Integer[]{1};
+        }
+
+        public String docs() {
+            return "void {seconds} Sleeps the script for the specified number of seconds, up to the maximum time limit defined in the preferences file."
+                    + " Seconds may be a double value, so 0.5 would be half a second."
+                    + " PLEASE NOTE: Sleep times are NOT very accurate, and should not be relied on for preciseness.";
+        }
+        
+        public ExceptionType[] thrown() {
+            return new ExceptionType[]{ExceptionType.CastException};
+        }
+
+        public boolean isRestricted() {
+            return true;
+        }
+
+        public void varList(IVariableList varList) {
+        }
+
+        public boolean preResolveVariables() {
+            return true;
+        }
+
+        public String since() {
+            return "3.1.0";
+        }
+
+        public Construct exec(int line_num, File f, Env env, Construct... args) throws CancelCommandException, ConfigRuntimeException {
+            if (Thread.currentThread().getName().equals("Server thread")) {
+                throw new ConfigRuntimeException("sleep() cannot be run in the main server thread", 
+                        null, line_num, f);
+            }
+            Construct x = args[0];
+            double time = Static.getNumber(x);
+            Integer i = (Integer) (Static.getPreferences().getPreference("max-sleep-time"));
+            if (i > time || i <= 0) {
+                try {
+                    Thread.sleep((int)(time * 1000));
+                } catch (InterruptedException ex) {
+                }
+            } else {
+                throw new ConfigRuntimeException("The value passed to sleep must be less than the server defined value of " + i + " seconds or less.", 
+                        ExceptionType.RangeException, line_num, f);
+            }
+            return new CVoid(line_num, f);
+        }
+
+        public Boolean runAsync() {
+            //Because we stop the thread
+            return true;
+        }
+    }
+}
diff --git a/src/main/java/com/laytonsmith/core/functions/StringHandling.java b/src/main/java/com/laytonsmith/core/functions/StringHandling.java
new file mode 100644
index 0000000..d7c1231
--- /dev/null
+++ b/src/main/java/com/laytonsmith/core/functions/StringHandling.java
@@ -0,0 +1,617 @@
+/*
+ * To change this template, choose Tools | Templates
+ * and open the template in the editor.
+ */
+package com.laytonsmith.core.functions;
+
+import com.laytonsmith.core.Env;
+import com.laytonsmith.core.GenericTreeNode;
+import com.laytonsmith.core.Static;
+import com.laytonsmith.core.api;
+import com.laytonsmith.core.constructs.*;
+import com.laytonsmith.core.exceptions.CancelCommandException;
+import com.laytonsmith.core.exceptions.ConfigRuntimeException;
+import com.laytonsmith.core.functions.Exceptions.ExceptionType;
+import java.io.BufferedReader;
+import java.io.File;
+import java.io.FileReader;
+import java.util.ArrayList;
+import java.util.List;
+import java.util.logging.Level;
+
+/**
+ *
+ * @author Layton
+ */
+public class StringHandling {
+
+    public static String docs() {
+        return "These class provides functions that allow strings to be manipulated";
+    }
+    
+    //@api
+    public static class cc implements Function{
+
+        public String getName() {
+            return "cc";
+        }
+
+        public Integer[] numArgs() {
+            return new Integer[]{Integer.MAX_VALUE};
+        }
+
+        public String docs() {
+            return "string {args...} The cousin to <strong>c</strong>on<strong>c</strong>at, this function does some magic under the covers"
+                    + " to remove the auto-concatenation effect in bare strings. Take the following examples.";
+        }
+
+        public ExceptionType[] thrown() {
+            throw new UnsupportedOperationException("Not supported yet.");
+        }
+
+        public boolean isRestricted() {
+            throw new UnsupportedOperationException("Not supported yet.");
+        }
+
+        public boolean preResolveVariables() {
+            throw new UnsupportedOperationException("Not supported yet.");
+        }
+
+        public String since() {
+            throw new UnsupportedOperationException("Not supported yet.");
+        }
+
+        public Boolean runAsync() {
+            throw new UnsupportedOperationException("Not supported yet.");
+        }
+
+        public Construct exec(int line_num, File f, Env environment, Construct... args) throws ConfigRuntimeException {
+            throw new UnsupportedOperationException("Not supported yet.");
+        }
+        
+    }
+
+    @api
+    public static class concat implements Function {
+
+        public String getName() {
+            return "concat";
+        }
+
+        public Integer[] numArgs() {
+            return new Integer[]{Integer.MAX_VALUE};
+        }
+
+        public ExceptionType[] thrown() {
+            return new ExceptionType[]{};
+        }
+
+        public Construct exec(int line_num, File f, Env env, Construct... args) throws CancelCommandException, ConfigRuntimeException {
+            StringBuilder b = new StringBuilder();
+            for (int i = 0; i < args.length; i++) {
+                b.append(args[i].val());
+            }
+            return new CString(b.toString(), line_num, f);
+        }
+
+        public String docs() {
+            return "string {var1, [var2...]} Concatenates any number of arguments together, and returns a string";
+        }
+
+        public boolean isRestricted() {
+            return false;
+        }
+
+        public void varList(IVariableList varList) {
+        }
+
+        public boolean preResolveVariables() {
+            return true;
+        }
+
+        public String since() {
+            return "3.0.1";
+        }
+
+        public Boolean runAsync() {
+            return null;
+        }
+    }
+
+    @api
+    public static class sconcat implements Function {
+
+        public String getName() {
+            return "sconcat";
+        }
+
+        public Integer[] numArgs() {
+            return new Integer[]{Integer.MAX_VALUE};
+        }
+
+        public Construct exec(int line_num, File f, Env env, Construct... args) throws CancelCommandException, ConfigRuntimeException {
+            return null;
+        }
+
+        public Construct execs(int line_num, File f, Env env, List<GenericTreeNode<Construct>> nodes) throws CancelCommandException, ConfigRuntimeException {
+            StringBuilder b = new StringBuilder();
+            boolean centry = false;
+            Construct key = null;
+            for (int i = 0; i < nodes.size(); i++) {
+                Construct c = env.GetScript().preResolveVariable(env.GetScript().eval(nodes.get(i), env));
+                if (i == 0) {
+                    if (c instanceof CLabel) {
+                        key = c;
+                        centry = true;
+                        break;
+                    }
+                }
+                if (!centry) {
+                    if (i > 1 || i > 0 && !centry) {
+                        b.append(" ");
+                    }
+                    b.append(c.val());
+                }
+            }
+            if (centry) {
+                Construct value;
+                if (nodes.subList(1, nodes.size()).size() > 1) {
+                    //it's a string
+                    StringBuilder c = new StringBuilder();
+                    for (int i = 1; i < nodes.size(); i++) {
+                        Construct d = env.GetScript().preResolveVariable(env.GetScript().eval(nodes.get(i), env));
+                        if (i > 1) {
+                            c.append(" ");
+                        }
+                        c.append(d.val());                        
+                    }
+                    value = new CString(c.toString(), line_num, f);
+                } else {
+                    value = env.GetScript().eval(nodes.subList(1, nodes.size()).get(0), env);
+                }
+                value = env.GetScript().preResolveVariable(value);
+                return new CEntry(key, value, line_num, f);
+            } else {
+                return new CString(b.toString(), line_num, f);
+            }
+        }
+
+        public String docs() {
+            return "string {var1, [var2...]} Concatenates any number of arguments together, but puts a space between elements";
+        }
+
+        public ExceptionType[] thrown() {
+            return new ExceptionType[]{};
+        }
+
+        public boolean isRestricted() {
+            return false;
+        }
+
+        public void varList(IVariableList varList) {
+        }
+
+        public boolean preResolveVariables() {
+            return true;
+        }
+
+        public String since() {
+            return "3.0.1";
+        }
+
+        public Boolean runAsync() {
+            return null;
+        }
+    }
+
+    @api
+    public static class read implements Function {
+
+        public static String file_get_contents(String file_location) throws Exception {
+            BufferedReader in = new BufferedReader(new FileReader(file_location));
+            StringBuilder ret = new StringBuilder();
+            String str;
+            while ((str = in.readLine()) != null) {
+                ret.append(str).append("\n");
+            }
+            in.close();
+            return ret.toString();
+        }
+
+        public String getName() {
+            return "read";
+        }
+
+        public Integer[] numArgs() {
+            return new Integer[]{1};
+        }
+
+        public Construct exec(int line_num, File f, Env env, Construct... args) throws CancelCommandException, ConfigRuntimeException {
+            String location = args[0].val();
+            //Verify this file is not above the craftbukkit directory (or whatever directory the user specified
+            if (!Static.CheckSecurity(location)) {
+                throw new ConfigRuntimeException("You do not have permission to access the file '" + location + "'",
+                        ExceptionType.SecurityException, line_num, f);
+            }
+            try {
+                String s = file_get_contents(location);
+                s = s.replaceAll("\n|\r\n", "\n");
+                return new CString(s, line_num, f);
+            } catch (Exception ex) {
+                Static.getLogger().log(Level.SEVERE, "Could not read in file while attempting to find " + new File(location).getAbsolutePath()
+                        + "\nFile " + (new File(location).exists() ? "exists" : "does not exist"));
+                ex.printStackTrace();
+                throw new ConfigRuntimeException("File could not be read in.",
+                        ExceptionType.IOException, line_num, f);
+            }
+        }
+
+        public String docs() {
+            return "string {file} Reads in a file from the file system at location var1 and returns it as a string. The path is relative to"
+                    + " the server, not CommandHelper. If the file is not found, or otherwise can't be read in, an IOException is thrown."
+                    + " If the file specified is not within base-dir (as specified in the preferences file), a SecurityException is thrown."
+                    + " The line endings for the string returned will always be \\n, even if they originally were \\r\\n.";
+        }
+
+        public ExceptionType[] thrown() {
+            return new ExceptionType[]{ExceptionType.IOException, ExceptionType.SecurityException};
+        }
+
+        public boolean isRestricted() {
+            return true;
+        }
+
+        public void varList(IVariableList varList) {
+        }
+
+        public boolean preResolveVariables() {
+            return true;
+        }
+
+        public String since() {
+            return "3.0.1";
+        }
+
+        public Boolean runAsync() {
+            //Because we do disk IO
+            return true;
+        }
+    }
+
+    @api
+    public static class replace implements Function {
+
+        public String getName() {
+            return "replace";
+        }
+
+        public Integer[] numArgs() {
+            return new Integer[]{3};
+        }
+
+        public Construct exec(int line_num, File f, Env env, Construct... args) throws CancelCommandException, ConfigRuntimeException {
+            String thing = args[0].val();
+            String what = args[1].val();
+            String that = args[2].val();
+            return new CString(thing.replace(what, that), line_num, f);
+        }
+
+        public String docs() {
+            return "string {main, what, that} Replaces all instances of 'what' with 'that' in 'main'";
+        }
+
+        public ExceptionType[] thrown() {
+            return new ExceptionType[]{};
+        }
+
+        public boolean isRestricted() {
+            return false;
+        }
+
+        public void varList(IVariableList varList) {
+        }
+
+        public boolean preResolveVariables() {
+            return true;
+        }
+
+        public String since() {
+            return "3.0.1";
+        }
+
+        public Boolean runAsync() {
+            return null;
+        }
+    }
+
+    @api
+    public static class parse_args implements Function {
+
+        public String getName() {
+            return "parse_args";
+        }
+
+        public Integer[] numArgs() {
+            return new Integer[]{1};
+        }
+
+        public Construct exec(int line_num, File f, Env env, Construct... args) throws CancelCommandException, ConfigRuntimeException {
+            String[] sa = args[0].val().split(" ");
+            ArrayList<Construct> a = new ArrayList<Construct>();
+            for (String s : sa) {
+                if (!s.trim().equals("")) {
+                    a.add(new CString(s.trim(), line_num, f));
+                }
+            }
+            Construct[] csa = new Construct[a.size()];
+            for (int i = 0; i < a.size(); i++) {
+                csa[i] = a.get(i);
+            }
+            return new CArray(line_num, f, csa);
+        }
+
+        public String docs() {
+            return "array {string} Parses string into an array, where string is a space seperated list of arguments. Handy for turning"
+                    + " $ into a usable array of items with which to script against. Extra spaces are ignored, so you would never get an empty"
+                    + " string as an input.";
+        }
+
+        public ExceptionType[] thrown() {
+            return new ExceptionType[]{};
+        }
+
+        public boolean isRestricted() {
+            return false;
+        }
+
+        public void varList(IVariableList varList) {
+        }
+
+        public boolean preResolveVariables() {
+            return true;
+        }
+
+        public String since() {
+            return "3.0.1";
+        }
+
+        public Boolean runAsync() {
+            return null;
+        }
+    }
+
+    @api
+    public static class trim implements Function {
+
+        public String getName() {
+            return "trim";
+        }
+
+        public Integer[] numArgs() {
+            return new Integer[]{1};
+        }
+
+        public String docs() {
+            return "string {s} Returns the string s with leading and trailing whitespace cut off";
+        }
+
+        public ExceptionType[] thrown() {
+            return new ExceptionType[]{};
+        }
+
+        public boolean isRestricted() {
+            return false;
+        }
+
+        public void varList(IVariableList varList) {
+        }
+
+        public boolean preResolveVariables() {
+            return true;
+        }
+
+        public String since() {
+            return "3.0.1";
+        }
+
+        public Construct exec(int line_num, File f, Env env, Construct... args) throws CancelCommandException, ConfigRuntimeException {
+            return new CString(args[0].val().trim(), args[0].getLineNum(), args[0].getFile());
+        }
+
+        public Boolean runAsync() {
+            return null;
+        }
+    }
+
+    @api
+    public static class length implements Function {
+
+        public String getName() {
+            return "length";
+        }
+
+        public Integer[] numArgs() {
+            return new Integer[]{1};
+        }
+
+        public String docs() {
+            return "int {str | array} Returns the character length of str, if the value is castable to a string, or the length of the array, if an array is given";
+        }
+
+        public ExceptionType[] thrown() {
+            return new ExceptionType[]{};
+        }
+
+        public boolean isRestricted() {
+            return false;
+        }
+
+        public void varList(IVariableList varList) {
+        }
+
+        public boolean preResolveVariables() {
+            return true;
+        }
+
+        public String since() {
+            return "3.1.2";
+        }
+
+        public Boolean runAsync() {
+            return null;
+        }
+
+        public Construct exec(int line_num, File f, Env env, Construct... args) throws CancelCommandException, ConfigRuntimeException {
+            if (args[0] instanceof CArray) {
+                return new CInt(((CArray) args[0]).size(), line_num, f);
+            } else {
+                return new CInt(args[0].val().length(), line_num, f);
+            }
+        }
+    }
+
+    @api
+    public static class to_upper implements Function {
+
+        public String getName() {
+            return "to_upper";
+        }
+
+        public Integer[] numArgs() {
+            return new Integer[]{1};
+        }
+
+        public String docs() {
+            return "string {str} Returns an all caps version of str";
+        }
+
+        public ExceptionType[] thrown() {
+            return new ExceptionType[]{};
+        }
+
+        public boolean isRestricted() {
+            return false;
+        }
+
+        public void varList(IVariableList varList) {
+        }
+
+        public boolean preResolveVariables() {
+            return true;
+        }
+
+        public String since() {
+            return "3.1.2";
+        }
+
+        public Boolean runAsync() {
+            return null;
+        }
+
+        public Construct exec(int line_num, File f, Env env, Construct... args) throws CancelCommandException, ConfigRuntimeException {
+            return new CString(args[0].val().toUpperCase(), line_num, f);
+        }
+    }
+
+    @api
+    public static class to_lower implements Function {
+
+        public String getName() {
+            return "to_lower";
+        }
+
+        public Integer[] numArgs() {
+            return new Integer[]{1};
+        }
+
+        public String docs() {
+            return "string {str} Returns an all lower case version of str";
+        }
+
+        public ExceptionType[] thrown() {
+            return new ExceptionType[]{};
+        }
+
+        public boolean isRestricted() {
+            return false;
+        }
+
+        public void varList(IVariableList varList) {
+        }
+
+        public boolean preResolveVariables() {
+            return true;
+        }
+
+        public String since() {
+            return "3.1.2";
+        }
+
+        public Boolean runAsync() {
+            return null;
+        }
+
+        public Construct exec(int line_num, File f, Env env, Construct... args) throws CancelCommandException, ConfigRuntimeException {
+            return new CString(args[0].val().toLowerCase(), line_num, f);
+        }
+    }
+
+    @api
+    public static class substr implements Function {
+
+        public String getName() {
+            return "substr";
+        }
+
+        public Integer[] numArgs() {
+            return new Integer[]{2, 3};
+        }
+
+        public String docs() {
+            return "string {str, begin, [end]} Returns a substring of the given string str, starting from index begin, to index end, or the"
+                    + " end of the string, if no index is given. If either begin or end are out of bounds of the string, an exception is thrown."
+                    + " substr('hamburger', 4, 8) returns \"urge\", substr('smiles', 1, 5) returns \"mile\", and substr('lightning', 5) returns \"ning\"."
+                    + " See also length().";
+        }
+
+        public ExceptionType[] thrown() {
+            return new ExceptionType[]{ExceptionType.RangeException, ExceptionType.CastException};
+        }
+
+        public boolean isRestricted() {
+            return false;
+        }
+
+        public void varList(IVariableList varList) {
+        }
+
+        public boolean preResolveVariables() {
+            return true;
+        }
+
+        public String since() {
+            return "3.1.2";
+        }
+
+        public Boolean runAsync() {
+            return null;
+        }
+
+        public Construct exec(int line_num, File f, Env env, Construct... args) throws CancelCommandException, ConfigRuntimeException {
+            try {
+                String s = args[0].val();
+                int begin = (int) Static.getInt(args[1]);
+                int end;
+                if (args.length == 3) {
+                    end = (int) Static.getInt(args[2]);
+                } else {
+                    end = s.length();
+                }
+                return new CString(s.substring(begin, end), line_num, f);
+            } catch (IndexOutOfBoundsException e) {
+                throw new ConfigRuntimeException("The indices given are not valid for string '" + args[0].val() + "'",
+                        ExceptionType.RangeException, line_num, f);
+            }
+        }
+    }
+}
diff --git a/src/main/java/com/laytonsmith/core/functions/Weather.java b/src/main/java/com/laytonsmith/core/functions/Weather.java
new file mode 100644
index 0000000..7e29af2
--- /dev/null
+++ b/src/main/java/com/laytonsmith/core/functions/Weather.java
@@ -0,0 +1,157 @@
+/*
+ * To change this template, choose Tools | Templates
+ * and open the template in the editor.
+ */
+package com.laytonsmith.core.functions;
+
+import com.laytonsmith.abstraction.MCLocation;
+import com.laytonsmith.abstraction.MCPlayer;
+import com.laytonsmith.abstraction.MCWorld;
+import com.laytonsmith.abstraction.StaticLayer;
+import com.laytonsmith.core.Env;
+import com.laytonsmith.core.ObjectGenerator;
+import com.laytonsmith.core.Static;
+import com.laytonsmith.core.api;
+import com.laytonsmith.core.constructs.CArray;
+import com.laytonsmith.core.constructs.CVoid;
+import com.laytonsmith.core.constructs.Construct;
+import com.laytonsmith.core.exceptions.CancelCommandException;
+import com.laytonsmith.core.exceptions.ConfigRuntimeException;
+import com.laytonsmith.core.functions.Exceptions.ExceptionType;
+import java.io.File;
+
+/**
+ *
+ * @author Layton
+ */
+public class Weather {
+    public static String docs(){
+        return "Provides functions to control the weather";
+    }
+    
+    @api public static class lightning implements Function{
+
+        public String getName() {
+            return "lightning";
+        }
+
+        public Integer[] numArgs() {
+            return new Integer[]{1, 2, 3, 4};
+        }
+        
+        public ExceptionType[] thrown() {
+            return new ExceptionType[]{ExceptionType.CastException, ExceptionType.LengthException, ExceptionType.InvalidWorldException, ExceptionType.FormatException};
+        }
+
+        public Construct exec(int line_num, File f, Env env, Construct... args) throws CancelCommandException, ConfigRuntimeException {
+            int x;
+            int y;
+            int z;
+            MCWorld w = null;
+            boolean safe = false;
+            int safeIndex = 1;
+            if(args[0] instanceof CArray){
+                CArray a = (CArray)args[0];
+                MCLocation l = ObjectGenerator.GetGenerator().location(a, (env.GetCommandSender() instanceof MCPlayer?env.GetPlayer().getWorld():null), line_num, f);
+                x = (int)java.lang.Math.floor(l.getX());
+                y = (int)java.lang.Math.floor(l.getY());
+                z = (int)java.lang.Math.floor(l.getZ());
+                w = l.getWorld();
+            } else {
+                x = (int)java.lang.Math.floor(Static.getNumber(args[0]));
+                y = (int)java.lang.Math.floor(Static.getNumber(args[1]));
+                z = (int)java.lang.Math.floor(Static.getNumber(args[2]));
+                safeIndex = 3;
+            }
+            if(args.length >= safeIndex + 1){
+                safe = Static.getBoolean(args[safeIndex]);
+            }
+            if(w != null){
+                if(!safe){
+                    w.strikeLightning(StaticLayer.GetLocation(w, x, y + 1, z)); 
+                } else {
+                    w.strikeLightningEffect(StaticLayer.GetLocation(w, x, y + 1, z));
+                }
+            } else {
+                throw new ConfigRuntimeException("World was not specified", ExceptionType.InvalidWorldException, line_num, f);
+            }
+            
+            return new CVoid(line_num, f);
+        }
+
+        public String docs() {
+            return "void {strikeLocArray, [safe] | x, y, z, [safe]} Makes lightning strike at the x y z coordinates specified in the array(x, y, z). safe"
+                    + " defaults to false, but if true, lightning striking a player will not hurt them.";
+        }
+
+        public boolean isRestricted() {
+            return true;
+        }
+
+        public void varList(IVariableList varList) {}
+
+        public boolean preResolveVariables() {
+            return true;
+        }
+        public String since() {
+            return "3.0.1";
+        }
+        public Boolean runAsync(){
+            return false;
+        }
+    }
+    
+    @api public static class storm implements Function{
+
+        public String getName() {
+            return "storm";
+        }
+
+        public Integer[] numArgs() {
+            return new Integer[]{1, 2};
+        }
+
+        public Construct exec(int line_num, File f, Env env, Construct... args) throws CancelCommandException, ConfigRuntimeException {
+            boolean b = Static.getBoolean(args[0]);
+            MCWorld w = null;
+            if(env.GetCommandSender() instanceof MCPlayer){
+                w = env.GetPlayer().getWorld();
+            }
+            if(args.length == 2){
+                w = Static.getServer().getWorld(args[1].val());
+            }
+            if(w != null){
+                w.setStorm(b);
+            } else {
+                throw new ConfigRuntimeException("World was not specified", ExceptionType.InvalidWorldException, line_num, f);
+            }
+            return new CVoid(line_num, f);
+        }
+
+        public String docs() {
+            return "void {isStorming, [world]} Creates a storm if isStorming is true, stops a storm if isStorming is false";
+        }
+        
+        public ExceptionType[] thrown() {
+            return new ExceptionType[]{ExceptionType.CastException, ExceptionType.InvalidWorldException};
+        }
+
+        public boolean isRestricted() {
+            return true;
+        }
+
+        public void varList(IVariableList varList) {}
+
+        public boolean preResolveVariables() {
+            return true;
+        }
+        public String since() {
+            return "3.0.1";
+        }
+        public Boolean runAsync(){
+            return false;
+        }
+        
+    }
+    
+}
diff --git a/src/main/java/com/laytonsmith/core/functions/World.java b/src/main/java/com/laytonsmith/core/functions/World.java
new file mode 100644
index 0000000..6acf950
--- /dev/null
+++ b/src/main/java/com/laytonsmith/core/functions/World.java
@@ -0,0 +1,319 @@
+/*
+ * To change this template, choose Tools | Templates
+ * and open the template in the editor.
+ */
+package com.laytonsmith.core.functions;
+
+import com.laytonsmith.abstraction.MCLocation;
+import com.laytonsmith.abstraction.MCPlayer;
+import com.laytonsmith.abstraction.MCWorld;
+import com.laytonsmith.core.Env;
+import com.laytonsmith.core.ObjectGenerator;
+import com.laytonsmith.core.Static;
+import com.laytonsmith.core.api;
+import com.laytonsmith.core.constructs.*;
+import com.laytonsmith.core.exceptions.ConfigRuntimeException;
+import com.laytonsmith.core.functions.Exceptions.ExceptionType;
+import java.io.File;
+import java.io.IOException;
+import java.util.Enumeration;
+import java.util.Properties;
+import java.util.SortedMap;
+import java.util.TreeMap;
+import java.util.logging.Level;
+import java.util.logging.Logger;
+import java.util.regex.Matcher;
+import java.util.regex.Pattern;
+
+/**
+ *
+ * @author Layton
+ */
+public class World {
+    public static String docs(){
+        return "Provides functions for manipulating a world";
+    }
+    
+    @api public static class get_spawn implements Function{
+
+        public String getName() {
+            return "get_spawn";
+        }
+
+        public Integer[] numArgs() {
+            return new Integer[]{0, 1};
+        }
+
+        public String docs() {
+            return "array {[world]} Returns a location array for the specified world, or the current player's world, if not specified.";
+        }
+
+        public ExceptionType[] thrown() {
+            return new ExceptionType[]{ExceptionType.InvalidWorldException, ExceptionType.FormatException};
+        }
+
+        public boolean isRestricted() {
+            return true;
+        }
+
+        public boolean preResolveVariables() {
+            return true;
+        }
+
+        public String since() {
+            return "3.3.0";
+        }
+
+        public Boolean runAsync() {
+            return false;
+        }
+
+        public Construct exec(int line_num, File f, Env environment, Construct... args) throws ConfigRuntimeException {
+            String world;
+            if(args.length == 1){
+                world = environment.GetPlayer().getWorld().getName();
+            } else {
+                world = args[0].val();
+            }
+            return ObjectGenerator.GetGenerator().location(Static.getServer().getWorld(world).getSpawnLocation());
+        }
+        
+    }
+    
+    @api public static class refresh_chunk implements Function{
+
+        public String getName() {
+            return "refresh_chunk";
+        }
+
+        public Integer[] numArgs() {
+            return new Integer[]{1, 2, 3};
+        }
+
+        public String docs() {
+            return "void {[world], x, z | [world], locationArray} Resends the chunk to all clients, using the specified world, or the current"
+                    + " players world if not provided.";
+        }
+
+        public ExceptionType[] thrown() {
+            return new ExceptionType[]{ExceptionType.CastException, ExceptionType.FormatException, ExceptionType.InvalidWorldException};
+        }
+
+        public boolean isRestricted() {
+            return true;
+        }
+
+        public boolean preResolveVariables() {
+            return true;
+        }
+
+        public String since() {
+            return "3.3.0";
+        }
+
+        public Boolean runAsync() {
+            return false;
+        }
+
+        public Construct exec(int line_num, File f, Env environment, Construct... args) throws ConfigRuntimeException {
+            MCPlayer m = environment.GetPlayer();
+            MCWorld world;
+            int x;
+            int z;
+            if(args.length == 1){
+                //Location array provided                
+                MCLocation l = ObjectGenerator.GetGenerator().location(args[0], m!=null?m.getWorld():null, line_num, f);
+                world = l.getWorld();
+                x = l.getBlockX();
+                z = l.getBlockZ();
+            } else if(args.length == 2) {
+                //Either location array and world provided, or x and z. Test for array at pos 2
+                if(args[1] instanceof CArray){
+                    world = Static.getServer().getWorld(args[0].val());
+                    MCLocation l = ObjectGenerator.GetGenerator().location(args[1], null, line_num, f);
+                    x = l.getBlockX();
+                    z = l.getBlockZ();
+                } else {
+                    if(m == null){
+                        throw new ConfigRuntimeException("No world specified", ExceptionType.InvalidWorldException, line_num, f);
+                    }
+                    world = m.getWorld();
+                    x = (int)Static.getInt(args[0]);
+                    z = (int)Static.getInt(args[1]);
+                }
+            } else {
+                //world, x and z provided
+                world = Static.getServer().getWorld(args[0].val());
+                x = (int)Static.getInt(args[1]);
+                z = (int)Static.getInt(args[2]);
+            }
+            world.refreshChunk(x, z);
+            return new CVoid(line_num, f);
+        }
+        
+    }
+    
+    private static final SortedMap<String, Construct> TimeLookup = new TreeMap<String, Construct>();
+    static{
+        Properties p = new Properties();
+        try {
+            p.load(Minecraft.class.getResourceAsStream("/time_names.txt"));
+            Enumeration e = p.propertyNames();
+            while(e.hasMoreElements()){
+                String name = e.nextElement().toString();
+                TimeLookup.put(name, new CString(p.getProperty(name).toString(), 0, null));
+            }
+        } catch (IOException ex) {
+            Logger.getLogger(World.class.getName()).log(Level.SEVERE, null, ex);
+        }
+    }
+    
+    @api public static class set_world_time implements Function{
+
+        public String getName() {
+            return "set_world_time";
+        }
+
+        public Integer[] numArgs() {
+            return new Integer[]{1, 2};
+        }
+
+        public String docs() {
+            StringBuilder doc = new StringBuilder();
+            doc.append("void {[world], time} Sets the time of a given world. Should be a number from 0 to"
+                    + " 24000, if not, it is modulo scaled. Alternatively, common time notation (9:30pm, 4:00 am)"
+                    + " is acceptable, and convenient english mappings also exist:"
+                    );
+            doc.append("<ul>");
+            for(String key : TimeLookup.keySet()){
+                doc.append("<li>").append(key).append(" = ").append(TimeLookup.get(key)).append("</li>\n");
+            }
+            doc.append("</ul>");
+            return doc.toString();
+        }
+
+        public ExceptionType[] thrown() {
+            return new ExceptionType[]{ExceptionType.InvalidWorldException, ExceptionType.FormatException};
+        }
+
+        public boolean isRestricted() {
+            return true;
+        }
+
+        public boolean preResolveVariables() {
+            return true;
+        }
+
+        public String since() {
+            return "3.3.0";
+        }
+
+        public Boolean runAsync() {
+            return false;
+        }
+
+        public Construct exec(int line_num, File f, Env environment, Construct... args) throws ConfigRuntimeException {
+            MCWorld w = null;
+            if(environment.GetPlayer() != null){
+                w = environment.GetPlayer().getWorld();
+            }
+            if(args.length == 2){
+                w = Static.getServer().getWorld(args[0].val());                
+            }
+            if(w == null){
+                throw new ConfigRuntimeException("No world specified", ExceptionType.InvalidWorldException, line_num, f);
+            }
+            long time = 0;
+            String stime = (args.length == 1?args[0]:args[1]).val().toLowerCase();
+            if(TimeLookup.containsKey(stime.replaceAll("[^a-z]", ""))){
+                stime = TimeLookup.get(stime.replaceAll("[^a-z]", "")).val();
+            }
+            if(stime.matches("^([\\d]+)[:.]([\\d]+)[ ]*?(?:([pa])\\.*m\\.*){0,1}$")){
+                Pattern p = Pattern.compile("^([\\d]+)[:.]([\\d]+)[ ]*?(?:([pa])\\.*m\\.*){0,1}$");
+                Matcher m = p.matcher(stime);
+                m.find();
+                int hour = Integer.parseInt(m.group(1));
+                int minute = Integer.parseInt(m.group(2));
+                String offset = "a";
+                if(m.group(3) != null){
+                    offset = m.group(3);
+                }
+                if(offset.equals("p")){
+                    hour += 12;
+                }
+                if(hour == 24) hour = 0;
+                if(hour > 24){
+                    throw new ConfigRuntimeException("Invalid time provided", ExceptionType.FormatException, line_num, f);
+                }
+                if(minute > 59){
+                    throw new ConfigRuntimeException("Invalid time provided", ExceptionType.FormatException, line_num, f);                    
+                }
+                hour -= 6;
+                hour = hour % 24;
+                long ttime = hour * 1000;
+                ttime += ((minute / 60.0) * 1000);
+                stime = Long.toString(ttime);
+            }
+            try{
+                Long.valueOf(stime);
+            } catch(NumberFormatException e){
+                throw new ConfigRuntimeException("Invalid time provided", ExceptionType.FormatException, line_num, f);
+            }
+            time = Long.parseLong(stime);
+            w.setTime(time);
+            return new CVoid(line_num, f);
+        }
+        
+    }
+    
+    @api public static class get_world_time implements Function{
+
+        public String getName() {
+            return "get_world_time";
+        }
+
+        public Integer[] numArgs() {
+            return new Integer[]{0, 1};
+        }
+
+        public String docs() {
+            return "int {[world]} Returns the time of the specified world, as an integer from"
+                    + " 0 to 24000-1";
+        }
+
+        public ExceptionType[] thrown() {
+            return new ExceptionType[]{ExceptionType.InvalidWorldException};
+        }
+
+        public boolean isRestricted() {
+            return true;
+        }
+
+        public boolean preResolveVariables() {
+            return true;
+        }
+
+        public String since() {
+            return "3.3.0";
+        }
+
+        public Boolean runAsync() {
+            return false;
+        }
+
+        public Construct exec(int line_num, File f, Env environment, Construct... args) throws ConfigRuntimeException {
+            MCWorld w = null;
+            if(environment.GetPlayer() != null){
+                w = environment.GetPlayer().getWorld();
+            }
+            if(args.length == 1){
+                w = Static.getServer().getWorld(args[0].val());                
+            }
+            if(w == null){
+                throw new ConfigRuntimeException("No world specified", ExceptionType.InvalidWorldException, line_num, f);
+            }
+            return new CInt(w.getTime(), line_num, f);
+        }
+        
+    }
+}
diff --git a/src/main/java/com/laytonsmith/core/functions/WorldEdit.java b/src/main/java/com/laytonsmith/core/functions/WorldEdit.java
new file mode 100644
index 0000000..ee28276
--- /dev/null
+++ b/src/main/java/com/laytonsmith/core/functions/WorldEdit.java
@@ -0,0 +1,519 @@
+/*
+ * To change this template, choose Tools | Templates
+ * and open the template in the editor.
+ */
+package com.laytonsmith.core.functions;
+
+import com.laytonsmith.abstraction.MCLocation;
+import com.laytonsmith.abstraction.MCPlayer;
+import com.laytonsmith.abstraction.bukkit.BukkitMCLocation;
+import com.laytonsmith.abstraction.bukkit.BukkitMCPlayer;
+import com.laytonsmith.abstraction.bukkit.BukkitMCWorld;
+import com.laytonsmith.core.Env;
+import com.laytonsmith.core.ObjectGenerator;
+import com.laytonsmith.core.Static;
+import com.laytonsmith.core.api;
+import com.laytonsmith.core.constructs.*;
+import com.laytonsmith.core.exceptions.CancelCommandException;
+import com.laytonsmith.core.exceptions.ConfigRuntimeException;
+import com.laytonsmith.core.functions.Exceptions.ExceptionType;
+import com.sk89q.worldedit.BlockVector2D;
+import com.sk89q.worldedit.Vector;
+import com.sk89q.worldedit.bukkit.BukkitUtil;
+import com.sk89q.worldedit.regions.CuboidRegion;
+import com.sk89q.worldedit.regions.CuboidRegionSelector;
+import com.sk89q.worldedit.regions.RegionSelector;
+import com.sk89q.worldguard.protection.ApplicableRegionSet;
+import com.sk89q.worldguard.protection.GlobalRegionManager;
+import com.sk89q.worldguard.protection.flags.Flag;
+import com.sk89q.worldguard.protection.managers.RegionManager;
+import com.sk89q.worldguard.protection.regions.ProtectedPolygonalRegion;
+import com.sk89q.worldguard.protection.regions.ProtectedRegion;
+import java.io.File;
+import java.util.*;
+import org.bukkit.Bukkit;
+import org.bukkit.Location;
+import org.bukkit.World;
+
+/**
+ *
+ * @author Layton
+ */
+public class WorldEdit {
+
+    public static String docs() {
+        return "Provides various methods for programmatically hooking into WorldEdit";
+    }
+
+    @api public static class sk_pos1 extends SKFunction {
+
+        public String getName() {
+            return "sk_pos1";
+        }
+
+        public Integer[] numArgs() {
+            return new Integer[]{0, 1, 2};
+        }
+
+        public ExceptionType[] thrown() {
+            return new ExceptionType[]{ExceptionType.PlayerOfflineException, ExceptionType.CastException};
+        }
+
+        public String docs() {
+            return "mixed {[player], locationArray | [player]} Sets the player's point 1, or returns it if the array to set isn't specified. If"
+                    + " the location is returned, it is returned as a 4 index array:(x, y, z, world)";
+        }
+
+        public Construct exec(int line_num, File f, Env env, Construct... args) throws CancelCommandException, ConfigRuntimeException {
+            MCPlayer m = null;
+            MCLocation l = null;
+            boolean setter = false;
+            Static.checkPlugin("WorldEdit", line_num, f);
+            
+            if(env.GetCommandSender() instanceof MCPlayer){
+                m = env.GetPlayer();
+            }
+            if(args.length == 2){
+                m = Static.GetPlayer(args[0].val(), line_num, f);
+                l = ObjectGenerator.GetGenerator().location(args[1], m.getWorld(), line_num, f);
+                setter = true;
+            } else if(args.length == 1){
+                if(args[0] instanceof CArray){
+                    l = ObjectGenerator.GetGenerator().location(args[0], (m==null?null:m.getWorld()), line_num, f);
+                    setter = true;
+                } else {
+                    m = Static.GetPlayer(args[0].val(), line_num, f);
+                }
+            }
+
+            if (m == null) {
+                throw new ConfigRuntimeException(this.getName() + " needs a player", ExceptionType.PlayerOfflineException, line_num, f);
+            }
+
+            RegionSelector sel = Static.getWorldEditPlugin(line_num, f).getSession(((BukkitMCPlayer)m)._Player()).getRegionSelector(BukkitUtil.getLocalWorld(((BukkitMCWorld)m.getWorld()).__World()));
+            if (!(sel instanceof CuboidRegionSelector)) {
+                throw new ConfigRuntimeException("Only cuboid regions are supported with " + this.getName(), ExceptionType.PluginInternalException, line_num, f);
+            }
+            if(setter){
+                sel.selectPrimary(BukkitUtil.toVector(((BukkitMCLocation)l)._Location()));
+                return new CVoid(line_num, f);
+            } else {
+                Vector pt = ((CuboidRegion) sel.getIncompleteRegion()).getPos1();
+                if (pt == null) throw new ConfigRuntimeException("Point in " + this.getName() +  "undefined", line_num, f);
+                return new CArray(line_num, f,
+                        new CInt(pt.getBlockX(), line_num, f),
+                        new CInt(pt.getBlockY(), line_num, f),
+                        new CInt(pt.getBlockZ(), line_num, f),
+                        new CString(m.getWorld().getName(), line_num, f));
+            }
+        }
+    }
+
+    @api public static class sk_pos2 extends SKFunction {
+
+        public String getName() {
+            return "sk_pos2";
+        }
+
+        public Integer[] numArgs() {
+            return new Integer[]{0, 1, 2};
+        }
+
+        public String docs() {
+            return "mixed {[player], array | [player]} Sets the player's point 2, or returns it if the array to set isn't specified";
+        }
+
+        public ExceptionType[] thrown() {
+            return new ExceptionType[]{ExceptionType.PlayerOfflineException, ExceptionType.CastException};
+        }
+
+        public Construct exec(int line_num, File f, Env env, Construct... args) throws CancelCommandException, ConfigRuntimeException {
+            MCPlayer m = null;
+            MCLocation l = null;
+            boolean setter = false;
+            Static.checkPlugin("WorldEdit", line_num, f);
+
+            if (env.GetCommandSender() instanceof MCPlayer) {
+                m = env.GetPlayer();
+            }
+            if (args.length == 2){
+                m = Static.GetPlayer(args[0].val(), line_num, f);
+                l = ObjectGenerator.GetGenerator().location(args[1], m.getWorld(), line_num, f);
+                setter = true;
+            } else if (args.length == 1){
+                if (args[0] instanceof CArray) {
+                    l = ObjectGenerator.GetGenerator().location(args[0], (m==null?null:m.getWorld()), line_num, f);
+                    setter = true;
+                } else {
+                    m = Static.GetPlayer(args[0].val(), line_num, f);
+                }
+            }
+
+            if (m == null) {
+                throw new ConfigRuntimeException(this.getName() + " needs a player", ExceptionType.PlayerOfflineException, line_num, f);
+            }
+
+            RegionSelector sel = Static.getWorldEditPlugin(line_num, f).getSession(((BukkitMCPlayer)m)._Player()).getRegionSelector(BukkitUtil.getLocalWorld(((BukkitMCWorld)m.getWorld()).__World()));
+            if (!(sel instanceof CuboidRegionSelector)) {
+                throw new ConfigRuntimeException("Only cuboid regions are supported with " + this.getName(), ExceptionType.PluginInternalException, line_num, f);
+            }
+
+            if(setter){
+                sel.selectSecondary(BukkitUtil.toVector(((BukkitMCLocation)l)._Location()));
+                return new CVoid(line_num, f);
+            } else {
+                Vector pt = ((CuboidRegion)sel.getIncompleteRegion()).getPos2();
+                if (pt == null) throw new ConfigRuntimeException("Point in " + this.getName() +  "undefined", line_num, f);
+                return new CArray(line_num, f,
+                        new CInt(pt.getBlockX(), line_num, f),
+                        new CInt(pt.getBlockY(), line_num, f),
+                        new CInt(pt.getBlockZ(), line_num, f),
+                        new CString(m.getWorld().getName(), line_num, f));
+            }
+        }
+    }
+
+//    public static class sk_points extends SKFunction {
+//
+//        public String getName() {
+//            return "sk_points";
+//        }
+//
+//        public Integer[] numArgs() {
+//            return new Integer[]{0, 1, 2};
+//        }
+//
+//        public String docs() {
+//            return "mixed {[player], arrayOfArrays | [player]} Sets a series of points, or returns the poly selection for this player, if one is specified."
+//                    + " The array should be an array of arrays, and the arrays should be array(x, y, z)";
+//        }
+//
+//        public ExceptionType[] thrown() {
+//            return new ExceptionType[]{ExceptionType.PlayerOfflineException, ExceptionType.CastException};
+//        }
+//
+//        public Construct exec(int line_num, File f, Env env, Construct... args) throws CancelCommandException, ConfigRuntimeException {
+//            Static.checkPlugin("WorldEdit", line_num, f);
+//            return new CVoid(line_num, f);
+//        }
+//    }
+
+    @api public static class sk_region_info extends SKFunction {
+
+        public String getName() {
+            return "sk_region_info";
+        }
+
+        public Integer[] numArgs() {
+            return new Integer[]{2};
+        }
+
+        public String docs() {
+            return "array {region, world} Given a region name, returns an array of information about that region, as follows:<ul>"
+                    + " <li>0 - An array of points that define this region</li>"
+                    + " <li>1 - An array of owners of this region</li>"
+                    + " <li>2 - An array of members of this region</li>"
+                    + " <li>3 - An array of arrays of this region's flags, where each array is: array(flag_name, value)</li>"
+                    + " <li>4 - This region's priority</li>"
+                    + " <li>5 - The volume of this region (in meters cubed)</li>"
+                    + "</ul>"
+                    + "If the region cannot be found, a PluginInternalException is thrown.";
+        }
+
+        public ExceptionType[] thrown() {
+            return new ExceptionType[]{ExceptionType.PluginInternalException};
+        }
+
+        public Construct exec(int line_num, File f, Env env, Construct... args) throws CancelCommandException, ConfigRuntimeException {
+            try {
+                String regionName = args[0].val();
+                String worldName = args[1].val();
+                //Fill these data structures in with the information we need
+                List<Location> points = new ArrayList<Location>();
+                List<String> owners = new ArrayList<String>();
+                List<String> members = new ArrayList<String>();
+                Map<String, String> flags = new HashMap<String, String>();
+                int priority = -1;
+                float volume = -1;
+                World world = Bukkit.getServer().getWorld(worldName);
+                if (world == null) throw new ConfigRuntimeException("Unknown world specified", ExceptionType.PluginInternalException, line_num, f);
+                RegionManager mgr = Static.getWorldGuardPlugin(line_num, f).getGlobalRegionManager().get(world);
+                ProtectedRegion region = mgr.getRegion(regionName);
+                if (region == null) throw new ConfigRuntimeException("Region could not be found!", ExceptionType.PluginInternalException, line_num, f);
+                
+                owners.addAll(region.getOwners().getPlayers());
+                members.addAll(region.getMembers().getPlayers());
+                for (Map.Entry<Flag<?>, Object> ent: region.getFlags().entrySet()) {
+                    flags.put(ent.getKey().getName(), String.valueOf(ent.getValue()));
+                }
+                priority = region.getPriority();
+                volume = region.volume();
+                boolean first = true;
+                if (region instanceof ProtectedPolygonalRegion) {
+                    for (BlockVector2D pt : ((ProtectedPolygonalRegion) region).getPoints()) {
+                        points.add(new Location(world, pt.getX(), first ? region.getMaximumPoint().getY() 
+                                    : region.getMinimumPoint().getY(), pt.getZ()));
+                        first = false;
+                    }
+                } else {
+                    points.add(com.sk89q.worldguard.bukkit.BukkitUtil.toLocation(world, region.getMaximumPoint()));
+                    points.add(com.sk89q.worldguard.bukkit.BukkitUtil.toLocation(world, region.getMinimumPoint()));
+                }
+                
+                
+                CArray ret = new CArray(line_num, f);
+                
+                CArray pointSet = new CArray(line_num, f);
+                for(Location l : points){
+                    CArray point = new CArray(line_num, f);
+                    point.push(new CInt(l.getBlockX(), line_num, f));
+                    point.push(new CInt(l.getBlockY(), line_num, f));
+                    point.push(new CInt(l.getBlockZ(), line_num, f));
+                    point.push(new CString(l.getWorld().getName(), line_num, f));
+                    pointSet.push(point);
+                }
+                CArray ownerSet = new CArray(line_num, f);
+                for(String owner : owners){
+                    ownerSet.push(new CString(owner, line_num, f));
+                }
+                CArray memberSet = new CArray(line_num, f);
+                for(String member : members){
+                    memberSet.push(new CString(member, line_num, f));
+                }
+                CArray flagSet = new CArray(line_num, f);
+                for(Map.Entry<String, String> flag : flags.entrySet()){
+                    CArray fl = new CArray(line_num, f, 
+                            new CString(flag.getKey(), line_num, f), 
+                            new CString(flag.getValue(), line_num, f)
+                    );
+                    flagSet.push(fl);
+                }
+                ret.push(pointSet);
+                ret.push(ownerSet);
+                ret.push(memberSet);
+                ret.push(flagSet);
+                ret.push(new CInt(priority, line_num, f));
+                ret.push(new CDouble(volume, line_num, f));
+                return ret;
+                
+            } catch (NoClassDefFoundError e) {
+                throw new ConfigRuntimeException("It does not appear as though the WorldEdit or WorldGuard plugin is loaded properly. Execution of " + this.getName() + " cannot continue.", ExceptionType.InvalidPluginException, line_num, f, e);
+            }
+        }
+    }
+
+    @api public static class sk_region_overlaps extends SKFunction {
+
+        public String getName() {
+            return "sk_region_overlaps";
+        }
+
+        public Integer[] numArgs() {
+            return new Integer[]{Integer.MAX_VALUE}; //@wraithguard01
+        }
+
+        public String docs() {
+            return "boolean {world, region1, array(region2, [regionN...])} Returns true or false whether or not the specified regions overlap.";
+        }
+
+        public ExceptionType[] thrown() {
+            return new ExceptionType[]{ExceptionType.PluginInternalException};
+        }
+
+        public Construct exec(int line_num, File f, Env env, Construct... args) throws CancelCommandException, ConfigRuntimeException {
+            String region1 = args[1].val();
+            List<ProtectedRegion> checkRegions = new ArrayList<ProtectedRegion>();
+            Static.checkPlugin("WorldGuard", line_num, f);
+            World world = Bukkit.getServer().getWorld(args[0].val());
+            if (world == null) throw new ConfigRuntimeException("Unknown world specified", ExceptionType.PluginInternalException, line_num, f);
+            RegionManager mgr = Static.getWorldGuardPlugin(line_num, f).getGlobalRegionManager().get(world);
+            if (args[2] instanceof CArray) {
+                CArray arg = (CArray)args[2];
+                for (int i = 0; i < arg.size(); i++) {
+                    ProtectedRegion region = mgr.getRegion(arg.get(i, line_num, f).val());
+                    if (region == null) throw new ConfigRuntimeException("Region " + arg.get(i, line_num, f).val() + " could not be found!", ExceptionType.PluginInternalException, line_num, f);
+                    checkRegions.add(region);
+                }
+            } else {
+                ProtectedRegion region = mgr.getRegion(args[2].val());
+                    if (region == null) throw new ConfigRuntimeException("Region " + args[2] + " could not be found!", ExceptionType.PluginInternalException, line_num, f);
+                    checkRegions.add(region);
+            }
+            
+            ProtectedRegion region = mgr.getRegion(region1);
+            if (region == null) throw new ConfigRuntimeException("Region could not be found!", ExceptionType.PluginInternalException, line_num, f);
+            
+            try {
+                if (!region.getIntersectingRegions(checkRegions).isEmpty()) return new CBoolean(true, line_num, f);
+            } catch (Exception e) {}
+            return new CBoolean(false, line_num, f);
+        }
+    }
+
+    @api public static class sk_all_regions extends SKFunction {
+
+        public String getName() {
+            return "sk_all_regions";
+        }
+
+        public Integer[] numArgs() {
+            return new Integer[]{0, 1};
+        }
+
+        public String docs() {
+            return "array {[world]} Returns all the regions in all worlds, or just the one world, if specified.";
+        }
+
+        public ExceptionType[] thrown() {
+            return new ExceptionType[]{};
+        }
+
+        public Construct exec(int line_num, File f, Env env, Construct... args) throws CancelCommandException, ConfigRuntimeException {
+            Static.checkPlugin("WorldGuard", line_num, f);
+            List<World> checkWorlds = null;
+            CArray arr = new CArray(line_num, f);
+            if (args.length == 1) {
+                World world = Bukkit.getServer().getWorld(args[0].val());
+                if (world != null) checkWorlds = Arrays.asList(world);
+            }
+            if (checkWorlds == null) {
+                checkWorlds = Bukkit.getServer().getWorlds();
+            }
+            GlobalRegionManager mgr = Static.getWorldGuardPlugin(line_num, f).getGlobalRegionManager();
+            for (World world : checkWorlds) {
+                for (String region : mgr.get(world).getRegions().keySet()) arr.push(new CString(region, line_num, f));
+            }
+            return arr;
+            
+        }
+    }
+    
+        
+    @api public static class sk_current_regions extends SKFunction {
+        public String getName() {
+            return "sk_current_regions";
+        }
+        
+        public Integer[] numArgs() {
+            return new Integer[]{0, 1};
+        }
+        
+        public String docs() {
+            return "mixed {[player]} Returns the list regions that player is in. If no player specified, then the current player is used."
+                    + " If region is found, an array of region names are returned, else null is returned";
+        }
+        
+        public ExceptionType[] thrown() {
+            return new ExceptionType[]{ExceptionType.PlayerOfflineException, ExceptionType.PluginInternalException};
+        }
+        
+        public Construct exec(int line_num, File f, Env env, Construct... args) throws CancelCommandException, ConfigRuntimeException {
+            Static.checkPlugin("WorldGuard", line_num, f);
+            World world;
+            
+            MCPlayer m = null;
+            
+            if(env.GetCommandSender() instanceof MCPlayer){
+                m = env.GetPlayer();
+            }
+            if (args.length == 1) {
+                m = Static.GetPlayer(args[0].val(), line_num, f);
+            }
+            
+            if (m == null) {
+                throw new ConfigRuntimeException(this.getName() + " needs a player", ExceptionType.PlayerOfflineException, line_num, f);
+            }
+            
+            world = Bukkit.getServer().getWorld(m.getWorld().getName());
+            
+            RegionManager mgr = Static.getWorldGuardPlugin(line_num, f).getGlobalRegionManager().get(world);
+            Vector pt = new Vector(m.getLocation().getBlockX(), m.getLocation().getBlockY(), m.getLocation().getBlockZ());
+            ApplicableRegionSet set = mgr.getApplicableRegions(pt);
+            
+            CArray regions = new CArray(line_num, f);
+            
+            List<ProtectedRegion> sortedRegions = new ArrayList<ProtectedRegion>();
+            
+            for (ProtectedRegion r : set) {
+                boolean placed = false;
+                for (int i = 0; i < sortedRegions.size(); i++) {
+                    if (sortedRegions.get(i).volume() < r.volume()) {
+                        sortedRegions.add(i, r);
+                        placed = true;
+                        break;
+                    }
+                }
+                if (!placed) {
+                    sortedRegions.add(r);
+                }
+            }
+            
+            for (ProtectedRegion region : sortedRegions) {
+                regions.push(new CString(region.getId(), line_num, f));
+            }
+            
+            if (regions.size() > 0) {
+                return regions;
+            }
+            
+            return new CNull(line_num, f);
+        }
+    }
+    
+    @api public static class sk_region_volume extends SKFunction {
+        public String getName() {
+            return "sk_region_volume";
+        }
+        
+        public Integer[] numArgs() {
+            return new Integer[]{2};
+        }
+        
+        public String docs() {
+            return "int {region, world} Returns the volume of the given region in the given world.";
+        }
+        
+        public ExceptionType[] thrown() {
+            return new ExceptionType[]{ExceptionType.PluginInternalException};
+        }
+        
+        public Construct exec(int line_num, File f, Env env, Construct... args) throws CancelCommandException, ConfigRuntimeException {
+            Static.checkPlugin("WorldGuard", line_num, f);
+            World world;
+            
+            world = Bukkit.getServer().getWorld(args[1].val());
+            
+            RegionManager mgr = Static.getWorldGuardPlugin(line_num, f).getGlobalRegionManager().get(world);
+            
+            ProtectedRegion region = mgr.getRegion(args[0].val());
+            
+            if (region == null) {
+                throw new ConfigRuntimeException(String.format("The region (%s) does not exist in world (%s).", args[0].val(), args[1].val()), ExceptionType.PluginInternalException, line_num, f);
+            }
+            
+            return new CInt(region.volume(), line_num, f);
+        }
+    }
+
+    public static abstract class SKFunction implements Function {
+
+        public boolean isRestricted() {
+            return true;
+        }
+
+        public void varList(IVariableList varList) {
+        }
+
+        public boolean preResolveVariables() {
+            return true;
+        }
+
+        public String since() {
+            return "3.2.0";
+        }
+
+        public Boolean runAsync() {
+            return false;
+        }
+    }
+}
diff --git a/src/main/java/com/laytonsmith/tools/DocGen.java b/src/main/java/com/laytonsmith/tools/DocGen.java
new file mode 100644
index 0000000..be129da
--- /dev/null
+++ b/src/main/java/com/laytonsmith/tools/DocGen.java
@@ -0,0 +1,403 @@
+/*
+ * To change this template, choose Tools | Templates
+ * and open the template in the editor.
+ */
+package com.laytonsmith.tools;
+
+import com.laytonsmith.PureUtilities.ClassDiscovery;
+import com.laytonsmith.core.Documentation;
+import com.laytonsmith.core.docs;
+import com.laytonsmith.core.events.AbstractEvent;
+import com.laytonsmith.core.events.EventHandlerInterface;
+import com.laytonsmith.core.functions.Exceptions.ExceptionType;
+import com.laytonsmith.core.functions.Function;
+import com.laytonsmith.core.functions.FunctionList;
+import java.lang.reflect.Constructor;
+import java.lang.reflect.InvocationTargetException;
+import java.lang.reflect.Method;
+import java.lang.reflect.Modifier;
+import java.util.*;
+import java.util.regex.Matcher;
+import java.util.regex.Pattern;
+
+/**
+ *
+ * @author Layton
+ */
+public class DocGen {
+
+    public static void main(String[] args) {
+        events("wiki");
+    }
+
+    public static void functions(String type) {
+        List<Function> functions = FunctionList.getFunctionList();
+        HashMap<Class, ArrayList<Function>> functionlist = new HashMap<Class, ArrayList<Function>>();
+        for (int i = 0; i < functions.size(); i++) {
+            //Sort the functions into classes
+            Function f = functions.get(i);
+            Class apiClass = (f.getClass().getEnclosingClass() != null
+                    ? f.getClass().getEnclosingClass()
+                    : null);
+            ArrayList<Function> fl = functionlist.get(apiClass);
+            if (fl == null) {
+                fl = new ArrayList<Function>();
+                functionlist.put(apiClass, fl);
+            }
+            fl.add(f);
+        }
+        if (type.equals("html")) {
+            System.out.println("Command Helper uses a language called MScript, which greatly extend the capabilities of the plugin, "
+                    + "and make the plugin a fully "
+                    + "<a href=\"http://en.wikipedia.org/wiki/Turing_Complete\">Turing Complete</a> language. "
+                    + "There are several functions defined, and they are grouped into \"classes\". ");
+        } else if (type.equals("wiki")) {
+            System.out.println("Command Helper uses a language called MScript, which greatly extend the capabilities of the plugin, "
+                    + "and make the plugin a fully "
+                    + "[http://en.wikipedia.org/wiki/Turing_Complete Turing Complete] language. "
+                    + "There are several functions defined, and they are grouped into \"classes\". ");
+            System.out.println("<p>Each function has its own page for documentation, where you can put examples for how to use"
+                    + " particular functions. Because this is a wiki, it is encouraged that you edit the pages if you see errors, "
+                    + "or can think of a better example to show. Please copy over [[CommandHelper/API/Function Template|this template]]"
+                    + " and use it.");
+        } else if (type.equals("text")) {
+            System.out.println("Command Helper uses a language called MScript, which greatly extend the capabilities of the plugin, "
+                    + "and make the plugin a fully "
+                    + "Turing Complete language [http://en.wikipedia.org/wiki/Turing_Complete].\n"
+                    + "There are several functions defined, and they are grouped into \"classes\".");
+        }
+
+        for (Map.Entry<Class, ArrayList<Function>> entry : functionlist.entrySet()) {
+            Class apiClass = entry.getKey();
+            String className = apiClass.getName().split("\\.")[apiClass.getName().split("\\.").length - 1];
+            if (className.equals("Sandbox")) {
+                continue; //Skip Sandbox functions
+            }
+            String classDocs = null;
+            try {
+                Method m = apiClass.getMethod("docs", (Class[]) null);
+                Object o = null;
+                if ((m.getModifiers() & Modifier.STATIC) == 0) {
+                    try {
+                        o = apiClass.newInstance();
+                    } catch (InstantiationException ex) {
+                    }
+                }
+                classDocs = (String) m.invoke(o, (Object[]) null);
+            } catch (IllegalAccessException ex) {
+            } catch (IllegalArgumentException ex) {
+            } catch (InvocationTargetException ex) {
+            } catch (NoSuchMethodException e) {
+            }
+            if (type.equals("html")) {
+                if (className != null) {
+                    System.out.println("<h1>" + className + "</h1>");
+                    System.out.println(classDocs == null ? "" : classDocs);
+                } else {
+                    System.out.println("<h1>Other Functions</h1>");
+                }
+                System.out.println("<table>");
+            } else if (type.equals("wiki")) {
+                if (className != null) {
+                    System.out.println("===" + className + "===");
+                    System.out.println(classDocs == null ? "" : classDocs);
+                } else {
+                    System.out.println("===Other Functions===");
+                }
+                System.out.println("{| width=\"100%\" cellspacing=\"1\" cellpadding=\"1\" border=\"1\" align=\"left\" class=\"wikitable\"\n"
+                        + "|-\n"
+                        + "! scope=\"col\" width=\"6%\" | Function Name\n"
+                        + "! scope=\"col\" width=\"5%\" | Returns\n"
+                        + "! scope=\"col\" width=\"10%\" | Arguments\n"
+                        + "! scope=\"col\" width=\"10%\" | Throws\n"
+                        + "! scope=\"col\" width=\"61%\" | Description\n"
+                        + "! scope=\"col\" width=\"3%\" | Since\n"
+                        + "! scope=\"col\" width=\"5%\" | Restricted");
+            } else if (type.equals("text")) {
+                System.out.println("**********************************************************************************************");
+                if (className != null) {
+                    System.out.println(classDocs == null ? "" : classDocs);
+                } else {
+                    System.out.println("Other Functions");
+                }
+                System.out.println("**********************************************************************************************");
+            }
+            for (Function f : entry.getValue()) {
+                String doc = f.docs();
+                String ret = null;
+                String args = null;
+                String desc = null;
+                String restricted = f.isRestricted() ? "<div style=\"background-color: red; font-weight: bold; text-align: center;\">Yes</div>"
+                        : "<div style=\"background-color: green; font-weight: bold; text-align: center;\">No</div>";
+                StringBuilder thrown = new StringBuilder();
+                if (f.thrown() != null) {
+                    List thrownList = Arrays.asList(f.thrown());
+                    for (int i = 0; i < thrownList.size(); i++) {
+                        ExceptionType t = (ExceptionType) thrownList.get(i);
+                        if (type.equals("html") || type.equals("text")) {
+                            if (i != 0) {
+                                thrown.append((type.equals("html") ? "<br />\n" : " | "));
+                            }
+                            thrown.append(t.toString());
+                        } else {
+                            if (i != 0) {
+                                thrown.append("<br />\n");
+                            }
+                            thrown.append("[[Exceptions#").append(t.toString()).append("|").append(t.toString()).append("]]");
+                        }
+                    }
+                }
+
+                String since = f.since();
+                Pattern p = Pattern.compile("\\s*(.*?)\\s*\\{(.*?)\\}\\s*(.*)\\s*");
+                Matcher m = p.matcher(doc);
+                if (m.find()) {
+                    ret = m.group(1);
+                    args = m.group(2);
+                    desc = m.group(3);
+                }
+                if (ret == null || args == null || desc == null) {
+                    System.out.println(f.getName() + "'s documentation is not correctly formatted. Please check it and try again.");
+                }
+                if (type.equals("html")) {
+                    System.out.println("<tr><td>" + ret + "</td><td>" + args + "</td><td>" + thrown.toString() + "</td><td>" + desc + "</td><td>" + since + "</td><td>" + restricted + "</td></tr>\n");
+                } else if (type.equals("wiki")) {
+                    //Turn args into a prettified version
+                    args = args.replaceAll("\\|", "<hr />").replaceAll("\\[(.*?)\\]", "<strong>[</strong>$1<strong>]</strong>");
+                    System.out.println("|-\n"
+                            + "! scope=\"row\" | [[CommandHelper/API/" + f.getName() + "|" + f.getName() + "]]\n"
+                            + "| " + ret + "\n"
+                            + "| " + args + "\n"
+                            + "| " + thrown.toString() + "\n"
+                            + "| " + desc + "\n"
+                            + "| " + since + "\n"
+                            + "| " + restricted);
+
+                } else if (type.equals("text")) {
+                    System.out.println(ret + f.getName() + "(" + args + ")" + " {" + thrown.toString() + "}\n\t" + desc + "\n\t" + since + (f.isRestricted() ? "\n\tThis function is restricted"
+                            : "\n\tThis function is not restricted"));
+                }
+            }
+            if (type.equals("html")) {
+                System.out.println("</table>");
+            } else if (type.equals("wiki")) {
+                System.out.println("|}");
+            } else if (type.equals("text")) {
+                System.out.println();
+            }
+        }
+        if (type.equals("html")) {
+            System.out.println(""
+                    + "<h2>Errors in documentation</h2>\n"
+                    + "<em>Please note that this documentation is generated automatically,"
+                    + " if you notice an error in the documentation, please file a bug report for the"
+                    + " plugin itself!</em>");
+        } else if (type.equals("wiki")) {
+            System.out.println(""
+                    + "===Errors in documentation===\n"
+                    + "''Please note that this documentation is generated automatically,"
+                    + " if you notice an error in the documentation, please file a bug report for the"
+                    + " plugin itself!'' For information on undocumented functions, see [[CommandHelper/Sandbox|this page]]");
+        }
+    }
+
+    public static void events(String type) {
+        Class[] classes = ClassDiscovery.GetClassesWithAnnotation(docs.class);
+        Set<Documentation> list = new TreeSet<Documentation>();
+        for (Class c : classes) {
+            docs d = (docs) c.getAnnotation(docs.class);
+            if (d.type().equals(docs.type.EVENT) && AbstractEvent.class.isAssignableFrom(c)
+                    && Documentation.class.isAssignableFrom(c)) {
+                try {
+                    //First, we have to instatiate the event. We don't have a handler, but
+                    //that's ok, we're just interested in the Documentation element
+                    Constructor<AbstractEvent> cons = c.getConstructor(EventHandlerInterface.class);
+                    Documentation docs = (Documentation) cons.newInstance((Object) null);
+                    list.add(docs);
+                } catch (Exception ex) {
+                    System.err.println("Could not get documentation for " + c.getSimpleName());
+                }
+            }
+        }
+
+        StringBuilder doc = new StringBuilder();
+        if (type.equals("html")) {
+            doc.append("Events allow you to trigger scripts not just on commands, but also on other actions, such as"
+                    + " a player logging in, or a player breaking a block. See the documentation on events for"
+                    + " more information"
+                    + "<table><thead><tr><th>Name</th><th>Description</th><th>Prefilters</th>"
+                    + "<th>Event Data</th><th>Mutable Fields</th><th>Since</th></thead><tbody>");
+        } else if (type.equals("wiki")) {
+            doc.append("Events allow you to trigger scripts not just on commands, but also on other actions, such as"
+                    + " a player logging in, or a player breaking a block. See the [[CommandHelper/Events|documentation on events]] for"
+                    + " more information<br />\n\n");
+            
+            doc.append("{| width=\"100%\" cellspacing=\"1\" cellpadding=\"1\" border=\"1\" align=\"left\" class=\"wikitable\"\n"
+                        + "|-\n"
+                        + "! scope=\"col\" width=\"7%\" | Event Name\n"
+                        + "! scope=\"col\" width=\"36%\" | Description\n"
+                        + "! scope=\"col\" width=\"18%\" | Prefilters\n"
+                        + "! scope=\"col\" width=\"18%\" | Event Data\n"
+                        + "! scope=\"col\" width=\"18%\" | Mutable Fields\n"
+                        + "! scope=\"col\" width=\"3%\" | Since\n");
+        } else if (type.equals("text")) {
+            doc.append("Events allow you to trigger scripts not just on commands, but also on other actions, such as"
+                    + " a player logging in, or a player breaking a block. See the documentation on events for"
+                    + " more information\n\n\n");
+        }
+        Pattern p = Pattern.compile("\\{(.*?)\\} *?(.*?) *?\\{(.*?)\\} *?\\{(.*?)\\}");
+        for (Documentation d : list) {
+            Matcher m = p.matcher(d.docs());
+            if (m.find()) {
+                String name = d.getName();
+                String description = m.group(2).trim();
+                String prefilter = PrefilterData.Get(m.group(1).split("\\|"), type);
+                String eventData = EventData.Get(m.group(3).split("\\|"), type);
+                String mutability = MutabilityData.Get(m.group(4).split("\\|"), type);
+                //String manualTrigger = ManualTriggerData.Get(m.group(5).split("\\|"), type);
+                String since = d.since();
+
+                if (type.equals("html")) {
+                    doc.append("<tr><td style=\"vertical-align:top\">").append(name).append("</td><td style=\"vertical-align:top\">").append(description).append("</td><td style=\"vertical-align:top\">").append(prefilter).append("</td><td style=\"vertical-align:top\">").append(eventData).append("</td><td style=\"vertical-align:top\">").append(mutability).append("</td><td style=\"vertical-align:top\">").append(since).append("</td></tr>");
+                } else if (type.equals("wiki")) {
+                    doc.append("|-\n" + "! scope=\"row\" | [[CommandHelper/Event API/").append(name).append("|").append(name).append("]]\n" + "| ").append(description).append("\n" + "| ").append(prefilter).append("\n" + "| ").append(eventData).append("\n" + "| ").append(mutability).append("\n" + "| ").append(since).append("\n");
+                } else if (type.equals("text")) {
+                    doc.append("Name: ").append(name).append("\nDescription: ").append(description).append("\nPrefilters:\n").append(prefilter).append("\nEvent Data:\n").append(eventData).append("\nMutable Fields:\n").append(mutability).append("\nSince: ").append(since).append("\n\n");
+                }
+            }
+        }
+
+        if (type.equals("html")) {
+            doc.append("</tbody></table>");
+        } else if (type.equals("wiki")) {
+            doc.append("|}");
+        }
+
+        System.out.println(doc.toString());
+
+        if (type.equals("html")) {
+            System.out.println(""
+                    + "<h2>Errors in documentation</h2>\n"
+                    + "<em>Please note that this documentation is generated automatically,"
+                    + " if you notice an error in the documentation, please file a bug report for the"
+                    + " plugin itself!</em>");
+        } else if (type.equals("wiki")) {
+            System.out.println(""
+                    + "===Errors in documentation===\n"
+                    + "''Please note that this documentation is generated automatically,"
+                    + " if you notice an error in the documentation, please file a bug report for the"
+                    + " plugin itself!'' For information on undocumented functions, see [[CommandHelper/Sandbox|this page]]\n\n{{LearningTrail}}");
+        }
+    }
+
+    private static class PrefilterData {
+
+        public static String Get(String[] data, String type) {
+            StringBuilder b = new StringBuilder();
+            boolean first = true;
+            for (String d : data) {
+                int split = d.indexOf(":");
+                String name = d.substring(0, split).trim();
+                String description = ExpandMacro(d.substring(split + 1).trim(), type);
+                if (type.equals("html")) {
+                    b.append(first ? "" : "<br />").append("<strong>").append(name).append("</strong>: ").append(description);
+                } else if (type.equals("wiki")) {
+                    b.append(first ? "" : "<br />").append("'''").append(name).append("''': ").append(description);
+                } else if (type.equals("text")) {
+                    b.append(first ? "" : "\n").append("\t").append(name).append(": ").append(description);
+                }
+                first = false;
+            }
+            return b.toString();
+        }
+
+        private static String ExpandMacro(String macro, String type) {
+            if (type.equals("html")) {
+                return "<em>" + macro
+                    .replaceAll("<string match>", "&lt;String Match&gt;")
+                    .replaceAll("<regex>", "&lt;Regex&gt;")
+                    .replaceAll("<item match>", "&lt;Item Match&gt;")
+                    .replaceAll("<math match>", "&lt;Math Match&gt;")
+                    .replaceAll("<macro>", "&lt;Macro&gt;")
+                    .replaceAll("<expression>", "&lt;Expression&gt;") + "</em>";
+            } else if (type.equals("wiki")) {
+                return macro
+                    .replaceAll("<string match>", "[[CommandHelper/Events/Prefilters#String Match|String Match]]")
+                    .replaceAll("<regex>", "[[CommandHelper/Events/Prefilters#Regex|Regex]]")
+                    .replaceAll("<item match>", "[[CommandHelper/Events/Prefilters#Item Match|Item Match]]")
+                    .replaceAll("<math match>", "[[CommandHelper/Events/Prefilters#Math Match|Math Match]]")
+                    .replaceAll("<macro>", "[[CommandHelper/Events/Prefilters#Macro|Macro]]")
+                    .replaceAll("<expression>", "[[CommandHelper/Events/Prefilters#Expression|Expression]]");                
+            } else if (type.equals("text")) {
+                return macro
+                    .replaceAll("<string match>", "<String Match>")
+                    .replaceAll("<regex>", "<Regex>")
+                    .replaceAll("<item match>", "<Item Match>")
+                    .replaceAll("<math match>", "<Math Match>")
+                    .replaceAll("<macro>", "<Macro>")
+                    .replaceAll("<expression>", "<Expression>");
+            }
+            return macro;
+        }
+    }
+
+    private static class EventData {
+
+        public static String Get(String[] data, String type) {
+            StringBuilder b = new StringBuilder();
+            boolean first = true;
+            for (String d : data) {
+                int split = d.indexOf(":");
+                String name = d.substring(0, split).trim();
+                String description = d.substring(split + 1).trim();
+                if (type.equals("html")) {
+                    b.append(first ? "" : "<br />").append("<strong>").append(name).append("</strong>: ").append(description);
+                } else if (type.equals("wiki")) {
+                    b.append(first ? "" : "<br />").append("'''").append(name).append("''': ").append(description);
+                } else if (type.equals("text")) {
+                    b.append(first ? "" : "\n").append("\t").append(name).append(": ").append(description);
+                }
+                first = false;
+            }
+            return b.toString();
+        }
+    }
+
+    private static class MutabilityData {
+
+        public static String Get(String[] data, String type) {
+            StringBuilder b = new StringBuilder();
+            boolean first = true;
+            for (String d : data) {
+                int split = d.indexOf(":");
+                if (split == -1) {
+                    if (type.equals("html")) {
+                        b.append(first ? "" : "<br />").append("<strong>").append(d.trim()).append("</strong>");
+                    } else if (type.equals("wiki")) {
+                        b.append(first ? "" : "<br />").append("'''").append(d.trim()).append("'''");
+                    } else if (type.equals("text")) {
+                        b.append(first ? "" : "\n").append("\t").append(d.trim());
+                    }
+                } else {
+                    String name = d.substring(0, split).trim();
+                    String description = d.substring(split).trim();
+                    if (type.equals("html")) {
+                        b.append(first ? "" : "<br />").append("<strong>").append(name).append("</strong>: ").append(description);
+                    } else if (type.equals("wiki")) {
+                        b.append(first ? "" : "<br />").append("'''").append(name).append("''': ").append(description);
+                    } else if (type.equals("text")) {
+                        b.append(first ? "" : "\n").append("\t").append(name).append(": ").append(description);
+                    }
+                }
+                first = false;
+            }
+            return b.toString();
+        }
+    }
+    
+    private static class ManualTriggerData{
+        public static String Get(String[] data, String type){
+            throw new UnsupportedOperationException("FIXME");
+        }
+    }
+}
diff --git a/src/main/java/com/laytonsmith/tools/Interpreter.java b/src/main/java/com/laytonsmith/tools/Interpreter.java
new file mode 100644
index 0000000..453990c
--- /dev/null
+++ b/src/main/java/com/laytonsmith/tools/Interpreter.java
@@ -0,0 +1,121 @@
+/*
+ * To change this template, choose Tools | Templates
+ * and open the template in the editor.
+ */
+package com.laytonsmith.tools;
+
+import com.laytonsmith.PureUtilities.SerializedPersistance;
+import static com.laytonsmith.PureUtilities.TermColors.*;
+import com.laytonsmith.commandhelper.CommandHelperPlugin;
+import com.laytonsmith.core.Env;
+import com.laytonsmith.core.GenericTreeNode;
+import com.laytonsmith.core.MScriptCompiler;
+import com.laytonsmith.core.MScriptComplete;
+import com.laytonsmith.core.constructs.Token;
+import com.laytonsmith.core.exceptions.CancelCommandException;
+import com.laytonsmith.core.exceptions.ConfigCompileException;
+import static com.laytonsmith.tools.Manager.p;
+import static com.laytonsmith.tools.Manager.pl;
+import java.io.File;
+import java.util.List;
+import java.util.Scanner;
+
+/**
+ * This is a command line implementation of the in game interpreter mode.
+ * This should only be run while the server is stopped, as it has full
+ * access to filesystem resources. Many things won't work as intended, but
+ * pure abstract functions should still work fine.
+ * @author layton
+ */
+public class Interpreter {
+    static boolean multilineMode = false;
+    static String script;
+
+    public static void start(){
+        try {
+            MScriptCompiler.execute(MScriptCompiler.compile(MScriptCompiler.lex("player()", null)), new Env(), null, null);
+        } catch (ConfigCompileException ex) {}
+        CommandHelperPlugin.persist = new SerializedPersistance(new File("CommandHelper/persistance.ser"));
+        pl(YELLOW + "You are now in cmdline interpreter mode. Type a dash (-) on a line by itself to exit, and >>> to enter"
+                + " multiline mode.\nMost Minecraft features will not work, and your working directory is the"
+                + " CommandHelper.jar directory, not the Server directory. Have fun!");
+        Scanner scanner = new Scanner(System.in);
+        p(BLUE + ":" + WHITE);
+        while(textLine(scanner.nextLine())){
+            p(BLUE + ":" + WHITE);
+        }
+    }
+
+    public static boolean textLine(String line) {
+        if (line.equals("-")) {
+            //Exit interpreter mode
+            pl(YELLOW + "Now exiting interpreter mode");
+            return false;
+        } else if (line.equals(">>>")) {
+            //Start multiline mode
+            if (multilineMode) {
+                pl(RED + "You are already in multiline mode!");
+            } else {
+                multilineMode = true;
+                pl(YELLOW + "You are now in multiline mode. Type <<< on a line by itself to execute.");
+                pl(":" + WHITE + ">>>");
+            }
+        } else if (line.equals("<<<")) {
+            //Execute multiline
+            pl(":" + WHITE + "<<<");
+            multilineMode = false;
+            try {
+                execute(script);
+                script = "";
+            } catch (ConfigCompileException e) {
+                pl(RED + e.getMessage() + ":" + e.getLineNum());
+            }
+        } else {
+            if (multilineMode) {
+                //Queue multiline
+                script = script + line + "\n";
+                pl(":" + WHITE + line);
+            } else {
+                try {
+                    //Execute single line
+                    execute(line);
+                } catch (ConfigCompileException ex) {
+                    pl(RED + ex.getMessage());
+                }
+            }
+        }
+        return true;
+    }
+
+    public static void execute(String script) throws ConfigCompileException {
+        List<Token> stream = MScriptCompiler.lex(script, new File("Interpreter"));
+        GenericTreeNode tree = MScriptCompiler.compile(stream);
+        Env env = new Env();
+        env.SetPlayer(null);
+        env.SetLabel("*");
+        try {
+            MScriptCompiler.execute(tree, env, new MScriptComplete() {
+
+                public void done(String output) {
+                    output = output.trim();
+                    if (output.equals("")) {
+                        pl(":");
+                    } else {
+                        if (output.startsWith("/")) {
+                            //Run the command
+                            pl(":" + YELLOW + output);
+                        } else {
+                            //output the results
+                            pl(":" + GREEN + output);
+                        }
+                    }
+                }
+            }, null);
+        } catch (CancelCommandException e) {
+            pl(":");
+        } catch(Exception e){
+            pl(RED + e.toString());
+            e.printStackTrace();
+        }
+    }
+}
diff --git a/src/main/java/com/laytonsmith/tools/Manager.java b/src/main/java/com/laytonsmith/tools/Manager.java
new file mode 100644
index 0000000..1800b38
--- /dev/null
+++ b/src/main/java/com/laytonsmith/tools/Manager.java
@@ -0,0 +1,442 @@
+/*
+ * To change this template, choose Tools | Templates
+ * and open the template in the editor.
+ */
+package com.laytonsmith.tools;
+
+import com.laytonsmith.PureUtilities.Persistance;
+import com.laytonsmith.PureUtilities.SerializedPersistance;
+import com.laytonsmith.PureUtilities.TermColors.SYS;
+import static com.laytonsmith.PureUtilities.TermColors.*;
+import com.laytonsmith.PureUtilities.fileutility.FileUtility;
+import com.laytonsmith.core.Env;
+import com.laytonsmith.core.MScriptCompiler;
+import com.laytonsmith.core.Static;
+import com.laytonsmith.core.constructs.Construct;
+import com.laytonsmith.core.exceptions.ConfigCompileException;
+import java.awt.Color;
+import java.io.File;
+import java.io.IOException;
+import java.io.Serializable;
+import java.util.Map;
+import java.util.Scanner;
+import java.util.regex.Matcher;
+import java.util.regex.Pattern;
+/**
+ *
+ * @author layton
+ */
+public class Manager {
+
+    private static Scanner scanner;
+
+    public static void start() {
+        cls();
+        pl("\n" + Static.Logo() + "\n\n" + Static.DataManagerLogo());
+        scanner = new Scanner(System.in);
+        
+        pl("Starting the Data Manager...");
+        try {
+            MScriptCompiler.execute(MScriptCompiler.compile(MScriptCompiler.lex("player()", null)), new Env(), null, null);
+        } catch (ConfigCompileException ex) {}
+        pl(GREEN + "Welcome to the CommandHelper " + CYAN + "Data Manager!");
+        pl(BLINKON + RED + "Warning!" + BLINKOFF + YELLOW + " Be sure your server is not running before using this tool to make changes to your database!");
+        pl("------------------------");
+        boolean finished = false;
+        do {
+            pl(YELLOW + "What function would you like to run? Type \"help\" for a full list of options.");
+            String input = prompt();
+            pl();
+            if (input.toLowerCase().startsWith("help")) {
+                help(input.replaceFirst("help ?", "").toLowerCase().split(" "));
+            } else if (input.equalsIgnoreCase("refactor")) {
+                pl("refactor - That feature isn't implemented yet :(");
+            } else if (input.toLowerCase().startsWith("print")) {                
+                print(input.replaceFirst("print ?", "").toLowerCase().split(" "));
+            } else if (input.equalsIgnoreCase("cleardb")) {
+                cleardb();
+            } else if(input.equalsIgnoreCase("import")){                
+                pl("import - That feature isn't implemented yet :(");
+            } else if (input.equalsIgnoreCase("export")) {
+                export();
+            } else if(input.equalsIgnoreCase("edit")){
+                edit();
+            } else if (input.equalsIgnoreCase("upgrade")) {
+                upgrade();
+            } else if(input.equalsIgnoreCase("interpreter")){
+                Interpreter.start();
+            } else if (input.equalsIgnoreCase("exit")) {
+                pl("Thanks for using the " + CYAN + "Data Manager!");
+                finished = true;
+            } else {
+                pl("I'm sorry, that's not a valid command. Here's the help:");
+                help(new String[]{});
+            }
+        } while (finished == false);
+    }
+    
+    public static void export(){
+        cls();
+        pl(GREEN + "Export creates a text based file that you can use to get your persisted data\n"
+         + "out of the database. You have various options for the export type.");
+        String type;
+        while(true){
+            pl(YELLOW + "What export type would you like? The options are: XML, plain text, INI, and YML.");
+            pl("[XML/TEXT/INI/YML]");
+            type = prompt().toLowerCase();
+            if(type.equals("xml") || type.equals("text") || type.equals("ini") || type.equals("yml")){
+                break;
+            } else {
+                pl(RED + "That's not a valid type.");
+            }
+        }
+        
+        String filename;
+        while(true){
+            pl("Give me a filename to store it in:");
+            filename = prompt();
+            File file = new File(filename);
+            if(file.exists()){
+                pl(RED + "That file already exists, do you want to overwrite it? " + WHITE + "[Y/N]");
+                if(prompt().equalsIgnoreCase("y")){
+                    break;
+                }
+            } else if(file.getAbsoluteFile().getParentFile() != null && !file.getAbsoluteFile().getParentFile().exists()){
+                pl(RED + "That file's parent directory doesn't exist yet.");
+                pl("I'm not going to create any directories, so go create them first\n"
+                        + "if that's really where you want the file.");
+            } else {
+                break;
+            }            
+        }
+        
+        pl("Alright, I'm going to create a " + type + " type file at " + new File(filename).getAbsolutePath());
+        pl("Is this alright? [Y/N]");
+        if(prompt().equalsIgnoreCase("y")){
+            doExport(type, new File(filename));
+        }
+    }
+    
+    public static void doExport(String type, File file){
+        pl(RED + "Actually, this feature isn't implemented yet :(");
+    }
+    
+    public static void cleardb(){
+        pl(RED + "Are you absolutely sure you want to clear out your database? " + BLINKON + "No backup is going to be made." + BLINKOFF);
+        pl(WHITE + "This will completely wipe your persistance information out. (No other data will be changed)");
+        pl("[YES/No]");
+        String choice = prompt();
+        if(choice.equals("YES")){
+            pl("Positive? [YES/No]");
+            if(prompt().equals("YES")){
+                p("Ok, here we go... ");
+                Persistance db = GetDB();
+                try {
+                    db.load();
+                    db.clearAllData();
+                    db.save();
+                } catch (Exception ex) {
+                    pl(RED + ex.getMessage());
+                }
+                pl("Done!");
+            }
+        } else if(choice.equalsIgnoreCase("yes")){
+            pl("No, you have to type YES exactly.");
+        }
+    }
+    
+    public static void help(String [] args){
+        if(args[0].equals("")){
+            pl("Currently, your options are:\n"
+                            + "\t" + BLUE + "refactor" + WHITE + " - Options for refactoring your persisted data from one backend to another\n"
+                            + "\t" + GREEN + "upgrade" + WHITE + " - Runs upgrade scripts on your persisted data\n"
+                            + "\t" + GREEN + "print" + WHITE + " - Prints out the information from your persisted data\n"
+                            + "\t" + GREEN + "cleardb" + WHITE + " - Clears out your database of persisted data\n"
+                            + "\t" + BLUE + "import" + WHITE + " - Imports a text based file into the persistance database\n"
+                            + "\t" + BLUE + "export" + WHITE + " - Exports your persisted data to a text based file\n"
+                            + "\t" + GREEN + "edit" + WHITE + " - Allows you to edit individual fields\n"
+                            + "\t" + GREEN + "interpreter" + WHITE + " - Command Line Interpreter mode. Most minecraft related functions don't work.\n"
+                            + "\n\t" + RED + "exit" + WHITE + " - Quits the Data Manager\n");
+            
+            pl("Type " + MAGENTA + "help <command>" + WHITE + " for more details about a specific command");
+            if(SYSTEM.equals(SYS.UNIX)){
+                pl(BLUE + "Blue" + WHITE + " entries are not yet working.");
+            }
+        } else {
+            if(args[0].equals("refactor")){
+                pl("Not implemented yet");
+            } else if(args[0].equals("upgrade")){
+                pl("Converts any old formatted data into the new format. Any data that doesn't explicitely"
+                        + " match the old format is not touched.");
+            } else if(args[0].equals("print")){
+                pl("Prints out the information in your persistance file. Entries may be narrowed down by"
+                        + " specifying the namespace (for instance " + MAGENTA + "print user.username" + WHITE
+                        + " will only show that particular users's aliases.) This is namespace based, so you"
+                        + " must provide the entire namespace that your are trying to narrow down."
+                        + "(" + MAGENTA + "print storage" + WHITE + " is valid, but " + MAGENTA + "print stor"
+                        + WHITE + " is not)");
+            } else if(args[0].equals("cleardb")){
+                pl("Wipes your database clean of CommandHelper's persistance entries, but not other data. This"
+                        + " includes any data that CommandHelper would have inserted into the database, or data"
+                        + " that CommandHelper otherwise knows how to use. If using SerializedPersistance, this"
+                        + " means the entire file. For other data backends, this may vary slightly, for instance,"
+                        + " an SQL backend would only have the CH specific tables truncated, but the rest of the"
+                        + " database would remain untouched.");
+            } else if(args[0].equals("import")){
+                pl("Not implemented yet");
+            } else if(args[0].equals("export")){
+                pl("Not implemented yet");
+            } else if(args[0].equals("edit")){
+                pl("Allows you to manually edit the values in the database. You have the option to add or edit an existing"
+                        + " value, delete a single value, or view the value of an individual key.");
+            } else if(args[0].equals("exit")){
+                pl("Exits the data manager");
+            } else if(args[0].equals("interpreter")){
+                pl("Generally speaking, works the same as the in game interpreter mode, but none"
+                        + " of the minecraft related functions will work. You should not"
+                        + " run this while the server is operational.");
+            } else {
+                pl("That's not a recognized command: '" + args[0] + "'");
+            }
+        }
+    }
+
+    public static void edit(){
+        cls();
+        while(true){
+            pl("Would you like to " + GREEN + "(a)dd/edit" + WHITE 
+                    + " a value, " + RED + "(r)emove" + WHITE + " a value, " + CYAN 
+                    + "(v)iew" + WHITE + " a single value, or " 
+                    + MAGENTA + "(s)top" + WHITE + " editting? [" + GREEN + "A" + WHITE + "/" 
+                    + RED + "R" + WHITE + "/" + CYAN + "V" + WHITE + "/" + MAGENTA + "S" + WHITE + "]");
+            String choice = prompt();
+            if(choice.equalsIgnoreCase("s") || choice.equalsIgnoreCase("exit")){
+                break;
+            } else if(choice.equalsIgnoreCase("a")){
+                pl("Type the name of the key " + YELLOW + "EXACTLY" + WHITE + " as shown in the"
+                        + " persistance format,\nnot the format you use when using store_value().");
+                String key = prompt();
+                pl("Provide a value for " + CYAN + key + WHITE + ". This value you provide will"
+                        + " be interpreted as pure mscript. (So things like array() will work)");
+                String value = prompt();
+                if(doAddEdit(key, value)){
+                    pl("Value changed!");
+                }
+            } else if(choice.equalsIgnoreCase("r")){
+                pl("Type the name of the key " + YELLOW + "EXACTLY" + WHITE + " as shown in the"
+                        + " persistance format,\nnot the format you use when using store_value().");
+                String key = prompt();
+                if(doRemove(key)){
+                    pl("Value removed!");
+                } else {
+                    pl("That value wasn't in the database to start with");
+                }
+            } else if(choice.equalsIgnoreCase("v")){
+                pl("Type the name of the key " + YELLOW + "EXACTLY" + WHITE + " as shown in the"
+                        + " persistance format,\nnot the format you use when using store_value().");
+                String key = prompt();
+                doView(key);
+            } else {
+                pl("I'm sorry, that's not a valid choice.");
+            }
+        }
+        
+    }
+    
+    public static boolean doView(String key){
+        Persistance db = GetDB();
+        try {
+            db.load();
+        } catch (Exception ex) {
+            pl(RED + ex.getMessage());
+        }
+        if(!db.isKeySet(new String[]{key})){
+            pl(RED + "That value is not set!");
+            return true;
+        }
+        pl(CYAN + key + ":" + WHITE + db.getValue(new String[]{key}));
+        return true;
+    }
+    
+    public static boolean doAddEdit(String key, String valueScript){
+        try {
+            Construct c = MScriptCompiler.execute(MScriptCompiler.compile(MScriptCompiler.lex(valueScript, null)), new Env(), null, null);
+            String value = Construct.json_encode(c, 0, null);
+            pl(CYAN + "Adding: " + WHITE + value);
+            Persistance db = GetDB();
+            db.setValue(new String[]{key}, value);
+            db.save();
+            return true;
+        } catch (Exception ex) {
+            pl(RED + ex.getMessage());
+            return false;
+        }        
+    }
+    
+    public static boolean doRemove(String key){
+        Persistance db = GetDB();
+        try {
+            db.load();
+        } catch (Exception ex) {
+            pl(RED + ex.getMessage());
+            return false;
+        }
+        if(db.isKeySet(new String[]{key})){
+            db.setValue(new String[]{key}, null);
+            return true;
+        } else {
+            return false;
+        }
+    }
+    
+    public static void print(String [] args) {
+        Map data = null;
+        if (GetDB() instanceof SerializedPersistance) {
+            File db = new File("CommandHelper/persistance.ser");
+            if (!db.exists()) {
+                pl("Looks like you haven't used your persistance file yet.");
+                return;
+            }
+            SerializedPersistance sp = new SerializedPersistance(db, null);
+            try {
+                sp.load();
+            } catch (Exception ex) {
+                pl(RED + ex.getMessage());
+            }
+            data = sp.rawData();
+        }
+        pl();
+        if (data != null) {
+            int count = 0;
+            for (Object key : data.keySet()) {
+                if(!args[0].equals("")){
+                    //We are splitting by namespace
+                    if(!key.toString().toLowerCase().startsWith(args[0] + ".")){
+                        continue;
+                    }
+                }
+                pl(CYAN + key.toString() + ": " + WHITE + data.get(key).toString());
+                count++;
+            }
+            pl(BLUE + count + " items found");
+        }
+    }
+
+    public static void upgrade() {
+        pl("\nThis will automatically detect and upgrade your persisted data. Though this will"
+                + " create a backup for you, you should manually back up your data before running"
+                + " this utility.");
+        pl("Would you like to continue? [" + GREEN + "Y" + WHITE + "/"
+                + RED + "N" + WHITE + "]");
+        String choice = prompt();
+        pl();
+        if (choice.equalsIgnoreCase("y")) {
+            //First we have to read in the preferences file, and see what persistance type they are using
+            //Only serialization is supported right now
+            String backingType = "serialization";
+            if (backingType.equals("serialization")) {
+                try {
+                    //Back up the persistance.ser file
+                    File db = new File("CommandHelper/persistance.ser");
+                    if (!db.exists()) {
+                        pl("Looks like you haven't used your persistance file yet.");
+                        return;
+                    }
+                    FileUtility.copy(db, new File("CommandHelper/persistance.ser.bak"));
+                    //Now, load in all the data
+                    SerializedPersistance sp = new SerializedPersistance(db, null);
+                    try {
+                        sp.load();
+                    } catch (Exception ex) {
+                        pl(RED + ex.getMessage());
+                    }
+                    Map<String, Serializable> data = sp.rawData();
+                    if (data.isEmpty()) {
+                        pl("Looks like you haven't used your persistance file yet.");
+                        return;
+                    }
+                    sp.clearAllData(); //Bye bye!
+                    //Ok, now we need to determine the type of data we're currently working with
+                    p(WHITE + "Working");
+                    int counter = 0;
+                    int changes = 0;
+                    Color[] colors = new Color[]{Color.RED, Color.YELLOW, Color.GREEN, Color.CYAN, Color.BLUE, Color.MAGENTA};
+                    for (String key : data.keySet()) {
+                        counter++;
+                        int c = counter / 20;
+                        if(c == ((double)counter / 20.0)){
+                            p(color(colors[c % 6]) + ".");
+                        }
+                        if (key.matches("^plugin\\.com\\.sk89q\\.commandhelper\\.CommandHelperPlugin\\.commandhelper\\.function\\.storage\\..*")) {
+                            //We're in version 1, and we need to upgrade to version 2
+                            String newKey = "storage." + key.replaceFirst("plugin\\.com\\.sk89q\\.commandhelper\\.CommandHelperPlugin\\.commandhelper\\.function\\.storage\\.", "");
+                            sp.rawData().put(newKey, data.get(key));
+                            changes++;
+                        } else if(key.matches("^plugin\\.com\\.sk89q\\.commandhelper\\.CommandHelperPlugin\\..*?\\.aliases\\.\\d+$")){
+                            //Pull out the parts we need
+                            Pattern p = Pattern.compile("^plugin\\.com\\.sk89q\\.commandhelper\\.CommandHelperPlugin\\.(.*?)\\.aliases\\.(\\d+)$");
+                            Matcher m = p.matcher(key);
+                            String newKey = null;
+                            if(m.find()){
+                                String username = m.group(1);
+                                String id = m.group(2);
+                                newKey = "user." + username + ".aliases." + id;
+                            }
+                            //If something went wrong, just put the old one back in
+                            if(newKey == null){
+                                sp.rawData().put(key, data.get(key));
+                            } else {
+                                sp.rawData().put(newKey, data.get(key));
+                                changes++;
+                            }
+                        } else {
+                            sp.rawData().put(key, data.get(key));
+                        }
+                    }
+                    try {
+                        sp.save();
+                    } catch (Exception ex) {
+                        pl(RED + ex.getMessage());
+                    }
+                    pl();
+                    pl(GREEN + "Assuming there are no error messages above, it should be upgraded now! (Use print to verify)");
+                    pl(CYAN.toString() + changes + " change" + (changes==1?" was":"s were") + " made");
+
+                } catch (IOException ex) {
+                    pl(RED + ex.getMessage());
+                }
+            }
+        } else {
+            pl(RED + "Upgrade Cancelled");
+        }
+    }
+    
+    public static Persistance GetDB(){
+        //Figure out what engine they're using
+        //For now, it's obviously SerializedPersistance
+        return new SerializedPersistance(new File("CommandHelper/persistance.ser"), null);
+    }
+
+    public static void p(CharSequence c) {
+        System.out.print(c);
+        System.out.flush();
+    }
+
+    public static void pl() {
+        pl("");
+    }
+    
+    public static String prompt(){
+        p(">" + MAGENTA);
+        System.out.flush();
+        String ret = scanner.nextLine();
+        p(WHITE);
+        return ret;
+    }
+
+    public static void pl(CharSequence c) {
+        System.out.println(c + WHITE);
+    }
+
+    
+}
diff --git a/src/main/java/com/laytonsmith/tools/SyntaxHighlighters.java b/src/main/java/com/laytonsmith/tools/SyntaxHighlighters.java
new file mode 100644
index 0000000..6467ab1
--- /dev/null
+++ b/src/main/java/com/laytonsmith/tools/SyntaxHighlighters.java
@@ -0,0 +1,214 @@
+/*
+ * To change this template, choose Tools | Templates
+ * and open the template in the editor.
+ */
+package com.laytonsmith.tools;
+
+import com.laytonsmith.PureUtilities.ClassDiscovery;
+import com.laytonsmith.abstraction.MCChatColor;
+import com.laytonsmith.core.Documentation;
+import com.laytonsmith.core.Static;
+import com.laytonsmith.core.api;
+import com.laytonsmith.core.docs;
+import com.laytonsmith.core.docs.type;
+import com.laytonsmith.core.events.EventHandlerInterface;
+import com.laytonsmith.core.functions.Function;
+import java.lang.reflect.Constructor;
+import java.util.ArrayList;
+import java.util.List;
+import java.util.logging.Level;
+import java.util.logging.Logger;
+import java.util.regex.Matcher;
+import java.util.regex.Pattern;
+
+/**
+ *
+ * @author layton
+ */
+public class SyntaxHighlighters {
+
+    public static String generate(String type, String theme) {
+        if("npp".equals(type) || "notepad++".equals(type)){
+
+            if("default".equals(theme)){
+                return template("/syntax-templates/notepad++/default.xml");
+            }
+            if("obsidian".equals(theme)){
+                return template("/syntax-templates/notepad++/obsidian.xml");                
+            }
+
+            return "Available themes for Notepad++: default, obsidian";            
+        }
+        if("textwrangler".equals(type)){
+            return template("/syntax-templates/text-wrangler/default.plist");
+        }
+        if("geshi".equals(type)){
+            return template("/syntax-templates/geshi/default.php");
+        }
+        if("vim".equals(type)){
+            return template("/syntax-templates/vim/default.vim");
+        }
+
+        return "File for the following syntax highlighters are currently available:\n"
+                + "\tNotepad++ - Use type \"npp\". You may also select a theme, either \"default\" or \"obsidian\"\n"
+                + "\tTextWrangler - Use type \"textwrangler\". Only the default theme is available.\n"
+                + "\t\tTo install: put the generated file in ~/Library/Application Support/TextWrangler/Language Modules/\n"
+                + "\tGeSHi - Use type \"geshi\". Only the default theme is available.\n"
+                + "\tViM - Use type \"vim\". Only the default theme is available.\n"
+                + "\t\tTo install: put in ~/.vim/syntax/commandhelper.vim then edit\n"
+                + "\t\t~/.vim/ftdetect/commandhelper.vim and add the line \n"
+                + "\t\tau BufRead,BufNewFile *.ms set filetype=commandhelper\n"
+                + "\t\t(Create directories and files as needed)\n"
+                + "\n\n"
+                + "Know how to write a syntax highlighter file for your favorite text editor? Let me know, and we\n"
+                + "can work to get it included in CommandHelper!";
+    }
+
+    /**
+     * Available macros are listed in the code below.
+     * @param location
+     * @return 
+     */
+    private static String template(String location) {        
+        String template = Static.GetStringResource(location);
+        Pattern p = Pattern.compile("%%(.*?)%%");
+        Matcher m = p.matcher(template);
+        while(m.find()){
+            template = template.replaceAll("%%" + m.group(1) + "%%", macro(m.group(1)));
+        }
+        return template;
+    }
+    
+    private static String macro(String macroName){
+        String[] split = macroName.split(":");
+        String type = split[0];
+        String datalist = split[1];
+        List<String> params = new ArrayList<String>();
+        for(int i = 2; i < split.length; i++){
+            params.add(split[i].toLowerCase());
+        }
+        List<String> base = new ArrayList<String>();
+        if(datalist.equalsIgnoreCase("colors")){
+            for(MCChatColor c : MCChatColor.values()){
+                base.add(c.name());
+            }
+        } else if(datalist.equalsIgnoreCase("keywords")){
+            base.add("null");
+            base.add("false");
+            base.add("true");
+        } else if(datalist.equalsIgnoreCase("functions")){
+            for(Function f : GetFunctions()){
+                if(params.contains("restricted") || params.contains("unrestricted")){
+                    if(params.contains("restricted") && f.isRestricted()){
+                        base.add(f.getName());
+                    } else if(params.contains("unrestricted") && !f.isRestricted()){
+                        base.add(f.getName());
+                    }
+                } else {
+                    base.add(f.getName());
+                }
+            }
+        } else if(datalist.equalsIgnoreCase("events")){
+            for(Documentation d : GetEvents()){
+                base.add(d.getName());
+            }
+        }
+        String header = "";
+        String spliter = "IMPROPER FORMATTING";
+        String footer = "";
+        if(type.equalsIgnoreCase("space")){
+            if(params.contains("quoted")){
+                header = "'";
+                spliter = "' '";
+                footer = "'";
+            } else {
+                spliter = " ";
+            }
+        } else if(type.equalsIgnoreCase("comma")){
+            if(params.contains("quoted")){
+                header = "'";
+                spliter = "', '";
+                footer = "'";
+            } else {
+                spliter = ", ";
+            }
+        } else if(type.equalsIgnoreCase("xml")){
+            String tag = "PLEASE INCLUDE THE TAG NAME USING tag=tagname AS A PARAMETER";
+            for(String param : params){
+                //Find the tag name
+                if(param.matches("tag=.*")){
+                    tag = param.substring(4);
+                    break;
+                }
+            }
+            if(params.contains("quoted")){
+                header = "<" + tag + ">'";
+                spliter = "'</" + tag + "><" + tag + ">'";
+                footer = "'</" + tag + ">";
+            } else {
+                header = "<" + tag + ">";
+                spliter = "</" + tag + "><" + tag + ">";
+                footer = "</" + tag + ">";
+            }
+        }
+        return header + Join(base, spliter) + footer;
+        
+    }
+
+    
+    
+    private static List<Documentation> GetEvents(){
+        List<Documentation> l = new ArrayList<Documentation>();
+        Class[] classes = ClassDiscovery.GetClassesWithAnnotation(docs.class);
+        for(Class c : classes){
+            if (Documentation.class.isAssignableFrom(c)) {
+                docs d = (docs) c.getAnnotation(docs.class);
+                if(d.type().equals(type.EVENT)){
+                    try {
+                        Constructor m = c.getConstructor(EventHandlerInterface.class);
+                        Documentation e = (Documentation)m.newInstance((EventHandlerInterface)null);
+                        l.add(e);
+                    } catch (Exception ex) {
+                        System.err.println(ex.getMessage());
+                    }
+                }
+            }           
+        }
+        return l;
+    }
+    
+    private static List<Function> GetFunctions(){
+        List<Function> fl = new ArrayList<Function>();
+        Class[] functions = ClassDiscovery.GetClassesWithAnnotation(api.class);
+        for(Class c : functions){
+            if(Function.class.isAssignableFrom(c)){
+                try {
+                    fl.add((Function)c.newInstance());
+                } catch (InstantiationException ex) {
+                    Logger.getLogger(SyntaxHighlighters.class.getName()).log(Level.SEVERE, null, ex);
+                } catch (IllegalAccessException ex) {
+                    Logger.getLogger(SyntaxHighlighters.class.getName()).log(Level.SEVERE, null, ex);
+                } catch(NoClassDefFoundError e){
+                    //Hmm. No real good way to handle this... echo out to stderr, I guess.
+                    System.err.println(e.getMessage());
+                }
+                
+            }
+        }
+        return fl;
+    }
+    
+    
+    private static String Join(List l, String joiner){
+        StringBuilder b = new StringBuilder();
+        for(int i = 0; i < l.size(); i++){
+            if(i == 0){
+                b.append(l.get(i).toString());
+            } else {
+                b.append(joiner).append(l.get(i).toString());
+            }
+        }
+        return b.toString();
+    }
+    
+}
diff --git a/src/main/java/com/sk89q/commandhelper/CommandHelperInterpreterListener.java b/src/main/java/com/sk89q/commandhelper/CommandHelperInterpreterListener.java
deleted file mode 100644
index bea1e3c..0000000
--- a/src/main/java/com/sk89q/commandhelper/CommandHelperInterpreterListener.java
+++ /dev/null
@@ -1,140 +0,0 @@
-/*
- * To change this template, choose Tools | Templates
- * and open the template in the editor.
- */
-package com.sk89q.commandhelper;
-
-import com.laytonsmith.aliasengine.Constructs.Token;
-import com.laytonsmith.aliasengine.GenericTreeNode;
-import com.laytonsmith.aliasengine.MScriptCompiler;
-import com.laytonsmith.aliasengine.MScriptComplete;
-import com.laytonsmith.aliasengine.Static;
-import com.laytonsmith.aliasengine.functions.exceptions.CancelCommandException;
-import com.laytonsmith.aliasengine.functions.exceptions.ConfigCompileException;
-import java.io.File;
-import java.util.HashMap;
-import java.util.HashSet;
-import java.util.List;
-import java.util.Map;
-import java.util.Set;
-import org.bukkit.ChatColor;
-import org.bukkit.entity.Player;
-import org.bukkit.event.player.PlayerChatEvent;
-import org.bukkit.event.player.PlayerCommandPreprocessEvent;
-import org.bukkit.event.player.PlayerListener;
-import org.bukkit.event.player.PlayerQuitEvent;
-
-/**
- *
- * @author Layton
- */
-public class CommandHelperInterpreterListener extends PlayerListener {
-
-    Set<String> interpreterMode = new HashSet<String>();
-    Map<String, String> multilineMode = new HashMap<String, String>();
-
-    @Override
-    public void onPlayerChat(PlayerChatEvent event) {
-        if (interpreterMode.contains(event.getPlayer().getName())) {
-            Player p = event.getPlayer();
-            textLine(p, event.getMessage());
-            event.setCancelled(true);
-        }
-
-    }
-
-    @Override
-    public void onPlayerQuit(PlayerQuitEvent event) {
-        interpreterMode.remove(event.getPlayer().getName());
-        multilineMode.remove(event.getPlayer().getName());
-    }
-
-    @Override
-    public void onPlayerCommandPreprocess(PlayerCommandPreprocessEvent event) {
-        if (interpreterMode.contains(event.getPlayer().getName())) {
-            Player p = event.getPlayer();
-            textLine(p, event.getMessage());
-            event.setCancelled(true);
-        }
-    }
-
-    public void textLine(Player p, String line) {
-        if (line.equals("-")) {
-            //Exit interpreter mode
-            interpreterMode.remove(p.getName());
-            Static.SendMessage(p, ChatColor.YELLOW + "Now exiting interpreter mode");
-        } else if (line.equals(">>>")) {
-            //Start multiline mode
-            if (multilineMode.containsKey(p.getName())) {
-                Static.SendMessage(p, ChatColor.RED + "You are already in multiline mode!");
-            } else {
-                multilineMode.put(p.getName(), "");
-                Static.SendMessage(p, ChatColor.YELLOW + "You are now in multiline mode. Type <<< on a line by itself to execute.");
-                Static.SendMessage(p, ":" + ChatColor.GRAY + ">>>");
-            }
-        } else if (line.equals("<<<")) {
-            //Execute multiline
-            Static.SendMessage(p, ":" + ChatColor.GRAY + "<<<");
-            String script = multilineMode.get(p.getName());
-            multilineMode.remove(p.getName());
-            try {
-                execute(script, p);
-            } catch (ConfigCompileException e) {
-                Static.SendMessage(p, ChatColor.RED + e.getMessage() + ":" + e.getLineNum());
-            }
-        } else {
-            if (multilineMode.containsKey(p.getName())) {
-                //Queue multiline
-                multilineMode.put(p.getName(), multilineMode.get(p.getName()) + line + "\n");
-                Static.SendMessage(p, ":" + ChatColor.GRAY + line);
-            } else {
-                try {
-                    //Execute single line
-                    execute(line, p);
-                } catch (ConfigCompileException ex) {
-                    Static.SendMessage(p, ChatColor.RED + ex.getMessage());
-                }
-            }
-        }
-    }
-
-    public void reload() {
-    }
-
-    public void execute(String script, final Player p) throws ConfigCompileException {
-        List<Token> stream = MScriptCompiler.lex(/*"include('plugins/CommandHelper/auto_include.ms')\n" +*/ script, new File("Interpreter"));
-        GenericTreeNode tree = MScriptCompiler.compile(stream);
-        interpreterMode.remove(p.getName());
-        try {
-            MScriptCompiler.execute(tree, p, new MScriptComplete() {
-
-                public void done(String output) {
-                    output = output.trim();
-                    if (output.equals("")) {
-                        Static.SendMessage(p, ":");
-                    } else {
-                        if (output.startsWith("/")) {
-                            //Run the command
-                            Static.SendMessage(p, ":" + ChatColor.YELLOW + output);
-                            p.chat(output);
-                        } else {
-                            //output the results
-                            Static.SendMessage(p, ":" + ChatColor.GREEN + output);
-                        }
-                    }
-                    interpreterMode.add(p.getName());
-                }
-            }, null);
-        } catch (CancelCommandException e) {
-            interpreterMode.add(p.getName());
-        } catch(Exception e){
-            Static.SendMessage(p, ChatColor.RED + e.toString());
-            e.printStackTrace();
-            interpreterMode.add(p.getName());
-        }
-    }
-
-    public void startInterpret(String playername) {
-        interpreterMode.add(playername);
-    }
-}
diff --git a/src/main/java/com/sk89q/commandhelper/CommandHelperListener.java b/src/main/java/com/sk89q/commandhelper/CommandHelperListener.java
deleted file mode 100644
index 6432094..0000000
--- a/src/main/java/com/sk89q/commandhelper/CommandHelperListener.java
+++ /dev/null
@@ -1,294 +0,0 @@
-// $Id$
-/*
- * CommandHelper
- * Copyright (C) 2010 sk89q <http://www.sk89q.com>
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program. If not, see <http://www.gnu.org/licenses/>.
- */
-package com.sk89q.commandhelper;
-
-import com.laytonsmith.aliasengine.AliasCore;
-import com.laytonsmith.aliasengine.DirtyRegisteredListener;
-import com.laytonsmith.aliasengine.functions.exceptions.ConfigCompileException;
-import com.laytonsmith.aliasengine.functions.exceptions.ConfigRuntimeException;
-import com.laytonsmith.aliasengine.InternalException;
-import com.laytonsmith.aliasengine.MScriptCompiler;
-import com.laytonsmith.aliasengine.Script;
-import com.laytonsmith.aliasengine.Static;
-import com.laytonsmith.aliasengine.User;
-import java.util.logging.Logger;
-import java.util.logging.Level;
-import java.util.Map;
-import java.util.HashMap;
-import java.io.*;
-import java.util.ArrayList;
-import org.bukkit.ChatColor;
-import org.bukkit.entity.Player;
-import org.bukkit.event.player.PlayerCommandPreprocessEvent;
-import org.bukkit.event.player.PlayerListener;
-import org.bukkit.event.player.PlayerQuitEvent;
-
-/**
- * Event listener for Hey0's server mod.
- *
- * @author sk89q
- */
-public class CommandHelperListener extends PlayerListener {
-
-    /**
-     * Logger.
-     */
-    private static final Logger logger = Logger.getLogger("Minecraft");
-    /**
-     * Sessions.
-     */
-    private Map<String, CommandHelperSession> sessions =
-            new HashMap<String, CommandHelperSession>();
-    /**
-     * List of global aliases.
-     */
-    private AliasCore ac;
-    private CommandHelperPlugin plugin;
-
-    public CommandHelperListener(CommandHelperPlugin plugin) {
-        this.plugin = plugin;
-    }
-
-    /**
-     * Load global aliases.
-     */
-    public void loadGlobalAliases() {
-        ac = CommandHelperPlugin.getCore();
-    }
-
-    /**
-     * Find and run aliases for a player for a given command.
-     *
-     * @param command
-     * @return
-     */
-    public boolean runAlias(String command, Player player) {
-        try {
-            User u = new User(player, plugin.persist);
-            ArrayList<String> aliases = u.getAliasesAsArray();
-            ArrayList<Script> scripts = new ArrayList<Script>();
-            for (String script : aliases) {
-                scripts.addAll(MScriptCompiler.preprocess(MScriptCompiler.lex(script, new File("Player"))));
-            }
-            return CommandHelperPlugin.getCore().alias(command, player, scripts);
-            //return globalAliases.get(command.toLowerCase());
-
-        } catch (ConfigCompileException ex) {
-            logger.log(Level.SEVERE, null, ex);
-            return false;
-        }
-    }
-
-    /**
-     * Get session.
-     * 
-     * @param player
-     * @return
-     */
-    public CommandHelperSession getSession(Player player) {
-        if (sessions.containsKey(player.getName())) {
-            return sessions.get(player.getName());
-        } else {
-            CommandHelperSession session = new CommandHelperSession(player.getName());
-            sessions.put(player.getName(), session);
-            return session;
-        }
-    }
-        
-
-    /**
-     * Called when a player attempts to use a command
-     *
-     * @param event Relevant event details
-     */
-    @Override
-    public void onPlayerCommandPreprocess(PlayerCommandPreprocessEvent event) {        
-        String cmd = event.getMessage();        
-        Player player = event.getPlayer();
-        playDirty();
-        if (cmd.equals("/.") || cmd.equals("/repeat")) {
-            return;
-        }
-        this.getSession(player).setLastCommand(cmd);
-
-        if (!(Boolean) Static.getPreferences().getPreference("play-dirty")) {
-            if (event.isCancelled()) {
-                return;
-            }
-        } //If we are playing dirty, ignore the cancelled flag
-
-        try {
-            if (runAlias(event.getMessage(), player)) {
-                event.setCancelled(true);
-                if((Boolean) Static.getPreferences().getPreference("play-dirty")){
-                    //Super cancel the event
-                    DirtyRegisteredListener.setCancelled(event);
-                }
-                //System.out.println("Command Cancelled: " + cmd);
-                return;
-            }
-        } catch (InternalException e) {
-            logger.log(Level.SEVERE, e.getMessage());
-        } catch (ConfigRuntimeException e) {
-            logger.log(Level.WARNING, e.getMessage());
-        } catch (Throwable e) {
-            player.sendMessage(ChatColor.RED + "Command failed with following reason: " + e.getMessage());
-            //Obviously the command is registered, but it somehow failed. Cancel the event.
-            event.setCancelled(true);
-            e.printStackTrace();
-            return;
-        }
-    }
-
-    /**
-     * Runs commands.
-     *
-     * @param player
-     * @param split
-     * @return
-     */
-//    private boolean runCommand(Player player, String split) throws InsufficientArgumentsException {
-//        CommandHelperSession session = getSession(player);
-//
-//        if (split[0].equals("/repeat") || split[0].equals("/.")) {
-//            return false;
-//        }
-//
-//        // Catch aliases
-//        session.setLastCommand(CommandHelperPlugin.joinString(split, " "));
-//
-//
-//
-////        String[] commands = getSession(player).findAlias(split[0]);
-////        String[] arguments = new String[split.length - 1];
-////        System.arraycopy(split, 1, arguments, 0, split.length - 1);
-//
-//        if (commands != null) {
-//            execCommands(player, commands, arguments, false);
-//            return true;
-//        } else if (true /*player.canUseCommand(split[0])*/) {
-//            return runAlias(CommandHelperPlugin.joinString(split, " "), player);
-//        }
-//
-//        return false;
-//    }
-    /**
-     * Called when a player leaves a server
-     *
-     * @param event Relevant event details
-     */
-    @Override
-    public void onPlayerQuit(PlayerQuitEvent event) {
-        Player player = event.getPlayer();
-        sessions.remove(player.getName());
-    }
-
-    /**
-     * Execute a command.
-     *
-     * @param cmd
-     */
-    private void execScriptableCommand(Player player, String cmd) {
-        if (cmd.charAt(0) != '@') {
-            CommandHelperPlugin.execCommand(player, cmd);
-            return;
-        }
-
-        String[] args = cmd.split(" ");
-
-        if (args[0].equalsIgnoreCase("@read")) {
-            if (args.length >= 2) {
-                try {
-                    String[] newArgs = new String[args.length - 1];
-                    System.arraycopy(args, 1, newArgs, 0, args.length - 1);
-                    FileReader input = new FileReader(CommandHelperPlugin.joinString(newArgs, " "));
-                    BufferedReader reader = new BufferedReader(input);
-                    String line;
-                    while ((line = reader.readLine()) != null) {
-                        player.sendMessage(line);
-                    }
-                } catch (IOException e) {
-                    logger.log(Level.WARNING, "@read: Could not read "
-                            + args[1] + ": " + e.getMessage());
-                }
-            } else {
-                logger.log(Level.WARNING, "@read requires 2 arguments");
-            }
-        } else {
-            logger.log(Level.WARNING, "Unknown CommandHelper instruction: "
-                    + args[0]);
-        }
-    }
-
-    /**
-     * Execute a command.
-     *
-     * @param cmd
-     */
-    private void execCommands(Player player, String[] commands,
-            String[] args, boolean scriptable) {
-        for (String cmd : commands) {
-            String[] parts = cmd.split(" ");
-
-            for (int i = 0; i < parts.length; i++) {
-                if (parts[i].matches("%[0-9]+")) {
-                    int n = Integer.parseInt(parts[i].substring(1)) - 1;
-                    if (n < args.length && n >= 0) {
-                        parts[i] = args[n];
-                    } else {
-                        parts[i] = "";
-                    }
-                }
-            }
-
-            cmd = CommandHelperPlugin.joinString(parts, " ");
-
-            if (scriptable) {
-                execScriptableCommand(player, cmd);
-            } else {
-                CommandHelperPlugin.execCommand(player, cmd);
-            }
-        }
-    }
-
-    
-
-    /**
-     * Sets up CommandHelper to play-dirty, if the user has specified as such
-     */
-    public void playDirty() {
-        if ((Boolean) Static.getPreferences().getPreference("play-dirty")) {
-            try {
-                    //Set up our "proxy"
-                    DirtyRegisteredListener.Repopulate();                
-            } catch (NoSuchMethodException ex) {
-                Logger.getLogger(CommandHelperListener.class.getName()).log(Level.SEVERE, null, ex);
-            } catch (NoSuchFieldException ex) {
-                logger.log(Level.SEVERE, "Uh oh, play dirty mode isn't working.", ex);
-            } catch (ClassCastException ex) {
-                logger.log(Level.SEVERE, "Uh oh, play dirty mode isn't working.", ex);
-            } catch (IllegalArgumentException ex) {
-                logger.log(Level.SEVERE, "Uh oh, play dirty mode isn't working.", ex);
-            } catch (IllegalAccessException ex) {
-                logger.log(Level.SEVERE, "Uh oh, play dirty mode isn't working.", ex);
-            }
-        } //else play nice :(
-    }
-
-}
\ No newline at end of file
diff --git a/src/main/java/com/sk89q/commandhelper/CommandHelperPlugin.java b/src/main/java/com/sk89q/commandhelper/CommandHelperPlugin.java
deleted file mode 100644
index c69782b..0000000
--- a/src/main/java/com/sk89q/commandhelper/CommandHelperPlugin.java
+++ /dev/null
@@ -1,355 +0,0 @@
-// $Id$
-/*
- * CommandHelper
- * Copyright (C) 2010 sk89q <http://www.sk89q.com>
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program. If not, see <http://www.gnu.org/licenses/>.
-*/
-
-package com.sk89q.commandhelper;
-
-import com.laytonsmith.PureUtilities.SerializedPersistance;
-import com.laytonsmith.aliasengine.AliasCore;
-import com.laytonsmith.aliasengine.functions.exceptions.ConfigCompileException;
-import com.laytonsmith.PureUtilities.Preferences;
-import com.laytonsmith.aliasengine.Installer;
-import com.laytonsmith.aliasengine.Static;
-import com.laytonsmith.aliasengine.User;
-import com.laytonsmith.aliasengine.Version;
-import com.sk89q.bukkit.migration.PermissionsResolverManager;
-import com.sk89q.bukkit.migration.PermissionsResolverServerListener;
-import com.sk89q.worldedit.bukkit.WorldEditPlugin;
-import java.io.File;
-import java.io.IOException;
-import java.util.ArrayList;
-import java.util.HashSet;
-import java.util.Set;
-import java.util.logging.Level;
-import java.util.logging.Logger;
-import org.bukkit.ChatColor;
-import org.bukkit.Server;
-import org.bukkit.command.Command;
-import org.bukkit.command.CommandSender;
-import org.bukkit.entity.Player;
-import org.bukkit.event.Event;
-import org.bukkit.event.Listener;
-import org.bukkit.event.Event.Priority;
-import org.bukkit.plugin.Plugin;
-import org.bukkit.plugin.java.JavaPlugin;
-
-/**
- * Entry point for the plugin.
- *
- * @author sk89q
- */
-public class CommandHelperPlugin extends JavaPlugin {
-    public static final Logger logger = Logger.getLogger("Minecraft.CommandHelper");
-    private static AliasCore ac;
-    public static Server myServer;
-    public static SerializedPersistance persist;
-    public static PermissionsResolverManager perms;
-    public static Version version;
-    public static Preferences prefs;
-    public static CommandHelperPlugin self;
-    public static WorldEditPlugin wep;
-    /**
-     * Listener for the plugin system.
-     */
-    final CommandHelperListener playerListener =
-            new CommandHelperListener(this);
-    
-    /**
-     * Interpreter listener
-     */
-    final CommandHelperInterpreterListener interpreterListener = 
-            new CommandHelperInterpreterListener();
-    /**
-     * Server Command Listener, for console commands
-     */
-    final CommandHelperServerListener serverListener =
-            new CommandHelperServerListener();
-
-    final Set<Player> commandRunning = new HashSet<Player>();
-    
-    
-    @Override
-    public void onLoad(){
-        Installer.Install();
-    }
-    /**
-     * Called on plugin enable.
-     */
-    public void onEnable() {
-        self = this;
-        myServer = getServer();
-        persist = new SerializedPersistance(new File("plugins/CommandHelper/persistance.ser"), this);
-        logger.info("CommandHelper " + getDescription().getVersion() + " enabled");
-        version = new Version(getDescription().getVersion());
-        perms = new PermissionsResolverManager(getConfiguration(), getServer(),
-                getDescription().getName(), logger);
-        Plugin pwep = getServer().getPluginManager().getPlugin("WorldEdit");
-        if(pwep != null && pwep.isEnabled() && pwep instanceof WorldEditPlugin){
-            wep = (WorldEditPlugin)pwep;
-        }
-        try {
-            File prefsFile = new File("plugins/CommandHelper/preferences.txt");
-            Static.getPreferences().init(prefsFile);
-            String script_name = (String) Static.getPreferences().getPreference("script-name");
-            ac = new AliasCore(new File("plugins/CommandHelper/" + script_name), prefsFile, perms, this);
-        } catch (IOException ex) {
-            logger.log(Level.SEVERE, null, ex);
-        } catch (ConfigCompileException ex) {
-            logger.log(Level.SEVERE, null, ex);
-        }
-        playerListener.playDirty();
-        registerEvent(Event.Type.PLAYER_COMMAND_PREPROCESS, playerListener, Priority.Lowest);
-        registerEvent(Event.Type.PLAYER_QUIT, playerListener, Priority.Normal);
-        
-        //interpreter events
-        registerEvent(Event.Type.PLAYER_CHAT, interpreterListener, Priority.Lowest);
-        registerEvent(Event.Type.PLAYER_COMMAND_PREPROCESS, interpreterListener, Priority.Lowest);
-        registerEvent(Event.Type.PLAYER_QUIT, interpreterListener, Priority.Normal);
-        registerEvent(Event.Type.SERVER_COMMAND, serverListener, Priority.Lowest);
-        (new PermissionsResolverServerListener(perms)).register(this);
-        
-        playerListener.loadGlobalAliases();
-        interpreterListener.reload();
-    }
-
-    public static AliasCore getCore(){
-        return ac;
-    }
-
-    /**
-     * Disables the plugin.
-     */
-    @Override
-    public void onDisable() {
-        //free up some memory
-        ac = null;
-        wep = null;
-    }
-    
-    /**
-     * Register an event.
-     * 
-     * @param type
-     * @param listener
-     * @param priority
-     */
-    private void registerEvent(Event.Type type, Listener listener, Priority priority) {
-        getServer().getPluginManager().registerEvent(type, listener, priority, this);
-    }
-
-    /**
-     * Called when a command registered by this plugin is received.
-     */
-    @Override
-    public boolean onCommand(CommandSender sender, Command cmd, String commandLabel, String[] args) {
-        if(sender.isOp() && (cmd.getName().equals("reloadaliases") || cmd.getName().equals("reloadalias"))){
-            try {
-                if(ac.reload()){
-                    System.out.println("Command Helper scripts sucessfully recompiled.");
-                } else{
-                    System.out.println("An error occured when trying to compile the script. Check the console for more information.");
-                }
-                return true;
-            } catch (ConfigCompileException ex) {
-                logger.log(Level.SEVERE, null, ex);
-                System.out.println("An error occured when trying to compile the script. Check the console for more information.");
-                return false;
-            }
-        } else if(cmd.getName().equals("commandhelper") && args[0].equalsIgnoreCase("null")){
-            return true;
-        } else if (sender instanceof Player) {
-                return runCommand((Player)sender, cmd.getName(), args);
-        } else {
-            return false;
-        }
-    }
-    
-    /**
-     * Runs commands.
-     *
-     * @param player
-     * @param split
-     * @return
-     */
-    private boolean runCommand(final Player player, String cmd, String[] args) {
-        CommandHelperSession session = playerListener.getSession(player);
-        if(commandRunning.contains(player)){
-            return true;
-        }
-
-        commandRunning.add(player);
-        
-        // Repeat command
-        if (cmd.equals("repeat")) {
-            if(perms.hasPermission(player.getName(), "commandhelper.repeat") ||
-                    perms.hasPermission(player.getName(), "ch.repeat")){
-                //Go ahead and remove them, so that they can repeat aliases. They can't get stuck in
-                //an infinite loop though, because the preprocessor won't try to fire off a repeat command
-                commandRunning.remove(player);
-                if (session.getLastCommand() != null) {
-                    Static.SendMessage(player, ChatColor.GRAY + session.getLastCommand());
-                    execCommand(player, session.getLastCommand());
-                } else {
-                    Static.SendMessage(player, ChatColor.RED + "No previous command.");
-                }
-                return true;
-            } else {
-                Static.SendMessage(player, ChatColor.RED + "You do not have permission to access the repeat command");
-                commandRunning.remove(player);
-                return true;
-            }
-    
-        // Save alias
-        } else if (cmd.equalsIgnoreCase("alias") || cmd.equalsIgnoreCase("commandhelper")
-                /*&& player.canUseCommand("/alias")*/) {
-            if(!perms.hasPermission(player.getName(), "commandhelper.useralias") && !perms.hasPermission(player.getName(), "ch.useralias")){
-                Static.SendMessage(player, ChatColor.RED + "You do not have permission to access the alias command");
-                commandRunning.remove(player);
-                return true;
-            }
-            if(args.length > 0){
-
-                String alias = CommandHelperPlugin.joinString(args, " ");
-                try {
-                    User u = new User(player, persist);
-                    //AliasConfig uac = new AliasConfig(alias, u, perms);
-                    //MScriptCompiler.compile(MScriptCompiler.preprocess(MScriptCompiler.lex(alias)));
-                    //TODO: Finish this
-                    int id = u.addAlias(alias);
-                    if(id > -1){
-                        Static.SendMessage(player, ChatColor.YELLOW + "Alias added with id '" + id + "'");
-                    }
-                } catch (/*ConfigCompile*/Exception ex) {
-                    Static.SendMessage(player, ChatColor.RED + ex.getMessage());
-                }
-            } else{
-                //Display a help message
-                Static.SendMessage(player, ChatColor.GREEN + "Command usage: \n"
-                        + ChatColor.GREEN + "/alias <alias> - adds an alias to your user defined list\n"
-                        + ChatColor.GREEN + "/delalias <id> - deletes alias with id <id> from your user defined list\n"
-                        + ChatColor.GREEN + "/viewalias - shows you all of your aliases");
-            }
-
-            commandRunning.remove(player);
-            return true;
-        //View all aliases for this user
-        } else if(cmd.equalsIgnoreCase("viewalias")){
-            if(!perms.hasPermission(player.getName(), "commandhelper.useralias") && !perms.hasPermission(player.getName(), "ch.useralias")){
-                Static.SendMessage(player, ChatColor.RED + "You do not have permission to access the viewalias command");
-                commandRunning.remove(player);
-                return true;
-            }
-            User u = new User(player, persist);
-            Static.SendMessage(player, u.getAllAliases());
-            commandRunning.remove(player);
-            return true;
-        // Delete alias
-        } else if (cmd.equalsIgnoreCase("delalias")) {
-            if(!perms.hasPermission(player.getName(), "commandhelper.useralias") && !perms.hasPermission(player.getName(), "ch.useralias")){
-                Static.SendMessage(player, ChatColor.RED + "You do not have permission to access the delalias command");
-                commandRunning.remove(player);
-                return true;
-            }
-            User u = new User(player, persist);
-            try{
-                ArrayList<String> deleted = new ArrayList<String>();
-                for(int i = 0; i < args.length; i++){
-                    u.removeAlias(Integer.parseInt(args[i]));
-                    deleted.add("#" + args[i]);
-                }
-                if(args.length > 1){
-                    String s = ChatColor.YELLOW + "Aliases " + deleted.toString() + " were deleted";
-                    Static.SendMessage(player, s);
-
-                } else{
-                    Static.SendMessage(player, ChatColor.YELLOW + "Alias #" + args[0] + "was deleted");
-                }
-            } catch(NumberFormatException e){
-                Static.SendMessage(player, ChatColor.RED + "The id must be a number");
-            } catch(ArrayIndexOutOfBoundsException e){
-                Static.SendMessage(player, ChatColor.RED + "Usage: /delalias <id> <id> ...");
-            }
-            commandRunning.remove(player);
-            return true;
-    
-        // Reload global aliases
-        } else if (cmd.equalsIgnoreCase("reloadaliases")) {
-            if(!perms.hasPermission(player.getName(), "commandhelper.reloadaliases") && !perms.hasPermission(player.getName(), "ch.reloadaliases")){
-                Static.SendMessage(player, ChatColor.DARK_RED + "You do not have permission to use that command");
-                commandRunning.remove(player);
-                return true;
-            }
-            try {
-                if(ac.reload()){
-                    Static.SendMessage(player, "Command Helper scripts sucessfully recompiled.");
-                } else{
-                    Static.SendMessage(player, "An error occured when trying to compile the script. Check the console for more information.");
-                }
-                commandRunning.remove(player);
-                return true;
-            } catch (ConfigCompileException ex) {
-                logger.log(Level.SEVERE, null, ex);
-                Static.SendMessage(player, "An error occured when trying to compile the script. Check the console for more information.");
-            }
-        } else if(cmd.equalsIgnoreCase("interpreter")){
-            if(perms.hasPermission(player.getName(), "commandhelper.interpreter")){
-                if((Boolean)Static.getPreferences().getPreference("enable-interpreter")){
-                    interpreterListener.startInterpret(player.getName());
-                    Static.SendMessage(player, ChatColor.YELLOW + "You are now in interpreter mode. Type a dash (-) on a line by itself to exit, and >>> to enter"
-                            + " multiline mode.");
-                } else {
-                    Static.SendMessage(player, ChatColor.RED + "The interpreter is currently disabled. Check your preferences file.");
-                }
-            } else {
-                Static.SendMessage(player, ChatColor.RED + "You do not have permission to run that command");
-            }
-            commandRunning.remove(player);
-            return true;
-        }
-        commandRunning.remove(player);
-        return false;
-    }
-
-    /**
-     * Joins a string from an array of strings.
-     *
-     * @param str
-     * @param delimiter
-     * @return
-     */
-    public static String joinString(String[] str, String delimiter) {
-        if (str.length == 0) {
-            return "";
-        }
-        StringBuilder buffer = new StringBuilder(str[0]);
-        for (int i = 1; i < str.length; i++) {
-            buffer.append(delimiter).append(str[i]);
-        }
-        return buffer.toString();
-    }
-    
-    /**
-     * Execute a command.
-     * @param player 
-     *
-     * @param cmd
-     */
-    public static void execCommand(Player player, String cmd) {
-        player.chat(cmd);
-    }
-}
diff --git a/src/main/java/com/sk89q/commandhelper/CommandHelperServerListener.java b/src/main/java/com/sk89q/commandhelper/CommandHelperServerListener.java
deleted file mode 100644
index 92d3f23..0000000
--- a/src/main/java/com/sk89q/commandhelper/CommandHelperServerListener.java
+++ /dev/null
@@ -1,47 +0,0 @@
-/*
- * To change this template, choose Tools | Templates
- * and open the template in the editor.
- */
-package com.sk89q.commandhelper;
-
-import com.laytonsmith.aliasengine.InternalException;
-import com.laytonsmith.aliasengine.Script;
-import com.laytonsmith.aliasengine.Static;
-import com.laytonsmith.aliasengine.functions.exceptions.ConfigRuntimeException;
-import java.util.ArrayList;
-import java.util.logging.Level;
-import org.bukkit.ChatColor;
-import org.bukkit.command.CommandSender;
-import org.bukkit.event.server.ServerCommandEvent;
-import org.bukkit.event.server.ServerListener;
-
-/**
- *
- * @author Layton
- */
-public class CommandHelperServerListener extends ServerListener{
-    
-    @Override
-    public void onServerCommand(ServerCommandEvent event){
-        CommandSender player = event.getSender();
-        boolean match = false;
-        try {
-            match = Static.getAliasCore().alias("/" + event.getCommand(), player, new ArrayList<Script>());
-        } catch (InternalException e) {
-            Static.getLogger().log(Level.SEVERE, e.getMessage());
-        } catch (ConfigRuntimeException e) {
-            Static.getLogger().log(Level.WARNING, e.getMessage());
-        } catch (Throwable e) {
-            player.sendMessage(ChatColor.RED + "Command failed with following reason: " + e.getMessage());
-            //Obviously the command is registered, but it somehow failed. Cancel the event.
-            e.printStackTrace();
-            return;
-        }
-        //To prevent "unknown console command" error, set the command to the meta command
-        //commandhelper null, which just returns true.
-        if(match){
-            event.setCommand("commandhelper null");
-        }
-    }
-    
-}
diff --git a/src/main/java/com/sk89q/commandhelper/CommandHelperSession.java b/src/main/java/com/sk89q/commandhelper/CommandHelperSession.java
deleted file mode 100644
index 55f0d04..0000000
--- a/src/main/java/com/sk89q/commandhelper/CommandHelperSession.java
+++ /dev/null
@@ -1,260 +0,0 @@
-// $Id$
-/*
- * CommandHelper
- * Copyright (C) 2010 sk89q <http://www.sk89q.com>
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program. If not, see <http://www.gnu.org/licenses/>.
-*/
-
-package com.sk89q.commandhelper;
-
-import java.util.logging.Logger;
-import java.util.logging.Level;
-import java.util.List;
-import java.util.ArrayList;
-import java.util.Map;
-import java.util.HashMap;
-import java.io.*;
-import org.bukkit.entity.Player;
-
-/**
- * Command history, etc.
- *
- * @author sk89q
- */
-public class CommandHelperSession {
-    /**
-     * Logger.
-     */
-    private static final Logger logger = Logger.getLogger("Minecraft");
-    
-    /**
-     * Player name.
-     */
-    private String name;
-    /**
-     * Last command used.
-     */
-    private String lastCommand;
-    /**
-     * List of aliases.
-     */
-    private Map<Player,String[]> aliases =
-            new HashMap<Player,String[]>();
-
-    Map<Player, String[]> getAliases(){
-        return aliases;
-    }
-
-    /**
-     * Construct the instance.
-     * 
-     * @param name
-     */
-    public CommandHelperSession(String name) {
-        this.name = name;
-        loadAliases();
-    }
-
-    /**
-     * @return the last command
-     */
-    public String getLastCommand() {
-        return lastCommand;
-    }
-
-    /**
-     * @param lastCommand the last command to set
-     */
-    public void setLastCommand(String lastCommand) {
-        this.lastCommand = lastCommand;
-    }
-
-    /**
-     * Find an alias. May return null.
-     * 
-     * @param command
-     * @return
-     */
-    public String[] findAlias(String command) {
-        return aliases.get(command.toLowerCase());
-    }
-
-    /**
-     * Set an alias.
-     * 
-     * @param command
-     * @param commands 
-     */
-    public void setAlias(Player player, String[] commands) {
-        aliases.put(player, commands);
-    }
-
-    /**
-     * Remove an alias.
-     * 
-     * @param command
-     */
-    public void removeAlias(String command) {
-        aliases.remove(command.toLowerCase());
-    }
-
-    /**
-     * Returns true if the player's name is valid.
-     * 
-     * @return
-     */
-    private boolean isValidName() {
-        if (name.length() < 1 || name.length() > 40) {
-            return false;
-        }
-        if (name.matches("[^abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789_]")) {
-            return false;
-        }
-        return true;
-    }
-
-    /**
-     * Load aliases.
-     */
-    public void loadAliases() {
-        if (!isValidName()) { return; }
-        aliases = readAliases("aliases" + File.separator + name + ".txt");
-    }
-
-    /**
-     * Save aliases.
-     */
-    public void saveAliases() {
-        if (!isValidName()) { return; }
-        writeAliases("aliases" + File.separator + name + ".txt", aliases);
-    }
-
-    /**
-     * Read a file containing cauldron recipes.
-     *
-     * @param path
-     * @return
-     */
-    public static Map<Player,String[]> readAliases(String path) {
-        File file = new File(path);
-        FileReader input = null;
-        Map<String,List<String>> aliases = new HashMap<String,List<String>>();
-        String alias = null;
-
-        try {
-            input = new FileReader(file);
-            BufferedReader buff = new BufferedReader(input);
-
-            String line;
-            while ((line = buff.readLine()) != null) {
-                line = line.trim();
-
-                // Blank lines
-                if (line.length() == 0) {
-                    continue;
-                }
-
-                // Comment
-                if (line.charAt(0) == ';' || line.charAt(0) == '#' || line.equals("")) {
-                    continue;
-                }
-
-                // Alias
-                if (line.charAt(0) == ':') {
-                    alias = line.substring(1).toLowerCase();
-
-                // Alias contents
-                } else if (alias == null) {
-                    logger.log(Level.WARNING, "Alias command '" + line
-                            + "' not under any alias");
-                } else {
-                    List<String> commands;
-                    if (!aliases.containsKey(alias)) {
-                        commands = new ArrayList<String>();
-                        aliases.put(alias, commands);
-                    } else {
-                        commands = aliases.get(alias);
-                    }
-                    commands.add(line);
-                }
-            }
-
-            Map<Player,String[]> outAliases = new HashMap<Player,String[]>();
-
-            for (Map.Entry<String,List<String>> entry : aliases.entrySet()) {
-                outAliases.put(CommandHelperPlugin.myServer.getPlayer(entry.getKey()), entry.getValue().toArray(new String[]{}));
-            }
-
-            return outAliases;
-        } catch (FileNotFoundException e) {
-            return new HashMap<Player, String[]>();
-        } catch (IOException e) {
-            logger.log(Level.WARNING, "Failed to load aliases: "
-                    + e.getMessage());
-            return new HashMap<Player, String[]>();
-        } finally {
-            try {
-                if (input != null) {
-                    input.close();
-                }
-            } catch (IOException e2) {
-            }
-        }
-    }
-
-    /**
-     * Write aliases to file.
-     * 
-     * @param path
-     * @param aliases
-     */
-    public static void writeAliases(String path, Map<Player,String[]> aliases) {
-        File file = new File(path);
-        FileWriter output = null;
-
-        // Make parent directory
-        String parentPath = file.getParent();
-        if (parentPath != null) {
-            (new File(parentPath)).mkdirs();
-        }
-
-        try {
-            output = new FileWriter(file);
-            BufferedWriter buff = new BufferedWriter(output);
-            buff.write("# Generated automatically\r\n");
-            buff.write("# Manual changes will likely be overwritten\r\n");
-
-            for (Map.Entry<Player,String[]> entry : aliases.entrySet()) {
-                buff.write(":" + entry.getKey() + "\r\n");
-
-                for (String command : entry.getValue()) {
-                    buff.write(command + "\r\n");
-                }
-            }
-
-            buff.close();            
-        } catch (IOException e) {
-            logger.log(Level.WARNING, "Failed to write aliases: "
-                    + e.getMessage());
-        } finally {
-            try {
-                if (output != null) {
-                    output.close();
-                }
-            } catch (IOException e2) {
-            }
-        }
-    }
-}
diff --git a/src/main/resources/data_values.txt b/src/main/resources/data_values.txt
new file mode 100644
index 0000000..2d64516
--- /dev/null
+++ b/src/main/resources/data_values.txt
@@ -0,0 +1,2571 @@
+stone=1:0
+sstone=1:0
+smoothstone=1:0
+rock=1:0
+grass=2:0
+grassblock=2:0
+grassb=2:0
+dirt=3:0
+cobblestone=4:0
+cstone=4:0
+cobble=4:0
+plank=5:0
+woodenplank=5:0
+woodplank=5:0
+wplank=5:0
+plankwooden=5:0
+plankwood=5:0
+plankw=5:0
+sapling=6:0
+treesapling=6:0
+logsapling=6:0
+trunksapling=6:0
+woodsapling=6:0
+oaktreesapling=6:0
+oaklogsapling=6:0
+oaktrunksapling=6:0
+oakwoodsapling=6:0
+normaltreesapling=6:0
+normallogsapling=6:0
+normaltrunksapling=6:0
+normalwoodsapling=6:0
+osapling=6:0
+otreesapling=6:0
+ologsapling=6:0
+otrunksapling=6:0
+owoodsapling=6:0
+nsapling=6:0
+ntreesapling=6:0
+nlogsapling=6:0
+ntrunksapling=6:0
+nwoodsapling=6:0
+treesap=6:0
+logsap=6:0
+trunksap=6:0
+woodsap=6:0
+oaktreesap=6:0
+oaklogsap=6:0
+oaktrunksap=6:0
+oakwoodsap=6:0
+normaltreesap=6:0
+normallogsap=6:0
+normaltrunksap=6:0
+normalwoodsap=6:0
+osap=6:0
+otreesap=6:0
+ologsap=6:0
+otrunksap=6:0
+owoodsap=6:0
+nsap=6:0
+ntreesap=6:0
+nlogsap=6:0
+ntrunksap=6:0
+nwoodsap=6:0
+redsapling=6:1
+redtreesapling=6:1
+redlogsapling=6:1
+redtrunksapling=6:1
+redwoodsapling=6:1
+darksapling=6:1
+darktreesapling=6:1
+darklogsapling=6:1
+darktrunksapling=6:1
+darkwoodsapling=6:1
+blacksapling=6:1
+blacktreesapling=6:1
+blacklogsapling=6:1
+blacktrunksapling=6:1
+blackwoodsapling=6:1
+pinesapling=6:1
+pinetreesapling=6:1
+pinelogsapling=6:1
+pinetrunksapling=6:1
+pinewoodsapling=6:1
+sprucesapling=6:1
+sprucetreesapling=6:1
+sprucelogsapling=6:1
+sprucetrunksapling=6:1
+sprucewoodsapling=6:1
+rsapling=6:1
+rtreesapling=6:1
+rlogsapling=6:1
+rtrunksapling=6:1
+rwoodsapling=6:1
+dsapling=6:1
+dtreesapling=6:1
+dlogsapling=6:1
+dtrunksapling=6:1
+dwoodsapling=6:1
+blsapling=6:1
+bltreesapling=6:1
+bllogsapling=6:1
+bltrunksapling=6:1
+blwoodsapling=6:1
+psapling=6:1
+ptreesapling=6:1
+plogsapling=6:1
+ptrunksapling=6:1
+pwoodsapling=6:1
+ssapling=6:1
+streesapling=6:1
+slogsapling=6:1
+strunksapling=6:1
+swoodsapling=6:1
+redsap=6:1
+redtreesap=6:1
+redlogsap=6:1
+redtrunksap=6:1
+redwoodsap=6:1
+darksap=6:1
+darktreesap=6:1
+darklogsap=6:1
+darktrunksap=6:1
+darkwoodsap=6:1
+blacksap=6:1
+blacktreesap=6:1
+blacklogsap=6:1
+blacktrunksap=6:1
+blackwoodsap=6:1
+pinesap=6:1
+pinetreesap=6:1
+pinelogsap=6:1
+pinetrunksap=6:1
+pinewoodsap=6:1
+sprucesap=6:1
+sprucetreesap=6:1
+sprucelogsap=6:1
+sprucetrunksap=6:1
+sprucewoodsap=6:1
+rsap=6:1
+rtreesap=6:1
+rlogsap=6:1
+rtrunksap=6:1
+rwoodsap=6:1
+dsap=6:1
+dtreesap=6:1
+dlogsap=6:1
+dtrunksap=6:1
+dwoodsap=6:1
+blsap=6:1
+bltreesap=6:1
+bllogsap=6:1
+bltrunksap=6:1
+blwoodsap=6:1
+psap=6:1
+ptreesap=6:1
+plogsap=6:1
+ptrunksap=6:1
+pwoodsap=6:1
+ssap=6:1
+streesap=6:1
+slogsap=6:1
+strunksap=6:1
+swoodsap=6:1
+birchsapling=6:2
+birchtreesapling=6:2
+birchlogsapling=6:2
+birchtrunksapling=6:2
+birchwoodsapling=6:2
+pandasapling=6:2
+pandatreesapling=6:2
+pandalogsapling=6:2
+pandatrunksapling=6:2
+pandawoodsapling=6:2
+whitesapling=6:2
+whitetreesapling=6:2
+whitelogsapling=6:2
+whitetrunksapling=6:2
+whitewoodsapling=6:2
+bisapling=6:2
+bitreesapling=6:2
+bilogsapling=6:2
+bitrunksapling=6:2
+biwoodsapling=6:2
+bsapling=6:2
+btreesapling=6:2
+blogsapling=6:2
+btrunksapling=6:2
+bwoodsapling=6:2
+pasapling=6:2
+patreesapling=6:2
+palogsapling=6:2
+patrunksapling=6:2
+pawoodsapling=6:2
+wsapling=6:2
+wtreesapling=6:2
+wlogsapling=6:2
+wtrunksapling=6:2
+wwoodsapling=6:2
+birchsap=6:2
+birchtreesap=6:2
+birchlogsap=6:2
+birchtrunksap=6:2
+birchwoodsap=6:2
+pandasap=6:2
+pandatreesap=6:2
+pandalogsap=6:2
+pandatrunksap=6:2
+pandawoodsap=6:2
+whitesap=6:2
+whitetreesap=6:2
+whitelogsap=6:2
+whitetrunksap=6:2
+whitewoodsap=6:2
+bisap=6:2
+bitreesap=6:2
+bilogsap=6:2
+bitrunksap=6:2
+biwoodsap=6:2
+bsap=6:2
+btreesap=6:2
+blogsap=6:2
+btrunksap=6:2
+bwoodsap=6:2
+pasap=6:2
+patreesap=6:2
+palogsap=6:2
+patrunksap=6:2
+pawoodsap=6:2
+wsap=6:2
+wtreesap=6:2
+wlogsap=6:2
+wtrunksap=6:2
+wwoodsap=6:2
+bedrock=7:0
+oprock=7:0
+opblock=7:0
+adminblock=7:0
+adminrock=7:0
+adminium=7:0
+water=8:0
+stationarywater=9:0
+swater=9:0
+lava=10:0
+stationarylava=11:0
+slava=11:0
+sand=12:0
+gravel=13:0
+goldore=14:0
+oregold=14:0
+goldo=14:0
+ogold=14:0
+gore=14:0
+oreg=14:0
+ironore=15:0
+oreiron=15:0
+irono=15:0
+oiron=15:0
+steelore=15:0
+oresteel=15:0
+steelo=15:0
+osteel=15:0
+iore=15:0
+orei=15:0
+sore=15:0
+ores=15:0
+coalore=16:0
+orecoal=16:0
+coalo=16:0
+ocoal=16:0
+core=16:0
+wood=17:0
+tree=17:0
+log=17:0
+trunk=17:0
+oaktree=17:0
+oaklog=17:0
+oaktrunk=17:0
+oakwood=17:0
+normaltree=17:0
+normallog=17:0
+normaltrunk=17:0
+normalwood=17:0
+otree=17:0
+olog=17:0
+otrunk=17:0
+owood=17:0
+ntree=17:0
+nlog=17:0
+ntrunk=17:0
+nwood=17:0
+redtree=17:1
+redlog=17:1
+redtrunk=17:1
+redwood=17:1
+darktree=17:1
+darklog=17:1
+darktrunk=17:1
+darkwood=17:1
+blacktree=17:1
+blacklog=17:1
+blacktrunk=17:1
+blackwood=17:1
+pine=17:1
+pinetree=17:1
+pinelog=17:1
+pinetrunk=17:1
+pinewood=17:1
+spruce=17:1
+sprucetree=17:1
+sprucelog=17:1
+sprucetrunk=17:1
+sprucewood=17:1
+rtree=17:1
+rlog=17:1
+rtrunk=17:1
+rwood=17:1
+dtree=17:1
+dlog=17:1
+dtrunk=17:1
+dwood=17:1
+bltree=17:1
+bllog=17:1
+bltrunk=17:1
+blwood=17:1
+ptree=17:1
+plog=17:1
+ptrunk=17:1
+pwood=17:1
+stree=17:1
+slog=17:1
+strunk=17:1
+swood=17:1
+birch=17:2
+birchtree=17:2
+birchlog=17:2
+birchtrunk=17:2
+birchwood=17:2
+pandatree=17:2
+pandalog=17:2
+pandatrunk=17:2
+pandawood=17:2
+whitetree=17:2
+whitelog=17:2
+whitetrunk=17:2
+whitewood=17:2
+bitree=17:2
+bilog=17:2
+bitrunk=17:2
+biwood=17:2
+btree=17:2
+blog=17:2
+btrunk=17:2
+bwood=17:2
+patree=17:2
+palog=17:2
+patrunk=17:2
+pawood=17:2
+wtree=17:2
+wlog=17:2
+wtrunk=17:2
+wwood=17:2
+leaves=18:4
+leaf=18:4
+treeleaves=18:4
+logleaves=18:4
+trunkleaves=18:4
+woodleaves=18:4
+oaktreeleaves=18:4
+oaklogleaves=18:4
+oaktrunkleaves=18:4
+oakwoodleaves=18:4
+normaltreeleaves=18:4
+normallogleaves=18:4
+normaltrunkleaves=18:4
+normalwoodleaves=18:4
+otreeleaves=18:4
+ologleaves=18:4
+otrunkleaves=18:4
+owoodleaves=18:4
+ntreeleaves=18:4
+nlogleaves=18:4
+ntrunkleaves=18:4
+nwoodleaves=18:4
+treeleaf=18:4
+logleaf=18:4
+trunkleaf=18:4
+woodleaf=18:4
+oaktreeleaf=18:4
+oaklogleaf=18:4
+oaktrunkleaf=18:4
+oakwoodleaf=18:4
+normaltreeleaf=18:4
+normallogleaf=18:4
+normaltrunkleaf=18:4
+normalwoodleaf=18:4
+otreeleaf=18:4
+ologleaf=18:4
+otrunkleaf=18:4
+owoodleaf=18:4
+ntreeleaf=18:4
+nlogleaf=18:4
+ntrunkleaf=18:4
+nwoodleaf=18:4
+pineleaves=18:5
+pineleaf=18:5
+pinetreeleaves=18:5
+pinelogleaves=18:5
+pinetrunkleaves=18:5
+pinewoodleaves=18:5
+ptreeleaves=18:5
+plogleaves=18:5
+ptrunkleaves=18:5
+pwoodleaves=18:5
+pitreeleaves=18:5
+pilogleaves=18:5
+pitrunkleaves=18:5
+piwoodleaves=18:5
+pinetreeleaf=18:5
+pinelogleaf=18:5
+pinetrunkleaf=18:5
+pinewoodleaf=18:5
+ptreeleaf=18:5
+plogleaf=18:5
+ptrunkleaf=18:5
+pwoodleaf=18:5
+pitreeleaf=18:5
+pilogleaf=18:5
+pitrunkleaf=18:5
+piwoodleaf=18:5
+birchleaves=18:6
+birchleaf=18:6
+birchtreeleaves=18:6
+birchlogleaves=18:6
+birchtrunkleaves=18:6
+birchwoodleaves=18:6
+btreeleaves=18:6
+blogleaves=18:6
+btrunkleaves=18:6
+bwoodleaves=18:6
+bitreeleaves=18:6
+bilogleaves=18:6
+bitrunkleaves=18:6
+biwoodleaves=18:6
+birchtreeleaf=18:6
+birchlogleaf=18:6
+birchtrunkleaf=18:6
+birchwoodleaf=18:6
+btreeleaf=18:6
+blogleaf=18:6
+btrunkleaf=18:6
+bwoodleaf=18:6
+bitreeleaf=18:6
+bilogleaf=18:6
+bitrunkleaf=18:6
+biwoodleaf=18:6
+sponge=19:0
+glass=20:0
+lapislazuliore=21:0
+lapislazulio=21:0
+orelapislazuli=21:0
+olapislazuli=21:0
+lapisore=21:0
+lapiso=21:0
+orelapis=21:0
+olapis=21:0
+lore=21:0
+orel=21:0
+lapislazuliblock=22:0
+blocklapislazuli=22:0
+lapisblock=22:0
+blocklapis=22:0
+lblock=22:0
+blockl=22:9
+dispenser=23:0
+dispense=23:0
+sandstone=24:0
+sastone=24:0
+noteblock=25:0
+musicblock=25:0
+nblock=25:0
+mblock=25:0
+bedblock=26:0
+poweredtrack=27:0
+poweredrail=27:0
+boostertrack=27:0
+boosterrail=27:0
+powertrack=27:0
+powerrail=27:0
+boosttrack=27:0
+boostrail=27:0
+ptrack=27:0
+prail=27:0
+btrack=27:0
+brail=27:0
+detectortrack=28:0
+detectorrail=28:0
+detectingtrack=28:0
+detectingrail=28:0
+detecttrack=28:0
+detectrail=28:0
+dtrack=28:0
+drail=28:0
+stickypistonbase=29:7
+stickypiston=29:7
+stickpistonbase=29:7
+stickpiston=29:7
+stickyp=29:7
+spistonbase=29:7
+spiston=29:7
+pistonstickybase=29:7
+pistonsticky=29:7
+pistonstickbase=29:7
+pistonstick=29:7
+pistonsbase=29:7
+pistons=29:7
+psticky=29:7
+cobweb=30:0
+spiderweb=30:0
+sweb=30:0
+web=30:0
+shrub=31:0
+longgrass=31:1
+tallgrass=31:1
+wildgrass=31:1
+grasslong=31:1
+grasstall=31:1
+grasswild=31:1
+lgrass=31:1
+tgrass=31:1
+wgrass=31:1
+grassl=31:1
+grasst=31:1
+grassw=31:1
+fern=31:2
+deadshrub=32:0
+shrubdead=32:0
+deadbush=32:0
+bushdead=32:0
+dshrub=32:0
+shrubd=32:0
+piston=33:7
+normalpistonbase=33:7
+normalpiston=33:7
+normpistonbase=33:7
+normpiston=33:7
+npistonbase=33:7
+npiston=33:7
+pistonnormalbase=33:7
+pistonnormal=33:7
+pistonnormbase=33:7
+pistonnorm=33:7
+pistonnbase=33:7
+pistonn=33:7
+pistonbase=33:7
+pistonblock=33:7
+pistonextensionnormal=34:0
+pistonextensionnorm=34:0
+pistonextensionn=34:0
+pistonextension=34:0
+pistonextnormal=34:0
+pistonextnorm=34:0
+pistonextn=34:0
+pistonext=34:0
+pistonenormal=34:0
+pistonenorm=34:0
+pistonen=34:0
+pistone=34:0
+extensionpistonnormal=34:0
+extensionpistonnorm=34:0
+extensionpistonn=34:0
+extensionpiston=34:0
+extpistonnormal=34:0
+extpistonnorm=34:0
+extpistonn=34:0
+extpiston=34:0
+epistonnormal=34:0
+epistonnorm=34:0
+epistonn=34:0
+episton=34:0
+wool=35:0
+whitecloth=35:0
+whitewool=35:0
+whitecotton=35:0
+wcloth=35:0
+wwool=35:0
+wcotton=35:0
+cloth=35:0
+cotton=35:0
+orangecloth=35:1
+orangewool=35:1
+orangecotton=35:1
+ocloth=35:1
+owool=35:1
+ocotton=35:1
+magentacloth=35:2
+magentawool=35:2
+magentacotton=35:2
+mcloth=35:2
+mwool=35:2
+mcotton=35:2
+lightbluecloth=35:3
+lightbluewool=35:3
+lightbluecotton=35:3
+lbluecloth=35:3
+lbluewool=35:3
+lbluecotton=35:3
+lightblucloth=35:3
+lightbluwool=35:3
+lightblucotton=35:3
+lblucloth=35:3
+lbluwool=35:3
+lblucotton=35:3
+yellowcloth=35:4
+yellowwool=35:4
+yellowcotton=35:4
+ycloth=35:4
+ywool=35:4
+ycotton=35:4
+limecloth=35:5
+limewool=35:5
+limecotton=35:5
+lightgreencloth=35:5
+lightgreenwool=35:5
+lightgreencotton=35:5
+lgreencloth=35:5
+lgreenwool=35:5
+lgreencotton=35:5
+lightgrecloth=35:5
+lightgrewool=35:5
+lightgrecotton=35:5
+lgrecloth=35:5
+lgrewool=35:5
+lgrecotton=35:5
+pinkcloth=35:6
+pinkwool=35:6
+pinkcotton=35:6
+picloth=35:6
+piwool=35:6
+picotton=35:6
+graycloth=35:7
+graywool=35:7
+graycotton=35:7
+gracloth=35:7
+grawool=35:7
+gracotton=35:7
+lightgraycloth=35:8
+lightgraywool=35:8
+lightgraycotton=35:8
+lgraycloth=35:8
+lgraywool=35:8
+lgraycotton=35:8
+lightgracloth=35:8
+lightgrawool=35:8
+lightgracotton=35:8
+lgracloth=35:8
+lgrawool=35:8
+lgracotton=35:8
+cyancloth=35:9
+cyanwool=35:9
+cyancotton=35:9
+ccloth=35:9
+cwool=35:9
+ccotton=35:9
+purplecloth=35:10
+purplewool=35:10
+purplecotton=35:10
+pucloth=35:10
+puwool=35:10
+pucotton=35:10
+bluecloth=35:11
+bluewool=35:11
+bluecotton=35:11
+blucloth=35:11
+bluwool=35:11
+blucotton=35:11
+browncloth=35:12
+brownwool=35:12
+browncotton=35:12
+brocloth=35:12
+browool=35:12
+brocotton=35:12
+darkgreencloth=35:13
+darkgreenwool=35:13
+darkgreencotton=35:13
+dgreencloth=35:13
+dgreenwool=35:13
+dgreencotton=35:13
+greencloth=35:13
+greenwool=35:13
+greencotton=35:13
+darkgrecloth=35:13
+darkgrewool=35:13
+darkgrecotton=35:13
+dgrecloth=35:13
+dgrewool=35:13
+dgrecotton=35:13
+grecloth=35:13
+grewool=35:13
+grecotton=35:13
+redcloth=35:14
+redwool=35:14
+redcotton=35:14
+rcloth=35:14
+rwool=35:14
+rcotton=35:14
+blackcloth=35:15
+blackwool=35:15
+blackcotton=35:15
+blacloth=35:15
+blawool=35:15
+blacotton=35:15
+pistonmovingpiece=36:0
+pistonmp=36:0
+flower=37:0
+yellowflower=37:0
+yflower=37:0
+rose=38:0
+redrose=38:0
+rrose=38:0
+redflower=38:0
+rflower=38:0
+brownmushroom=39:0
+brownmush=39:0
+bmushroom=39:0
+bmush=39:0
+redmushroom=40:0
+redmush=40:0
+rmushroom=40:0
+rmush=40:0
+goldblock=41:0
+blockgold=41:0
+gblock=41:0
+blockg=41:0
+ironblock=42:0
+steelblock=42:0
+blockiron=42:0
+blocksteel=42:0
+iblock=42:0
+stblock=42:0
+blocki=42:0
+blockst=42:0
+smoothstonedoublestep=43:0
+smoothstonedstep=43:0
+stonedoublestep=43:0
+stonedstep=43:0
+sdoublestep=43:0
+sdstep=43:0
+doublesmoothstonestep=43:0
+dsmoothstonestep=43:0
+doublestonestep=43:0
+dstonestep=43:0
+doublesstep=43:0
+doublestep=43:0
+dstep=43:0
+smoothstonedoubleslab=43:0
+smoothstonedslab=43:0
+stonedoubleslab=43:0
+stonedslab=43:0
+sdoubleslab=43:0
+sdslab=43:0
+doublesmoothstoneslab=43:0
+dsmoothstoneslab=43:0
+doublestoneslab=43:0
+dstoneslab=43:0
+doublesslab=43:0
+doubleslab=43:0
+dslab=43:0
+sandstonedoublestep=43:1
+sandstonedstep=43:1
+sstonedoublestep=43:1
+sstonedstep=43:1
+ssdoublestep=43:1
+ssdstep=43:1
+doublesandstonestep=43:1
+dsandstonestep=43:1
+doublesstonestep=43:1
+dsstonestep=43:1
+doublessstep=43:1
+dsstep=43:1
+sandstonedoubleslab=43:1
+sandstonedslab=43:1
+sstonedoubleslab=43:1
+sstonedslab=43:1
+ssdoubleslab=43:1
+ssdslab=43:1
+doublesandstoneslab=43:1
+dsandstoneslab=43:1
+doublesstoneslab=43:1
+dsstoneslab=43:1
+doublessslab=43:1
+dsslab=43:1
+woodenplankdoublestep=43:2
+woodenplankdstep=43:2
+woodplankdoublestep=43:2
+woodplankdstep=43:2
+wplankdoublestep=43:2
+wplankdstep=43:2
+plankdoublestep=43:2
+plankdstep=43:2
+wpdoublestep=43:2
+pdoublestep=43:2
+wpdstep=43:2
+pdstep=43:2
+doublewoodenplankstep=43:2
+dwoodenplankstep=43:2
+doublewoodplankstep=43:2
+dwoodplankstep=43:2
+doublewplankstep=43:2
+dwplankstep=43:2
+doubleplankstep=43:2
+dplankstep=43:2
+doublewpstep=43:2
+dwpstep=43:2
+doublepstep=43:2
+dpstep=43:2
+woodenplankdoubleslab=43:2
+woodenplankdslab=43:2
+woodplankdoubleslab=43:2
+woodplankdslab=43:2
+wplankdoubleslab=43:2
+wplankdslab=43:2
+plankdoubleslab=43:2
+plankdslab=43:2
+wpdoubleslab=43:2
+pdoubleslab=43:2
+wpdslab=43:2
+pdslab=43:2
+doublewoodenplankslab=43:2
+dwoodenplankslab=43:2
+doublewoodplankslab=43:2
+dwoodplankslab=43:2
+doublewplankslab=43:2
+dwplankslab=43:2
+doubleplankslab=43:2
+dplankslab=43:2
+doublewpslab=43:2
+dwpslab=43:2
+doublepslab=43:2
+dpslab=43:2
+cobblestonedoublestep=43:3
+cobblestonedstep=43:3
+cobbledoublestep=43:3
+cobbledstep=43:3
+cstonedoublestep=43:3
+cstonedstep=43:3
+csdoublestep=43:3
+csdstep=43:3
+doublecobblestonestep=43:3
+dcobblestonestep=43:3
+doublecobblestep=43:3
+dcobblestep=43:3
+doublecstonestep=43:3
+dcstonestep=43:3
+doublecsstep=43:3
+dcsstep=43:3
+cobblestonedoubleslab=43:3
+cobblestonedslab=43:3
+cobbledoubleslab=43:3
+cobbledslab=43:3
+cstonedoubleslab=43:3
+cstonedslab=43:3
+csdoubleslab=43:3
+csdslab=43:3
+doublecobblestoneslab=43:3
+dcobblestoneslab=43:3
+doublecobbleslab=43:3
+dcobbleslab=43:3
+doublecstoneslab=43:3
+dcstoneslab=43:3
+doublecsslab=43:3
+dcsslab=43:3
+smoothstonestep=44:0
+stonestep=44:0
+sstep=44:0
+step=44:0
+smoothstoneslab=44:0
+stoneslab=44:0
+sslab=44:0
+slab=44:0
+sandstonestep=44:1
+sstonestep=44:1
+ssstep=44:1
+sanddstoneslab=44:1
+sstoneslab=44:1
+ssslab=44:1
+woodenslab=44:2
+woodslab=44:2
+wslab=44:2
+woodplankstep=44:2
+wplankstep=44:2
+plankstep=44:2
+wpstep=44:2
+pstep=44:2
+woodplankslab=44:2
+wplankslab=44:2
+plankslab=44:2
+wpslab=44:2
+pslab=44:2
+cobblestonestep=44:3
+cobblestep=44:3
+cstonestep=44:3
+csstep=44:3
+cobblestoneslab=44:3
+cobbleslab=44:3
+cstoneslab=44:3
+csslab=44:3
+brickstep=44:4
+brickblockstep=44:4
+bstep=44:4
+brickslab=44:4
+brickblockslab=44:4
+bslab=44:4
+stonebrickstep=44:5
+sbstep=44:5
+stonebrickslab=44:5
+sbslab=44:5
+bricks=45:0
+brickblock=45:0
+blockbrick=45:0
+bblock=45:0
+blockb=45:0
+tnt=46:0
+tntblock=46:0
+blocktnt=46:0
+bombblock=46:0
+blockbomb=46:0
+dynamiteblock=46:0
+blockdynamite=46:0
+bomb=46:0
+dynamite=46:0
+bookshelf=47:0
+bookcase=47:0
+casebook=47:0
+shelfbook=47:0
+bookblock=47:0
+blockbook=47:0
+mossstone=48:0
+mossycobblestone=48:0
+mosscobblestone=48:0
+mcobblestone=48:0
+mossycobble=48:0
+mosscobble=48:0
+mcobble=48:0
+obsidian=49:0
+obsi=49:0
+obby=49:0
+torch=50:0
+fire=51:0
+flame=51:0
+flames=51:0
+mobspawner=52:0
+monsterspawner=52:0
+mspawner=52:0
+spawner=52:0
+woodenstairs=53:0
+woodstairs=53:0
+wstairs=53:0
+woodenstair=53:0
+woodstair=53:0
+wstair=53:0
+stairswooden=53:0
+stairswood=53:0
+stairsw=53:0
+stairwooden=53:0
+stairwood=53:0
+stairw=53:0
+chest=54:0
+redstonewireblock=55:0
+rstonewireblock=55:0
+redswireblock=55:0
+redwireblock=55:0
+rswireblock=55:0
+rwireblock=55:0
+redstonewire=55:0
+rstonewire=55:0
+redswire=55:0
+redwire=55:0
+rswire=55:0
+rwire=55:0
+wire=55:0
+diamondore=56:0
+crystalore=56:0
+diamondo=56:0
+crystalo=56:0
+orediamond=56:0
+odiamond=56:0
+orecrystal=56:0
+ocrystal=56:0
+dore=56:0
+ored=56:0
+diamondblock=57:0
+blockdiamond=57:0
+crystalblock=57:0
+blockcrystal=57:0
+dblock=57:0
+blockd=57:0
+workbench=58:0
+craftingbench=58:0
+crafterbench=58:0
+craftbench=58:0
+worktable=58:0
+craftingtable=58:0
+craftertable=58:0
+crafttable=58:0
+wbench=58:0
+cbench=58:0
+crops=59:0
+crop=59:0
+farmland=60:0
+soil=60:0
+furnace=61:0
+burningfurnace=62:0
+bfurnace=62:0
+signpost=63:0
+spost=63:0
+woodendoorhalf=64:0
+wooddoorhalf=64:0
+wdoorhalf=64:0
+woodendoorbottom=64:0
+wooddoorbottom=64:0
+wdoorbottom=64:0
+woodendoorblock=64:0
+wooddoorblock=64:0
+wdoorblock=64:0
+ladder=65:0
+rail=66:0
+minecarttrack=66:0
+minecartrail=66:0
+mcarttrack=66:0
+mcartrail=66:0
+mctrack=66:0
+mcrail=66:0
+track=66:0
+cobblestonestairs=67:0
+cstonestairs=67:0
+stonestairs=67:0
+cobblestairs=67:0
+csstairs=67:0
+sstairs=67:0
+cstairs=67:0
+cobblestonestair=67:0
+cstonestair=67:0
+stonestair=67:0
+cobblestair=67:0
+csstair=67:0
+sstair=67:0
+cstair=67:0
+stairscobblestone=67:0
+stairscstone=67:0
+stairsstone=67:0
+stairscobble=67:0
+stairscs=67:0
+stairss=67:0
+stairsc=67:0
+staircobblestone=67:0
+staircstone=67:0
+stairstone=67:0
+staircobble=67:0
+staircs=67:0
+stairs=67:0
+stairc=67:0
+wallsign=68:0
+wsign=68:0
+lever=69:0
+smoothstonepressureplate=70:0
+smoothstonepressplate=70:0
+smoothstonepplate=70:0
+smoothstoneplate=70:0
+sstonepressureplate=70:0
+sstonepressplate=70:0
+sstonepplate=70:0
+sstoneplate=70:0
+stonepressureplate=70:0
+stonepressplate=70:0
+stonepplate=70:0
+stoneplate=70:0
+spressureplate=70:0
+spressplate=70:0
+spplate=70:0
+splate=70:0
+irondoorhalf=71:0
+idoorhalf=71:0
+irondoorbottom=71:0
+idoorbottom=71:0
+irondoorblock=71:0
+idoorblock=71:0
+steeldoorhalf=71:0
+sdoorhalf=71:0
+steeldoorbottom=71:0
+sdoorbottom=71:0
+steeldoorblock=71:0
+sdoorblock=71:0
+woodenpressureplate=72:0
+woodenpressplate=72:0
+woodenpplate=72:0
+woodenplate=72:0
+woodpressureplate=72:0
+woodpressplate=72:0
+woodpplate=72:0
+woodplate=72:0
+wpressureplate=72:0
+wpressplate=72:0
+wpplate=72:0
+wplate=72:0
+redstoneore=73:0
+redsore=73:0
+redore=73:0
+rstoneore=73:0
+rsore=73:0
+rore=73:0
+oreredstone=73:0
+orereds=73:0
+orered=73:0
+orerstone=73:0
+orers=73:0
+orer=73:0
+glowingredstoneore=74:0
+glowredstoneore=74:0
+gredstoneore=74:0
+glowingrstoneore=74:0
+glowrstoneore=74:0
+grstoneore=74:0
+glowingredsore=74:0
+glowredsore=74:0
+gredsore=74:0
+glowingredore=74:0
+glowredore=74:0
+gredore=74:0
+glowingrsore=74:0
+glowrsore=74:0
+grsore=74:0
+grore=74:0
+oreglowingredstone=74:0
+oreglowredstone=74:0
+oregredstone=74:0
+oreglowingrstone=74:0
+oreglowrstone=74:0
+oregrstone=74:0
+oreglowingreds=74:0
+oreglowreds=74:0
+oregreds=74:0
+oreglowingred=74:0
+oreglowred=74:0
+oregred=74:0
+oreglowingrs=74:0
+oreglowrs=74:0
+oregrs=74:0
+oregr=74:0
+redstonetorchoff=75:0
+rstonetorchoff=75:0
+redstorchoff=75:0
+redtorchoff=75:0
+rstorchoff=75:0
+redstonetorchon=76:0
+redstonetorch=76:0
+rstonetorchon=76:0
+rstonetorch=76:0
+redstorchon=76:0
+redstorch=76:0
+redtorchon=76:0
+redtorch=76:0
+rstorchon=76:0
+rstorch=76:0
+button=77:0
+smoothstonebutton=77:0
+sstonebutton=77:0
+stonebutton=77:0
+sbutton=77:0
+snowcovering=78:0
+snowcover=78:0
+scover=78:0
+ice=79:0
+snow=80:0
+snowblock=80:0
+blocksnow=80:0
+sblock=80:0
+blocks=80:0
+cactus=81:0
+cactuses=81:0
+cacti=81:0
+clayblock=82:0
+blockclay=82:0
+cblock=82:0
+blockc=82:0
+reedblock=83:0
+reedsblock=83:0
+sugarcaneblock=83:0
+scaneblock=83:0
+bambooblock=83:0
+blockreed=83:0
+blockreeds=83:0
+blocksugarcane=83:0
+blockscane=83:0
+blockbamboo=83:0
+jukebox=84:0
+jbox=84:0
+fence=85:0
+pumpkin=86:0
+netherrack=87:0
+netherrock=87:0
+netherstone=87:0
+hellstone=87:0
+nstone=87:0
+hstone=87:0
+soulsand=88:0
+slowsand=88:0
+slowmud=88:0
+ssand=88:0
+smud=88:0
+mud=88:0
+glowstone=89:0
+glowingstoneblock=89:0
+lightstoneblock=89:0
+glowstoneblock=89:0
+blockglowingstone=89:0
+blocklightstone=89:0
+blockglowstone=89:0
+glowingstoneb=89:0
+lightstoneb=89:0
+glowstoneb=89:0
+bglowingstone=89:0
+blightstone=89:0
+bglowstone=89:0
+glowingstone=89:0
+lightstone=89:0
+glowingblock=89:0
+lightblock=89:0
+glowblock=89:0
+lstone=89:0
+gstone=89:0
+portal=90:0
+jackolantern=91:0
+pumpkinlantern=91:0
+glowingpumpkin=91:0
+lightpumpkin=91:0
+jpumpkin=91:0
+plantren=91:0
+glowpumpkin=91:0
+gpumpkin=91:0
+lpumpkin=91:0
+cakeblock=92:0
+repeateroff=93:0
+repeatoff=93:0
+delayeroff=93:0
+delayoff=93:0
+dioderoff=93:0
+diodeoff=93:0
+repeaterblockoff=93:0
+repeatblockoff=93:0
+delayerblockoff=93:0
+delayblockoff=93:0
+dioderblockoff=93:0
+diodeblockoff=93:0
+repeateron=94:0
+repeaton=94:0
+delayeron=94:0
+delayon=94:0
+dioderon=94:0
+diodeon=94:0
+repeaterblockon=94:0
+repeatblockon=94:0
+delayerblockon=94:0
+delayblockon=94:0
+dioderblockon=94:0
+diodeblockon=94:0
+lockedchest=95:0
+lockchest=95:0
+jokechest=95:0
+aprilfoolschest=95:0
+aprilchest=95:0
+lootchest=95:0
+trapdoor=96:0
+doortrap=96:0
+hatch=96:0
+tdoor=96:0
+doort=96:0
+trapd=96:0
+dtrap=96:0
+silverstone=97:0
+silverfishstone=97:0
+silverfishs=97:0
+sfstone=97:0
+stonesilverfish=97:0
+fishstone=97:0
+trapstone=97:0
+silverfish=97:0
+stonebrick=98:0
+stonebricks=98:0
+stonebrickblock=98:0
+stonebb=98:0
+sbrick=98:0
+mossystonebrick=98:1
+mossystonebricks=98:1
+mossystonebrickblock=98:1
+mossystonebb=98:1
+crackedstonebrick=98:2
+crackedstonebricks=98:2
+crackedstonebrickblock=98:2
+crackedstonebb=98:2
+hugeredmushroom=99:0
+bigredmushroom=99:0
+brmushroom=99:0
+giantredmushroom=99:0
+grmushroom=99:0
+hugebrownmushroom=100:0
+bigbrownmushroom=100:0
+bbmushroom=100:0
+giantbrownmushroom=100:0
+gbmushroom=100:0
+ironbars=101:0
+ironbarsb=101:0
+ironbarsblock=101:0
+metalbarsblock=101:0
+metalbarsb=101:0
+metalbars=101:0
+jailbarsblock=101:0
+jailbarsb=101:0
+jailbars=101:0
+glasspane=102:0
+flatglass=102:0
+skinnyglass=102:0
+glassflat=102:0
+melon=103:0
+watermelon=103:0
+greenmelon=103:0
+melongreen=103:0
+melonblock=103:0
+watermelonblock=103:0
+greenmelonblock=103:0
+pumpkinstem=104:0
+stempumpkin=104:0
+pumpstem=104:0
+stempump=104:0
+melonstem=105:0
+watermelonstem=105:0
+greenmelonstem=105:0
+stemmelon=105:0
+stemwatermelon=105:0
+stemgreenmelon=105:0
+vines=106:0
+vine=106:0
+greenvines=106:0
+gardenvines=106:0
+vinesgreen=106:0
+fencegate=107:0
+woodenfencegate=107:0
+gatefence=107:0
+woodengate=107:0
+woodgate=107:0
+gardengate=107:0
+brickstairs=108:0
+redbrickstairs=108:0
+bstairs=108:0
+stairsbrick=108:0
+brickstair=108:0
+redstairs=108:0
+stonebrickstairs=109:0
+stonebstairs=109:0
+sbstairs=109:0
+stairsstonebrick=109:0
+cementbrickstairs=109:0
+cementstairs=109:0
+cementbstairs=109:0
+greybrickstairs=109:0
+greybstairs=109:0
+mycelium=110:0
+mycel=110:0
+swampgrass=110:0
+sgrass=110:0
+mushroomgrass=110:0
+mushroomgrassblock=110:0
+mushroombiome=110:0
+waterlily=111:0
+lilypad=111:0
+lily=111:0
+swamppad=111:0
+lpad=111:0
+wlily=111:0
+netherbrick=112:0
+netherrackbrick=112:0
+netherrockbrick=112:0
+nbrick=112:0
+hellbrick=112:0
+deathbrick=112:0
+dbrick=112:0
+hbrick=112:0
+netherfence=113:0
+nfence=113:0
+netherbrickfence=113:0
+hellfence=113:0
+hellbrickfence=113:0
+netherbrickstairs=114:0
+hellbrickstairs=114:0
+hellstairs=114:0
+netherstairs=114:0
+netherwartsblock=115:0
+deathbrickstairs=114:0
+dbrickstairs=114:0
+hbrickstais=114:0
+enchantmenttable=116:0
+magictable=116:0
+enhancementtable=116:0
+etable=116:0
+booktable=116:0
+magicdesk=116:0
+enchantmentdesk=116:0
+edesk=116:0
+btable=116:0
+bdesk=116:0
+mtable=116:0
+mdesk=116:0
+brewingstandblock=117:0
+brewerblock=117:0
+potionstandblock=117:0
+potionbrewerblock=117:0
+pstandblock=117:0
+bstandblock=117:0
+pbrewerblock=117:0
+cauldronblock=118:0
+endportal=119:0
+enderportal=119:0
+theendportal=119:0
+endergoo=119:0
+endgoo=119:0
+endportal=119:0
+egoo=119:0
+eportal=119:0
+endportalframe=120:0
+enderportalframe=120:0
+theendportalframe=120:0
+endgooframe=120:0
+endergooframe=120:0
+egooframe=120:0
+eportalframe=120:0
+endstone=121:0
+enderstone=121:0
+theendstone=121:0
+endstone=121:0
+endrock=121:0
+enderrock=121:0
+erock=121:0
+estone=121:0
+dragonegg=122:0
+degg=122:0
+bossegg=122:0
+begg=122:0
+ironshovel=256:0
+ironspade=256:0
+ishovel=256:0
+ispade=256:0
+steelshovel=256:0
+steelspade=256:0
+ironpickaxe=257:0
+ironpick=257:0
+steelpickaxe=257:0
+steelpick=257:0
+ipickaxe=257:0
+ipick=257:0
+ironaxe=258:0
+iaxe=258:0
+steelaxe=258:0
+flintandsteel=259:0
+flintandiron=259:0
+flintandtinder=259:0
+flintnsteel=259:0
+flintniron=259:0
+flintntinder=259:0
+flintsteel=259:0
+flintiron=259:0
+flinttinder=259:0
+lighter=259:0
+apple=260:0
+redapple=260:0
+rapple=260:0
+bow=261:0
+arrow=262:0
+coal=263:0
+charcoal=263:1
+ccoal=263:1
+diamond=264:0
+crystal=264:0
+ironingot=265:0
+ironbar=265:0
+ironi=265:0
+steelingot=265:0
+steelbar=265:0
+steeli=265:0
+iingot=265:0
+ibar=265:0
+ingotiron=265:0
+bariron=265:0
+iiron=265:0
+ingotsteel=265:0
+barsteel=265:0
+isteel=265:0
+ingoti=265:0
+bari=265:0
+goldingot=266:0
+goldbar=266:0
+goldi=266:0
+gingot=266:0
+gbar=266:0
+ingotgold=266:0
+bargold=266:0
+igold=266:0
+ingotg=266:0
+barg=266:0
+ironsword=267:0
+steelsword=267:0
+isword=267:0
+woodensword=268:0
+woodsword=268:0
+wsword=268:0
+woodenshovel=269:0
+woodenspade=269:0
+woodshovel=269:0
+woodspade=269:0
+wshovel=269:0
+wspade=269:0
+woodenpickaxe=270:0
+woodenpick=270:0
+woodpickaxe=270:0
+woodpick=270:0
+wpickaxe=270:0
+wpick=270:0
+woodenaxe=271:0
+woodaxe=271:0
+waxe=271:0
+smoothstonesword=272:0
+cobblestonesword=272:0
+sstonesword=272:0
+cstonesword=272:0
+stonesword=272:0
+sssword=272:0
+cssword=272:0
+ssword=272:0
+smoothstoneshovel=273:0
+smoothstonespade=273:0
+cobblestoneshovel=273:0
+cobblestonespade=273:0
+sstoneshovel=273:0
+sstonespade=273:0
+cstoneshovel=273:0
+cstonespade=273:0
+stoneshovel=273:0
+stonespade=273:0
+ssshovel=273:0
+csshovel=273:0
+ssspade=273:0
+csspade=273:0
+sshovel=273:0
+sspade=273:0
+smoothstonepickaxe=274:0
+cobblestonepickaxe=274:0
+smoothstonepick=274:0
+cobblestonepick=274:0
+sstonepickaxe=274:0
+sstonepick=274:0
+cstonepickaxe=274:0
+cstonepick=274:0
+stonepickaxe=274:0
+stonepick=274:0
+sspickaxe=274:0
+sspick=274:0
+cspickaxe=274:0
+cspick=274:0
+spickaxe=274:0
+spick=274:0
+smoothstoneaxe=275:0
+cobblestoneaxe=275:0
+sstoneaxe=275:0
+cstoneaxe=275:0
+stoneaxe=275:0
+ssaxe=275:0
+csaxe=275:0
+saxe=275:0
+diamondsword=276:0
+crystalsword=276:0
+dsword=276:0
+diamondshovel=277:0
+diamondspade=277:0
+crystalshovel=277:0
+crystalspade=277:0
+dshovel=277:0
+dspade=277:0
+diamondpickaxe=278:0
+diamondpick=278:0
+crystalpickaxe=278:0
+crystalpick=278:0
+dpickaxe=278:0
+dpick=278:0
+diamondaxe=279:0
+crystalaxe=279:0
+daxe=279:0
+stick=280:0
+bowl=281:0
+mushroomstew=282:0
+mrstew=282:0
+stee=282:0
+mushroomsoup=282:0
+mrsoup=282:0
+soup=282:0
+goldensword=283:0
+goldsword=283:0
+gsword=283:0
+goldenshovel=284:0
+goldenspade=284:0
+goldshovel=284:0
+goldspade=284:0
+gshovel=284:0
+gspade=284:0
+goldenpickaxe=285:0
+goldenpick=285:0
+goldpickaxe=285:0
+goldpick=285:0
+gpickaxe=285:0
+gpick=285:0
+goldenaxe=286:0
+goldaxe=286:0
+gaxe=286:0
+string=287:0
+rope=287:0
+feather=288:0
+gunpowder=289:0
+sulfur=289:0
+woodenhoe=290:0
+woodhoe=290:0
+whoe=290:0
+smoothstonehoe=291:0
+cobblestonehoe=291:0
+sstonehoe=291:0
+cstonehoe=291:0
+stonehoe=291:0
+sshoe=291:0
+cshoe=291:0
+shoe=291:0
+ironhoe=292:0
+steelhoe=292:0
+ihoe=292:0
+diamondhoe=293:0
+crystalhoe=293:0
+dhoe=293:0
+goldenhoe=294:0
+goldhoe=294:0
+ghoe=294:0
+seeds=295:0
+seed=295:0
+wheat=296:0
+bread=297:0
+leathercap=298:0
+leatherhelmet=298:0
+leatherhelm=298:0
+leatherhat=298:0
+lhelmet=298:0
+lhelm=298:0
+lhat=298:0
+lcap=298:0
+leathertunic=299:0
+leatherchestplate=299:0
+leatherplatebody=299:0
+leatherplate=299:0
+leathershirt=299:0
+lchestplate=299:0
+lplatebody=299:0
+lplate=299:0
+lshirt=299:0
+ltunic=299:0
+leatherleggings=300:0
+leatherlegs=300:0
+leatherpants=300:0
+lleggings=300:0
+llegs=300:0
+lpants=300:0
+leatherboots=301:0
+leathershoes=301:0
+lboots=301:0
+lshoes=301:0
+chainmailhelmet=302:0
+chainmailhelm=302:0
+chainmailhat=302:0
+chainmhelmet=302:0
+chainmhelm=302:0
+chainmhat=302:0
+cmailhelmet=302:0
+cmailhelm=302:0
+cmailhat=302:0
+chainhelmet=302:0
+chainhelm=302:0
+chainhat=302:0
+cmhelmet=302:0
+cmhelm=302:0
+cmhat=302:0
+chainmailchestplate=303:0
+chainmailplatebody=303:0
+chainmailplate=303:0
+chainmailshirt=303:0
+chainmchestplate=303:0
+chainmplatebody=303:0
+chainmplate=303:0
+chainmshirt=303:0
+cmailchestplate=303:0
+cmailplatebody=303:0
+cmailplate=303:0
+cmailshirt=303:0
+chainchestplate=303:0
+chainplatebody=303:0
+chainplate=303:0
+chainshirt=303:0
+cmchestplate=303:0
+cmplatebody=303:0
+cmplate=303:0
+cmshirt=303:0
+chainmailleggings=304:0
+chainmaillegs=304:0
+chainmailpants=304:0
+chainmleggings=304:0
+chainmlegs=304:0
+chainmpants=304:0
+cmailleggings=304:0
+cmaillegs=304:0
+cmailpants=304:0
+chainleggings=304:0
+chainlegs=304:0
+chainpants=304:0
+cmleggings=304:0
+cmlegs=304:0
+cmpants=304:0
+chainmailboots=305:0
+chainmailshoes=305:0
+chainmboots=305:0
+chainmshoes=305:0
+cmailboots=305:0
+cmailshoes=305:0
+chainboots=305:0
+chainshoes=305:0
+cmboots=305:0
+cmshoes=305:0
+ironhelmet=306:0
+ironhelm=306:0
+ironhat=306:0
+ihelmet=306:0
+ihelm=306:0
+ihat=306:0
+steelhelmet=306:0
+steelhelm=306:0
+steelhat=306:0
+shelmet=306:0
+shelm=306:0
+shat=306:0
+ironchestplate=307:0
+ironplatebody=307:0
+ironplate=307:0
+ironshirt=307:0
+ichestplate=307:0
+iplatebody=307:0
+iplate=307:0
+ishirt=307:0
+steelchestplate=307:0
+steelplatebody=307:0
+steelplate=307:0
+steelshirt=307:0
+schestplate=307:0
+splatebody=307:0
+sshirt=307:0
+ironleggings=308:0
+ironlegs=308:0
+ironpants=308:0
+ileggings=308:0
+ilegs=308:0
+ipants=308:0
+steelleggings=308:0
+steellegs=308:0
+steelpants=308:0
+sleggings=308:0
+slegs=308:0
+spants=308:0
+ironboots=309:0
+ironshoes=309:0
+iboots=309:0
+ishoes=309:0
+steelboots=309:0
+steelshoes=309:0
+sboots=309:0
+sshoes=309:0
+diamondhelmet=310:0
+diamondhelm=310:0
+diamondhat=310:0
+dhelmet=310:0
+dhelm=310:0
+dhat=310:0
+crystalhelmet=310:0
+crystalhelm=310:0
+crystalhat=310:0
+chelmet=310:0
+chelm=310:0
+chat=310:0
+diamondchestplate=311:0
+diamondplatebody=311:0
+diamondplate=311:0
+diamondshirt=311:0
+dchestplate=311:0
+dplatebody=311:0
+dplate=311:0
+dshirt=311:0
+crystalchestplate=311:0
+crystalplatebody=311:0
+crystalplate=311:0
+crystalshirt=311:0
+cchestplate=311:0
+cplatebody=311:0
+cplate=311:0
+cshirt=311:0
+diamondleggings=312:0
+diamondlegs=312:0
+diamondpants=312:0
+dleggings=312:0
+dlegs=312:0
+dpants=312:0
+crystalleggings=312:0
+crystallegs=312:0
+crystalpants=312:0
+cleggings=312:0
+clegs=312:0
+cpants=312:0
+diamondboots=313:0
+diamondshoes=313:0
+dboots=313:0
+dshoes=313:0
+crystalboots=313:0
+crystalshoes=313:0
+cboots=313:0
+cshoes=313:0
+goldenhelmet=314:0
+goldenhelm=314:0
+goldenhat=314:0
+goldhelmet=314:0
+goldhelm=314:0
+goldhat=314:0
+ghelmet=314:0
+ghelm=314:0
+ghat=314:0
+goldenchestplate=315:0
+goldenplatebody=315:0
+goldenplate=315:0
+goldenshirt=315:0
+goldchestplate=315:0
+goldplatebody=315:0
+goldplate=315:0
+goldshirt=315:0
+gchestplate=315:0
+gplatebody=315:0
+gplateplate=315:0
+gshirt=315:0
+goldenleggings=316:0
+goldenlegs=316:0
+goldenpants=316:0
+goldleggings=316:0
+goldlegs=316:0
+goldpants=316:0
+gleggings=316:0
+glegs=316:0
+gpants=316:0
+goldenboots=317:0
+goldenshoes=317:0
+goldboots=317:0
+goldshoes=317:0
+gboots=317:0
+gshoes=317:0
+flint=318:0
+pork=319:0
+rawpork=319:0
+rpork=319:0
+porkchop=319:0
+rawporkchop=319:0
+rporkchop=319:0
+grilledpork=320:0
+grillpork=320:0
+gpork=320:0
+cookedpork=320:0
+grilledporkchop=320:0
+grillporkchop=320:0
+gporkchop=320:0
+cookedporkchop=320:0
+bacon=320:0
+painting=321:0
+art=321:0
+picture=321:0
+goldenapple=322:0
+goldapple=322:0
+gapple=322:0
+sign=323:0
+woodendoor=324:0
+wooddoor=324:0
+wdoor=324:0
+bucket=325:0
+bukkit=325:0
+waterbucket=326:0
+waterbukkit=326:0
+wbucket=326:0
+wbukkit=326:0
+magmabucket=327:0
+magmabukkit=327:0
+lavabucket=327:0
+lavabukkit=327:0
+lbucket=327:0
+lbukkit=327:0
+minecart=328:0
+mcart=328:0
+cart=328:0
+saddle=329:0
+pigsaddle=329:0
+irondoor=330:0
+idoor=330:0
+steeldoor=330:0
+sdoor=330:0
+dooriron=330:0
+doori=330:0
+doorsteel=330:0
+doors=330:0
+redstone=331:0
+redstonedust=331:0
+rstonedust=331:0
+rstone=331:0
+redsdust=331:0
+reddust=331:0
+rsdust=331:0
+rdust=331:0
+snowball=332:0
+snball=332:0
+boat=333:0
+leather=334:0
+milk=335:0
+milkbucket=335:0
+milkbukkit=335:0
+mbucket=335:0
+mbukkit=335:0
+brick=336:0
+claybrick=336:0
+clay=337:0
+clayball=337:0
+cball=337:0
+reeds=338:0
+reed=338:0
+sugarcane=338:0
+sugarcanes=338:0
+scane=338:0
+scanes=338:0
+bamboo=338:0
+paper=339:0
+papyrus=339:0
+book=340:0
+slimeball=341:0
+slball=341:0
+minecartwithchest=342:0
+minecartchest=342:0
+storageminecart=342:0
+chestminecart=342:0
+storagemcart=342:0
+chestmcart=342:0
+storagecart=342:0
+chestcart=342:0
+sminecart=342:0
+cminecart=342:0
+smcart=342:0
+cmcart=342:0
+scart=342:0
+ccart=342:0
+minecartwithfurnace=343:0
+minecartfurnace=343:0
+engineminecart=343:0
+poweredminecart=343:0
+powerminecart=343:0
+furnaceminecart=343:0
+enginemcart=343:0
+poweredmcart=343:0
+powermcart=343:0
+furnacemcart=343:0
+enginecart=343:0
+poweredcart=343:0
+powercart=343:0
+furnacecart=343:0
+eminecart=343:0
+pminecart=343:0
+fminecart=343:0
+emcart=343:0
+pmcart=343:0
+fmcart=343:0
+ecart=343:0
+pcart=343:0
+fcart=343:0
+egg=344:0
+chickenegg=344:0
+compass=345:0
+fishingrod=346:0
+fishrod=346:0
+frod=346:0
+rod=346:0
+clock=347:0
+goldwatch=347:0
+goldclock=347:0
+gwatch=347:0
+gclock=347:0
+watch=347:0
+glowingstoneblockdust=348:0
+lightstoneblockdust=348:0
+glowstoneblockdust=348:0
+blockglowingstonedust=348:0
+blocklightstonedust=348:0
+blockglowstonedust=348:0
+glowingstonebdust=348:0
+lightstonebdust=348:0
+glowstonebdust=348:0
+bglowingstonedust=348:0
+blightstonedust=348:0
+bglowstonedust=348:0
+glowingstonedust=348:0
+lightstonedust=348:0
+glowstonedust=348:0
+glowingblockdust=348:0
+lightblockdust=348:0
+glowblockdust=348:0
+lbdust=348:0
+gbdust=348:0
+lsdust=348:0
+gsdust=348:0
+rawfish=349:0
+rafish=349:0
+fish=349:0
+cookedfish=350:0
+cookfish=350:0
+cfish=350:0
+grilledfish=350:0
+grillfish=350:0
+gfish=350:0
+roastedfish=350:0
+roastfish=350:0
+rofish=350:0
+dye=351:0
+inksack=351:0
+inksac=351:0
+isack=351:0
+isac=351:0
+sack=351:0
+sac=351:0
+blackinksack=351:0
+blackinksac=351:0
+blackisack=351:0
+blackisac=351:0
+blacksack=351:0
+blacksac=351:0
+inksackblack=351:0
+inksacblack=351:0
+isackblack=351:0
+isacclack=351:0
+sackblack=351:0
+sacblack=351:0
+blackinksackcolour=351:0
+blackinksaccolour=351:0
+blackisackcolour=351:0
+blackisaccolour=351:0
+blacksackcolour=351:0
+blacksaccolour=351:0
+inksackblackcolour=351:0
+inksacblackcolour=351:0
+isackblackcolour=351:0
+isacclackcolour=351:0
+sackblackcolour=351:0
+sacblackcolour=351:0
+blackinksackcolor=351:0
+blackinksaccolor=351:0
+blackisackcolor=351:0
+blackisaccolor=351:0
+blacksackcolor=351:0
+blacksaccolor=351:0
+inksackblackcolor=351:0
+inksacblackcolor=351:0
+isackblackcolor=351:0
+isacblackcolor=351:0
+sackblackcolor=351:0
+sacblackcolor=351:0
+blackinksackdye=351:0
+blackinksacdye=351:0
+blackisackdye=351:0
+blackisacdye=351:0
+blacksackdye=351:0
+blacksacdye=351:0
+inksackblackdye=351:0
+inksacblackdye=351:0
+isackblackdye=351:0
+isacclackdye=351:0
+sackblackdye=351:0
+sacblackdye=351:0
+blackcolor=351:0
+blackdye=351:0
+rosered=351:1
+roseredcolor=351:1
+roseredcolour=351:1
+rosereddye=351:1
+redrosecolor=351:1
+redrosecolour=351:1
+redrosedye=351:1
+redr=351:1
+redrcolor=351:1
+redrcolour=351:1
+redrdye=351:1
+redcolor=351:1
+redcolour=351:1
+reddye=351:1
+cactusgreen=351:2
+greencactus=351:2
+cactusgreencolour=351:2
+greencactuscolour=351:2
+cactusgreencolor=351:2
+greencactuscolor=351:2
+cactusgreendye=351:2
+greencactusdye=351:2
+greencolour=351:2
+greencolor=351:2
+greendye=351:2
+cocoabeans=351:3
+cocoabean=351:3
+cocobeans=351:3
+cocobean=351:3
+cbeans=351:3
+cbean=351:3
+beans=351:3
+bean=351:3
+browncocoabeans=351:3
+browncocoabean=351:3
+browncocobeans=351:3
+browncocobean=351:3
+browncbeans=351:3
+browncbean=351:3
+brownbeans=351:3
+brownbean=351:3
+brownb=351:3
+cocoabeanscolour=351:3
+cocoabeancolour=351:3
+cocobeanscolour=351:3
+cocobeancolour=351:3
+cbeanscolour=351:3
+cbeancolour=351:3
+beanscolour=351:3
+beancolour=351:3
+browncocoabeanscolour=351:3
+browncocoabeancolour=351:3
+browncocobeanscolour=351:3
+browncocobeancolour=351:3
+browncbeanscolour=351:3
+browncbeancolour=351:3
+brownbeanscolour=351:3
+brownbeancolour=351:3
+brownbcolour=351:3
+cocoabeanscolor=351:3
+cocoabeancolor=351:3
+cocobeanscolor=351:3
+cocobeancolor=351:3
+cbeanscolor=351:3
+cbeancolor=351:3
+beanscolor=351:3
+beancolor=351:3
+browncocobeanscolor=351:3
+browncocobeancolor=351:3
+browncbeanscolor=351:3
+browncbeancolor=351:3
+brownbeanscolor=351:3
+brownbeancolor=351:3
+brownbcolor=351:3
+cocoabeansdye=351:3
+cocoabeandye=351:3
+cocobeansdye=351:3
+cocobeandye=351:3
+cbeansdye=351:3
+cbeandye=351:3
+beansdye=351:3
+beandye=351:3
+browncocobeansdye=351:3
+browncocobeandye=351:3
+browncbeansdye=351:3
+browncbeandye=351:3
+brownbeansdye=351:3
+brownbeandye=351:3
+brownbdye=351:3
+browncolour=351:3
+browncolor=351:3
+browndye=351:3
+bluelapislzuli=351:4
+bluelapisl=351:4
+bluelapis=351:4
+bluel=351:4
+lapislazuliblue=351:4
+lapislblue=351:4
+lapisblue=351:4
+lapislazuli=351:4
+lapisl=351:4
+lapis=351:4
+bluelapislazulicolour=351:4
+bluelapislcolour=351:4
+bluelapiscolour=351:4
+lapislazulibluecolour=351:4
+lapislbluecolour=351:4
+lapisbluecolour=351:4
+lapislazulicolour=351:4
+lapislcolour=351:4
+lapiscolour=351:4
+bluelapislazulicolor=351:4
+bluelapislcolor=351:4
+bluelapiscolor=351:4
+lapislazulibluecolor=351:4
+lapislbluecolor=351:4
+lapisbluecolor=351:4
+lapislazulicolor=351:4
+lapislcolor=351:4
+lapiscolor=351:4
+bluelapislazulidye=351:4
+bluelapisldye=351:4
+bluelapisdye=351:4
+lapislazulibluedye=351:4
+lapislbluedye=351:4
+lapisbluedye=351:4
+lapislazulidye=351:4
+lapisldye=351:4
+lapisdye=351:4
+bluecolour=351:4
+bluecolor=351:4
+bluedye=351:4
+purplecolour=351:5
+purplecolor=351:5
+purpledye=351:5
+cyancolour=351:6
+cyancolor=351:6
+cyandye=351:6
+lightgraycolour=351:7
+lightgraycolor=351:7
+lightgraydye=351:7
+lgraycolour=351:7
+lgraycolor=351:7
+lgraydye=351:7
+graycolour=351:8
+graycolor=351:8
+graydye=351:8
+pinkcolour=351:9
+pinkcolor=351:9
+pinkdye=351:9
+limecolour=351:10
+limecolor=351:10
+limedye=351:10
+dandelionyellow=351:11
+dandelionyellowcolour=351:11
+dandelionyellowcolor=351:11
+dandelionyellowdye=351:11
+yellowdandelion=351:11
+yellowdandelioncolour=351:11
+yellowdandelioncolor=351:11
+yellowdandeliondye=351:11
+yellowd=351:11
+yellowdcolour=351:11
+yellowdcolor=351:11
+yellowddye=351:11
+dyellow=351:11
+dyellowcolour=351:11
+dyellowcolor=351:11
+dyellowdye=351:11
+yellowcolour=351:11
+yellowcolor=351:11
+yellowdye=351:11
+lightbluecolour=351:12
+lightbluecolor=351:12
+lightbluedye=351:12
+lbluecolour=351:12
+lbluecolor=351:12
+lbluedye=351:12
+magentacolour=351:13
+magentacolor=351:13
+magentadye=351:13
+orangecolour=351:14
+orangecolor=351:14
+orangedye=351:14
+whitebonemeal=351:15
+whitebonemealcolour=351:15
+whitebonemealcolor=351:15
+whitebonemealdye=351:15
+bonemealwhite=351:15
+bonemealwhitecolour=351:15
+bonemealwhitecolor=351:15
+bonemealwhitedye=351:15
+whitebonem=351:15
+whitebonemcolour=351:15
+whitebonemcolor=351:15
+whitebonemdye=351:15
+bonemwhite=351:15
+bonemwhitecolour=351:15
+bonemwhitecolor=351:15
+bonemwhitedye=351:15
+bonemeal=351:15
+bonemealcolour=351:15
+bonemealcolor=351:15
+bonemealdye=351:15
+bonem=351:15
+bonemcolour=351:15
+bonemcolor=351:15
+bonemdye=351:15
+whitecolour=351:15
+whitecolor=351:15
+whitedye=351:15
+bone=352:0
+sugar=353:0
+cake=354:0
+bed=355:0
+redstonerepeater=356:0
+redstonerepeat=356:0
+redstonedelayer=356:0
+redstonedelay=356:0
+redstonedioder=356:0
+redstonediode=356:0
+rsrepeater=356:0
+rsrepeat=356:0
+rsdelayer=356:0
+rsdelay=356:0
+rsdioder=356:0
+rsdiode=356:0
+repeater=356:0
+repeat=356:0
+delayer=356:0
+delay=356:0
+dioder=356:0
+diode=356:0
+cookie=357:0
+chocolatecookie=357:0
+biscuit=357:0
+map=358:0
+chart=358:0
+shears=359:0
+shear=359:0
+sheers=359:0
+sheer=359:0
+melonslice=360:0
+mslice=360:0
+slicemelon=360:0
+watermelonslice=360:0
+greenmelonslice=360:0
+melongreenslice=360:0
+pumpkinseeds=361:0
+pseeds=361:0
+seedsp=361:0
+seedspumpkin=361:0
+pumpseeds=361:0
+seedspump=361:0
+melonseeds=362:0
+mseeds=362:0
+watermelonseeds=362:0
+greenmelonseeds=362:0
+gmelonseeds=362:0
+seedsmelon=362:0
+seedswatermelon=362:0
+rawbeef=363:0
+rawsteak=363:0
+uncookedbeef=363:0
+uncookedsteak=363:0
+cowmeat=363:0
+plainbeef=363:0
+steak=364:0
+cookedbeef=364:0
+grilledbeef=364:0
+cookedsteak=364:0
+grilledsteak=364:0
+cookedcowmeat=364:0
+rawchicken=365:0
+uncookedchicken=365:0
+plainchicken=365:0
+chickenplain=365:0
+chickenuncooked=365:0
+chickenraw=365:0
+cookedchicken=366:0
+grilledchicken=366:0
+toastedchicken=366:0
+rottenflesh=367:0
+zombieflesh=367:0
+rottenmeat=367:0
+zombiemeat=367:0
+badflesh=367:0
+poisenflesh=367:0
+zombieremains=367:0
+enderpearl=368:0
+pearl=368:0
+epearl=368:0
+bluepearl=368:0
+endergem=368:0
+blazerod=369:0
+goldenrod=369:0
+goldrod=369:0
+blazestick=369:0
+goldstick=369:0
+brod=369:0
+grod=369:0
+bstick=369:0
+gstick=369:0
+ghasttear=370:0
+irontear=370:0
+silvertear=370:0
+ghastdrop=370:0
+ghosttear=370:0
+ghostdrop=370:0
+gtear=370:0
+gdrop=370:0
+goldnugget=371:0
+goldtooth=371:0
+gnugget=371:0
+goldball=371:0
+goldpebble=371:0
+gball=371:0
+gpebble=371:0
+pigzombienugget=371:0
+pigzombieball=371:0
+pigzombiepebble=371:0
+nugget=371:0
+hellwart=372:0
+netherwart=372:0
+hellstalk=372:0
+netherwarts=372:0
+netherwart=372:0
+netherplant=372:0
+nethercrop=372:0
+hellwarts=372:0
+hellwart=372:0
+hellplant=372:0
+hellcrop=372:0
+deathwarts=372:0
+deathwart=372:0
+deathplant=372:0
+deathcrop=372:0
+nwarts=372:0
+nwart=372:0
+ncrop=372:0
+nplant=372:0
+hwarts=372:0
+hwart=372:0
+hplant=372:0
+hcrop=372:0
+dwarts=372:0
+dwart=372:0
+dplant=372:0
+dcrop=372:0
+netherstalk=372:0
+deathstalk=372:0
+hellstalk=372:0
+nstalk=372:0
+dstalk=372:0
+hstalk=372:0
+potion=373:0
+mixture=373:0
+potions=373:0
+potionbottle=373:0
+pbottle=373:0
+glassbottle=374:0
+bottle=374:0
+gbottle=374:0
+gvase=374:0
+vase=374:0
+glassvase=374:0
+emptypotion=374:0
+spidereye=375:0
+eyeofspider=375:0
+spiderseye=375:0
+spiderball=375:0
+spidernugget=375:0
+spidersball=375:0
+spidersnugget=375:0
+seye=375:0
+sball=375:0
+snugget=375:0
+fermentedspidereye=376:0
+craftedspidereye=376:0
+fermentedeyeofspider=376:0
+craftedeyeofspider=376:0
+fspidereye=376:0
+fseye=376:0
+feyeofspider=376:0
+ceyeofspider=376:0
+cspidereye=376:0
+blazepowder=377:0
+blazep=377:0
+blazedust=377:0
+goldpowder=377:0
+golddust=377:0
+gdust=377:0
+gpowder=377:0
+bpowder=377:0
+bdust=377:0
+magmacream=378:0
+goldcream=378:0
+blazecream=378:0
+mcream=378:0
+magmac=378:0
+gcream=378:0
+bcream=378:0
+combinedcream=378:0
+ccream=378:0
+brewingstand=379:0
+potionstand=379:0
+brewing=379:0
+bstand=379:0
+pstand=379:0
+cauldron=380:0
+cauldronitem=380:0
+steelcauldron=380:0
+ironcauldron=380:0
+icauldron=380:0
+scauldron=380:0
+potioncauldron=380:0
+pcauldron=380:0
+eyeofender=381:0
+eoe=381:0
+endereye=381:0
+evilendereye=381:0
+evileyeofender=381:0
+evilenderpearl=381:0
+eeye=381:0
+eofender=381:0
+speckledmelon=382:0
+goldmelon=382:0
+sparklymelon=382:0
+glisteningmelon=382:0
+glisteringmelon=382:0
+shiningmelon=382:0
+gmelon=382:0
+smelon=382:0
+thirteen=2256:0
+musicdisc1=2256:0
+disc1=2256:0
+record1=2256:0
+cat=2257:0
+musicdisc2=2257:0
+disc2=2257:0
+record2=2257:0
+blocks=2258:0
+musicdisc3=2258:0
+disc3=2258:0
+record3=2258:0
+chirp=2259:0
+musicdisc4=2259:0
+disc4=2259:0
+record4=2259:0
+far=2260:0
+musicdisc5=2260:0
+disc5=2260:0
+record5=2260:0
+mall=2261:0
+musicdisc6=2261:0
+disc6=2261:0
+record6=2261:0
+mellohi=2262:0
+musicdisc7=2262:0
+disc7=2262:0
+record7=2262:0
+stal=2263:0
+musicdisc8=2263:0
+disc8=2263:0
+record8=2263:0
+strad=2264:0
+musicdisc9=2264:0
+disc9=2264:0
+record9=2264:0
+ward=2265:0
+musicdisc10=2265:0
+disc10=2265:0
+record10=2265:0
+eleven=2266:0
+musicdisc11=2266:0
+disc11=2266:0
+record11=2266:0
diff --git a/src/main/resources/datamanagerlogo b/src/main/resources/datamanagerlogo
new file mode 100644
index 0000000..6b85647
--- /dev/null
+++ b/src/main/resources/datamanagerlogo
@@ -0,0 +1,16 @@
+    _/_/_/              _/                
+   _/    _/   _/_/_/ _/_/_/_/   _/_/_/   
+  _/    _/ _/    _/   _/     _/    _/    
+ _/    _/ _/    _/   _/     _/    _/     
+_/_/_/     _/_/_/     _/_/   _/_/_/      
+                                            
+                                            
+
+                                                                            
+    _/      _/                                                        
+   _/_/  _/_/   _/_/_/ _/_/_/     _/_/_/   _/_/_/   _/_/   _/  _/_/   
+  _/  _/  _/ _/    _/ _/    _/ _/    _/ _/    _/ _/_/_/_/ _/_/        
+ _/      _/ _/    _/ _/    _/ _/    _/ _/    _/ _/       _/           
+_/      _/   _/_/_/ _/    _/   _/_/_/   _/_/_/   _/_/_/ _/            
+                                           _/                           
+                                       _/_/                              
\ No newline at end of file
diff --git a/src/main/resources/mainlogo b/src/main/resources/mainlogo
new file mode 100644
index 0000000..d8b604f
--- /dev/null
+++ b/src/main/resources/mainlogo
@@ -0,0 +1,13 @@
+     _/_/_/                                                                _/   
+  _/        _/_/   _/_/_/  _/_/   _/_/_/  _/_/     _/_/_/ _/_/_/     _/_/_/    
+ _/      _/    _/ _/    _/    _/ _/    _/    _/ _/    _/ _/    _/ _/    _/     
+_/      _/    _/ _/    _/    _/ _/    _/    _/ _/    _/ _/    _/ _/    _/      
+ _/_/_/  _/_/   _/    _/    _/ _/    _/    _/   _/_/_/ _/    _/   _/_/_/       
+                                                                                                                                                                                                                                                                
+                      _/    _/            _/                                
+                     _/    _/    _/_/    _/  _/_/_/      _/_/    _/  _/_/   
+                    _/_/_/_/  _/_/_/_/  _/  _/    _/  _/_/_/_/  _/_/        
+                   _/    _/  _/        _/  _/    _/  _/        _/           
+                  _/    _/    _/_/_/  _/  _/_/_/      _/_/_/  _/            
+                                         _/                                 
+                                        _/                                 
\ No newline at end of file
diff --git a/src/main/resources/plugin.yml b/src/main/resources/plugin.yml
index 5d9c423..7338d74 100644
--- a/src/main/resources/plugin.yml
+++ b/src/main/resources/plugin.yml
@@ -1,5 +1,5 @@
 name: CommandHelper
-main: com.sk89q.commandhelper.CommandHelperPlugin
+main: com.laytonsmith.commandhelper.CommandHelperPlugin
 version: "${project.version}"
 commands:
     repeat:
@@ -25,4 +25,7 @@ commands:
         usage: /<command>
     commandhelper:
         description: Used to gain meta information about CommandHelper
-        usage: /<command> <arguments>
\ No newline at end of file
+        usage: /<command> <arguments>
+    runalias:
+        description: If another plugin wants to run a CommandHelper command, it isn't always straightforward to do that, because of the way bukkit works. To get around this, you may use this command. "/runalias /command to run" will fire off the alias "/command to run"
+        usage: /<command> <otherCommand>
\ No newline at end of file
diff --git a/src/main/resources/samp_main.txt b/src/main/resources/samp_main.txt
new file mode 100644
index 0000000..9d49757
--- /dev/null
+++ b/src/main/resources/samp_main.txt
@@ -0,0 +1,22 @@
+######################################################
+#
+#   Sample Main file. This file is run when the server
+#   starts up, or the plugin is reloaded. It can be used
+#   as an opportunity to register events or do other things
+#   when the server initially starts. Variables defined here
+#   will go out of scope, so you can't assign() something and
+#   then use it in a command, for instance.
+#
+######################################################
+
+assign(@server_name, '<Server Name>')
+
+#Echo out a server greeting to the console
+console('Welcome to this server, which is running CommandHelper!')
+
+#Bind an event to the player join, and tell ops hello. We send in
+#@server_name, so we can use it inside the event handler
+bind(player_join, null, null, @event, @server_name,
+    #if the player is an op, let's send them a message
+    if(pisop(@event[player]), tmsg(@event[player], 'Welcome to' @server_name))
+) 
diff --git a/src/main/resources/syntax-templates/geshi/default.php b/src/main/resources/syntax-templates/geshi/default.php
new file mode 100644
index 0000000..102406e
--- /dev/null
+++ b/src/main/resources/syntax-templates/geshi/default.php
@@ -0,0 +1,108 @@
+<?php
+/***************************************
+ * commandhelper.php
+ * Author: Deaygo Jarkko (deaygo@thezomg.com)
+ * Release Version: 0.0.1
+ * Date Started: 2012/01/23
+ *
+ * CommandHelper language file for GeSHi
+ *
+ * 2012/01/23 (0.0.1)
+ *  - First Release
+ ****************************************************/
+$language_data = array(
+    'LANG_NAME' => 'CommandHelper',
+    'COMMENT_SINGLE' => array(1 => '#'),
+    'HARD_QUOTE' => array("'", "'"),
+    'HARDESCAPE' => array("\\"),
+    'HARDCHAR' => array("\\"),
+    'CASE_KEYWORDS' => GESHI_CAPS_NO_CHANGE,
+    'QUOTEMARKS' => array('"', "'"),
+    'ESCAPE_REGEXP' => array(
+            //Simple Single Char Escapes
+            1 => "#\\\\[nfrtv\$\"\n\\\\]#i",
+            2 => "#[\\$\\@][a-zA-Z0-9]+"
+    ),
+    'NUMBERS' => GESHI_NUMBER_INT_BASIC,
+    'KEYWORDS' => array(
+        // Non-Restricted
+        1 => array(
+            %%comma:functions:quoted:unrestricted%%
+        ),
+        // Restricted
+        2 => array(
+             %%comma:functions:quoted:restricted%%
+        ),
+        3 => array(
+             %%comma:events:quoted%%
+        ),
+        4 => array(
+            %%comma:colors:quoted%%
+        )
+    ),
+    'SYMBOLS' => array (
+        0 => array(
+            '(', ')', '[', ']', '{', '}',
+            '$', '@', '<', '>',
+            '=', ':', ',', '>>>', '<<<'
+        )
+    ),
+    'CASE_SENSITIVE' => array(
+        GESHI_COMMENTS => false,
+        1 => false,
+        2 => false
+    ),
+    'STYLES' => array(
+        'KEYWORDS' => array(
+            1 => 'color: #1265A9;',
+            2 => 'color: #B35900;',
+            3 => 'color: #B30059;',
+            4 => 'color: #5900B3;'
+        ),
+        'COMMENTS' => array(
+            1 => 'color: #666666; font-weight: bold;'
+        ),
+        'ESCAPE_CHAR' => array(
+            1 => 'color: #000099; font-weight: bold;'
+        ),
+        'BRACKETS' => array(
+            0 => 'color: #009900;'
+        ),
+        'STRINGS' => array(
+            0 => 'color: #0000ff;',
+            'HARD' => 'color: #0000ff;'
+        ),
+        'NUMBERS' => array(
+            0 => 'color: #cc66cc;'
+        ),
+        'METHODS' => array(
+            1 => 'color: #004000;',
+            2 => 'color: #004000;'
+        ),
+        'SYMBOLS' => array(
+            1 => 'color: #339933;',
+            2 => 'color: #339933;'
+        ),
+        'REGEXPS' => array(
+            0 => 'color: #000088;'
+        )
+    ),
+    'URLS' => array(
+        1 => 'http://wiki.sk89q.com/wiki/CommandHelper/API/{FNAMEL}',
+        2 => 'http://wiki.sk89q.com/wiki/CommandHelper/API/{FNAMEL}'
+    ),
+    'OOLANG' => false,
+    'REGEXPS' => array(
+        //Variables
+        0 => "[\\$\\@][a-zA-Z00-9_]+"
+    ),
+    'STRICT_MODE_APPLIES' => GESHI_MAYBE,
+    'TAB_WIDTH' => 4,
+    'PARSER_CONTROL' => array(
+        'KEYWORDS' => array(
+            'DISALLOWED_AFTER' =>  "(?![\.\-a-zA-Z0-9_%=\\/\&])",
+            'DISALLOWED_BEFORE' => "(?<![\.\-a-zA-Z0-9_\$\@\#\&])"
+        )
+    )
+);
+?>
diff --git a/src/main/resources/syntax-templates/notepad++/default.xml b/src/main/resources/syntax-templates/notepad++/default.xml
new file mode 100644
index 0000000..23aa7f9
--- /dev/null
+++ b/src/main/resources/syntax-templates/notepad++/default.xml
@@ -0,0 +1,36 @@
+<NotepadPlus>
+    <UserLang name="CmdHelper" ext="ms">
+        <Settings>
+            <Global caseIgnored="yes" escapeChar="\" />
+            <TreatAsSymbol comment="yes" commentLine="yes" />
+            <Prefix words1="no" words2="yes" words3="yes" words4="yes" />
+        </Settings>
+        <KeywordLists>
+            <Keywords name="Delimiters">&apos;&quot;0&apos;&quot;0</Keywords>
+            <Keywords name="Folder+">&gt;&gt;&gt;</Keywords>
+            <Keywords name="Folder-">&lt;&lt;&lt;</Keywords>
+            <Keywords name="Operators">( ) , : [ \ ] =</Keywords>
+            <Keywords name="Comment">1/* 2*/ 0#</Keywords>
+            <Keywords name="Words1">%%space:functions%%</Keywords>
+            <Keywords name="Words2">_</Keywords>
+            <Keywords name="Words3">@</Keywords>
+            <Keywords name="Words4">$</Keywords>
+        </KeywordLists>
+        <Styles>
+            <WordsStyle name="DEFAULT" styleID="11" fgColor="FF0000" bgColor="FFFFFF" fontName="" fontStyle="0" />
+            <WordsStyle name="FOLDEROPEN" styleID="12" fgColor="000080" bgColor="FFFF80" fontName="" fontStyle="1" />
+            <WordsStyle name="FOLDERCLOSE" styleID="13" fgColor="000080" bgColor="FFFF80" fontName="" fontStyle="1" />
+            <WordsStyle name="KEYWORD1" styleID="5" fgColor="0080FF" bgColor="FFFFFF" fontName="" fontStyle="1" />
+            <WordsStyle name="KEYWORD2" styleID="6" fgColor="004080" bgColor="FFFFFF" fontName="" fontStyle="1" />
+            <WordsStyle name="KEYWORD3" styleID="7" fgColor="FF8000" bgColor="FFFFFF" fontName="" fontStyle="0" />
+            <WordsStyle name="KEYWORD4" styleID="8" fgColor="8000FF" bgColor="FFFFFF" fontName="" fontStyle="0" />
+            <WordsStyle name="COMMENT" styleID="1" fgColor="008000" bgColor="FFFFFF" fontName="" fontStyle="0" />
+            <WordsStyle name="COMMENT LINE" styleID="2" fgColor="008000" bgColor="FFFFFF" fontName="" fontStyle="0" />
+            <WordsStyle name="NUMBER" styleID="4" fgColor="FF0000" bgColor="FFFFFF" fontName="" fontStyle="0" />
+            <WordsStyle name="OPERATOR" styleID="10" fgColor="000080" bgColor="FFFFFF" fontName="" fontStyle="0" />
+            <WordsStyle name="DELIMINER1" styleID="14" fgColor="808080" bgColor="FFFFFF" fontName="" fontStyle="0" />
+            <WordsStyle name="DELIMINER2" styleID="15" fgColor="808080" bgColor="FFFFFF" fontName="" fontStyle="0" />
+            <WordsStyle name="DELIMINER3" styleID="16" fgColor="000000" bgColor="FFFFFF" fontName="" fontStyle="0" />
+        </Styles>
+    </UserLang>
+</NotepadPlus>
\ No newline at end of file
diff --git a/src/main/resources/syntax-templates/notepad++/obsidian.xml b/src/main/resources/syntax-templates/notepad++/obsidian.xml
new file mode 100644
index 0000000..0116ae7
--- /dev/null
+++ b/src/main/resources/syntax-templates/notepad++/obsidian.xml
@@ -0,0 +1,36 @@
+<NotepadPlus>
+    <UserLang name="CmdHelper" ext="ms">
+        <Settings>
+            <Global caseIgnored="yes" escapeChar="\"/>
+            <TreatAsSymbol comment="yes" commentLine="yes"/>
+            <Prefix words1="yes" words2="yes" words3="yes" words4="yes"/>
+        </Settings>
+        <KeywordLists>
+            <Keywords name="Delimiters">&apos;&quot;0&apos;&quot;0</Keywords>
+            <Keywords name="Folder+">&gt;&gt;&gt;</Keywords>
+            <Keywords name="Folder-">&lt;&lt;&lt;</Keywords>
+            <Keywords name="Operators">( ) , : [ \ ] =</Keywords>
+            <Keywords name="Comment">1/* 2*/ 0#</Keywords>
+            <Keywords name="Words1">%%space:functions%%</Keywords>
+            <Keywords name="Words2">_</Keywords>
+            <Keywords name="Words3">@</Keywords>
+            <Keywords name="Words4">$</Keywords>
+        </KeywordLists>
+        <Styles>
+            <WordsStyle name="DEFAULT" styleID="11" fgColor="E0E2E4" bgColor="293134" fontName="" fontStyle="0"/>
+            <WordsStyle name="FOLDEROPEN" styleID="12" fgColor="D955C1" bgColor="293134" fontName="" fontStyle="0"/>
+            <WordsStyle name="FOLDERCLOSE" styleID="13" fgColor="D955C1" bgColor="293134" fontName="" fontStyle="0"/>
+            <WordsStyle name="KEYWORD1" styleID="5" fgColor="93C763" bgColor="293134" fontName="" fontStyle="0"/>
+            <WordsStyle name="KEYWORD2" styleID="6" fgColor="678CB1" bgColor="293134" fontName="" fontStyle="0"/>
+            <WordsStyle name="KEYWORD3" styleID="7" fgColor="678CB1" bgColor="293134" fontName="" fontStyle="0"/>
+            <WordsStyle name="KEYWORD4" styleID="8" fgColor="678CB1" bgColor="293134" fontName="" fontStyle="0"/>
+            <WordsStyle name="COMMENT" styleID="1" fgColor="66747B" bgColor="293134" fontName="" fontStyle="0"/>
+            <WordsStyle name="COMMENT LINE" styleID="2" fgColor="66747B" bgColor="293134" fontName="" fontStyle="0"/>
+            <WordsStyle name="NUMBER" styleID="4" fgColor="FFCD22" bgColor="293134" fontName="" fontStyle="0"/>
+            <WordsStyle name="OPERATOR" styleID="10" fgColor="E8E2B7" bgColor="293134" fontName="" fontStyle="0"/>
+            <WordsStyle name="DELIMINER1" styleID="14" fgColor="EC7600" bgColor="293134" fontName="" fontStyle="0"/>
+            <WordsStyle name="DELIMINER2" styleID="15" fgColor="EC7600" bgColor="293134" fontName="" fontStyle="2"/>
+            <WordsStyle name="DELIMINER3" styleID="16" fgColor="FFFFFF" bgColor="293134" fontName="" fontStyle="0"/>
+        </Styles>
+    </UserLang>
+</NotepadPlus>
\ No newline at end of file
diff --git a/src/main/resources/syntax-templates/text-wrangler/default.plist b/src/main/resources/syntax-templates/text-wrangler/default.plist
new file mode 100644
index 0000000..692eced
--- /dev/null
+++ b/src/main/resources/syntax-templates/text-wrangler/default.plist
@@ -0,0 +1,73 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
+<plist version="1.0">
+<dict>
+	<key>BBEditDocumentType</key>
+	<string>CodelessLanguageModule</string>
+	<key>BBLMColorsSyntax</key>
+	<true/>
+	<key>BBLMIsCaseSensitive</key>
+	<true/>
+	<key>BBLMLanguageCode</key>
+	<string>CH</string>
+	<key>BBLMKeywordList</key>
+	<array>
+		%%xml:functions:tag=string%%
+                %%xml:events:tag=string%%
+	</array>
+	<key>BBLMLanguageDisplayName</key>
+	<string>CommandHelper</string>
+	<key>BBLMScansFunctions</key>
+	<true/>
+	<key>BBLMSuffixMap</key>
+	<array>
+		<dict>
+			<key>BBLMLanguageSuffix</key>
+			<string>.txt</string>
+		</dict>
+	</array>
+	<key>Language Features</key>
+	<dict>
+		<key>Close Block Comments</key>
+		<string></string>
+		<key>Close Parameter Lists</key>
+		<string>)</string>
+		<key>Close Statement Blocks</key>
+		<string></string>
+		<key>Close Strings 1</key>
+		<string>&apos;</string>
+		<key>Close Strings 2</key>
+		<string></string>
+		<key>End-of-line Ends Strings 1</key>
+		<false/>
+		<key>End-of-line Ends Strings 2</key>
+		<false/>
+		<key>Escape Char in Strings 1</key>
+		<string>\</string>
+		<key>Escape Char in Strings 2</key>
+		<string>\</string>
+		<key>Identifier and Keyword Characters</key>
+		<string>123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyz.</string>
+		<key>Open Block Comments</key>
+		<string></string>
+		<key>Open Line Comments</key>
+		<string>#</string>
+		<key>Open Parameter Lists</key>
+		<string>(</string>
+		<key>Open Statement Blocks</key>
+		<string></string>
+		<key>Open Strings 1</key>
+		<string>&apos;</string>
+		<key>Open Strings 2</key>
+		<string></string>
+		<key>Prefix for Functions</key>
+		<string></string>
+		<key>Prefix for Procedures</key>
+		<string></string>
+		<key>Terminator for Prototypes 1</key>
+		<string>@</string>
+		<key>Terminator for Prototypes 2</key>
+		<string>$</string>
+	</dict>
+</dict>
+</plist>
diff --git a/src/main/resources/syntax-templates/vim/default.vim b/src/main/resources/syntax-templates/vim/default.vim
new file mode 100644
index 0000000..e06fe66
--- /dev/null
+++ b/src/main/resources/syntax-templates/vim/default.vim
@@ -0,0 +1,33 @@
+if exists("b:current_syntax")
+  finish
+endif
+
+syn keyword restrictedFunctions %%space:functions:restricted%% 
+syn keyword unrestrictedFunctions %%space:functions:unrestricted%% 
+syn keyword events %%space:events%% 
+syn keyword colors %%space:colors%% 
+syn keyword unsymboledkeywords %%space:keywords%%
+syn match linecomment /#.*/
+syn region blockcomment start=/\/\*/ end=/\*\//
+syn region stringlit start=/'/ skip=/\\'/ end=/'/
+syn region smartstring start=/"/ skip=/\\"/ end=/"/
+syn match ivariable /@[a-zA-Z0-9]\+/
+syn match variable /\$[a-zA-Z0-9]\+/
+syn match finalvar /\$[^a-zA-Z0-9]/
+syn match label /[a-zA-Z][a-zA-Z0-9]\+:/
+
+let b:current_syntax = "commandhelper"
+
+highlight restrictedFunctions ctermfg=DarkCyan guifg=#1265A9
+highlight unrestrictedFunctions ctermfg=DarkGreen guifg=#B35900
+highlight events ctermfg=LightMagenta guifg=#B30059
+highlight colors ctermfg=yellow guifg=#5900B3
+highlight unsymboledkeywords ctermfg=LightBlue guifg=LightBlue
+highlight linecomment ctermfg=LightGray guifg=LightGray
+highlight blockcomment ctermfg=LightGray guifg=LightGray
+highlight stringlit ctermfg=3 guifg=orange
+highlight smartstring ctermfg=white ctermbg=red guifg=white guibg=red
+highlight ivariable ctermfg=green guifg=green
+highlight variable ctermfg=LightCyan guifg=LightCyan
+highlight finalvar ctermfg=6 guifg=6
+highlight label ctermfg=yellow guifg=yellow
\ No newline at end of file
diff --git a/src/main/resources/time_names.txt b/src/main/resources/time_names.txt
new file mode 100644
index 0000000..9f6ae63
--- /dev/null
+++ b/src/main/resources/time_names.txt
@@ -0,0 +1,13 @@
+morning=0
+day=2000
+midday=6000
+noon=6000
+afternoon=8000
+evening=12000
+sunset=13000
+dusk=13500
+night=14000
+midnight=18000
+earlymorning=20000
+dawn=22500
+sunrise=23000
\ No newline at end of file
diff --git a/src/test/java/com/laytonsmith/aliasengine/MScriptCompilerTest.java b/src/test/java/com/laytonsmith/aliasengine/MScriptCompilerTest.java
deleted file mode 100644
index 65315a8..0000000
--- a/src/test/java/com/laytonsmith/aliasengine/MScriptCompilerTest.java
+++ /dev/null
@@ -1,506 +0,0 @@
-/*
- * To change this template, choose Tools | Templates
- * and open the template in the editor.
- */
-package com.laytonsmith.aliasengine;
-
-import com.laytonsmith.testing.StaticTest;
-import com.sk89q.bukkit.migration.PermissionsResolverManager;
-import com.laytonsmith.aliasengine.Constructs.Variable;
-import org.bukkit.Server;
-import org.bukkit.entity.Player;
-import com.laytonsmith.aliasengine.functions.exceptions.ConfigCompileException;
-import com.laytonsmith.aliasengine.Constructs.Token;
-import com.sk89q.commandhelper.CommandHelperPlugin;
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.List;
-import java.util.concurrent.atomic.AtomicBoolean;
-import org.junit.After;
-import org.junit.AfterClass;
-import org.junit.Before;
-import org.junit.BeforeClass;
-import org.junit.Test;
-import static org.junit.Assert.*;
-import static org.mockito.Mockito.*;
-import static com.laytonsmith.testing.StaticTest.*;
-
-/**
- *
- * @author Layton
- */
-public class MScriptCompilerTest {
-
-    Server fakeServer;
-    Player fakePlayer;
-
-    public MScriptCompilerTest() {
-    }
-
-    @BeforeClass
-    public static void setUpClass() throws Exception {
-    }
-
-    @AfterClass
-    public static void tearDownClass() throws Exception {
-    }
-
-    @Before
-    public void setUp() {
-        fakePlayer = StaticTest.GetOnlinePlayer();
-        fakeServer = StaticTest.GetFakeServer();
-    }
-
-    @After
-    public void tearDown() {
-    }
-
-    /**
-     * Test of lex method, of class MScriptCompiler.
-     */
-    @Test
-    public void testLex() throws Exception {
-        System.out.println("lex");
-        String config = "/cmd = msg('string')";
-        List e = null;
-        e = new ArrayList();
-        //This is the decomposed version of the above config
-        e.add(new Token(Token.TType.COMMAND, "/cmd", 1, null));
-        e.add(new Token(Token.TType.ALIAS_END, "=", 1, null));
-        e.add(new Token(Token.TType.FUNC_NAME, "msg", 1, null));
-        e.add(new Token(Token.TType.FUNC_START, "(", 1, null));
-        e.add(new Token(Token.TType.STRING, "string", 1, null));
-        e.add(new Token(Token.TType.FUNC_END, ")", 1, null));
-        e.add(new Token(Token.TType.NEWLINE, "\n", 2, null));
-
-        List result = MScriptCompiler.lex(config, null);
-        assertEquals(e, result);
-
-        String[] badConfigs = {
-            "'\\q'", //Bad escape sequences
-            "'\\r'",};
-        for (String c : badConfigs) {
-            try {
-                MScriptCompiler.lex(c, null);
-                //Shouldn't get here
-                fail(c + " should not have lexed, but did.");
-            } catch (ConfigCompileException ex) {
-                //Success!
-            }
-        }
-    }
-    @Test
-    public void testCompile() throws ConfigCompileException {
-        System.out.println("compile");
-        MScriptCompiler.preprocess(MScriptCompiler.lex("/cmd = msg(this is a string, if(true, and, another) function)", null)).get(0).compileRight();
-        try {
-            //extra parameter
-            MScriptCompiler.preprocess(MScriptCompiler.lex("/cmd = msg(this is a string, if(true, and, another, oops) function)", null)).get(0).compileRight();
-            fail("Did not expect test to pass");
-        } catch (ConfigCompileException e) {
-            //passed
-        }
-        try {
-            //missing parenthesis
-            MScriptCompiler.preprocess(MScriptCompiler.lex("/cmd = msg(this is a string, if(true, and, another) function", null)).get(0).compileRight();
-            fail("Did not expect test to pass");
-        } catch (ConfigCompileException e) {
-            //passed
-        }
-        try {
-            //extra parenthesis
-            MScriptCompiler.preprocess(MScriptCompiler.lex("/cmd = msg(this is a string, if(true, and, another) function)))))", null)).get(0).compileRight();
-            fail("Did not expect test to pass");
-        } catch (ConfigCompileException e) {
-            //passed
-        }
-        try {
-            //extra parenthesis
-            MScriptCompiler.preprocess(MScriptCompiler.lex("/cmd = msg((this is a string, if(true, and, another) function))", null)).get(0).compileRight();
-            fail("Did not expect test to pass");
-        } catch (ConfigCompileException e) {
-            //passed
-        }
-        try {
-            //extra multiline end construct
-            MScriptCompiler.preprocess(MScriptCompiler.lex("/cmd = msg(this is a string, if(true, and, another) function) <<<", null)).get(0).compileRight();
-            fail("Did not expect test to pass");
-        } catch (ConfigCompileException e) {
-            //passed
-        }
-
-        MScriptCompiler.compile(MScriptCompiler.lex("if(1, msg('') msg(''))", null));
-    }
-
-    @Test
-    public void testExecute1() throws ConfigCompileException {
-        String script = "proc(_hello, @hello0,"
-                + "         msg(@hello0)"
-                + "      )"
-                + "      assign(@hello1, 'hello')"
-                + "      _hello(@hello1)";
-
-
-        MScriptCompiler.execute(MScriptCompiler.compile(MScriptCompiler.lex(script, null)), fakePlayer, null, null);
-        verify(fakePlayer).sendMessage("hello");
-    }
-
-    @Test
-    public void testExecute2() throws ConfigCompileException {
-        String script =
-                "proc(_hello,\n"
-                + "     assign(@hello, 'hello')\n"
-                + "     return(@hello)\n"
-                + ")\n"
-                + "assign(@blah, 'blah')\n"
-                + "assign(@blah, _hello())\n"
-                + "msg(@blah)\n";
-
-
-        MScriptCompiler.execute(MScriptCompiler.compile(MScriptCompiler.lex(script, null)), fakePlayer, null, null);
-        verify(fakePlayer).sendMessage("hello");
-    }
-
-    /**
-     * Here we are testing for mismatched (or empty) square brackets. Essentially, it should throw an exception.
-     */
-    @Test
-    public void testExecute3() {
-        try {
-            String script =
-                    "[";
-            MScriptCompiler.execute(MScriptCompiler.compile(MScriptCompiler.lex(script, null)), fakePlayer, null, null);
-            fail("Test passed, but wasn't supposed to");
-        } catch (ConfigCompileException ex) {
-            //Passed
-        }
-        try {
-            String script =
-                    "]";
-            MScriptCompiler.execute(MScriptCompiler.compile(MScriptCompiler.lex(script, null)), fakePlayer, null, null);
-            fail("Test passed, but wasn't supposed to");
-        } catch (ConfigCompileException ex) {
-            //Passed
-        }
-    }
-
-    @Test
-    public void testExecute4() throws ConfigCompileException {
-        String script =
-                "proc(_hello,"
-                + "     return('hello')"
-                + ")"
-                + "msg(_hello())";
-        MScriptCompiler.execute(MScriptCompiler.compile(MScriptCompiler.lex(script, null)), fakePlayer, null, null);
-        verify(fakePlayer).sendMessage("hello");
-    }
-
-    @Test
-    public void testExecute5() throws ConfigCompileException {
-        String script =
-                "proc(_hello,"
-                + "     return('hello')"
-                + ")"
-                + "msg(_hello())";
-        MScriptCompiler.execute(MScriptCompiler.compile(MScriptCompiler.lex(script, null)), fakePlayer, null, null);
-        verify(fakePlayer).sendMessage("hello");
-    }
-
-    @Test
-    public void testExecute6() throws ConfigCompileException {
-        String script =
-                "#This is a comment invalid()'\"'' function\n"
-                + "msg('hello')";
-        MScriptCompiler.execute(MScriptCompiler.compile(MScriptCompiler.lex(script, null)), fakePlayer, null, null);
-        verify(fakePlayer).sendMessage("hello");
-    }
-
-    @Test
-    public void testExecute7() throws ConfigCompileException {
-        String script =
-                "msg('hello') #This is a comment too invalid()'\"'' function\n";
-        MScriptCompiler.execute(MScriptCompiler.compile(MScriptCompiler.lex(script, null)), fakePlayer, null, null);
-        verify(fakePlayer).sendMessage("hello");
-    }
-
-    @Test(expected=ConfigCompileException.class)
-    public void testExecute8() throws ConfigCompileException {
-        String script =
-                "msg('hello') //This is no longer a comment too :( invalid()'\"'' function\n";
-        MScriptCompiler.execute(MScriptCompiler.compile(MScriptCompiler.lex(script, null)), fakePlayer, null, null);
-        verify(fakePlayer).sendMessage("hello");
-    }
-
-    @Test
-    public void testExecute9() throws ConfigCompileException {
-        String script =
-                "msg('hello') /* This is a comment too invalid()'\"'' function\n"
-                + "yup, still a comment. yay() */";
-        MScriptCompiler.execute(MScriptCompiler.compile(MScriptCompiler.lex(script, null)), fakePlayer, null, null);
-        verify(fakePlayer).sendMessage("hello");
-    }
-
-    @Test(expected = ConfigCompileException.class)
-    public void testExecute10() throws ConfigCompileException {
-        String script =
-                "msg('hello') /* This is a comment too invalid()'\"'' function\n"
-                + "yup, still a comment. yay() This will fail though, because the comment is unended.";
-        MScriptCompiler.execute(MScriptCompiler.compile(MScriptCompiler.lex(script, null)), fakePlayer, null, null);
-    }
-
-    @Test(expected = ConfigCompileException.class)
-    public void testExecute11() throws ConfigCompileException {
-        String script =
-                "msg('hello') 'unended string";
-        MScriptCompiler.execute(MScriptCompiler.compile(MScriptCompiler.lex(script, null)), fakePlayer, null, null);
-    }
-
-    @Test
-    public void testExecute12() throws ConfigCompileException {
-        String script =
-                "msg('hello') /* This is a comment too invalid()'\"'' function\n"
-                + "yup, still a comment. yay() */";
-        MScriptCompiler.execute(MScriptCompiler.compile(MScriptCompiler.lex(script, null)), fakePlayer, null, null);
-        verify(fakePlayer).sendMessage("hello");
-    } 
-    
-    @Test
-    public void testExecute13() throws ConfigCompileException {
-        String script =
-                "assign(@a, array(0, 1, 2))"
-                + "msg(@a[0])";
-        MScriptCompiler.execute(MScriptCompiler.compile(MScriptCompiler.lex(script, null)), fakePlayer, null, null);
-        verify(fakePlayer).sendMessage("0");
-    }
-    
-    @Test
-    public void testExecute14() throws ConfigCompileException {
-        String script =
-                "proc(_hello, assign(@i, 'world'),"
-                + "     return(@i)"
-                + ")"
-                + "msg(_hello('hello'))"
-                + "msg(_hello())";
-        MScriptCompiler.execute(MScriptCompiler.compile(MScriptCompiler.lex(script, null)), fakePlayer, null, null);
-        verify(fakePlayer).sendMessage("hello");
-        verify(fakePlayer).sendMessage("world");
-    }
-    
-    @Test public void testExecute15() throws ConfigCompileException{
-        String script =
-                "assign(@i, 0)\n"
-                + "msg('@i is currently' @i)\n"
-                + "proc(_out, @i,\n"
-                + "     msg('@i is currently' @i 'and @j is' @j)\n"
-                + ")\n"
-                + "_out('hello')\n"
-                + "assign(@j, 'goodbye')\n"
-                + "_out('world')\n";
-        MScriptCompiler.execute(MScriptCompiler.compile(MScriptCompiler.lex(script, null)), fakePlayer, null, null);
-        verify(fakePlayer).sendMessage("@i is currently 0");
-        verify(fakePlayer).sendMessage("@i is currently hello and @j is");
-        verify(fakePlayer).sendMessage("@i is currently world and @j is");
-    }
-    
-    @Test public void testExecute16() throws ConfigCompileException{
-        String script =
-                "proc(_myProc, @i, @j, @k, msg(@i @j @k))\n"
-                + "_myProc()\n"
-                + "_myProc(1)\n"
-                + "_myProc(1, 2)\n"
-                + "_myProc(1, 2, 3)\n"
-                + "_myProc(1, 2, 3, 4)\n";
-        MScriptCompiler.execute(MScriptCompiler.compile(MScriptCompiler.lex(script, null)), fakePlayer, null, null);
-        //verify(fakePlayer).sendMessage("null null null");
-        verify(fakePlayer).sendMessage("1");
-        verify(fakePlayer).sendMessage("1 2");
-        verify(fakePlayer, times(2)).sendMessage("1 2 3");
-    }
-    
-    @Test public void testExecute17() throws ConfigCompileException{
-        String script =
-                "proc(_addition, @i, @j, msg(add(@i, @j)))\n"
-                + "_addition(1, 1)\n"
-                + "_addition(2, 2)";
-        MScriptCompiler.execute(MScriptCompiler.compile(MScriptCompiler.lex(script, null)), fakePlayer, null, null);
-        //verify(fakePlayer).sendMessage("null null null");
-        verify(fakePlayer).sendMessage("2");
-        verify(fakePlayer).sendMessage("4");       
-    }
-    
-    @Test public void testExecute18() throws ConfigCompileException{
-        String script =
-                "proc(_myProc, msg(@arguments))\n"
-                + "_myProc()\n"
-                + "_myProc(1)\n"
-                + "_myProc(1, 2)";
-        MScriptCompiler.execute(MScriptCompiler.compile(MScriptCompiler.lex(script, null)), fakePlayer, null, null);
-        //verify(fakePlayer).sendMessage("null null null");
-        verify(fakePlayer).sendMessage("{}");
-        verify(fakePlayer).sendMessage("{1}");       
-        verify(fakePlayer).sendMessage("{1, 2}");       
-    }
-    
-    /**
-     * Variables are locked in when the procedure is defined
-     * @throws ConfigCompileException 
-     */
-    @Test
-    public void testExecute19() throws ConfigCompileException {
-        String script =
-                "assign(@j, 'world')\n"
-                + "proc(_hello, assign(@i, @j),"
-                + "     return(@i)"
-                + ")\n"
-                + "assign(@j, 'goodbye')\n"
-                + "msg(_hello('hello'))"
-                + "msg(_hello())";
-        MScriptCompiler.execute(MScriptCompiler.compile(MScriptCompiler.lex(script, null)), fakePlayer, null, null);
-        verify(fakePlayer).sendMessage("hello");
-        verify(fakePlayer).sendMessage("world");
-    }
-    @Test
-    public void testExecute20() throws ConfigCompileException {
-        final AtomicBoolean bool = new AtomicBoolean(false);
-        String script =
-                "msg('hello') world";
-        MScriptCompiler.execute(MScriptCompiler.compile(MScriptCompiler.lex(script, null)), fakePlayer, new MScriptComplete() {
-
-            public void done(String output) {
-                assertEquals("world", output.trim());
-                bool.set(true);
-            }
-        }, null);
-        verify(fakePlayer).sendMessage("hello");
-        assertTrue(bool.get());
-    }
-
-    @Test
-    public void testCompile1() {
-        try {
-            String config = "/cmd [$p] $q = msg('')";
-            MScriptCompiler.preprocess(MScriptCompiler.lex(config, null)).get(0).compile();
-            fail("Test passed, but wasn't supposed to");
-        } catch (ConfigCompileException ex) {
-            //Passed
-        }
-    }
-
-    @Test
-    public void testCompile2() {
-        try {
-            String config = "/cmd [$p=player()] = msg('')";
-            MScriptCompiler.preprocess(MScriptCompiler.lex(config, null)).get(0).compile();
-            fail("Test passed, but wasn't supposed to");
-        } catch (ConfigCompileException ex) {
-            //Passed
-        }
-    }
-
-    @Test
-    public void testCompile4() throws ConfigCompileException {
-        String config = "/cmd = >>>\n"
-                + "msg('hello') #This is a comment too invalid()'\"'' function\n"
-                + "<<<";
-        MScriptCompiler.preprocess(MScriptCompiler.lex(config, null));
-    }
-    
-    @Test
-    public void testCompile5() throws ConfigCompileException {
-        String config = "label:/cmd = >>>\n"
-                + "msg('hello') #This is a comment too invalid()'\"'' function\n"
-                + "<<<";
-        Script s = MScriptCompiler.preprocess(MScriptCompiler.lex(config, null)).get(0);
-        s.compile();
-        assertEquals("label", s.label);
-    }
-    
-    @Test
-    public void testCompile6() throws ConfigCompileException {
-        String config = "/cmd = >>>\n"
-                + "msg(hello 'world \\\\ \\' \\n')"
-                + "<<<";
-        Script s = MScriptCompiler.preprocess(MScriptCompiler.lex(config, null)).get(0);
-        s.compile();
-        s.run(new ArrayList<Variable>(), fakePlayer, null);
-        verify(fakePlayer).sendMessage("hello world \\ ' ".trim());
-    }
-    
-    @Test
-    public void testCompile7() throws ConfigCompileException {
-        String config = "/cmd = >>>\n"
-                + "msg(hello) \\ msg(world)"
-                + "<<<";
-        Script s = MScriptCompiler.preprocess(MScriptCompiler.lex(config, null)).get(0);
-        s.compile();
-        s.run(new ArrayList<Variable>(), fakePlayer, null);
-        verify(fakePlayer).sendMessage("hello");
-        verify(fakePlayer).sendMessage("world");
-    }
-    
-    @Test
-    public void testCompile8() throws ConfigCompileException {
-        String config = "/cmd $one $ = >>>\n"
-                + "msg($one) \\ msg($)"
-                + "<<<";
-        Script s = MScriptCompiler.preprocess(MScriptCompiler.lex(config, null)).get(0);
-        s.compile();
-        s.run(Arrays.asList(new Variable[]{new Variable("$one", "first", false, false, 0, null),
-            new Variable("$", "several variables", false, true, 0, null)}), fakePlayer, null);
-        verify(fakePlayer).sendMessage("first");
-        verify(fakePlayer).sendMessage("several variables");
-    }
-    
-    @Test
-    public void testCompile9() throws ConfigCompileException {
-        String config = "/test [$var=1] = >>>\n"
-                + "msg($var)"
-                + "<<<";
-        Script s = MScriptCompiler.preprocess(MScriptCompiler.lex(config, null)).get(0);
-        s.compile();
-        assertTrue(s.match("/test 2"));
-        s.run(Arrays.asList(new Variable[]{new Variable("$var", "2", true, false, 0, null)}), fakePlayer, null);
-        verify(fakePlayer).sendMessage("2");
-        assertTrue(s.match("/test"));
-        s.run(new ArrayList<Variable>(), fakePlayer, null);
-        verify(fakePlayer).sendMessage("1");
-    }
-    
-    @Test
-    public void testCompile10() throws ConfigCompileException{
-        String config = "/test $var = >>>\n"
-                + "msg($var)"
-                + "<<<";
-        Script s = MScriptCompiler.preprocess(MScriptCompiler.lex(config, null)).get(0);
-        s.compile();
-        assertTrue(s.match("/test 2"));
-        assertFalse(s.match("/test"));
-        s.run(Arrays.asList(new Variable[]{new Variable("$var", "2", true, false, 0, null)}), fakePlayer, null);
-    }
-    
-    @Test public void testCompile11() throws ConfigCompileException{
-        
-        CommandHelperPlugin.perms = mock(PermissionsResolverManager.class);
-        when(CommandHelperPlugin.perms.hasPermission(fakePlayer.getName(), "ch.alias.safe")).thenReturn(true);
-        CommandHelperPlugin.myServer = fakeServer;
-        when(fakeServer.getOnlinePlayers()).thenReturn(new Player[]{fakePlayer});
-        String config = "safe:/test $var = >>>\n"
-                + "all_players()\n"
-                + "msg($var)\n"
-                + "<<<";
-        Script s = MScriptCompiler.preprocess(MScriptCompiler.lex(config, null)).get(0);        
-        s.compile();
-        assertEquals("safe", s.label);
-        assertTrue(s.match("/test 2"));
-        s.run(Arrays.asList(new Variable[]{new Variable("$var", "2", true, false, 0, null)}), fakePlayer, null);
-        verify(fakePlayer).sendMessage("2");
-        verify(CommandHelperPlugin.perms).hasPermission(fakePlayer.getName(), "ch.alias.safe");
-    }
-    
-    @Test public void testUnicode() throws ConfigCompileException{
-        SRun("msg('\\u0037 is win!')", fakePlayer);
-        verify(fakePlayer).sendMessage("7 is win!");
-    }
-    
-    
-}
diff --git a/src/test/java/com/laytonsmith/aliasengine/ScriptTest.java b/src/test/java/com/laytonsmith/aliasengine/ScriptTest.java
deleted file mode 100644
index a9bd066..0000000
--- a/src/test/java/com/laytonsmith/aliasengine/ScriptTest.java
+++ /dev/null
@@ -1,139 +0,0 @@
-/*
- * To change this template, choose Tools | Templates
- * and open the template in the editor.
- */
-package com.laytonsmith.aliasengine;
-
-import com.laytonsmith.aliasengine.Constructs.Construct;
-import com.laytonsmith.aliasengine.Constructs.Variable;
-import java.util.ArrayList;
-import java.util.List;
-import org.bukkit.entity.Player;
-import org.junit.After;
-import org.junit.AfterClass;
-import org.junit.Before;
-import org.junit.BeforeClass;
-import org.junit.Test;
-import static org.junit.Assert.*;
-
-/**
- *
- * @author Layton
- */
-public class ScriptTest {
-    
-    public ScriptTest() {
-    }
-
-    @BeforeClass
-    public static void setUpClass() throws Exception {
-    }
-
-    @AfterClass
-    public static void tearDownClass() throws Exception {
-    }
-    
-    @Before
-    public void setUp() {
-    }
-    
-    @After
-    public void tearDown() {
-    }
-
-//    @Test
-//    public void testToString() {
-//        System.out.println("toString");
-//        Script instance = new Script(null, null);
-//        assertTrue(instance.toString().length() > 0);
-//    }
-
-//    @Test
-//    public void testUncompilable() {
-//        System.out.println("uncompilable");
-//        Script instance = null;
-//        boolean expResult = false;
-//        boolean result = instance.uncompilable();
-//        assertEquals(expResult, result);
-//        // TODO review the generated test code and remove the default call to fail.
-//        fail("The test case is a prototype.");
-//    }
-//
-//    @Test
-//    public void testRun() {
-//        System.out.println("run");
-//        List<Variable> vars = null;
-//        Player p = null;
-//        MScriptComplete done = null;
-//        Script instance = null;
-//        instance.run(vars, p, done);
-//        // TODO review the generated test code and remove the default call to fail.
-//        fail("The test case is a prototype.");
-//    }
-//
-//    @Test
-//    public void testEval() throws Exception {
-//        System.out.println("eval");
-//        GenericTreeNode<Construct> c = null;
-//        Player player = null;
-//        List<Variable> vars = null;
-//        Script instance = null;
-//        Construct expResult = null;
-//        Construct result = instance.eval(c, player, vars);
-//        assertEquals(expResult, result);
-//        // TODO review the generated test code and remove the default call to fail.
-//        fail("The test case is a prototype.");
-//    }
-//
-//    @Test
-//    public void testMatch() {
-//        System.out.println("match");
-//        String command = "";
-//        Script instance = null;
-//        boolean expResult = false;
-//        boolean result = instance.match(command);
-//        assertEquals(expResult, result);
-//        // TODO review the generated test code and remove the default call to fail.
-//        fail("The test case is a prototype.");
-//    }
-//
-//    @Test
-//    public void testGetVariables() {
-//        System.out.println("getVariables");
-//        String command = "";
-//        Script instance = null;
-//        List expResult = null;
-//        List result = instance.getVariables(command);
-//        assertEquals(expResult, result);
-//        // TODO review the generated test code and remove the default call to fail.
-//        fail("The test case is a prototype.");
-//    }
-//
-//    @Test
-//    public void testCompile() throws Exception {
-//        System.out.println("compile");
-//        Script instance = null;
-//        instance.compile();
-//        // TODO review the generated test code and remove the default call to fail.
-//        fail("The test case is a prototype.");
-//    }
-//
-//    @Test
-//    public void testCompileRight() throws Exception {
-//        System.out.println("compileRight");
-//        Script instance = null;
-//        instance.compileRight();
-//        // TODO review the generated test code and remove the default call to fail.
-//        fail("The test case is a prototype.");
-//    }
-//
-//    @Test
-//    public void testCheckAmbiguous() throws Exception {
-//        System.out.println("checkAmbiguous");
-//        ArrayList<Script> scripts = null;
-//        Script instance = null;
-//        instance.checkAmbiguous(scripts);
-//        // TODO review the generated test code and remove the default call to fail.
-//        fail("The test case is a prototype.");
-//    }
-}
diff --git a/src/test/java/com/laytonsmith/aliasengine/TestStatic.java b/src/test/java/com/laytonsmith/aliasengine/TestStatic.java
deleted file mode 100644
index 62b17a3..0000000
--- a/src/test/java/com/laytonsmith/aliasengine/TestStatic.java
+++ /dev/null
@@ -1,149 +0,0 @@
-/*
- * To change this template, choose Tools | Templates
- * and open the template in the editor.
- */
-package com.laytonsmith.aliasengine;
-
-import com.laytonsmith.aliasengine.functions.exceptions.ConfigRuntimeException;
-import com.laytonsmith.aliasengine.Constructs.*;
-import com.laytonsmith.testing.C;
-import org.junit.AfterClass;
-import org.junit.Before;
-import org.junit.BeforeClass;
-import org.junit.Test;
-import static org.junit.Assert.*;
-
-/**
- *
- * @author Layton
- */
-public class TestStatic {
-    
-    public TestStatic() {
-    }
-
-    @BeforeClass
-    public static void setUpClass() throws Exception {
-    }
-
-    @AfterClass
-    public static void tearDownClass() throws Exception {
-    }
-    
-    @Before
-    public void setUp() {
-    }
-
-    @Test
-    public void testGetNumber() {
-        System.out.println("getNumber");
-        assertEquals(1.0, Static.getNumber(C.String("1.0")), 0.0);
-        assertEquals(1.0, Static.getNumber(C.String("1")), 0.0);
-        assertEquals(1.0, Static.getNumber(C.Int(1)), 0.0);
-        assertEquals(1.0, Static.getNumber(C.Double(1.0)), 0.0);
-    }
-
-    @Test
-    public void testGetDouble() {
-        System.out.println("getDouble");
-        assertEquals(1.0, Static.getDouble(C.String("1.0")), 0.0);
-        assertEquals(1.0, Static.getDouble(C.String("1")), 0.0);
-        assertEquals(1.0, Static.getDouble(C.Int(1)), 0.0);
-        assertEquals(1.0, Static.getDouble(C.Double(1.0)), 0.0);
-    }
-
-    @Test
-    public void testGetInt() {
-        System.out.println("getInt");
-        assertEquals(1, Static.getInt(C.Int(1)));
-        assertEquals(1, Static.getInt(C.String("1")));
-        try{
-            Static.getInt(C.Double(1.0));
-            fail("Should not have been able to parse 1.0 as an int");
-        } catch(ConfigRuntimeException e){ /* Test Passed */ }
-    }
-
-    @Test
-    public void testGetBoolean() {
-        System.out.println("getBoolean");
-        assertEquals(true, Static.getBoolean(C.Boolean(true)));
-        assertEquals(true, Static.getBoolean(C.String("non-empty string")));
-        assertEquals(false, Static.getBoolean(C.String("")));
-        assertEquals(true, Static.getBoolean(C.Int(1)));
-        assertEquals(false, Static.getBoolean(C.Int(0)));
-    }
-
-    @Test
-    public void testAnyDoubles() {
-        System.out.println("anyDoubles");
-        assertTrue(Static.anyDoubles(C.Int(0), C.Int(1), C.Double(1)));
-        assertFalse(Static.anyDoubles(C.Int(1)));
-    }
-
-    @Test
-    public void testAnyStrings() {
-        System.out.println("anyStrings");
-        assertTrue(Static.anyStrings(C.Int(0), C.Int(1), C.String("")));
-        assertFalse(Static.anyStrings(C.Int(1)));
-    }
-
-    @Test
-    public void testAnyBooleans() {
-        System.out.println("anyBooleans");
-        assertTrue(Static.anyBooleans(C.Int(0), C.Int(1), C.Boolean(true)));
-        assertFalse(Static.anyBooleans(C.Int(1)));
-    }
-
-    @Test
-    public void testGetLogger() {
-        System.out.println("getLogger");
-        assertNotNull(Static.getLogger());
-    }
-
-////    @Test(expected=NotInitializedYetException.class)
-////    public void testGetServer() {
-////        System.out.println("getServer");
-////        Static.getServer();
-////    }
-
-    @Test(expected=NotInitializedYetException.class)
-    public void testGetAliasCore() {
-        System.out.println("getAliasCore");
-        Static.getAliasCore();
-    }
-
-    @Test(expected=NotInitializedYetException.class)
-    public void testGetPersistance() {
-        System.out.println("getPersistance");
-        Static.getPersistance();
-    }
-
-//    @Test(expected=NotInitializedYetException.class)
-//    public void testGetPermissionsResolverManager() {
-//        System.out.println("getPermissionsResolverManager");
-//        Static.getPermissionsResolverManager();
-//    }
-
-    @Test(expected=NotInitializedYetException.class)
-    public void testGetVersion() {
-        System.out.println("getVersion");
-        Static.getVersion();
-    }
-
-    @Test
-    public void testGetPreferences() {
-        System.out.println("getPreferences");
-        Static.getPreferences();
-    }
-
-    @Test
-    public void testResolveConstruct() {
-        System.out.println("resolveConstruct");
-        assertTrue(Static.resolveConstruct("1", 0, null) instanceof CInt);
-        assertTrue(Static.resolveConstruct("true", 0, null) instanceof CBoolean);
-        assertTrue(Static.resolveConstruct("false", 0, null) instanceof CBoolean);
-        assertTrue(Static.resolveConstruct("null", 0, null) instanceof CNull);
-        assertTrue(Static.resolveConstruct("1.1", 0, null) instanceof CDouble);
-        assertTrue(Static.resolveConstruct("string", 0, null) instanceof CString);
-    }
-}
diff --git a/src/test/java/com/laytonsmith/aliasengine/functions/ArrayHandlingTest.java b/src/test/java/com/laytonsmith/aliasengine/functions/ArrayHandlingTest.java
deleted file mode 100644
index b0431dc..0000000
--- a/src/test/java/com/laytonsmith/aliasengine/functions/ArrayHandlingTest.java
+++ /dev/null
@@ -1,183 +0,0 @@
-/*
- * To change this template, choose Tools | Templates
- * and open the template in the editor.
- */
-package com.laytonsmith.aliasengine.functions;
-
-import com.laytonsmith.aliasengine.MScriptCompiler;
-import com.laytonsmith.aliasengine.Constructs.Construct;
-import com.laytonsmith.aliasengine.functions.exceptions.CancelCommandException;
-import com.laytonsmith.aliasengine.functions.exceptions.ConfigCompileException;
-import com.laytonsmith.aliasengine.functions.exceptions.ConfigRuntimeException;
-import com.laytonsmith.aliasengine.Constructs.CArray;
-import com.laytonsmith.aliasengine.Constructs.CInt;
-import com.laytonsmith.testing.C;
-import com.laytonsmith.testing.StaticTest;
-import org.bukkit.entity.Player;
-import org.junit.Before;
-import org.junit.Test;
-import static org.mockito.Mockito.*;
-import static com.laytonsmith.testing.StaticTest.*;
-import static org.junit.Assert.*;
-
-/**
- *
- * @author Layton
- */
-public class ArrayHandlingTest {
-
-    static Player fakePlayer;
-    static CArray commonArray;
-
-    public ArrayHandlingTest() {
-    }
-
-    @Before
-    public void setUp() {
-        fakePlayer = StaticTest.GetOnlinePlayer();
-        commonArray = new CArray(0, null, new CInt(1, 0, null), new CInt(2, 0, null), new CInt(3, 0, null));
-    }
-
-    /**
-     * Test of docs method, of class ArrayHandling.
-     */
-    @Test
-    public void testDocs() {
-        TestClassDocs(ArrayHandling.docs(), ArrayHandling.class);
-    }
-
-    @Test
-    public void testArraySize() throws ConfigCompileException, CancelCommandException {
-        ArrayHandling.array_size a = new ArrayHandling.array_size();
-        TestBoilerplate(a, "array_size");
-        CArray arr = commonArray;
-        Construct ret = a.exec(0, null, fakePlayer, arr);
-        assertReturn(ret, C.Int);
-        assertCEquals(C.onstruct(3), ret);
-    }
-    
-    @Test(expected=Exception.class)
-    public void testArraySizeEx() throws CancelCommandException{
-        ArrayHandling.array_size a = new ArrayHandling.array_size();
-        a.exec(0, null, fakePlayer, C.Int(0));
-    }
-
-    @Test
-    public void testArraySet1() throws  ConfigCompileException {
-        String script =
-                "assign(@array, array(1,2,3)) msg(@array) array_set(@array, 2, 1) msg(@array)";
-        //MScriptCompiler.execute(MScriptCompiler.compile(MScriptCompiler.lex(script, null)), fakePlayer, null, null);
-        StaticTest.Run(script, fakePlayer);
-        verify(fakePlayer).sendMessage("{1, 2, 3}");
-        verify(fakePlayer).sendMessage("{1, 2, 1}");
-    }
-    
-    @Test public void testArraySet2() throws ConfigCompileException{
-        SRun("assign(@array, array(1, 2)) assign(@array2, @array) array_set(@array, 0, 2) msg(@array) msg(@array2)", fakePlayer);
-        verify(fakePlayer, times(2)).sendMessage("{2, 2}");
-    }
-    
-    @Test public void testArrayReferenceBeingCorrect() throws ConfigCompileException{
-        SRun("assign(@array, array(1, 2)) assign(@array2, @array[]) array_set(@array, 0, 2) msg(@array) msg(@array2)", fakePlayer);
-        verify(fakePlayer).sendMessage("{2, 2}");
-        verify(fakePlayer).sendMessage("{1, 2}");
-    }
-    
-    @Test public void testArrayReferenceBeingCorrectWithArrayGet() throws ConfigCompileException{
-        SRun("assign(@array, array(1, 2)) assign(@array2, array_get(@array)) array_set(@array, 0, 2) msg(@array) msg(@array2)", fakePlayer);
-        verify(fakePlayer).sendMessage("{2, 2}");
-        verify(fakePlayer).sendMessage("{1, 2}");
-    }
-    
-    @Test(expected=ConfigRuntimeException.class)
-    public void testArraySetEx() throws CancelCommandException, ConfigCompileException{
-        String script =
-                "assign(@array, array()) array_set(@array, 3, 1) msg(@array)";
-        MScriptCompiler.execute(MScriptCompiler.compile(MScriptCompiler.lex(script, null)), fakePlayer, null, null);
-    }
-
-    @Test
-    public void testArrayContains() throws CancelCommandException {
-        ArrayHandling.array_contains a = new ArrayHandling.array_contains();
-        TestBoilerplate(a, "array_contains");
-        assertCEquals(C.onstruct(true), a.exec(0, null, fakePlayer, commonArray, C.onstruct(1)));
-        assertCEquals(C.onstruct(false), a.exec(0, null, fakePlayer, commonArray, C.onstruct(55)));
-    }
-    
-    @Test(expected=Exception.class)
-    public void testArrayContainsEx() throws CancelCommandException{
-        ArrayHandling.array_contains a = new ArrayHandling.array_contains();
-        a.exec(0, null, fakePlayer, C.Int(0), C.Int(1));
-    }
-
-    @Test
-    public void testArrayGet() throws CancelCommandException {
-        ArrayHandling.array_get a = new ArrayHandling.array_get();
-        TestBoilerplate(a, "array_get");
-        assertCEquals(C.onstruct(1), a.exec(0, null, fakePlayer, commonArray, C.onstruct(0)));
-    }
-    
-    @Test(expected=Exception.class)
-    public void testArrayGetEx() throws CancelCommandException{
-        ArrayHandling.array_get a = new ArrayHandling.array_get();
-        a.exec(0, null, fakePlayer, C.Int(0), C.Int(1));
-    }
-
-    @Test(expected = ConfigRuntimeException.class)
-    public void testArrayGetBad() throws CancelCommandException {
-        ArrayHandling.array_get a = new ArrayHandling.array_get();
-        a.exec(0, null, fakePlayer, commonArray, C.onstruct(55));
-    }
-
-    @Test
-    public void testArrayPush() throws CancelCommandException {
-        ArrayHandling.array_push a = new ArrayHandling.array_push();
-        TestBoilerplate(a, "array_push");
-        assertReturn(a.exec(0, null, fakePlayer, commonArray, C.onstruct(4)), C.Void);
-        assertCEquals(C.onstruct(1), commonArray.get(0, 0));
-        assertCEquals(C.onstruct(2), commonArray.get(1, 0));
-        assertCEquals(C.onstruct(3), commonArray.get(2, 0));
-        assertCEquals(C.onstruct(4), commonArray.get(3, 0));
-    }
-    
-    @Test(expected=Exception.class)
-    public void testArrayPushEx() throws CancelCommandException{
-        ArrayHandling.array_push a = new ArrayHandling.array_push();
-        a.exec(0, null, fakePlayer, C.Int(0), C.Int(1));
-    }
-    
-    @Test public void testArrayResize() throws ConfigCompileException{
-        String script = "assign(@array, array(1)) msg(@array) array_resize(@array, 2) msg(@array) array_resize(@array, 3, 'hello') msg(@array)";
-        StaticTest.Run(script, fakePlayer);
-        verify(fakePlayer).sendMessage("{1}");
-        verify(fakePlayer).sendMessage("{1, null}");
-        verify(fakePlayer).sendMessage("{1, null, hello}");
-    }
-    
-    /**
-     * Because we are testing a loop, we put in an infinite loop detection of 10 seconds
-     * @throws ConfigCompileException 
-     */
-    @Test(timeout=10000) 
-    public void testRange() throws ConfigCompileException{
-        assertEquals("{0, 1, 2, 3, 4, 5, 6, 7, 8, 9}", SRun("range(10)", fakePlayer));
-        assertEquals("{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}", SRun("range(1, 11)", fakePlayer));
-        assertEquals("{0, 5, 10, 15, 20, 25}", SRun("range(0, 30, 5)", fakePlayer));
-        assertEquals("{0, 3, 6, 9}", SRun("range(0, 10, 3)", fakePlayer));
-        assertEquals("{0, -1, -2, -3, -4, -5, -6, -7, -8, -9}", SRun("range(0, -10, -1)", fakePlayer));
-        assertEquals("{}", SRun("range(0)", fakePlayer));
-        assertEquals("{}", SRun("range(1, 0)", fakePlayer));
-    }
-    
-    @Test public void testArraySliceAndNegativeIndexes() throws ConfigCompileException{
-        assertEquals("e", SRun("array(a, b, c, d, e)[-1]", null));
-        assertEquals("{a, b, c, d, e}", SRun("array(a, b, c, d, e)[]", null));
-        assertEquals("{b, c}", SRun("array(a, b, c, d, e)[1..2]", null));
-        assertEquals("{b, c, d, e}", SRun("array(a, b, c, d, e)[1..-1]", null));
-        assertEquals("1", SRun("array(a, array(1, 2), c, d, e)[0..1][1][0]", null));
-        assertEquals("{a, b}", SRun("array(a, b, c, d, e)[..1]", null));
-        assertEquals("{c, d, e}", SRun("array(a, b, c, d, e)[2..]", null));
-        assertEquals("{}", SRun("array(1, 2, 3, 4, 5)[3..0]", null));
-        assertEquals("{a, b}", SRun("array_get(array(a, b))", null));
-    }
-}
diff --git a/src/test/java/com/laytonsmith/aliasengine/functions/BasicLogicTest.java b/src/test/java/com/laytonsmith/aliasengine/functions/BasicLogicTest.java
deleted file mode 100644
index 837c520..0000000
--- a/src/test/java/com/laytonsmith/aliasengine/functions/BasicLogicTest.java
+++ /dev/null
@@ -1,161 +0,0 @@
-/*
- * To change this template, choose Tools | Templates
- * and open the template in the editor.
- */
-package com.laytonsmith.aliasengine.functions;
-
-import org.bukkit.Server;
-import com.laytonsmith.aliasengine.functions.exceptions.CancelCommandException;
-import com.laytonsmith.aliasengine.Constructs.*;
-import com.laytonsmith.aliasengine.functions.exceptions.ConfigCompileException;
-import com.laytonsmith.testing.C;
-import org.bukkit.entity.Player;
-import org.junit.After;
-import org.junit.AfterClass;
-import org.junit.Before;
-import org.junit.BeforeClass;
-import org.junit.Test;
-import static com.laytonsmith.testing.StaticTest.*;
-import static org.mockito.Mockito.*;
-
-/**
- *
- * @author Layton
- */
-public class BasicLogicTest {
-    
-    Player fakePlayer;
-    Server fakeServer;
-    CArray commonArray;
-    CInt arg1_1;
-    CInt arg1_2;
-    CInt arg2_1;
-    CInt argn1_1;
-    CInt argn2_1;
-    CBoolean _true;
-    CBoolean _false;
-    
-    public BasicLogicTest() {
-    }
-
-    @BeforeClass
-    public static void setUpClass() throws Exception {
-    }
-
-    @AfterClass
-    public static void tearDownClass() throws Exception {
-    }
-    
-    @Before
-    public void setUp() {
-        commonArray = C.Array(C.Null(), C.Int(1), C.String("2"), C.Double(3.0));
-        arg1_1 = C.Int(1);
-        arg1_2 = C.Int(1);
-        arg2_1 = C.Int(2);
-        argn1_1 = C.Int(-1);
-        argn2_1 = C.Int(-2);
-        _true = C.Boolean(true);
-        _false = C.Boolean(false);
-        fakeServer = GetFakeServer();
-        fakePlayer = GetOnlinePlayer(fakeServer);
-    }
-    
-    @After
-    public void tearDown() {
-    }
-
-    @Test
-    public void testDocs() {
-        TestClassDocs(BasicLogic.docs(), BasicLogic.class);
-    }
-    
-    @Test
-    public void testEquals() throws CancelCommandException{
-        BasicLogic.equals e = new BasicLogic.equals();
-        Construct ret = null;
-        assertCTrue(e.exec(0, null, fakePlayer, arg1_1, arg1_2));
-        assertCFalse(e.exec(0, null, fakePlayer, arg1_1, arg2_1));
-        assertCFalse(e.exec(0, null, fakePlayer, argn1_1, arg1_1));
-        assertCFalse(e.exec(0, null, fakePlayer, C.onstruct(1), C.onstruct("string")));
-    }
-    
-    public void testEqualsIC() throws ConfigCompileException{
-        SRun("if(equals_ic('hi', 'HI'), msg('pass'))", fakePlayer);
-        SRun("if(equals_ic('hi', 'hi'), msg('pass'))", fakePlayer);
-        SRun("if(not(equals_ic('what', 'hi')), msg('pass'))", fakePlayer);
-        SRun("if(equals_ic(2, 2), msg('pass'))", fakePlayer);
-        SRun("if(not(equals_ic(2, 'hi')), msg('pass'))", fakePlayer);
-        verify(fakePlayer, times(5)).sendMessage("pass");
-    }
-    
-    @Test public void testAnd() throws CancelCommandException{
-        BasicLogic.and a = new BasicLogic.and();
-        assertCTrue(a.exec(0, null, fakePlayer, _true, _true, _true));
-        assertCFalse(a.exec(0, null, fakePlayer, _true, _true, _false));
-        assertCTrue(a.exec(0, null, fakePlayer, _true, _true));
-        assertCFalse(a.exec(0, null, fakePlayer, _true, _false));
-        assertCFalse(a.exec(0, null,fakePlayer, _false, _false));
-        assertCTrue(a.exec(0, null, fakePlayer, _true));
-        assertCFalse(a.exec(0, null, fakePlayer, _false));
-    }
-    
-    @Test public void testOr() throws CancelCommandException{
-        BasicLogic.or a = new BasicLogic.or();
-        assertCTrue(a.exec(0, null, fakePlayer, _true, _true, _true));
-        assertCTrue(a.exec(0, null, fakePlayer, _true, _true, _false));
-        assertCTrue(a.exec(0, null, fakePlayer, _true, _true));
-        assertCTrue(a.exec(0, null, fakePlayer, _true, _false));
-        assertCFalse(a.exec(0, null, fakePlayer, _false, _false));
-        assertCTrue(a.exec(0, null, fakePlayer, _true));
-        assertCFalse(a.exec(0, null, fakePlayer, _false));
-    }
-    
-    @Test public void testNot() throws CancelCommandException{
-        BasicLogic.not a = new BasicLogic.not();
-        assertCFalse(a.exec(0, null, fakePlayer, _true));
-        assertCTrue(a.exec(0, null, fakePlayer, _false));
-    }
-    
-    @Test public void testGt() throws CancelCommandException{
-        BasicLogic.gt a = new BasicLogic.gt();
-        assertCFalse(a.exec(0, null, fakePlayer, arg1_1, arg1_2));
-        assertCTrue(a.exec(0, null, fakePlayer, arg2_1, arg1_1));
-        assertCFalse(a.exec(0, null, fakePlayer, arg1_1, arg2_1));
-        assertCFalse(a.exec(0, null, fakePlayer, argn1_1, arg1_1));
-        assertCTrue(a.exec(0, null, fakePlayer, arg1_1, argn1_1));
-    }
-    
-    @Test public void testGte() throws CancelCommandException{
-        BasicLogic.gte a = new BasicLogic.gte();
-        assertCTrue(a.exec(0, null, fakePlayer, arg1_1, arg1_2));
-        assertCTrue(a.exec(0, null, fakePlayer, arg2_1, arg1_1));
-        assertCFalse(a.exec(0, null, fakePlayer, arg1_1, arg2_1));
-        assertCFalse(a.exec(0, null, fakePlayer, argn1_1, arg1_1));
-        assertCTrue(a.exec(0, null, fakePlayer, arg1_1, argn1_1));
-    }
-    
-    @Test public void testLt() throws CancelCommandException{
-        BasicLogic.lt a = new BasicLogic.lt();
-        assertCFalse(a.exec(0, null, fakePlayer, arg1_1, arg1_2));
-        assertCFalse(a.exec(0, null, fakePlayer, arg2_1, arg1_1));
-        assertCTrue(a.exec(0, null, fakePlayer, arg1_1, arg2_1));
-        assertCTrue(a.exec(0, null, fakePlayer, argn1_1, arg1_1));
-        assertCFalse(a.exec(0, null, fakePlayer, arg1_1, argn1_1));
-    }
-    
-    @Test public void testLte() throws CancelCommandException{
-        BasicLogic.lte a = new BasicLogic.lte();
-        assertCTrue(a.exec(0, null, fakePlayer, arg1_1, arg1_2));
-        assertCFalse(a.exec(0, null, fakePlayer, arg2_1, arg1_1));
-        assertCTrue(a.exec(0, null, fakePlayer, arg1_1, arg2_1));
-        assertCTrue(a.exec(0, null, fakePlayer, argn1_1, arg1_1));
-        assertCFalse(a.exec(0, null, fakePlayer, arg1_1, argn1_1));
-    }
-    
-    @Test public void testIf() throws ConfigCompileException{
-        BasicLogic._if a = new BasicLogic._if();
-        SRun("if(true, msg('correct'), msg('incorrect'))", fakePlayer);
-        SRun("if(false, msg('incorrect'), msg('correct'))", fakePlayer);
-        verify(fakePlayer, times(2)).sendMessage("correct");
-    }
-}
diff --git a/src/test/java/com/laytonsmith/aliasengine/functions/DataHandlingTest.java b/src/test/java/com/laytonsmith/aliasengine/functions/DataHandlingTest.java
deleted file mode 100644
index c668d7d..0000000
--- a/src/test/java/com/laytonsmith/aliasengine/functions/DataHandlingTest.java
+++ /dev/null
@@ -1,261 +0,0 @@
-/*
- * To change this template, choose Tools | Templates
- * and open the template in the editor.
- */
-package com.laytonsmith.aliasengine.functions;
-
-import java.io.File;
-import com.laytonsmith.PureUtilities.fileutility.FileUtility;
-import com.laytonsmith.aliasengine.functions.exceptions.ConfigRuntimeException;
-import com.laytonsmith.testing.StaticTest;
-import java.io.IOException;
-import org.bukkit.entity.Player;
-import org.bukkit.Server;
-import com.laytonsmith.aliasengine.Constructs.Variable;
-import java.util.Arrays;
-import com.laytonsmith.aliasengine.Script;
-import com.laytonsmith.aliasengine.MScriptCompiler;
-import com.laytonsmith.aliasengine.functions.exceptions.ConfigCompileException;
-import org.junit.After;
-import org.junit.AfterClass;
-import org.junit.Before;
-import org.junit.BeforeClass;
-import org.junit.Test;
-import static org.junit.Assert.*;
-import static org.mockito.Mockito.*;
-
-/**
- *
- * @author layton
- */
-public class DataHandlingTest {
-    
-    Server fakeServer;
-    Player fakePlayer;
-
-    public DataHandlingTest() {
-    }
-
-    @BeforeClass
-    public static void setUpClass() throws Exception {
-    }
-
-    @AfterClass
-    public static void tearDownClass() throws Exception {
-    }
-
-    @Before
-    public void setUp() {
-        fakePlayer = StaticTest.GetOnlinePlayer();
-        fakeServer = StaticTest.GetFakeServer();
-    }
-
-    @After
-    public void tearDown() {
-    }
-
-
-    @Test
-    public void testFor1() throws ConfigCompileException {
-        String config = "/for = >>>\n"
-                + " assign(@array, array())"
-                + " for(assign(@i, 0), lt(@i, 5), inc(@i),\n"
-                + "     array_push(@array, @i)\n"
-                + " )\n"
-                + " msg(@array)\n"
-                + "<<<\n";
-        Script s = MScriptCompiler.preprocess(MScriptCompiler.lex(config, null)).get(0);
-        s.compile();
-        s.run(Arrays.asList(new Variable[]{}), fakePlayer, null);
-        verify(fakePlayer).sendMessage("{0, 1, 2, 3, 4}");
-    }
-    
-    @Test(expected=ConfigRuntimeException.class) 
-    public void testFor2() throws ConfigCompileException{
-        String script = "/for = >>>\n"
-                + " assign(@array, array())"
-                + " for(assign(@i, 0), 'nope', inc(@i),\n"
-                + "     array_push(@array, @i)\n"
-                + " )\n"
-                + " msg(@array)\n"
-                + "<<<\n";
-        MScriptCompiler.execute(MScriptCompiler.compile(MScriptCompiler.lex(script, null)), fakePlayer, null, null);
-        
-    }
-    
-    @Test(expected=ConfigRuntimeException.class) 
-    public void testFor3() throws ConfigCompileException{
-        String script = 
-                "   assign(@array, array())"
-                + " for('nope', lt(@i, 5), inc(@i),\n"
-                + "     array_push(@array, @i)\n"
-                + " )\n"
-                + " msg(@array)\n";
-        MScriptCompiler.execute(MScriptCompiler.compile(MScriptCompiler.lex(script, null)), fakePlayer, null, null);
-        
-    }
-    
-    @Test public void testForeach1() throws ConfigCompileException{
-        String config = "/for = >>>\n"
-                + " assign(@array, array(1, 2, 3, 4, 5))\n"
-                + " assign(@array2, array())"
-                + " foreach(@array, @i,\n"
-                + "     array_push(@array2, @i)\n"
-                + " )\n"
-                + " msg(@array2)\n"
-                + "<<<\n";
-        Script s = MScriptCompiler.preprocess(MScriptCompiler.lex(config, null)).get(0);
-        s.compile();
-        s.run(Arrays.asList(new Variable[]{}), fakePlayer, null);
-        verify(fakePlayer).sendMessage("{1, 2, 3, 4, 5}");
-    }
-    
-    @Test public void testForeach2() throws ConfigCompileException{
-        String config = "/for = >>>\n"
-                + " assign(@array, array(1, 2, 3, 4, 5))\n"
-                + " assign(@array2, array())"
-                + " foreach(@array, @i,\n"
-                + "     if(equals(@i, 1), continue(2))"
-                + "     array_push(@array2, @i)\n"
-                + " )\n"
-                + " msg(@array2)\n"
-                + "<<<\n";
-        Script s = MScriptCompiler.preprocess(MScriptCompiler.lex(config, null)).get(0);
-        s.compile();
-        s.run(Arrays.asList(new Variable[]{}), fakePlayer, null);
-        verify(fakePlayer).sendMessage("{3, 4, 5}");
-    }
-    
-    @Test public void testForeach3() throws ConfigCompileException{
-        String config = "/for = >>>\n"
-                + " assign(@array, array(1, 2, 3, 4, 5))\n"
-                + " assign(@array1, array(1, 2, 3, 4, 5))\n"
-                + " assign(@array2, array())\n"
-                + " foreach(@array1, @j,"
-                + "     foreach(@array, @i,\n"
-                + "         if(equals(@i, 3), break(2))"
-                + "         array_push(@array2, @i)\n"
-                + "     )\n"
-                + " )"
-                + " msg(@array2)\n"
-                + "<<<\n";
-        Script s = MScriptCompiler.preprocess(MScriptCompiler.lex(config, null)).get(0);
-        s.compile();
-        s.run(Arrays.asList(new Variable[]{}), fakePlayer, null);
-        verify(fakePlayer).sendMessage("{1, 2}");
-    }
-    
-    @Test public void testCallProcIsProc() throws ConfigCompileException{
-        String config = "/for = >>>\n"
-                + " msg(is_proc(_proc))\n"
-                + " proc(_proc,"
-                + "     msg('hello world')"
-                + " )"
-                + " msg(is_proc(_proc))"
-                + " call_proc(_proc)"
-                + "<<<\n";
-        Script s = MScriptCompiler.preprocess(MScriptCompiler.lex(config, null)).get(0);
-        s.compile();
-        s.run(Arrays.asList(new Variable[]{}), fakePlayer, null);
-        verify(fakePlayer).sendMessage("false");
-        verify(fakePlayer).sendMessage("true");
-        verify(fakePlayer).sendMessage("hello world");
-    }
-    
-    /**
-     * There is a bug that causes an infinite loop, so we put a 10 second timeout
-     * @throws ConfigCompileException 
-     */
-    @Test(timeout=10000) public void testContinue1() throws ConfigCompileException{
-        String config = "/continue = >>>\n"
-                + " assign(@array, array())"
-                + " for(assign(@i, 0), lt(@i, 5), inc(@i),\n"
-                + "     if(equals(@i, 2), continue(1))\n"
-                + "     array_push(@array, @i)\n"
-                + " )\n"
-                + " msg(@array)\n"
-                + "<<<\n";
-        Script s = MScriptCompiler.preprocess(MScriptCompiler.lex(config, null)).get(0);
-        s.compile();
-        s.run(Arrays.asList(new Variable[]{}), fakePlayer, null);
-        verify(fakePlayer).sendMessage("{0, 1, 3, 4}");
-    }
-    
-    @Test(timeout=10000) public void testContinue2() throws ConfigCompileException{
-        String config = "/continue = >>>\n"
-                + " assign(@array, array())"
-                + " for(assign(@i, 0), lt(@i, 5), inc(@i),\n"
-                + "     if(equals(@i, 2), continue(2))\n"
-                + "     array_push(@array, @i)\n"
-                + " )\n"
-                + " msg(@array)\n"
-                + "<<<\n";
-        Script s = MScriptCompiler.preprocess(MScriptCompiler.lex(config, null)).get(0);
-        s.compile();
-        s.run(Arrays.asList(new Variable[]{}), fakePlayer, null);
-        verify(fakePlayer).sendMessage("{0, 1, 4}");
-    }
-    
-    @Test(timeout=10000) public void testContinue3() throws ConfigCompileException{
-        String config = "/continue = >>>\n"
-                + " assign(@array, array())"
-                + " for(assign(@i, 0), lt(@i, 5), inc(@i),\n"
-                + "     if(equals(@i, 2), continue(3))\n"
-                + "     array_push(@array, @i)\n"
-                + " )\n"
-                + " msg(@array)\n"
-                + "<<<\n";
-        Script s = MScriptCompiler.preprocess(MScriptCompiler.lex(config, null)).get(0);
-        s.compile();
-        s.run(Arrays.asList(new Variable[]{}), fakePlayer, null);
-        verify(fakePlayer).sendMessage("{0, 1}");
-    }
-    
-    @Test public void testBreak1() throws ConfigCompileException{
-        String config = "/break = >>>\n"
-                + " assign(@array, array())"
-                + " for(assign(@i, 0), lt(@i, 2), inc(@i),\n"
-                + "     for(assign(@j, 0), lt(@j, 5), inc(@j),\n"
-                + "         if(equals(@j, 2), break())\n"
-                + "         array_push(@array, concat('j:', @j))\n"
-                + "     )\n"
-                + "     array_push(@array, concat('i:', @i))\n"
-                + " )\n"
-                + " msg(@array)\n"
-                + "<<<\n";
-        Script s = MScriptCompiler.preprocess(MScriptCompiler.lex(config, null)).get(0);
-        s.compile();
-        s.run(Arrays.asList(new Variable[]{}), fakePlayer, null);
-        verify(fakePlayer).sendMessage("{j:0, j:1, i:0, j:0, j:1, i:1}");
-    }
-    
-    @Test public void testBreak2() throws ConfigCompileException{
-        String config = "/break = >>>\n"
-                + " assign(@array, array())"
-                + " for(assign(@i, 0), lt(@i, 2), inc(@i),\n"
-                + "     for(assign(@j, 0), lt(@j, 5), inc(@j),\n"
-                + "         if(equals(@j, 2), break(2))\n"
-                + "         array_push(@array, concat('j:', @j))\n"
-                + "     )\n"
-                + "     array_push(@array, concat('i:', @i))\n"
-                + " )\n"
-                + " msg(@array)\n"
-                + "<<<\n";
-        Script s = MScriptCompiler.preprocess(MScriptCompiler.lex(config, null)).get(0);
-        s.compile();
-        s.run(Arrays.asList(new Variable[]{}), fakePlayer, null);
-        verify(fakePlayer).sendMessage("{j:0, j:1}");
-    }
-    
-    @Test public void testInclude() throws ConfigCompileException, IOException{
-        String script = 
-                "include('unit_test_inc.ms')";
-        //Create the test file
-        File test = new File("unit_test_inc.ms");
-        FileUtility.write("msg('hello')", test);
-        MScriptCompiler.execute(MScriptCompiler.compile(MScriptCompiler.lex(script, null)), fakePlayer, null, null);
-        verify(fakePlayer).sendMessage("hello");
-        //delete the test file
-        test.delete();
-    }
-}
diff --git a/src/test/java/com/laytonsmith/aliasengine/functions/EchoesTest.java b/src/test/java/com/laytonsmith/aliasengine/functions/EchoesTest.java
deleted file mode 100644
index e78c2d9..0000000
--- a/src/test/java/com/laytonsmith/aliasengine/functions/EchoesTest.java
+++ /dev/null
@@ -1,91 +0,0 @@
-/*
- * To change this template, choose Tools | Templates
- * and open the template in the editor.
- */
-package com.laytonsmith.aliasengine.functions;
-
-import com.laytonsmith.aliasengine.functions.exceptions.CancelCommandException;
-import com.laytonsmith.aliasengine.functions.exceptions.ConfigCompileException;
-import com.laytonsmith.testing.C;
-import com.sk89q.commandhelper.CommandHelperPlugin;
-import java.lang.reflect.InvocationTargetException;
-import org.bukkit.entity.Player;
-import org.bukkit.Server;
-import org.junit.After;
-import org.junit.AfterClass;
-import org.junit.Before;
-import org.junit.BeforeClass;
-import org.junit.Test;
-import static org.mockito.Mockito.*;
-import static com.laytonsmith.testing.StaticTest.*;
-
-/**
- *
- * @author Layton
- */
-public class EchoesTest {
-    
-    Server fakeServer;
-    Player fakePlayer;
-    
-    public EchoesTest() {
-    }
-
-    @BeforeClass
-    public static void setUpClass() throws Exception {        
-    }
-
-    @AfterClass
-    public static void tearDownClass() throws Exception {
-    }
-    
-    @Before
-    public void setUp() {
-        fakeServer = GetFakeServer();
-        fakePlayer = GetOnlinePlayer(fakeServer);
-    }
-    
-    @After
-    public void tearDown() {
-    }
-
-    @Test
-    public void testDocs() {
-        System.out.println("docs");
-        TestClassDocs(Echoes.docs(), Echoes.class);
-    }
-    
-    @Test public void testChat() throws CancelCommandException{
-        Echoes.chat a = new Echoes.chat();     
-        TestBoilerplate(a, "chat");
-        a.exec(0, null, fakePlayer, C.onstruct("Hello World!"));
-        verify(fakePlayer).chat("Hello World!");
-    }
-    
-    @Test public void testBroadcast() throws NoSuchFieldException, InstantiationException, 
-            IllegalAccessException, NoSuchMethodException, IllegalArgumentException, InvocationTargetException, CancelCommandException{
-        Echoes.broadcast a = new Echoes.broadcast();
-        TestBoilerplate(a, "broadcast");
-        when(fakePlayer.getServer()).thenReturn(fakeServer);
-        CommandHelperPlugin.myServer = fakeServer;
-        a.exec(0, null, fakePlayer, C.onstruct("Hello World!"));
-        verify(fakeServer).broadcastMessage("Hello World!");        
-    }
-    
-    @Test public void testChatas() throws CancelCommandException, ConfigCompileException{
-        //TODO: Can't get this to work right, though it does work in game
-//        String script = "chatas('wraithguard02', 'Hello World!')";
-//        Player wraithguard02 = GetOnlinePlayer("wraithguard02", fakeServer);
-//        Player op = GetOp("wraithguard", fakeServer);
-//        Run(script, op);
-//        verify(wraithguard02).chat("Hello World!");
-//        Echoes.chatas a = new Echoes.chatas();
-//        Player wraithguard01 = GetOnlinePlayer("wraithguard02", fakeServer);
-//        when(fakePlayer.getServer()).thenReturn(fakeServer);
-//        when(fakeServer.getPlayer("wraithguard01")).thenReturn(wraithguard01);
-//        a.exec(0, null, fakePlayer, C.onstruct("wraithguard02"), C.onstruct("Hello World!"));
-//        verify(wraithguard01).chat("Hello World!");        
-    }
-    
-    
-}
diff --git a/src/test/java/com/laytonsmith/aliasengine/functions/ExceptionsTest.java b/src/test/java/com/laytonsmith/aliasengine/functions/ExceptionsTest.java
deleted file mode 100644
index 5496e46..0000000
--- a/src/test/java/com/laytonsmith/aliasengine/functions/ExceptionsTest.java
+++ /dev/null
@@ -1,107 +0,0 @@
-/*
- * To change this template, choose Tools | Templates
- * and open the template in the editor.
- */
-package com.laytonsmith.aliasengine.functions;
-
-import com.laytonsmith.aliasengine.functions.exceptions.ConfigRuntimeException;
-import java.io.File;
-import com.laytonsmith.aliasengine.MScriptCompiler;
-import com.laytonsmith.aliasengine.functions.exceptions.ConfigCompileException;
-import com.sk89q.commandhelper.CommandHelperPlugin;
-import com.sk89q.bukkit.migration.PermissionsResolverManager;
-import com.laytonsmith.testing.StaticTest;
-import org.bukkit.entity.Player;
-import org.bukkit.Server;
-import org.junit.After;
-import org.junit.AfterClass;
-import org.junit.Before;
-import org.junit.BeforeClass;
-import org.junit.Test;
-import static org.junit.Assert.*;
-import static org.mockito.Mockito.*;
-
-/**
- *
- * @author layton
- */
-public class ExceptionsTest {
-    
-    static Server fakeServer;
-    static Player fakePlayer;
-
-    public ExceptionsTest() {
-    }
-
-    @BeforeClass
-    public static void setUpClass() throws Exception {
-        CommandHelperPlugin.perms = mock(PermissionsResolverManager.class);
-        CommandHelperPlugin.myServer = fakeServer;
-    }
-
-    @AfterClass
-    public static void tearDownClass() throws Exception {
-    }
-
-    @Before
-    public void setUp() {
-        fakePlayer = StaticTest.GetOnlinePlayer();
-        fakeServer = StaticTest.GetFakeServer();
-    }
-
-    @After
-    public void tearDown() {
-    }
-
-    @Test public void testTryCatch1() throws ConfigCompileException{
-        String script =
-                "try(\n"
-                + "ploc('offlineplayer'),\n"
-                + "@ex,\n"
-                + "msg(@ex[0])\n"
-                + "msg(@ex[1])\n"
-                + "msg(@ex[2])\n"
-                + "msg(@ex[3])\n"
-                + ")";
-        MScriptCompiler.execute(MScriptCompiler.compile(MScriptCompiler.lex(script, null)), fakePlayer, null, null);
-        verify(fakePlayer).sendMessage("InsufficientPermissionException");
-        verify(fakePlayer).sendMessage("You do not have permission to use the ploc function.");
-        verify(fakePlayer).sendMessage("null");
-        verify(fakePlayer).sendMessage("2");
-    }
-    
-    @Test public void testTryCatch2() throws ConfigCompileException{
-        String script =
-                "try(\n"
-                + "throw(PlayerOfflineException, This is a message),\n"
-                + "@ex,\n"
-                + "msg(@ex[0])\n"
-                + "msg(@ex[1])\n"
-                + "msg(@ex[2])\n"
-                + "msg(@ex[3])\n"               
-                + ")";
-        MScriptCompiler.execute(MScriptCompiler.compile(MScriptCompiler.lex(script, null)), fakePlayer, null, null);
-        verify(fakePlayer).sendMessage("PlayerOfflineException");
-        verify(fakePlayer).sendMessage("This is a message");
-        verify(fakePlayer).sendMessage("null");
-        verify(fakePlayer).sendMessage("2");
-    }
-    @Test public void testTryCatch3() throws ConfigCompileException{
-        String script =
-                "try(try(\n"
-                + "throw(null, This is a message),\n"
-                + "@ex,\n"
-                + "msg(@ex[0])\n"
-                + "msg(@ex[1])\n"
-                + "msg(@ex[2])\n"
-                + "msg(@ex[3])\n"               
-                + "), @ex, msg('2'))";
-        try{
-            MScriptCompiler.execute(MScriptCompiler.compile(MScriptCompiler.lex(script, new File("file.txt"))), fakePlayer, null, null);
-            fail("This test was supposed to throw an exception");
-        }catch(ConfigRuntimeException e){
-            //Pass
-        }
-        verify(fakePlayer, never()).sendMessage("2");
-    }
-}
diff --git a/src/test/java/com/laytonsmith/aliasengine/functions/MathTest.java b/src/test/java/com/laytonsmith/aliasengine/functions/MathTest.java
deleted file mode 100644
index 216e8da..0000000
--- a/src/test/java/com/laytonsmith/aliasengine/functions/MathTest.java
+++ /dev/null
@@ -1,218 +0,0 @@
-/*
- * To change this template, choose Tools | Templates
- * and open the template in the editor.
- */
-package com.laytonsmith.aliasengine.functions;
-
-import com.laytonsmith.aliasengine.functions.exceptions.ConfigCompileException;
-import com.laytonsmith.aliasengine.functions.exceptions.ConfigRuntimeException;
-import com.laytonsmith.aliasengine.Constructs.IVariable;
-import com.laytonsmith.aliasengine.Static;
-import com.laytonsmith.testing.C;
-import org.bukkit.Server;
-import org.bukkit.entity.Player;
-import com.laytonsmith.testing.StaticTest;
-import org.junit.After;
-import org.junit.AfterClass;
-import org.junit.Before;
-import org.junit.BeforeClass;
-import org.junit.Test;
-import static org.junit.Assert.*;
-import static com.laytonsmith.testing.StaticTest.*;
-import static org.mockito.Mockito.*;
-
-/**
- *
- * @author Layton
- */
-public class MathTest {
-    Server fakeServer;
-    Player fakePlayer;
-    IVariableList varList;
-    public MathTest() {
-    }
-
-    @BeforeClass
-    public static void setUpClass() throws Exception {
-    }
-
-    @AfterClass
-    public static void tearDownClass() throws Exception {
-    }
-    
-    @Before
-    public void setUp() {
-        fakePlayer = GetOnlinePlayer();
-        fakeServer = GetFakeServer();
-
-        varList = new IVariableList();
-        varList.set(new IVariable("var", C.onstruct(1), 0, null));
-        varList.set(new IVariable("var2", C.onstruct(2.5), 0, null));
-    }
-    
-    @After
-    public void tearDown() {
-    }
-
-    @Test
-    public void testDocs() {
-        System.out.println("docs");
-        StaticTest.TestClassDocs(Math.docs(), Math.class);
-    }
-    
-    @Test
-    public void testAbs(){
-        Math.abs a = new Math.abs();
-        TestBoilerplate(a, "abs");
-        assertCEquals(C.onstruct(5), a.exec(0, null, fakePlayer, C.onstruct(5)));
-        assertCEquals(C.onstruct(3), a.exec(0, null, fakePlayer, C.onstruct(-3)));
-        assertCEquals(C.onstruct(0), a.exec(0, null, fakePlayer, C.onstruct(0)));
-    }
-    
-    @Test
-    public void testAdd(){
-        Math.add a = new Math.add();
-        TestBoilerplate(a, "add");
-        assertCEquals(C.onstruct(7), a.exec(0, null, fakePlayer, C.onstruct(5), C.onstruct(2)));
-        assertCEquals(C.onstruct(6), a.exec(0, null, fakePlayer, C.onstruct(3), C.onstruct(3)));
-        assertCEquals(C.onstruct(-4), a.exec(0, null, fakePlayer, C.onstruct(-3), C.onstruct(-1)));
-        assertCEquals(C.onstruct(1), a.exec(0, null, fakePlayer, C.onstruct(1), C.onstruct(0)));
-        assertCEquals(C.onstruct(3.1415), a.exec(0, null, fakePlayer, C.onstruct(3), C.onstruct(0.1415)));
-    }
-    
-    @Test
-    public void testDec() throws ConfigCompileException{
-        Math.dec a = new Math.dec();
-        TestBoilerplate(a, "dec");
-        a.varList(varList);
-        IVariable v = (IVariable)a.exec(0, null, fakePlayer, new IVariable("var", C.onstruct(1), 0, null));
-        IVariable v2 = (IVariable)a.exec(0, null, fakePlayer,new IVariable("var2", C.onstruct(2.5), 0, null));
-        assertCEquals(C.onstruct(0), v.ival());
-        assertCEquals(C.onstruct(1.5), v2.ival());
-        StaticTest.SRun("assign(@var, 0) dec(@var, 2) msg(@var)", fakePlayer);
-        verify(fakePlayer).sendMessage("-2");
-    }
-    
-    @Test
-    public void testDivide(){
-        Math.divide a = new Math.divide();
-        TestBoilerplate(a, "divide");
-        assertCEquals(C.onstruct(2.5), a.exec(0, null, fakePlayer, C.onstruct(5), C.onstruct(2)));
-        assertCEquals(C.onstruct(1), a.exec(0, null, fakePlayer, C.onstruct(3), C.onstruct(3)));
-        assertCEquals(C.onstruct(3), a.exec(0, null, fakePlayer, C.onstruct(-3), C.onstruct(-1)));
-        assertCEquals(C.onstruct(Double.POSITIVE_INFINITY), a.exec(0, null, fakePlayer, C.onstruct(1), C.onstruct(0)));
-    }
-    
-    @Test
-    public void testInc() throws ConfigCompileException{
-        Math.inc a = new Math.inc();
-        TestBoilerplate(a, "inc");
-        a.varList(varList);
-        IVariable v = (IVariable)a.exec(0, null, fakePlayer, new IVariable("var", C.onstruct(1), 0, null));
-        IVariable v2 = (IVariable)a.exec(0, null, fakePlayer,new IVariable("var2", C.onstruct(2.5), 0, null));
-        assertCEquals(C.onstruct(2), v.ival());
-        assertCEquals(C.onstruct(3.5), v2.ival());
-        StaticTest.SRun("assign(@var, 0) inc(@var, 2) msg(@var)", fakePlayer);
-        verify(fakePlayer).sendMessage("2");
-    }
-    
-    @Test
-    public void testMod(){
-        Math.mod a = new Math.mod();
-        TestBoilerplate(a, "mod");
-        assertCEquals(C.onstruct(1), a.exec(0, null, fakePlayer, C.onstruct(5), C.onstruct(2)));
-        assertCEquals(C.onstruct(0), a.exec(0, null, fakePlayer, C.onstruct(3), C.onstruct(3)));
-        assertCEquals(C.onstruct(-1), a.exec(0, null, fakePlayer, C.onstruct(-3), C.onstruct(-2)));
-    }
-    
-    @Test
-    public void testMultiply(){
-        Math.multiply a = new Math.multiply();
-        TestBoilerplate(a, "multiply");
-        assertCEquals(C.onstruct(10), a.exec(0, null, fakePlayer, C.onstruct(5), C.onstruct(2)));
-        assertCEquals(C.onstruct(9), a.exec(0, null, fakePlayer, C.onstruct(3), C.onstruct(3)));
-        assertCEquals(C.onstruct(6), a.exec(0, null, fakePlayer, C.onstruct(-3), C.onstruct(-2)));
-        assertCEquals(C.onstruct(5), a.exec(0, null, fakePlayer, C.onstruct(10), C.onstruct(0.5)));
-    }
-    
-    @Test
-    public void testPow(){
-        Math.pow a = new Math.pow();
-        TestBoilerplate(a, "pow");
-        assertCEquals(C.onstruct(25), a.exec(0, null, fakePlayer, C.onstruct(5), C.onstruct(2)));
-        assertCEquals(C.onstruct(27), a.exec(0, null, fakePlayer, C.onstruct(3), C.onstruct(3)));
-        assertCEquals(C.onstruct(1), a.exec(0, null, fakePlayer, C.onstruct(-1), C.onstruct(-2)));
-    }
-    
-    @Test
-    public void testRand(){
-        Math.rand a = new Math.rand();
-        TestBoilerplate(a, "rand");
-        for(int i = 0; i < 1000; i++){
-            long j = Static.getInt(a.exec(0, null, fakePlayer, C.onstruct(10)));
-            if(!(j < 10 && j >= 0)){
-                fail("Expected a number between 0 and 10, but got " + j);
-            }
-            j = Static.getInt(a.exec(0, null, fakePlayer, C.onstruct(10), C.onstruct(20)));
-            if(!(j < 20 && j >= 10)){
-                fail("Expected a number between 10 and 20, but got " + j);
-            }
-        }
-        try{
-            a.exec(0, null, fakePlayer, C.onstruct(20), C.onstruct(10));
-            fail("Didn't expect this test to pass");
-        } catch(ConfigRuntimeException e){}
-        try{
-            a.exec(0, null, fakePlayer, C.onstruct(-1));
-            fail("Didn't expect this test to pass");
-        } catch(ConfigRuntimeException e){}
-        try{
-            a.exec(0, null, fakePlayer, C.onstruct(87357983597853791L));
-            fail("Didn't expect this test to pass");
-        } catch(ConfigRuntimeException e){}
-    }
-    
-    @Test
-    public void testSubtract(){
-        Math.subtract a = new Math.subtract();
-        TestBoilerplate(a, "subtract");
-        assertCEquals(C.onstruct(3), a.exec(0, null, fakePlayer, C.onstruct(5), C.onstruct(2)));
-        assertCEquals(C.onstruct(0), a.exec(0, null, fakePlayer, C.onstruct(3), C.onstruct(3)));
-        assertCEquals(C.onstruct(-1), a.exec(0, null, fakePlayer, C.onstruct(-3), C.onstruct(-2)));
-        assertCEquals(C.onstruct(3), a.exec(0, null, fakePlayer, C.onstruct(3.1415), C.onstruct(0.1415)));
-    }
-    
-    @Test
-    public void testFloor(){
-        Math.floor a = new Math.floor();
-        TestBoilerplate(a, "floor");
-        assertCEquals(C.onstruct(3), a.exec(0, null, fakePlayer, C.onstruct(3.8415)));
-        assertCEquals(C.onstruct(-4), a.exec(0, null, fakePlayer, C.onstruct(-3.1415)));
-    }
-    
-    @Test public void testCeil(){
-        Math.ceil a = new Math.ceil();
-        TestBoilerplate(a, "ceil");
-        assertCEquals(C.onstruct(4), a.exec(0, null, fakePlayer, C.onstruct(3.1415)));
-        assertCEquals(C.onstruct(-3), a.exec(0, null, fakePlayer, C.onstruct(-3.1415)));
-    }
-    
-    @Test public void testSqrt() throws ConfigCompileException{
-        assertEquals("3", StaticTest.SRun("sqrt(9)", fakePlayer));
-        assertEquals("Test failed", java.lang.Math.sqrt(2), Double.parseDouble(StaticTest.SRun("sqrt(2)", fakePlayer)), .000001);        
-        try{
-            StaticTest.SRun("sqrt(-1)", fakePlayer);
-            fail("Did not expect to pass");
-        } catch(ConfigRuntimeException e){
-            //pass
-        }
-    }
-    
-    @Test public void testMin() throws ConfigCompileException{
-        assertEquals("-2", StaticTest.SRun("min(2, array(5, 6, 4), -2)", fakePlayer));
-    }
-    
-    @Test public void testMax() throws ConfigCompileException{
-        assertEquals("50", StaticTest.SRun("max(6, 7, array(4, 4, 50), 2, 5)", fakePlayer));
-    }
-}
diff --git a/src/test/java/com/laytonsmith/aliasengine/functions/MetaTest.java b/src/test/java/com/laytonsmith/aliasengine/functions/MetaTest.java
deleted file mode 100644
index 8cf209d..0000000
--- a/src/test/java/com/laytonsmith/aliasengine/functions/MetaTest.java
+++ /dev/null
@@ -1,87 +0,0 @@
-/*
- * To change this template, choose Tools | Templates
- * and open the template in the editor.
- */
-package com.laytonsmith.aliasengine.functions;
-
-import com.sk89q.commandhelper.CommandHelperPlugin;
-import com.sk89q.bukkit.migration.PermissionsResolverManager;
-import com.laytonsmith.aliasengine.MScriptCompiler;
-import com.laytonsmith.aliasengine.functions.exceptions.ConfigCompileException;
-import com.laytonsmith.testing.StaticTest;
-import java.util.concurrent.atomic.AtomicBoolean;
-import org.bukkit.entity.Player;
-import org.bukkit.Server;
-import org.junit.After;
-import org.junit.AfterClass;
-import org.junit.Before;
-import org.junit.BeforeClass;
-import org.junit.Test;
-import org.mockito.invocation.InvocationOnMock;
-import org.mockito.stubbing.Answer;
-import static org.junit.Assert.*;
-import static org.mockito.Mockito.*;
-
-/**
- *
- * @author layton
- */
-public class MetaTest {
-    
-    static Server fakeServer;
-    static Player fakePlayer;
-
-    public MetaTest() {
-    }
-
-    @BeforeClass
-    public static void setUpClass() throws Exception {
-        fakePlayer = StaticTest.GetOnlinePlayer();
-        fakeServer = StaticTest.GetFakeServer();
-        CommandHelperPlugin.perms = mock(PermissionsResolverManager.class);
-        CommandHelperPlugin.myServer = fakeServer;
-    }
-
-    @AfterClass
-    public static void tearDownClass() throws Exception {
-    }
-
-    @Before
-    public void setUp() {
-    }
-
-    @After
-    public void tearDown() {
-    }
-
-    @Test public void testRunas1() throws ConfigCompileException{
-        String script = 
-                "runas('wraithguard02', '/cmd yay')";
-        Player fakePlayer2 = StaticTest.GetOnlinePlayer("wraithguard02", fakeServer);
-        when(fakeServer.getPlayer("wraithguard02")).thenReturn(fakePlayer2);
-        when(fakePlayer.isOp()).thenReturn(true);
-        MScriptCompiler.execute(MScriptCompiler.compile(MScriptCompiler.lex(script, null)), fakePlayer, null, null);
-        //verify(fakePlayer2).performCommand("cmd yay");
-        verify(fakeServer).dispatchCommand(fakePlayer2, "cmd yay");
-    }
-    //:( I can't get this to work right, because AlwaysOpPlayer is different than
-    //fakePlayer, so I can't get my test to activate when the function is called.
-//    @Test public void testRunas2() throws ConfigCompileException{
-//        final AtomicBoolean bool = new AtomicBoolean(false); 
-//        String script = 
-//                "runas(~op, '/cmd yay')";
-//        when(fakeServer.dispatchCommand(fakePlayer, "cmd yay")).thenAnswer(new Answer<Boolean>(){
-//
-//            public Boolean answer(InvocationOnMock invocation) throws Throwable {
-//                System.out.println("HERE");
-//                assertTrue(((Server)invocation.getMock()).getPlayer(fakePlayer.getName()).isOp());
-//                bool.set(true);
-//                return true;
-//            }
-//            
-//        });
-//        MScriptCompiler.execute(MScriptCompiler.compile(MScriptCompiler.lex(script, null)), fakePlayer, null, null);
-//        assertTrue(bool.get());
-//    }
-    
-}
diff --git a/src/test/java/com/laytonsmith/aliasengine/functions/PlayerManangementTest.java b/src/test/java/com/laytonsmith/aliasengine/functions/PlayerManangementTest.java
deleted file mode 100644
index 4e9b520..0000000
--- a/src/test/java/com/laytonsmith/aliasengine/functions/PlayerManangementTest.java
+++ /dev/null
@@ -1,181 +0,0 @@
-/*
- * To change this template, choose Tools | Templates
- * and open the template in the editor.
- */
-package com.laytonsmith.aliasengine.functions;
-
-import com.laytonsmith.aliasengine.MScriptComplete;
-import com.laytonsmith.aliasengine.functions.exceptions.ConfigCompileException;
-import com.laytonsmith.aliasengine.functions.exceptions.ConfigRuntimeException;
-import com.sk89q.commandhelper.CommandHelperPlugin;
-import org.bukkit.Location;
-import org.junit.Test;
-import org.bukkit.entity.Player;
-import org.bukkit.Server;
-import org.bukkit.World;
-import org.bukkit.block.Block;
-import org.bukkit.command.CommandSender;
-import org.bukkit.command.ConsoleCommandSender;
-import org.junit.After;
-import org.junit.AfterClass;
-import org.junit.Before;
-import org.junit.BeforeClass;
-import static org.mockito.Mockito.*;
-import static com.laytonsmith.testing.StaticTest.*;
-import static org.junit.Assert.*;
-
-/**
- *
- * @author Layton
- */
-public class PlayerManangementTest {
-
-    Server fakeServer;
-    Player fakePlayer;
-    
-    public PlayerManangementTest() {
-    }
-
-    @BeforeClass
-    public static void setUpClass() throws Exception {
-    }
-
-    @AfterClass
-    public static void tearDownClass() throws Exception {
-    }
-    
-    @Before
-    public void setUp() {
-        fakeServer = GetFakeServer();
-        fakePlayer = GetOp("wraithguard01", fakeServer);
-        when(fakePlayer.getServer()).thenReturn(fakeServer);
-        CommandHelperPlugin.myServer = fakeServer;
-        when(fakeServer.getPlayer(fakePlayer.getName())).thenReturn(fakePlayer);
-    }
-    
-    @After
-    public void tearDown() {
-    }
-
-    @Test public void testPlayer() throws ConfigCompileException{
-        String script = "player()";
-        assertEquals(fakePlayer.getName(), SRun(script, fakePlayer));
-        assertEquals("null", SRun(script, null));
-    }
-    
-    @Test public void testPlayer2() throws ConfigCompileException{
-        String script = "msg(player())";
-        ConsoleCommandSender c = GetFakeConsoleCommandSender();
-        Run(script, c);
-        verify(c).sendMessage("~console");
-    }
-    
-    @Test 
-    public void testPlayer3() throws ConfigCompileException{
-        CommandSender c = GetFakeConsoleCommandSender();
-        assertEquals("~console", SRun("player()", c));
-    }
-    
-    @Test public void testAllPlayers() throws ConfigCompileException{
-        String script = "all_players()";
-        String done = SRun(script, fakePlayer);
-        //This output is too long to test with msg()        
-        assertEquals("{wraithguard01, wraithguard02, wraithguard03}", done);
-    }
-    
-    @Test public void testPloc() throws ConfigCompileException{
-        String script = "ploc()";
-        World w = GetWorld("world");
-        when(fakePlayer.getLocation()).thenReturn(new Location(w, 0, 1, 0));
-        final StringBuilder done = new StringBuilder();
-        Run(script, fakePlayer, new MScriptComplete() {
-
-            public void done(String output) {
-                done.append(output);
-            }
-        });
-        assertEquals("{0.0, 0.0, 0.0}", done.toString());
-    }
-    
-    @Test public void testSetPloc() throws ConfigCompileException{
-        World w = GetWorld("world");
-        CommandHelperPlugin.myServer = fakeServer;
-        when(fakeServer.getPlayer(fakePlayer.getName())).thenReturn(fakePlayer);
-        when(fakePlayer.getWorld()).thenReturn(w);
-        when(fakePlayer.getLocation()).thenReturn(new Location(w, 0, 0, 0));
-        
-        Run("set_ploc(1, 1, 1)", fakePlayer);
-        verify(fakePlayer).teleport(new Location(w, 1, 2, 1, 0, 0));
-        
-        Run("set_ploc(array(2, 2, 2))", fakePlayer);
-        verify(fakePlayer).teleport(new Location(w, 2, 3, 2, 0, 0));
-        
-        Run("set_ploc('" + fakePlayer.getName() + "', 3, 3, 3)", fakePlayer);
-        verify(fakePlayer).teleport(new Location(w, 3, 4, 3, 0, 0));
-        
-        Run("set_ploc('" + fakePlayer.getName() + "', array(4, 4, 4))", fakePlayer);
-        verify(fakePlayer).teleport(new Location(w, 4, 5, 4, 0, 0));
-    }
-    
-    @Test public void testPcursor() throws ConfigCompileException{  
-        Block b = mock(Block.class);
-        CommandHelperPlugin.myServer = fakeServer;
-        when(fakeServer.getPlayer(fakePlayer.getName())).thenReturn(fakePlayer);
-        when(fakePlayer.getTargetBlock(null, 200)).thenReturn(b);
-        Run("pcursor()", fakePlayer);
-        Run("pcursor('" + fakePlayer.getName() + "')", fakePlayer);
-        verify(fakePlayer, times(2)).getTargetBlock(null, 200);
-    }
-    
-    @Test public void testKill() throws ConfigCompileException{        
-        Run("kill()", fakePlayer);
-        Run("kill('" + fakePlayer.getName() + "')", fakePlayer);
-        verify(fakePlayer, times(2)).setHealth(0);
-    }
-    
-    //@Test
-    public void testPgroup() throws ConfigCompileException{
-        Run("", fakePlayer);
-        Run("", fakePlayer);
-    }
-    
-    //@Test
-    public void testPinfo(){
-        
-    }
-    
-    //@Test
-    public void testPworld(){
-        
-    }
-    
-    //@Test
-    public void testKick(){
-        
-    }
-    
-    //@Test
-    public void testSetDisplayName(){
-        
-    }
-    
-    //@Test
-    public void testResetDisplayName(){
-        
-    }
-    
-    //@Test
-    public void testPFacing(){
-        
-    }
-    
-    //@Test
-    public void testPinv(){
-        
-    }
-    
-    //@Test
-    public void testSetPinv(){
-        
-    }
-}
diff --git a/src/test/java/com/laytonsmith/aliasengine/functions/RegexTest.java b/src/test/java/com/laytonsmith/aliasengine/functions/RegexTest.java
deleted file mode 100644
index 6c701eb..0000000
--- a/src/test/java/com/laytonsmith/aliasengine/functions/RegexTest.java
+++ /dev/null
@@ -1,75 +0,0 @@
-/*
- * To change this template, choose Tools | Templates
- * and open the template in the editor.
- */
-package com.laytonsmith.aliasengine.functions;
-
-import com.laytonsmith.aliasengine.functions.exceptions.ConfigCompileException;
-import com.laytonsmith.aliasengine.functions.exceptions.ConfigRuntimeException;
-import org.junit.After;
-import org.junit.AfterClass;
-import org.junit.Before;
-import org.junit.BeforeClass;
-import org.junit.Test;
-import static org.junit.Assert.*;
-import static org.mockito.Mockito.*;
-import static com.laytonsmith.testing.StaticTest.*;
-
-/**
- *
- * @author Layton
- */
-public class RegexTest {
-    
-    public RegexTest() {
-    }
-
-    @BeforeClass
-    public static void setUpClass() throws Exception {
-    }
-
-    @AfterClass
-    public static void tearDownClass() throws Exception {
-    }
-    
-    @Before
-    public void setUp() {
-    }
-    
-    @After
-    public void tearDown() {
-    }
-
-    @Test public void testRegMatch() throws ConfigCompileException{
-        assertEquals("{word}", SRun("reg_match('word', 'This is a word')", null));
-        assertEquals("{}", SRun("reg_match('word', 'This is an airplane')", null));
-        assertEquals("{word, word}", SRun("reg_match('(word)', 'This is a word')", null));
-        assertEquals("{This is a word, word}", SRun("reg_match('This is a (word)', 'This is a word')", null));
-        assertEquals("{WORD}", SRun("reg_match(array(word, i), 'THIS IS A WORD')", null));
-        try{
-            SRun("reg_match(array(word, l), hi)", null);
-            fail();
-        } catch(ConfigRuntimeException e){
-            //Pass
-        }
-    }
-    
-    @Test public void testRegMatchAll() throws ConfigCompileException{
-        assertEquals("{{This is a word, word}, {This is a word, word}}", SRun("reg_match_all('This is a (word)', 'word, This is a word, This is a word')", null));
-        assertEquals("{}", SRun("reg_match_all('word', 'yay')", null));
-    }
-    
-    @Test public void testRegReplace() throws ConfigCompileException{
-        assertEquals("word", SRun("reg_replace('This is a (word)', '$1', 'This is a word')", null));
-        assertEquals("It's a wordy day!", SRun("reg_replace('sunn', 'word', 'It\\'s a sunny day!')", null));
-    }
-    
-    @Test public void testRegSplit() throws ConfigCompileException{
-        assertEquals("{one, two, three}", SRun("reg_split('\\\\|', 'one|two|three')", null));
-    }
-    
-    @Test public void testRegCount() throws ConfigCompileException{
-        assertEquals("3", SRun("reg_count('/', '///yay')", null));
-        assertEquals("0", SRun("reg_count('poppycock', 'tiddly winks')", null));
-    }
-}
diff --git a/src/test/java/com/laytonsmith/aliasengine/functions/StringHandlingTest.java b/src/test/java/com/laytonsmith/aliasengine/functions/StringHandlingTest.java
deleted file mode 100644
index c17cf4a..0000000
--- a/src/test/java/com/laytonsmith/aliasengine/functions/StringHandlingTest.java
+++ /dev/null
@@ -1,127 +0,0 @@
-/*
- * To change this template, choose Tools | Templates
- * and open the template in the editor.
- */
-package com.laytonsmith.aliasengine.functions;
-
-import com.laytonsmith.testing.C;
-import com.laytonsmith.testing.StaticTest;
-import org.junit.After;
-import org.junit.AfterClass;
-import org.junit.Before;
-import org.junit.BeforeClass;
-import org.junit.Test;
-import static org.junit.Assert.*;
-import static com.laytonsmith.testing.StaticTest.*;
-import static org.mockito.Mockito.*;
-
-/**
- *
- * @author Layton
- */
-public class StringHandlingTest {
-    
-    public StringHandlingTest() {
-    }
-
-    @BeforeClass
-    public static void setUpClass() throws Exception {
-    }
-
-    @AfterClass
-    public static void tearDownClass() throws Exception {
-    }
-    
-    @Before
-    public void setUp() {
-    }
-    
-    @After
-    public void tearDown() {
-    }
-
-    @Test
-    public void testDocs() {
-        System.out.println("docs");
-        StaticTest.TestClassDocs(Math.docs(), Math.class);
-    }
-    
-    @Test
-    public void testConcat(){
-        StringHandling.concat a = new StringHandling.concat();
-        TestBoilerplate(a, "concat");
-        assertCEquals(C.onstruct("1234"), a.exec(0, null, null, C.onstruct(1), C.onstruct(2), C.onstruct(3), C.onstruct(4)));
-        assertCEquals(C.onstruct("astring"), a.exec(0, null, null, C.onstruct("a"), C.onstruct("string")));
-    }
-    
-    @Test
-    public void testLength(){
-        StringHandling.length a = new StringHandling.length();
-        TestBoilerplate(a, "length");
-        assertCEquals(C.onstruct(5), a.exec(0, null, null, C.onstruct("12345")));
-        assertCEquals(C.onstruct(2), a.exec(0, null, null, C.Array(C.onstruct(0), C.onstruct(1))));
-    }
-    
-    @Test
-    public void testParseArgs(){
-        StringHandling.parse_args a = new StringHandling.parse_args();
-        TestBoilerplate(a, "parse_args");
-        assertCEquals(C.Array(C.onstruct("one"), C.onstruct("two")), a.exec(0, null, null, C.onstruct("one   two")));
-        assertCEquals(C.Array(C.onstruct("one"), C.onstruct("two")), a.exec(0, null, null, C.onstruct("one two")));
-    }
-    
-    @Test
-    public void testRead(){
-        
-    }
-    
-    @Test
-    public void testReplace(){
-        StringHandling.replace a = new StringHandling.replace();
-        TestBoilerplate(a, "replace");
-        assertCEquals(C.onstruct("yay"), a.exec(0, null, null, C.onstruct("yayathing"), C.onstruct("athing"), C.onstruct("")));
-        assertCEquals(C.onstruct("yaymonkey"), a.exec(0, null, null, C.onstruct("yayathing"), C.onstruct("athing"), C.onstruct("monkey")));
-        assertCEquals(C.onstruct("yayathing"), a.exec(0, null, null, C.onstruct("yayathing"), C.onstruct("wut"), C.onstruct("chicken")));
-    }
-    
-    @Test
-    public void testSconcat(){
-        StringHandling.sconcat a = new StringHandling.sconcat();
-        TestBoilerplate(a, "sconcat");
-        assertCEquals(C.onstruct("1 2 3 4"), a.exec(0, null, null, C.onstruct(1), C.onstruct(2), C.onstruct(3), C.onstruct(4)));
-        assertCEquals(C.onstruct("a string"), a.exec(0, null, null, C.onstruct("a"), C.onstruct("string")));
-    }
-    
-    @Test
-    public void testSubstr(){
-        StringHandling.substr a = new StringHandling.substr();
-        TestBoilerplate(a, "substr");
-        assertCEquals(C.onstruct("urge"), a.exec(0, null, null, C.onstruct("hamburger"), C.onstruct(4), C.onstruct(8)));
-        assertCEquals(C.onstruct("mile"), a.exec(0, null, null, C.onstruct("smiles"), C.onstruct(1), C.onstruct(5)));
-        assertCEquals(C.onstruct("ning"), a.exec(0, null, null, C.onstruct("lightning"), C.onstruct(5)));
-    }
-    
-    @Test
-    public void testToUpper(){
-        StringHandling.to_upper a = new StringHandling.to_upper();
-        TestBoilerplate(a, "to_upper");
-        assertCEquals(C.onstruct("TESTING 123"), a.exec(0, null, null, C.onstruct("testing 123")));
-        assertCEquals(C.onstruct("TESTING 123"), a.exec(0, null, null, C.onstruct("TeStInG 123")));
-    }
-    
-    @Test
-    public void testToLower(){
-        StringHandling.to_lower a = new StringHandling.to_lower();
-        TestBoilerplate(a, "to_lower");
-        assertCEquals(C.onstruct("testing 123"), a.exec(0, null, null, C.onstruct("TESTING 123")));
-        assertCEquals(C.onstruct("testing 123"), a.exec(0, null, null, C.onstruct("TeStInG 123")));
-    }
-    
-    @Test
-    public void testTrim(){
-        StringHandling.trim a = new StringHandling.trim();
-        TestBoilerplate(a, "trim");
-        assertCEquals(C.onstruct("test 123"), a.exec(0, null, null, C.onstruct("    test 123    ")));
-        assertCEquals(C.onstruct("test   123"), a.exec(0, null, null, C.onstruct("test   123")));
-    }
-}
diff --git a/src/test/java/com/laytonsmith/core/MScriptCompilerTest.java b/src/test/java/com/laytonsmith/core/MScriptCompilerTest.java
new file mode 100644
index 0000000..1ec86c6
--- /dev/null
+++ b/src/test/java/com/laytonsmith/core/MScriptCompilerTest.java
@@ -0,0 +1,515 @@
+/*
+ * To change this template, choose Tools | Templates
+ * and open the template in the editor.
+ */
+package com.laytonsmith.core;
+
+import com.laytonsmith.abstraction.MCPlayer;
+import com.laytonsmith.abstraction.MCServer;
+import com.laytonsmith.commandhelper.CommandHelperPlugin;
+import com.laytonsmith.core.constructs.Token;
+import com.laytonsmith.core.constructs.Variable;
+import com.laytonsmith.core.exceptions.ConfigCompileException;
+import com.laytonsmith.testing.StaticTest;
+import static com.laytonsmith.testing.StaticTest.SRun;
+import com.sk89q.bukkit.migration.PermissionsResolverManager;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.List;
+import java.util.concurrent.atomic.AtomicBoolean;
+import static org.junit.Assert.*;
+import org.junit.*;
+import static org.mockito.Mockito.*;
+
+/**
+ *
+ * @author Layton
+ */
+public class MScriptCompilerTest {
+
+    MCServer fakeServer;
+    MCPlayer fakePlayer;
+    Env env = new Env();
+
+    public MScriptCompilerTest() {
+    }
+
+    @BeforeClass
+    public static void setUpClass() throws Exception {
+    }
+
+    @AfterClass
+    public static void tearDownClass() throws Exception {
+    }
+
+    @Before
+    public void setUp() {        
+        fakePlayer = StaticTest.GetOnlinePlayer();
+        fakeServer = StaticTest.GetFakeServer();
+        env.SetPlayer(fakePlayer);
+    }
+
+    @After
+    public void tearDown() {
+    }
+
+    /**
+     * Test of lex method, of class MScriptCompiler.
+     */
+    @Test
+    public void testLex() throws Exception {
+        System.out.println("lex");
+        String config = "/cmd = msg('string')";
+        List e = null;
+        e = new ArrayList();
+        //This is the decomposed version of the above config
+        e.add(new Token(Token.TType.COMMAND, "/cmd", 1, null));
+        e.add(new Token(Token.TType.ALIAS_END, "=", 1, null));
+        e.add(new Token(Token.TType.FUNC_NAME, "msg", 1, null));
+        e.add(new Token(Token.TType.FUNC_START, "(", 1, null));
+        e.add(new Token(Token.TType.STRING, "string", 1, null));
+        e.add(new Token(Token.TType.FUNC_END, ")", 1, null));
+        e.add(new Token(Token.TType.NEWLINE, "\n", 2, null));
+
+        List result = MScriptCompiler.lex(config, null);
+        assertEquals(e, result);
+
+        String[] badConfigs = {
+            "'\\q'", //Bad escape sequences
+            "'\\r'",};
+        for (String c : badConfigs) {
+            try {
+                MScriptCompiler.lex(c, null);
+                //Shouldn't get here
+                fail(c + " should not have lexed, but did.");
+            } catch (ConfigCompileException ex) {
+                //Success!
+            }
+        }
+    }
+    @Test
+    public void testCompile() throws ConfigCompileException {
+        System.out.println("compile");
+        MScriptCompiler.preprocess(MScriptCompiler.lex("/cmd = msg(this is a string, if(true, and, another) function)", null), env).get(0).compileRight();
+        try {
+            //extra parameter
+            MScriptCompiler.preprocess(MScriptCompiler.lex("/cmd = msg(this is a string, if(true, and, another, oops) function)", null), env).get(0).compileRight();
+            fail("Did not expect test to pass");
+        } catch (ConfigCompileException e) {
+            //passed
+        }
+        try {
+            //missing parenthesis
+            MScriptCompiler.preprocess(MScriptCompiler.lex("/cmd = msg(this is a string, if(true, and, another) function", null), env).get(0).compileRight();
+            fail("Did not expect test to pass");
+        } catch (ConfigCompileException e) {
+            //passed
+        }
+        try {
+            //extra parenthesis
+            MScriptCompiler.preprocess(MScriptCompiler.lex("/cmd = msg(this is a string, if(true, and, another) function)))))", null), env).get(0).compileRight();
+            fail("Did not expect test to pass");
+        } catch (ConfigCompileException e) {
+            //passed
+        }
+        try {
+            //extra parenthesis
+            MScriptCompiler.preprocess(MScriptCompiler.lex("/cmd = msg((this is a string, if(true, and, another) function))", null), env).get(0).compileRight();
+            fail("Did not expect test to pass");
+        } catch (ConfigCompileException e) {
+            //passed
+        }
+        try {
+            //extra multiline end construct
+            MScriptCompiler.preprocess(MScriptCompiler.lex("/cmd = msg(this is a string, if(true, and, another) function) <<<", null), env).get(0).compileRight();
+            fail("Did not expect test to pass");
+        } catch (ConfigCompileException e) {
+            //passed
+        }
+
+        MScriptCompiler.compile(MScriptCompiler.lex("if(1, msg('') msg(''))", null));
+    }
+
+    @Test
+    public void testExecute1() throws ConfigCompileException {
+        String script = "proc(_hello, @hello0,"
+                + "         msg(@hello0)"
+                + "      )"
+                + "      assign(@hello1, 'hello')"
+                + "      _hello(@hello1)";
+
+
+        MScriptCompiler.execute(MScriptCompiler.compile(MScriptCompiler.lex(script, null)), env, null, null);
+        verify(fakePlayer).sendMessage("hello");
+    }
+
+    @Test
+    public void testExecute2() throws ConfigCompileException {
+        String script =
+                "proc(_hello,\n"
+                + "     assign(@hello, 'hello')\n"
+                + "     return(@hello)\n"
+                + ")\n"
+                + "assign(@blah, 'blah')\n"
+                + "assign(@blah, _hello())\n"
+                + "msg(@blah)\n";
+
+
+        MScriptCompiler.execute(MScriptCompiler.compile(MScriptCompiler.lex(script, null)), env, null, null);
+        verify(fakePlayer).sendMessage("hello");
+    }
+
+    /**
+     * Here we are testing for mismatched (or empty) square brackets. Essentially, it should throw an exception.
+     */
+    @Test
+    public void testExecute3() {
+        try {
+            String script =
+                    "[";
+            MScriptCompiler.execute(MScriptCompiler.compile(MScriptCompiler.lex(script, null)), env, null, null);
+            fail("Test passed, but wasn't supposed to");
+        } catch (ConfigCompileException ex) {
+            //Passed
+        }
+        try {
+            String script =
+                    "]";
+            MScriptCompiler.execute(MScriptCompiler.compile(MScriptCompiler.lex(script, null)), env, null, null);
+            fail("Test passed, but wasn't supposed to");
+        } catch (ConfigCompileException ex) {
+            //Passed
+        }
+    }
+
+    @Test
+    public void testExecute4() throws ConfigCompileException {
+        String script =
+                "proc(_hello,"
+                + "     return('hello')"
+                + ")"
+                + "msg(_hello())";
+        MScriptCompiler.execute(MScriptCompiler.compile(MScriptCompiler.lex(script, null)), env, null, null);
+        verify(fakePlayer).sendMessage("hello");
+    }
+
+    @Test
+    public void testExecute5() throws ConfigCompileException {
+        String script =
+                "proc(_hello,"
+                + "     return('hello')"
+                + ")"
+                + "msg(_hello())";
+        MScriptCompiler.execute(MScriptCompiler.compile(MScriptCompiler.lex(script, null)), env, null, null);
+        verify(fakePlayer).sendMessage("hello");
+    }
+
+    @Test
+    public void testExecute6() throws ConfigCompileException {
+        String script =
+                "#This is a comment invalid()'\"'' function\n"
+                + "msg('hello')";
+        MScriptCompiler.execute(MScriptCompiler.compile(MScriptCompiler.lex(script, null)), env, null, null);
+        verify(fakePlayer).sendMessage("hello");
+    }
+
+    @Test
+    public void testExecute7() throws ConfigCompileException {
+        String script =
+                "msg('hello') #This is a comment too invalid()'\"'' function\n";
+        MScriptCompiler.execute(MScriptCompiler.compile(MScriptCompiler.lex(script, null)), env, null, null);
+        verify(fakePlayer).sendMessage("hello");
+    }
+
+    @Test(expected=ConfigCompileException.class)
+    public void testExecute8() throws ConfigCompileException {
+        String script =
+                "msg('hello') //This is no longer a comment too :( invalid()'\"'' function\n";
+        MScriptCompiler.execute(MScriptCompiler.compile(MScriptCompiler.lex(script, null)), env, null, null);
+        verify(fakePlayer).sendMessage("hello");
+    }
+
+    @Test
+    public void testExecute9() throws ConfigCompileException {
+        String script =
+                "msg('hello') /* This is a comment too invalid()'\"'' function\n"
+                + "yup, still a comment. yay() */";
+        MScriptCompiler.execute(MScriptCompiler.compile(MScriptCompiler.lex(script, null)), env, null, null);
+        verify(fakePlayer).sendMessage("hello");
+    }
+
+    @Test(expected = ConfigCompileException.class)
+    public void testExecute10() throws ConfigCompileException {
+        String script =
+                "msg('hello') /* This is a comment too invalid()'\"'' function\n"
+                + "yup, still a comment. yay() This will fail though, because the comment is unended.";
+        MScriptCompiler.execute(MScriptCompiler.compile(MScriptCompiler.lex(script, null)), env, null, null);
+    }
+
+    @Test(expected = ConfigCompileException.class)
+    public void testExecute11() throws ConfigCompileException {
+        String script =
+                "msg('hello') 'unended string";
+        MScriptCompiler.execute(MScriptCompiler.compile(MScriptCompiler.lex(script, null)), env, null, null);
+    }
+
+    @Test
+    public void testExecute12() throws ConfigCompileException {
+        String script =
+                "msg('hello') /* This is a comment too invalid()'\"'' function\n"
+                + "yup, still a comment. yay() */";
+        MScriptCompiler.execute(MScriptCompiler.compile(MScriptCompiler.lex(script, null)), env, null, null);
+        verify(fakePlayer).sendMessage("hello");
+    } 
+    
+    @Test
+    public void testExecute13() throws ConfigCompileException {
+        String script =
+                "assign(@a, array(0, 1, 2))"
+                + "msg(@a[0])";
+        MScriptCompiler.execute(MScriptCompiler.compile(MScriptCompiler.lex(script, null)), env, null, null);
+        verify(fakePlayer).sendMessage("0");
+    }
+    
+    @Test
+    public void testExecute14() throws ConfigCompileException {
+        String script =
+                "proc(_hello, assign(@i, 'world'),"
+                + "     return(@i)"
+                + ")"
+                + "msg(_hello('hello'))"
+                + "msg(_hello())";
+        MScriptCompiler.execute(MScriptCompiler.compile(MScriptCompiler.lex(script, null)), env, null, null);
+        verify(fakePlayer).sendMessage("hello");
+        verify(fakePlayer).sendMessage("world");
+    }
+    
+    @Test public void testExecute15() throws ConfigCompileException{
+        String script =
+                "assign(@i, 0)\n"
+                + "msg('@i is currently' @i)\n"
+                + "proc(_out, @i,\n"
+                + "     msg('@i is currently' @i 'and @j is' @j)\n"
+                + ")\n"
+                + "_out('hello')\n"
+                + "assign(@j, 'goodbye')\n"
+                + "_out('world')\n";
+        MScriptCompiler.execute(MScriptCompiler.compile(MScriptCompiler.lex(script, null)), env, null, null);
+        verify(fakePlayer).sendMessage("@i is currently 0");
+        verify(fakePlayer).sendMessage("@i is currently hello and @j is");
+        verify(fakePlayer).sendMessage("@i is currently world and @j is");
+    }
+    
+    @Test public void testExecute16() throws ConfigCompileException{
+        String script =
+                "proc(_myProc, @i, @j, @k, msg(@i @j @k))\n"
+                + "_myProc()\n"
+                + "_myProc(1)\n"
+                + "_myProc(1, 2)\n"
+                + "_myProc(1, 2, 3)\n"
+                + "_myProc(1, 2, 3, 4)\n";
+        MScriptCompiler.execute(MScriptCompiler.compile(MScriptCompiler.lex(script, null)), env, null, null);
+        //verify(fakePlayer).sendMessage("null null null");
+        verify(fakePlayer).sendMessage("1");
+        verify(fakePlayer).sendMessage("1 2");
+        verify(fakePlayer, times(2)).sendMessage("1 2 3");
+    }
+    
+    @Test public void testExecute17() throws ConfigCompileException{
+        String script =
+                "proc(_addition, @i, @j, msg(add(@i, @j)))\n"
+                + "_addition(1, 1)\n"
+                + "_addition(2, 2)";
+        MScriptCompiler.execute(MScriptCompiler.compile(MScriptCompiler.lex(script, null)), env, null, null);
+        //verify(fakePlayer).sendMessage("null null null");
+        verify(fakePlayer).sendMessage("2");
+        verify(fakePlayer).sendMessage("4");       
+    }
+    
+    @Test public void testExecute18() throws ConfigCompileException{
+        String script =
+                "proc(_myProc, msg(@arguments))\n"
+                + "_myProc()\n"
+                + "_myProc(1)\n"
+                + "_myProc(1, 2)";
+        MScriptCompiler.execute(MScriptCompiler.compile(MScriptCompiler.lex(script, null)), env, null, null);
+        //verify(fakePlayer).sendMessage("null null null");
+        verify(fakePlayer).sendMessage("{}");
+        verify(fakePlayer).sendMessage("{1}");       
+        verify(fakePlayer).sendMessage("{1, 2}");       
+    }
+    
+    /**
+     * Variables are locked in when the procedure is defined
+     * @throws ConfigCompileException 
+     */
+    @Test
+    public void testExecute19() throws ConfigCompileException {
+        String script =
+                "assign(@j, 'world')\n"
+                + "proc(_hello, assign(@i, @j),"
+                + "     return(@i)"
+                + ")\n"
+                + "assign(@j, 'goodbye')\n"
+                + "msg(_hello('hello'))"
+                + "msg(_hello())";
+        MScriptCompiler.execute(MScriptCompiler.compile(MScriptCompiler.lex(script, null)), env, null, null);
+        verify(fakePlayer).sendMessage("hello");
+        verify(fakePlayer).sendMessage("world");
+    }
+    @Test
+    public void testExecute20() throws ConfigCompileException {
+        final AtomicBoolean bool = new AtomicBoolean(false);
+        String script =
+                "msg('hello') world";
+        MScriptCompiler.execute(MScriptCompiler.compile(MScriptCompiler.lex(script, null)), env, new MScriptComplete() {
+
+            public void done(String output) {
+                assertEquals("world", output.trim());
+                bool.set(true);
+            }
+        }, null);
+        verify(fakePlayer).sendMessage("hello");
+        assertTrue(bool.get());
+    }
+
+    @Test
+    public void testCompile1() {
+        try {
+            String config = "/cmd [$p] $q = msg('')";
+            MScriptCompiler.preprocess(MScriptCompiler.lex(config, null), env).get(0).compile();
+            fail("Test passed, but wasn't supposed to");
+        } catch (ConfigCompileException ex) {
+            //Passed
+        }
+    }
+
+    @Test
+    public void testCompile2() {
+        try {
+            String config = "/cmd [$p=player()] = msg('')";
+            MScriptCompiler.preprocess(MScriptCompiler.lex(config, null), env).get(0).compile();
+            fail("Test passed, but wasn't supposed to");
+        } catch (ConfigCompileException ex) {
+            //Passed
+        }
+    }
+
+    @Test
+    public void testCompile4() throws ConfigCompileException {
+        String config = "/cmd = >>>\n"
+                + "msg('hello') #This is a comment too invalid()'\"'' function\n"
+                + "<<<";
+        MScriptCompiler.preprocess(MScriptCompiler.lex(config, null), env);
+    }
+    
+    @Test
+    public void testCompile5() throws ConfigCompileException {
+        String config = "label:/cmd = >>>\n"
+                + "msg('hello') #This is a comment too invalid()'\"'' function\n"
+                + "<<<";
+        Script s = MScriptCompiler.preprocess(MScriptCompiler.lex(config, null), env).get(0);
+        s.compile();
+        assertEquals("label", s.getLabel());
+    }
+    
+    @Test
+    public void testCompile6() throws ConfigCompileException {
+        String config = "/cmd = >>>\n"
+                + "msg(hello 'world \\\\ \\' \\n')"
+                + "<<<";
+        Script s = MScriptCompiler.preprocess(MScriptCompiler.lex(config, null), env).get(0);
+        s.compile();
+        s.run(new ArrayList<Variable>(), env, null);
+        verify(fakePlayer).sendMessage("hello world \\ ' ".trim());
+    }
+    
+    @Test
+    public void testCompile7() throws ConfigCompileException {
+        String config = "/cmd = >>>\n"
+                + "msg(hello) \\ msg(world)"
+                + "<<<";
+        Script s = MScriptCompiler.preprocess(MScriptCompiler.lex(config, null), env).get(0);
+        s.compile();
+        s.run(new ArrayList<Variable>(), env, null);
+        verify(fakePlayer).sendMessage("hello");
+        verify(fakePlayer).sendMessage("world");
+    }
+    
+    @Test
+    public void testCompile8() throws ConfigCompileException {
+        String config = "/cmd $one $ = >>>\n"
+                + "msg($one) \\ msg($)"
+                + "<<<";
+        Script s = MScriptCompiler.preprocess(MScriptCompiler.lex(config, null), env).get(0);
+        s.compile();
+        s.run(Arrays.asList(new Variable[]{new Variable("$one", "first", false, false, 0, null),
+            new Variable("$", "several variables", false, true, 0, null)}), env, null);
+        verify(fakePlayer).sendMessage("first");
+        verify(fakePlayer).sendMessage("several variables");
+    }
+    
+    @Test
+    public void testCompile9() throws ConfigCompileException {
+        String config = "/test [$var=1] = >>>\n"
+                + "msg($var)"
+                + "<<<";
+        Script s = MScriptCompiler.preprocess(MScriptCompiler.lex(config, null), env).get(0);
+        s.compile();
+        assertTrue(s.match("/test 2"));
+        s.run(Arrays.asList(new Variable[]{new Variable("$var", "2", true, false, 0, null)}), env, null);
+        verify(fakePlayer).sendMessage("2");
+        assertTrue(s.match("/test"));
+        s.run(new ArrayList<Variable>(), env, null);
+        verify(fakePlayer).sendMessage("1");
+    }
+    
+    @Test
+    public void testCompile10() throws ConfigCompileException{
+        String config = "/test $var = >>>\n"
+                + "msg($var)"
+                + "<<<";
+        Script s = MScriptCompiler.preprocess(MScriptCompiler.lex(config, null), env).get(0);
+        s.compile();
+        assertTrue(s.match("/test 2"));
+        assertFalse(s.match("/test"));
+        s.run(Arrays.asList(new Variable[]{new Variable("$var", "2", true, false, 0, null)}), env, null);
+    }
+    
+    @Test public void testCompile11() throws ConfigCompileException{
+        
+        CommandHelperPlugin.perms = mock(PermissionsResolverManager.class);
+        when(CommandHelperPlugin.perms.hasPermission(fakePlayer.getName(), "ch.alias.safe")).thenReturn(true);
+        CommandHelperPlugin.myServer = fakeServer;
+        when(fakeServer.getOnlinePlayers()).thenReturn(new MCPlayer[]{fakePlayer});
+        String config = "safe:/test $var = >>>\n"
+                + "all_players()\n"
+                + "msg($var)\n"
+                + "<<<";
+        Script s = MScriptCompiler.preprocess(MScriptCompiler.lex(config, null), env).get(0);        
+        s.compile();
+        assertEquals("safe", s.getLabel());
+        assertTrue(s.match("/test 2"));
+        s.run(Arrays.asList(new Variable[]{new Variable("$var", "2", true, false, 0, null)}), env, null);
+        verify(fakePlayer).sendMessage("2");
+        verify(CommandHelperPlugin.perms).hasPermission(fakePlayer.getName(), "ch.alias.safe");
+    }
+    
+    @Test public void testCompile12() throws ConfigCompileException{
+        String config = "/*/one = bad()*/\n"
+                + "/two = msg('Good')\n";
+        Script s = MScriptCompiler.preprocess(MScriptCompiler.lex(config, null), env).get(0);
+        s.compile();
+        assertFalse(s.match("/one"));
+        assertTrue(s.match("/two"));
+    }
+    
+    @Test public void testUnicode() throws ConfigCompileException{
+        SRun("msg('\\u0037 is win!')", fakePlayer);
+        verify(fakePlayer).sendMessage("7 is win!");
+        SRun("msg('\\u20ac')", fakePlayer);
+        verify(fakePlayer).sendMessage("");
+    }
+    
+    
+}
diff --git a/src/test/java/com/laytonsmith/core/ScriptTest.java b/src/test/java/com/laytonsmith/core/ScriptTest.java
new file mode 100644
index 0000000..58f0f38
--- /dev/null
+++ b/src/test/java/com/laytonsmith/core/ScriptTest.java
@@ -0,0 +1,132 @@
+/*
+ * To change this template, choose Tools | Templates
+ * and open the template in the editor.
+ */
+package com.laytonsmith.core;
+
+import org.junit.After;
+import org.junit.AfterClass;
+import org.junit.Before;
+import org.junit.BeforeClass;
+
+/**
+ *
+ * @author Layton
+ */
+public class ScriptTest {
+    
+    public ScriptTest() {
+    }
+
+    @BeforeClass
+    public static void setUpClass() throws Exception {
+    }
+
+    @AfterClass
+    public static void tearDownClass() throws Exception {
+    }
+    
+    @Before
+    public void setUp() {
+    }
+    
+    @After
+    public void tearDown() {
+    }
+
+//    @Test
+//    public void testToString() {
+//        System.out.println("toString");
+//        Script instance = new Script(null, null);
+//        assertTrue(instance.toString().length() > 0);
+//    }
+
+//    @Test
+//    public void testUncompilable() {
+//        System.out.println("uncompilable");
+//        Script instance = null;
+//        boolean expResult = false;
+//        boolean result = instance.uncompilable();
+//        assertEquals(expResult, result);
+//        // TODO review the generated test code and remove the default call to fail.
+//        fail("The test case is a prototype.");
+//    }
+//
+//    @Test
+//    public void testRun() {
+//        System.out.println("run");
+//        List<Variable> vars = null;
+//        Player p = null;
+//        MScriptComplete done = null;
+//        Script instance = null;
+//        instance.run(vars, p, done);
+//        // TODO review the generated test code and remove the default call to fail.
+//        fail("The test case is a prototype.");
+//    }
+//
+//    @Test
+//    public void testEval() throws Exception {
+//        System.out.println("eval");
+//        GenericTreeNode<Construct> c = null;
+//        Player player = null;
+//        List<Variable> vars = null;
+//        Script instance = null;
+//        Construct expResult = null;
+//        Construct result = instance.eval(c, player, vars);
+//        assertEquals(expResult, result);
+//        // TODO review the generated test code and remove the default call to fail.
+//        fail("The test case is a prototype.");
+//    }
+//
+//    @Test
+//    public void testMatch() {
+//        System.out.println("match");
+//        String command = "";
+//        Script instance = null;
+//        boolean expResult = false;
+//        boolean result = instance.match(command);
+//        assertEquals(expResult, result);
+//        // TODO review the generated test code and remove the default call to fail.
+//        fail("The test case is a prototype.");
+//    }
+//
+//    @Test
+//    public void testGetVariables() {
+//        System.out.println("getVariables");
+//        String command = "";
+//        Script instance = null;
+//        List expResult = null;
+//        List result = instance.getVariables(command);
+//        assertEquals(expResult, result);
+//        // TODO review the generated test code and remove the default call to fail.
+//        fail("The test case is a prototype.");
+//    }
+//
+//    @Test
+//    public void testCompile() throws Exception {
+//        System.out.println("compile");
+//        Script instance = null;
+//        instance.compile();
+//        // TODO review the generated test code and remove the default call to fail.
+//        fail("The test case is a prototype.");
+//    }
+//
+//    @Test
+//    public void testCompileRight() throws Exception {
+//        System.out.println("compileRight");
+//        Script instance = null;
+//        instance.compileRight();
+//        // TODO review the generated test code and remove the default call to fail.
+//        fail("The test case is a prototype.");
+//    }
+//
+//    @Test
+//    public void testCheckAmbiguous() throws Exception {
+//        System.out.println("checkAmbiguous");
+//        ArrayList<Script> scripts = null;
+//        Script instance = null;
+//        instance.checkAmbiguous(scripts);
+//        // TODO review the generated test code and remove the default call to fail.
+//        fail("The test case is a prototype.");
+//    }
+}
diff --git a/src/test/java/com/laytonsmith/core/TestStatic.java b/src/test/java/com/laytonsmith/core/TestStatic.java
new file mode 100644
index 0000000..c020b3e
--- /dev/null
+++ b/src/test/java/com/laytonsmith/core/TestStatic.java
@@ -0,0 +1,150 @@
+/*
+ * To change this template, choose Tools | Templates
+ * and open the template in the editor.
+ */
+package com.laytonsmith.core;
+
+import com.laytonsmith.core.constructs.*;
+import com.laytonsmith.core.exceptions.ConfigRuntimeException;
+import com.laytonsmith.testing.C;
+import org.junit.AfterClass;
+import static org.junit.Assert.*;
+import org.junit.Before;
+import org.junit.BeforeClass;
+import org.junit.Test;
+
+/**
+ *
+ * @author Layton
+ */
+public class TestStatic {
+    
+    public TestStatic() {
+    }
+
+    @BeforeClass
+    public static void setUpClass() throws Exception {
+    }
+
+    @AfterClass
+    public static void tearDownClass() throws Exception {
+    }
+    
+    @Before
+    public void setUp() {
+    }
+
+    @Test
+    public void testGetNumber() {
+        System.out.println("getNumber");
+        assertEquals(1.0, Static.getNumber(C.String("1.0")), 0.0);
+        assertEquals(1.0, Static.getNumber(C.String("1")), 0.0);
+        assertEquals(1.0, Static.getNumber(C.Int(1)), 0.0);
+        assertEquals(1.0, Static.getNumber(C.Double(1.0)), 0.0);
+    }
+
+    @Test
+    public void testGetDouble() {
+        System.out.println("getDouble");
+        assertEquals(1.0, Static.getDouble(C.String("1.0")), 0.0);
+        assertEquals(1.0, Static.getDouble(C.String("1")), 0.0);
+        assertEquals(1.0, Static.getDouble(C.Int(1)), 0.0);
+        assertEquals(1.0, Static.getDouble(C.Double(1.0)), 0.0);
+    }
+
+    @Test
+    public void testGetInt() {
+        System.out.println("getInt");
+        assertEquals(1, Static.getInt(C.Int(1)));
+        assertEquals(1, Static.getInt(C.String("1")));
+        try{
+            Static.getInt(C.Double(1.0));
+            fail("Should not have been able to parse 1.0 as an int");
+        } catch(ConfigRuntimeException e){ /* Test Passed */ }
+    }
+
+    @Test
+    public void testGetBoolean() {
+        System.out.println("getBoolean");
+        assertEquals(true, Static.getBoolean(C.Boolean(true)));
+        assertEquals(true, Static.getBoolean(C.String("non-empty string")));
+        assertEquals(false, Static.getBoolean(C.String("")));
+        assertEquals(true, Static.getBoolean(C.Int(1)));
+        assertEquals(false, Static.getBoolean(C.Int(0)));
+    }
+
+    @Test
+    public void testAnyDoubles() {
+        System.out.println("anyDoubles");
+        assertTrue(Static.anyDoubles(C.Int(0), C.Int(1), C.Double(1)));
+        assertFalse(Static.anyDoubles(C.Int(1)));
+    }
+
+    @Test
+    public void testAnyStrings() {
+        System.out.println("anyStrings");
+        assertTrue(Static.anyStrings(C.Int(0), C.Int(1), C.String("")));
+        assertFalse(Static.anyStrings(C.Int(1)));
+    }
+
+    @Test
+    public void testAnyBooleans() {
+        System.out.println("anyBooleans");
+        assertTrue(Static.anyBooleans(C.Int(0), C.Int(1), C.Boolean(true)));
+        assertFalse(Static.anyBooleans(C.Int(1)));
+    }
+
+    @Test
+    public void testGetLogger() {
+        System.out.println("getLogger");
+        assertNotNull(Static.getLogger());
+    }
+
+////    @Test(expected=NotInitializedYetException.class)
+////    public void testGetServer() {
+////        System.out.println("getServer");
+////        Static.getServer();
+////    }
+
+    @Test(expected=NotInitializedYetException.class)
+    public void testGetAliasCore() {
+        System.out.println("getAliasCore");
+        Static.getAliasCore();
+    }
+
+//    @Test(expected=NotInitializedYetException.class)
+//    public void testGetPersistance() {
+//        System.out.println("getPersistance");
+//        Static.getPersistance();
+//    }
+
+//    @Test(expected=NotInitializedYetException.class)
+//    public void testGetPermissionsResolverManager() {
+//        System.out.println("getPermissionsResolverManager");
+//        Static.getPermissionsResolverManager();
+//    }
+
+    @Test(expected=NotInitializedYetException.class)
+    public void testGetVersion() {
+        System.out.println("getVersion");
+        Static.getVersion();
+    }
+
+    @Test
+    public void testGetPreferences() {
+        System.out.println("getPreferences");
+        Static.getPreferences();
+    }
+
+    @Test
+    public void testResolveConstruct() {
+        System.out.println("resolveConstruct");
+        assertTrue(Static.resolveConstruct("1", 0, null) instanceof CInt);
+        assertTrue(Static.resolveConstruct("true", 0, null) instanceof CBoolean);
+        assertTrue(Static.resolveConstruct("false", 0, null) instanceof CBoolean);
+        assertTrue(Static.resolveConstruct("null", 0, null) instanceof CNull);
+        assertTrue(Static.resolveConstruct("1.1", 0, null) instanceof CDouble);
+        assertTrue(Static.resolveConstruct("string", 0, null) instanceof CString);
+    }
+        
+}
diff --git a/src/test/java/com/laytonsmith/core/events/PrefiltersTest.java b/src/test/java/com/laytonsmith/core/events/PrefiltersTest.java
new file mode 100644
index 0000000..f394c7b
--- /dev/null
+++ b/src/test/java/com/laytonsmith/core/events/PrefiltersTest.java
@@ -0,0 +1,151 @@
+/*
+ * To change this template, choose Tools | Templates
+ * and open the template in the editor.
+ */
+package com.laytonsmith.core.events;
+
+import com.laytonsmith.core.constructs.Construct;
+import com.laytonsmith.core.events.Prefilters.PrefilterType;
+import com.laytonsmith.core.exceptions.PrefilterNonMatchException;
+import com.laytonsmith.testing.C;
+import java.util.HashMap;
+import java.util.Map;
+import static org.junit.Assert.fail;
+import org.junit.*;
+
+/**
+ *
+ * @author layton
+ */
+public class PrefiltersTest {
+
+    public PrefiltersTest() {
+    }
+
+    @BeforeClass
+    public static void setUpClass() throws Exception {
+    }
+
+    @AfterClass
+    public static void tearDownClass() throws Exception {
+    }
+
+    @Before
+    public void setUp() {
+    }
+
+    @After
+    public void tearDown() {
+    }
+
+    /**
+     * Test of match method, of class Prefilters.
+     */
+    @Test
+    public void testRegexMatch() {
+        Map<String, Construct> map = new HashMap<String, Construct>();
+        map.put("x", C.String("/1|2|3/"));
+        try {
+            Prefilters.match(map, "x", C.Int(2), PrefilterType.REGEX);
+        } catch (PrefilterNonMatchException e) {
+            fail("Expected a match here");
+        }
+        try {
+            Prefilters.match(map, "x", C.Int(4), PrefilterType.REGEX);
+            fail("Did not expect a match here");
+        } catch (PrefilterNonMatchException e) {
+        }
+    }
+
+    @Test
+    public void testItemMatch() {
+        Map<String, Construct> map = new HashMap<String, Construct>();
+        map.put("x", C.String("35:2"));
+        try {
+            Prefilters.match(map, "x", "35:4", PrefilterType.ITEM_MATCH);
+        } catch (PrefilterNonMatchException e) {
+            fail("Expected a match here");
+        }
+        try {
+            Prefilters.match(map, "x", "35", PrefilterType.ITEM_MATCH);
+        } catch (PrefilterNonMatchException e) {
+            fail("Expected a match here");
+        }
+        try {
+            Prefilters.match(map, "x", "36:2", PrefilterType.ITEM_MATCH);
+            fail("Did not expect a match here");
+        } catch (PrefilterNonMatchException e) {
+        }
+
+    }
+
+    @Test
+    public void testStringMatch() {
+        Map<String, Construct> map = new HashMap<String, Construct>();
+        map.put("x", C.String("test"));
+        try {
+            Prefilters.match(map, "x", "test", PrefilterType.STRING_MATCH);
+        } catch (PrefilterNonMatchException e) {
+            fail("Expected a match here");
+        }
+        try {
+            Prefilters.match(map, "x", "nope", PrefilterType.STRING_MATCH);
+            fail("Did not expect a match here");
+        } catch (PrefilterNonMatchException e) {
+        }
+    }
+    
+    @Test public void testMathMatch(){
+        Map<String, Construct> map = new HashMap<String, Construct>();
+        map.put("x", C.String("2"));
+        try {
+            Prefilters.match(map, "x", "2.0", PrefilterType.MATH_MATCH);
+        } catch (PrefilterNonMatchException e) {
+            fail("Expected a match here");
+        }
+        try {
+            Prefilters.match(map, "x", "2.00001", PrefilterType.MATH_MATCH);
+            fail("Did not expect a match here");
+        } catch (PrefilterNonMatchException e) {
+        }
+    }
+    
+    @Test public void testExpressionMatch(){
+        Map<String, Construct> map = new HashMap<String, Construct>();
+        map.put("x", C.String("(x > 4)"));
+        try {
+            Prefilters.match(map, "x", "5", PrefilterType.EXPRESSION);
+        } catch (PrefilterNonMatchException e) {
+            fail("Expected a match here");
+        }
+        try {
+            Prefilters.match(map, "x", "4", PrefilterType.EXPRESSION);
+            fail("Did not expect a match here");
+        } catch (PrefilterNonMatchException e) {
+        }
+        
+        map.put("x", C.String("(x == 5)"));
+        try {
+            Prefilters.match(map, "x", "5", PrefilterType.EXPRESSION);
+        } catch (PrefilterNonMatchException e) {
+            fail("Expected a match here");
+        }
+        try {
+            Prefilters.match(map, "x", "4", PrefilterType.EXPRESSION);
+            fail("Did not expect a match here");
+        } catch (PrefilterNonMatchException e) {
+        }
+        
+        map.put("x", C.String("(2 + 3)"));
+        try {
+            Prefilters.match(map, "x", "5", PrefilterType.EXPRESSION);
+        } catch (PrefilterNonMatchException e) {
+            fail("Expected a match here");
+        }
+        try {
+            Prefilters.match(map, "x", "4", PrefilterType.EXPRESSION);
+            fail("Did not expect a match here");
+        } catch (PrefilterNonMatchException e) {
+        }
+    }
+}
diff --git a/src/test/java/com/laytonsmith/core/functions/ArrayHandlingTest.java b/src/test/java/com/laytonsmith/core/functions/ArrayHandlingTest.java
new file mode 100644
index 0000000..332c607
--- /dev/null
+++ b/src/test/java/com/laytonsmith/core/functions/ArrayHandlingTest.java
@@ -0,0 +1,211 @@
+/*
+ * To change this template, choose Tools | Templates
+ * and open the template in the editor.
+ */
+package com.laytonsmith.core.functions;
+
+import com.laytonsmith.abstraction.MCPlayer;
+import com.laytonsmith.core.Env;
+import com.laytonsmith.core.constructs.CArray;
+import com.laytonsmith.core.constructs.CInt;
+import com.laytonsmith.core.constructs.Construct;
+import com.laytonsmith.core.exceptions.CancelCommandException;
+import com.laytonsmith.core.exceptions.ConfigCompileException;
+import com.laytonsmith.core.exceptions.ConfigRuntimeException;
+import com.laytonsmith.testing.C;
+import com.laytonsmith.testing.StaticTest;
+import static com.laytonsmith.testing.StaticTest.*;
+import static org.junit.Assert.assertEquals;
+import org.junit.Before;
+import org.junit.Test;
+import static org.mockito.Mockito.*;
+
+/**
+ *
+ * @author Layton
+ */
+public class ArrayHandlingTest {
+
+    MCPlayer fakePlayer;
+    CArray commonArray;
+    Env env = new Env();
+
+    public ArrayHandlingTest() {
+    }
+
+    @Before
+    public void setUp() {
+        fakePlayer = StaticTest.GetOnlinePlayer();
+        commonArray = new CArray(0, null, new CInt(1, 0, null), new CInt(2, 0, null), new CInt(3, 0, null));
+        env.SetPlayer(fakePlayer);
+    }
+
+    /**
+     * Test of docs method, of class ArrayHandling.
+     */
+    @Test
+    public void testDocs() {
+        TestClassDocs(ArrayHandling.docs(), ArrayHandling.class);
+    }
+
+    @Test
+    public void testArraySize() throws ConfigCompileException, CancelCommandException {
+        ArrayHandling.array_size a = new ArrayHandling.array_size();
+        CArray arr = commonArray;
+        Construct ret = a.exec(0, null, env, arr);
+        assertReturn(ret, C.Int);
+        assertCEquals(C.onstruct(3), ret);
+    }
+    
+    @Test(expected=Exception.class)
+    public void testArraySizeEx() throws CancelCommandException{
+        ArrayHandling.array_size a = new ArrayHandling.array_size();
+        a.exec(0, null, env, C.Int(0));
+    }
+
+    @Test
+    public void testArraySet1() throws  ConfigCompileException {
+        String script =
+                "assign(@array, array(1,2,3)) msg(@array) array_set(@array, 2, 1) msg(@array)";
+        //MScriptCompiler.execute(MScriptCompiler.compile(MScriptCompiler.lex(script, null)), env, null, null);
+        StaticTest.Run(script, fakePlayer);
+        verify(fakePlayer).sendMessage("{1, 2, 3}");
+        verify(fakePlayer).sendMessage("{1, 2, 1}");
+    }
+    
+    @Test public void testArraySet2() throws ConfigCompileException{
+        SRun("assign(@array, array(1, 2)) assign(@array2, @array) array_set(@array, 0, 2) msg(@array) msg(@array2)", fakePlayer);
+        verify(fakePlayer, times(2)).sendMessage("{2, 2}");
+    }
+    
+    @Test public void testArrayReferenceBeingCorrect() throws ConfigCompileException{
+        SRun("assign(@array, array(1, 2)) assign(@array2, @array[]) array_set(@array, 0, 2) msg(@array) msg(@array2)", fakePlayer);
+        verify(fakePlayer).sendMessage("{2, 2}");
+        verify(fakePlayer).sendMessage("{1, 2}");
+    }
+    
+    @Test public void testArrayReferenceBeingCorrectWithArrayGet() throws ConfigCompileException{
+        SRun("assign(@array, array(1, 2)) "
+                + "assign(@array2, array_get(@array)) "
+                + "array_set(@array, 0, 2) "
+                + "msg(@array) "
+                + "msg(@array2)", fakePlayer);
+        verify(fakePlayer).sendMessage("{2, 2}");
+        verify(fakePlayer).sendMessage("{1, 2}");
+    }
+    
+    //This is valid behavior now.
+//    @Test(expected=ConfigRuntimeException.class)
+//    public void testArraySetEx() throws CancelCommandException, ConfigCompileException{
+//        String script =
+//                "assign(@array, array()) array_set(@array, 3, 1) msg(@array)";
+//        MScriptCompiler.execute(MScriptCompiler.compile(MScriptCompiler.lex(script, null)), env, null, null);
+//    }
+
+    @Test
+    public void testArrayContains() throws CancelCommandException {
+        ArrayHandling.array_contains a = new ArrayHandling.array_contains();
+        assertCEquals(C.onstruct(true), a.exec(0, null, env, commonArray, C.onstruct(1)));
+        assertCEquals(C.onstruct(false), a.exec(0, null, env, commonArray, C.onstruct(55)));
+    }
+    
+    @Test(expected=Exception.class)
+    public void testArrayContainsEx() throws CancelCommandException{
+        ArrayHandling.array_contains a = new ArrayHandling.array_contains();
+        a.exec(0, null, env, C.Int(0), C.Int(1));
+    }
+
+    @Test
+    public void testArrayGet() throws CancelCommandException {
+        ArrayHandling.array_get a = new ArrayHandling.array_get();
+        assertCEquals(C.onstruct(1), a.exec(0, null, env, commonArray, C.onstruct(0)));
+    }
+    
+    @Test(expected=Exception.class)
+    public void testArrayGetEx() throws CancelCommandException{
+        ArrayHandling.array_get a = new ArrayHandling.array_get();
+        a.exec(0, null, env, C.Int(0), C.Int(1));
+    }
+
+    @Test(expected = ConfigRuntimeException.class)
+    public void testArrayGetBad() throws CancelCommandException {
+        ArrayHandling.array_get a = new ArrayHandling.array_get();
+        a.exec(0, null, env, commonArray, C.onstruct(55));
+    }
+
+    @Test
+    public void testArrayPush() throws CancelCommandException {
+        ArrayHandling.array_push a = new ArrayHandling.array_push();
+        assertReturn(a.exec(0, null, env, commonArray, C.onstruct(4)), C.Void);
+        assertCEquals(C.onstruct(1), commonArray.get(0, 0, null));
+        assertCEquals(C.onstruct(2), commonArray.get(1, 0, null));
+        assertCEquals(C.onstruct(3), commonArray.get(2, 0, null));
+        assertCEquals(C.onstruct(4), commonArray.get(3, 0, null));
+    }
+    
+    @Test public void testArrayPush2() throws ConfigCompileException{
+        SRun("assign(@a, array(1))"
+                + "array_push(@a, 2, 3)"
+                + "msg(@a)", fakePlayer);
+        verify(fakePlayer).sendMessage("{1, 2, 3}");
+    }
+    
+    @Test(expected=Exception.class)
+    public void testArrayPushEx() throws CancelCommandException{
+        ArrayHandling.array_push a = new ArrayHandling.array_push();
+        a.exec(0, null, env, C.Int(0), C.Int(1));
+    }
+    
+    @Test public void testArrayResize() throws ConfigCompileException{
+        String script = "assign(@array, array(1)) msg(@array) array_resize(@array, 2) msg(@array) array_resize(@array, 3, 'hello') msg(@array)";
+        StaticTest.Run(script, fakePlayer);
+        verify(fakePlayer).sendMessage("{1}");
+        verify(fakePlayer).sendMessage("{1, null}");
+        verify(fakePlayer).sendMessage("{1, null, hello}");
+    }
+    
+    /**
+     * Because we are testing a loop, we put in an infinite loop detection of 10 seconds
+     * @throws ConfigCompileException 
+     */
+    @Test(timeout=10000) 
+    public void testRange() throws ConfigCompileException{
+        assertEquals("{0, 1, 2, 3, 4, 5, 6, 7, 8, 9}", SRun("range(10)", fakePlayer));
+        assertEquals("{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}", SRun("range(1, 11)", fakePlayer));
+        assertEquals("{0, 5, 10, 15, 20, 25}", SRun("range(0, 30, 5)", fakePlayer));
+        assertEquals("{0, 3, 6, 9}", SRun("range(0, 10, 3)", fakePlayer));
+        assertEquals("{0, -1, -2, -3, -4, -5, -6, -7, -8, -9}", SRun("range(0, -10, -1)", fakePlayer));
+        assertEquals("{}", SRun("range(0)", fakePlayer));
+        assertEquals("{}", SRun("range(1, 0)", fakePlayer));
+    }
+    
+    @Test public void testArraySliceAndNegativeIndexes() throws ConfigCompileException{
+        assertEquals("e", SRun("array(a, b, c, d, e)[-1]", null));
+        assertEquals("{a, b, c, d, e}", SRun("array(a, b, c, d, e)[]", null));
+        assertEquals("{b, c}", SRun("array(a, b, c, d, e)[1..2]", null));
+        assertEquals("{b, c, d, e}", SRun("array(a, b, c, d, e)[1..-1]", null));
+        assertEquals("1", SRun("array(a, array(1, 2), c, d, e)[0..1][1][0]", null));
+        assertEquals("{a, b}", SRun("array(a, b, c, d, e)[..1]", null));
+        assertEquals("{c, d, e}", SRun("array(a, b, c, d, e)[2..]", null));
+        assertEquals("{}", SRun("array(1, 2, 3, 4, 5)[3..0]", null));
+        assertEquals("{a, b}", SRun("array_get(array(a, b))", null));
+        assertEquals("{2, 3}", SRun("array(1, 2, 3)[1..-1]", null));
+        assertEquals("{2}", SRun("array(1, 2)[1..-1]", null));
+        assertEquals("{}", SRun("array(1)[1..-1]", null));
+    }
+    
+    @Test public void testArrayMergeNormal() throws ConfigCompileException{
+        assertEquals("{1, 2, 3, 4, 5, {6, 7}}", SRun("array_merge(array(1, 2, 3), array(4, 5, array(6, 7)))", fakePlayer));
+    }
+    
+    @Test public void testArrayMergeAssociative() throws ConfigCompileException{
+        assertEquals("{a: a, b: b, c: c, d: {1, 2}}", SRun("array_merge(array(a: a, b: b), array(c: c, d: array(1, 2)))", fakePlayer));
+    }
+    
+    @Test public void testArrayRemove() throws ConfigCompileException{
+        SRun("assign(@a, array(1, 2, 3)) array_remove(@a, 1) msg(@a)", fakePlayer);
+        verify(fakePlayer).sendMessage("{1, 3}");
+        SRun("assign(@a, array(a: a, b: b, c: c)) array_remove(@a, 'b') msg(@a)", fakePlayer);
+        verify(fakePlayer).sendMessage("{a: a, c: c}");
+    }
+}
diff --git a/src/test/java/com/laytonsmith/core/functions/BasicLogicTest.java b/src/test/java/com/laytonsmith/core/functions/BasicLogicTest.java
new file mode 100644
index 0000000..6f9a753
--- /dev/null
+++ b/src/test/java/com/laytonsmith/core/functions/BasicLogicTest.java
@@ -0,0 +1,310 @@
+/*
+ * To change this template, choose Tools | Templates
+ * and open the template in the editor.
+ */
+package com.laytonsmith.core.functions;
+
+import com.laytonsmith.abstraction.MCPlayer;
+import com.laytonsmith.abstraction.MCServer;
+import com.laytonsmith.core.Env;
+import com.laytonsmith.core.constructs.CArray;
+import com.laytonsmith.core.constructs.CBoolean;
+import com.laytonsmith.core.constructs.CInt;
+import com.laytonsmith.core.exceptions.CancelCommandException;
+import com.laytonsmith.core.exceptions.ConfigCompileException;
+import com.laytonsmith.testing.C;
+import static com.laytonsmith.testing.StaticTest.*;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.fail;
+import org.junit.*;
+import static org.mockito.Mockito.times;
+import static org.mockito.Mockito.verify;
+
+/**
+ *
+ * @author Layton
+ */
+public class BasicLogicTest {
+    
+    MCPlayer fakePlayer;
+    MCServer fakeServer;
+    CArray commonArray;
+    CInt arg1_1;
+    CInt arg1_2;
+    CInt arg2_1;
+    CInt argn1_1;
+    CInt argn2_1;
+    CBoolean _true;
+    CBoolean _false;
+    Env env = new Env();
+    
+    public BasicLogicTest() {
+    }
+
+    @BeforeClass
+    public static void setUpClass() throws Exception {
+    }
+
+    @AfterClass
+    public static void tearDownClass() throws Exception {
+    }
+    
+    @Before
+    public void setUp() {
+        commonArray = C.Array(C.Null(), C.Int(1), C.String("2"), C.Double(3.0));
+        arg1_1 = C.Int(1);
+        arg1_2 = C.Int(1);
+        arg2_1 = C.Int(2);
+        argn1_1 = C.Int(-1);
+        argn2_1 = C.Int(-2);
+        _true = C.Boolean(true);
+        _false = C.Boolean(false);
+        fakeServer = GetFakeServer();
+        fakePlayer = GetOnlinePlayer(fakeServer);
+        env.SetPlayer(fakePlayer);
+    }
+    
+    @After
+    public void tearDown() {
+    }
+
+    @Test
+    public void testDocs() {
+        TestClassDocs(BasicLogic.docs(), BasicLogic.class);
+    }
+    
+    @Test
+    public void testEquals() throws CancelCommandException{
+        BasicLogic.equals e = new BasicLogic.equals();
+
+//             T   F   1   0  -1  '1' '0' '-1' N  {} 'CH'  '' 1.0
+//        ---------------------------------------------------
+//        T    T   F   T   F   T   T   T   T   F   F   T   F   T
+//        F    -   T   F   T   F   F   F   F   T   T   F   T   F
+//        1    -   -   T   F   F   T   F   F   F   F   F   F   T
+//        0    -   -   -   T   F   F   T   F   F   F   F   F   F
+//        -1   -   -   -   -   T   F   F   T   F   F   F   F   F
+//        '1'  -   -   -   -   -   T   F   F   F   F   F   F   T
+//        '0'  -   -   -   -   -   -   T   F   F   F   F   F   F
+//        '-1' -   -   -   -   -   -   -   T   F   F   F   F   F
+//        N    -   -   -   -   -   -   -   -   T   F   F   F   F
+//        {}   -   -   -   -   -   -   -   -   -   T   F   F   F
+//        'CH' -   -   -   -   -   -   -   -   -   -   T   F   F
+//        ''   -   -   -   -   -   -   -   -   -   -   -   T   F
+//        1.0  -   -   -   -   -   -   -   -   -   -   -   -   T
+
+        _t("false", "false");
+        _f("false", "1");
+        _t("false", "0");
+        //TODO: Finish
+        
+        _t("true", "true");
+        _f("true", "false");
+        _t("true", "1");
+        _f("true", "0");
+        _t("true", "-1");
+        _t("true", "'1'");
+        _t("true", "'0'");
+        _t("true", "'-1'");
+        _f("true", "null");
+        _f("true", "array()");
+        _t("true", "'CH'");
+        _f("true", "''");
+        _t("true", "1.0");
+        
+        
+    }
+    
+    public void _t(String val1, String val2){
+        try {
+            assertEquals("true", SRun("equals(" + val1 + ", " + val2 + ")", null));
+        } catch (ConfigCompileException ex) {
+            fail(ex.getMessage());
+        }
+    }
+    
+    public void _f(String val1, String val2){
+        try {
+            assertEquals("false", SRun("equals(" + val1 + ", " + val2 + ")", null));
+        } catch (ConfigCompileException ex) {
+            fail(ex.getMessage());
+        }
+    }
+    
+    public void testEqualsIC() throws ConfigCompileException{
+        SRun("if(equals_ic('hi', 'HI'), msg('pass'))", fakePlayer);
+        SRun("if(equals_ic('hi', 'hi'), msg('pass'))", fakePlayer);
+        SRun("if(not(equals_ic('what', 'hi')), msg('pass'))", fakePlayer);
+        SRun("if(equals_ic(2, 2), msg('pass'))", fakePlayer);
+        SRun("if(not(equals_ic(2, 'hi')), msg('pass'))", fakePlayer);
+        verify(fakePlayer, times(5)).sendMessage("pass");
+    }
+    
+    @Test public void testAnd1() throws CancelCommandException, ConfigCompileException{
+        SRun("if(and(true, true, true), msg(pass))", fakePlayer);
+        SRun("if(and(true, true, false), '', msg(pass))", fakePlayer);
+        SRun("if(and(true, true), msg(pass))", fakePlayer);
+        SRun("if(and(true, false), '', msg(pass))", fakePlayer);
+        SRun("if(and(false, false), '', msg(pass))", fakePlayer);
+        SRun("if(and(true), msg(pass))", fakePlayer);
+        SRun("if(and(false), '', msg(pass))", fakePlayer);
+        verify(fakePlayer, times(7)).sendMessage("pass");
+    }
+    
+    /**
+     * Tests lazy evaluation
+     * @return
+     * @throws ConfigCompileException 
+     */
+    @Test public void testAnd2() throws ConfigCompileException{
+        SRun("and(false, msg(lol))", fakePlayer);
+        verify(fakePlayer, times(0)).sendMessage("lol");
+    }
+    
+    @Test public void testOr1() throws CancelCommandException, ConfigCompileException{
+        SRun("if(or(true, true, true), msg(pass))", fakePlayer);
+        SRun("if(or(true, true, false), msg(pass))", fakePlayer);
+        SRun("if(or(true, true), msg(pass))", fakePlayer);
+        SRun("if(or(true, false), msg(pass))", fakePlayer);
+        SRun("if(or(false, false), '', msg(pass))", fakePlayer);
+        SRun("if(or(true), msg(pass))", fakePlayer);
+        SRun("if(or(false), '', msg(pass))", fakePlayer);
+        verify(fakePlayer, times(7)).sendMessage("pass");
+    }
+    
+    @Test public void testOr2() throws ConfigCompileException{
+        SRun("or(true, msg(lol))", fakePlayer);
+        verify(fakePlayer, times(0)).sendMessage("lol");
+    }
+    
+    @Test public void testNot() throws CancelCommandException{
+        BasicLogic.not a = new BasicLogic.not();
+        assertCFalse(a.exec(0, null, env, _true));
+        assertCTrue(a.exec(0, null, env, _false));
+    }
+    
+    @Test public void testGt() throws CancelCommandException{
+        BasicLogic.gt a = new BasicLogic.gt();
+        assertCFalse(a.exec(0, null, env, arg1_1, arg1_2));
+        assertCTrue(a.exec(0, null, env, arg2_1, arg1_1));
+        assertCFalse(a.exec(0, null, env, arg1_1, arg2_1));
+        assertCFalse(a.exec(0, null, env, argn1_1, arg1_1));
+        assertCTrue(a.exec(0, null, env, arg1_1, argn1_1));
+    }
+    
+    @Test public void testGte() throws CancelCommandException{
+        BasicLogic.gte a = new BasicLogic.gte();
+        assertCTrue(a.exec(0, null, env, arg1_1, arg1_2));
+        assertCTrue(a.exec(0, null, env, arg2_1, arg1_1));
+        assertCFalse(a.exec(0, null, env, arg1_1, arg2_1));
+        assertCFalse(a.exec(0, null, env, argn1_1, arg1_1));
+        assertCTrue(a.exec(0, null, env, arg1_1, argn1_1));
+    }
+    
+    @Test public void testLt() throws CancelCommandException{
+        BasicLogic.lt a = new BasicLogic.lt();
+        assertCFalse(a.exec(0, null, env, arg1_1, arg1_2));
+        assertCFalse(a.exec(0, null, env, arg2_1, arg1_1));
+        assertCTrue(a.exec(0, null, env, arg1_1, arg2_1));
+        assertCTrue(a.exec(0, null, env, argn1_1, arg1_1));
+        assertCFalse(a.exec(0, null, env, arg1_1, argn1_1));
+    }
+    
+    @Test public void testLte() throws CancelCommandException{
+        BasicLogic.lte a = new BasicLogic.lte();
+        assertCTrue(a.exec(0, null, env, arg1_1, arg1_2));
+        assertCFalse(a.exec(0, null, env, arg2_1, arg1_1));
+        assertCTrue(a.exec(0, null, env, arg1_1, arg2_1));
+        assertCTrue(a.exec(0, null, env, argn1_1, arg1_1));
+        assertCFalse(a.exec(0, null, env, arg1_1, argn1_1));
+    }
+    
+    @Test public void testIf() throws ConfigCompileException{
+        BasicLogic._if a = new BasicLogic._if();
+        SRun("if(true, msg('correct'), msg('incorrect'))", fakePlayer);
+        SRun("if(false, msg('incorrect'), msg('correct'))", fakePlayer);
+        verify(fakePlayer, times(2)).sendMessage("correct");
+    }
+    
+    @Test public void testXor() throws ConfigCompileException{
+        assertEquals("false", SRun("xor(false, false)", null));
+        assertEquals("true", SRun("xor(false, true)", null));
+        assertEquals("true", SRun("xor(true, false)", null));
+        assertEquals("false", SRun("xor(true, true)", null));
+    }
+    @Test public void testNand() throws ConfigCompileException{
+        assertEquals("true", SRun("nand(false, false)", null));
+        assertEquals("true", SRun("nand(false, true)", null));
+        assertEquals("true", SRun("nand(true, false)", null));
+        assertEquals("false", SRun("nand(true, true)", null));
+    }
+    @Test public void testNor() throws ConfigCompileException{
+        assertEquals("true", SRun("nor(false, false)", null));
+        assertEquals("false", SRun("nor(false, true)", null));
+        assertEquals("false", SRun("nor(true, false)", null));
+        assertEquals("false", SRun("nor(true, true)", null));
+    }
+    @Test public void testXnor() throws ConfigCompileException{
+        assertEquals("true", SRun("xnor(false, false)", null));
+        assertEquals("false", SRun("xnor(false, true)", null));
+        assertEquals("false", SRun("xnor(true, false)", null));
+        assertEquals("true", SRun("xnor(true, true)", null));
+    }
+    
+    @Test public void testBitAnd() throws ConfigCompileException{
+        assertEquals("4", SRun("bit_and(4, 7)", null));
+        assertEquals("5", SRun("bit_and(7, 5)", null));
+        assertEquals("0", SRun("bit_and(1, 4)", null));
+    }
+    @Test public void testBitOr() throws ConfigCompileException{
+        assertEquals("3", SRun("bit_or(1, 3)", null));
+        assertEquals("6", SRun("bit_or(2, 4)", null));
+    }
+    @Test public void testBitNot() throws ConfigCompileException{
+        assertEquals("-5", SRun("bit_not(4)", null));
+    }
+    @Test public void testLshift() throws ConfigCompileException{
+        assertEquals("16", SRun("lshift(4, 2)", null));
+    }
+    @Test public void testRshift() throws ConfigCompileException{
+        assertEquals("-3", SRun("rshift(-10, 2)", null));
+        assertEquals("1", SRun("rshift(3, 1)", null));
+    }
+    @Test public void testUrshift() throws ConfigCompileException{
+        assertEquals("2", SRun("urshift(10, 2)", null));
+        assertEquals("4611686018427387901", SRun("urshift(-10, 2)", null));
+    }
+    
+    @Test public void testIfelse() throws ConfigCompileException{
+        assertEquals("3", SRun("ifelse("
+                + "false, 1,"
+                + "false, 2,"
+                + "true, 3,"
+                + "true, 4,"
+                + "false, 5)", null));
+        assertEquals("4", SRun("ifelse("
+                + "false, 1,"
+                + "false, 2,"
+                + "false, 3,"
+                + "add(2, 2))", null));
+    }
+    
+    @Test public void testSwitch() throws ConfigCompileException{
+        assertEquals("correct", SRun("switch(3,"
+                + "1, wrong,"
+                + "2, wrong,"
+                + "3, correct,"
+                + "4, wrong)", null));
+        assertEquals("correct", SRun("switch(4,"
+                + "1, wrong,"
+                + "2, wrong,"
+                + "3, wrong,"
+                + "correct)", null));
+    }
+    
+    @Test public void testSequals() throws ConfigCompileException{
+        assertEquals("true", SRun("sequals(1, 1)", null));
+        assertEquals("false", SRun("sequals(1, '1')", null));
+        assertEquals("false", SRun("sequals(1, '2')", null));
+    }
+}
diff --git a/src/test/java/com/laytonsmith/core/functions/CryptoTest.java b/src/test/java/com/laytonsmith/core/functions/CryptoTest.java
new file mode 100644
index 0000000..ba60f6f
--- /dev/null
+++ b/src/test/java/com/laytonsmith/core/functions/CryptoTest.java
@@ -0,0 +1,48 @@
+/*
+ * To change this template, choose Tools | Templates
+ * and open the template in the editor.
+ */
+package com.laytonsmith.core.functions;
+
+import com.laytonsmith.core.exceptions.ConfigCompileException;
+import static com.laytonsmith.testing.StaticTest.SRun;
+import static org.junit.Assert.assertEquals;
+import org.junit.*;
+
+/**
+ *
+ * @author Layton
+ */
+public class CryptoTest {
+    
+    public CryptoTest() {
+    }
+
+    @BeforeClass
+    public static void setUpClass() throws Exception {
+    }
+
+    @AfterClass
+    public static void tearDownClass() throws Exception {
+    }
+    
+    @Before
+    public void setUp() {
+    }
+    
+    @After
+    public void tearDown() {
+    }
+
+    @Test public void testRot13() throws ConfigCompileException{
+        assertEquals("hello world", SRun("rot13(uryyb jbeyq)", null));
+    }
+    
+    @Test public void testMd5() throws ConfigCompileException{
+        assertEquals("5eb63bbbe01eeed093cb22bb8f5acdc3", SRun("md5('hello world')", null));
+    }
+    
+    @Test public void testSha1() throws ConfigCompileException{
+        assertEquals("2aae6c35c94fcfb415dbe95f408b9ce91ee846ed", SRun("sha1('hello world')", null));
+    }
+}
diff --git a/src/test/java/com/laytonsmith/core/functions/DataHandlingTest.java b/src/test/java/com/laytonsmith/core/functions/DataHandlingTest.java
new file mode 100644
index 0000000..e26abeb
--- /dev/null
+++ b/src/test/java/com/laytonsmith/core/functions/DataHandlingTest.java
@@ -0,0 +1,279 @@
+/*
+ * To change this template, choose Tools | Templates
+ * and open the template in the editor.
+ */
+package com.laytonsmith.core.functions;
+
+import com.laytonsmith.PureUtilities.fileutility.FileUtility;
+import com.laytonsmith.abstraction.MCPlayer;
+import com.laytonsmith.abstraction.MCServer;
+import com.laytonsmith.core.Env;
+import com.laytonsmith.core.MScriptCompiler;
+import com.laytonsmith.core.Script;
+import com.laytonsmith.core.constructs.Variable;
+import com.laytonsmith.core.exceptions.ConfigCompileException;
+import com.laytonsmith.core.exceptions.ConfigRuntimeException;
+import com.laytonsmith.testing.StaticTest;
+import static com.laytonsmith.testing.StaticTest.SRun;
+import java.io.File;
+import java.io.IOException;
+import java.util.Arrays;
+import org.junit.*;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.when;
+
+/**
+ *
+ * @author layton
+ */
+public class DataHandlingTest {
+    
+    MCServer fakeServer;
+    MCPlayer fakePlayer;
+    Env env = new Env();
+
+    public DataHandlingTest() {
+    }
+
+    @BeforeClass
+    public static void setUpClass() throws Exception {
+    }
+
+    @AfterClass
+    public static void tearDownClass() throws Exception {
+    }
+
+    @Before
+    public void setUp() {
+        fakePlayer = StaticTest.GetOnlinePlayer();
+        fakeServer = StaticTest.GetFakeServer();
+        env.SetPlayer(fakePlayer);
+    }
+
+    @After
+    public void tearDown() {
+    }
+
+
+    @Test
+    public void testFor1() throws ConfigCompileException {
+        String config = "/for = >>>\n"
+                + " assign(@array, array())"
+                + " for(assign(@i, 0), lt(@i, 5), inc(@i),\n"
+                + "     array_push(@array, @i)\n"
+                + " )\n"
+                + " msg(@array)\n"
+                + "<<<\n";
+        Script s = MScriptCompiler.preprocess(MScriptCompiler.lex(config, null), env).get(0);
+        s.compile();
+        s.run(Arrays.asList(new Variable[]{}), env, null);
+        verify(fakePlayer).sendMessage("{0, 1, 2, 3, 4}");
+    }
+    
+    @Test(expected=ConfigRuntimeException.class) 
+    public void testFor2() throws ConfigCompileException{
+        String script = "/for = >>>\n"
+                + " assign(@array, array())"
+                + " for(assign(@i, 0), 'nope', inc(@i),\n"
+                + "     array_push(@array, @i)\n"
+                + " )\n"
+                + " msg(@array)\n"
+                + "<<<\n";
+        MScriptCompiler.execute(MScriptCompiler.compile(MScriptCompiler.lex(script, null)), env, null, null);
+        
+    }
+    
+    @Test(expected=ConfigRuntimeException.class) 
+    public void testFor3() throws ConfigCompileException{
+        String script = 
+                "   assign(@array, array())"
+                + " for('nope', lt(@i, 5), inc(@i),\n"
+                + "     array_push(@array, @i)\n"
+                + " )\n"
+                + " msg(@array)\n";
+        MScriptCompiler.execute(MScriptCompiler.compile(MScriptCompiler.lex(script, null)), env, null, null);
+        
+    }
+    
+    @Test public void testForeach1() throws ConfigCompileException{
+        String config = "/for = >>>\n"
+                + " assign(@array, array(1, 2, 3, 4, 5))\n"
+                + " assign(@array2, array())"
+                + " foreach(@array, @i,\n"
+                + "     array_push(@array2, @i)\n"
+                + " )\n"
+                + " msg(@array2)\n"
+                + "<<<\n";
+        Script s = MScriptCompiler.preprocess(MScriptCompiler.lex(config, null), env).get(0);
+        s.compile();
+        s.run(Arrays.asList(new Variable[]{}), env, null);
+        verify(fakePlayer).sendMessage("{1, 2, 3, 4, 5}");
+    }
+    
+    @Test public void testForeach2() throws ConfigCompileException{
+        String config = "/for = >>>\n"
+                + " assign(@array, array(1, 2, 3, 4, 5))\n"
+                + " assign(@array2, array())"
+                + " foreach(@array, @i,\n"
+                + "     if(equals(@i, 1), continue(2))"
+                + "     array_push(@array2, @i)\n"
+                + " )\n"
+                + " msg(@array2)\n"
+                + "<<<\n";
+        Script s = MScriptCompiler.preprocess(MScriptCompiler.lex(config, null), env).get(0);
+        s.compile();
+        s.run(Arrays.asList(new Variable[]{}), env, null);
+        verify(fakePlayer).sendMessage("{3, 4, 5}");
+    }
+    
+    @Test public void testForeach3() throws ConfigCompileException{
+        String config = "/for = >>>\n"
+                + " assign(@array, array(1, 2, 3, 4, 5))\n"
+                + " assign(@array1, array(1, 2, 3, 4, 5))\n"
+                + " assign(@array2, array())\n"
+                + " foreach(@array1, @j,"
+                + "     foreach(@array, @i,\n"
+                + "         if(equals(@i, 3), break(2))"
+                + "         array_push(@array2, @i)\n"
+                + "     )\n"
+                + " )"
+                + " msg(@array2)\n"
+                + "<<<\n";
+        Script s = MScriptCompiler.preprocess(MScriptCompiler.lex(config, null), env).get(0);
+        s.compile();
+        s.run(Arrays.asList(new Variable[]{}), env, null);
+        verify(fakePlayer).sendMessage("{1, 2}");
+    }
+    
+    @Test public void testCallProcIsProc() throws ConfigCompileException{
+        when(fakePlayer.isOp()).thenReturn(true);
+        String config = "/for = >>>\n"
+                + " msg(is_proc(_proc))\n"
+                + " proc(_proc,"
+                + "     msg('hello world')"
+                + " )"
+                + " msg(is_proc(_proc))"
+                + " call_proc(_proc)"
+                + "<<<\n";
+        Script s = MScriptCompiler.preprocess(MScriptCompiler.lex(config, null), env).get(0);
+        s.compile();
+        s.run(Arrays.asList(new Variable[]{}), env, null);
+        verify(fakePlayer).sendMessage("false");
+        verify(fakePlayer).sendMessage("true");
+        verify(fakePlayer).sendMessage("hello world");
+    }
+    
+    /**
+     * There is a bug that causes an infinite loop, so we put a 10 second timeout
+     * @throws ConfigCompileException 
+     */
+    @Test(timeout=10000) public void testContinue1() throws ConfigCompileException{
+        String config = "/continue = >>>\n"
+                + " assign(@array, array())"
+                + " for(assign(@i, 0), lt(@i, 5), inc(@i),\n"
+                + "     if(equals(@i, 2), continue(1))\n"
+                + "     array_push(@array, @i)\n"
+                + " )\n"
+                + " msg(@array)\n"
+                + "<<<\n";
+        Script s = MScriptCompiler.preprocess(MScriptCompiler.lex(config, null), env).get(0);
+        s.compile();
+        s.run(Arrays.asList(new Variable[]{}), env, null);
+        verify(fakePlayer).sendMessage("{0, 1, 3, 4}");
+    }
+    
+    @Test(timeout=10000) public void testContinue2() throws ConfigCompileException{
+        String config = "/continue = >>>\n"
+                + " assign(@array, array())"
+                + " for(assign(@i, 0), lt(@i, 5), inc(@i),\n"
+                + "     if(equals(@i, 2), continue(2))\n"
+                + "     array_push(@array, @i)\n"
+                + " )\n"
+                + " msg(@array)\n"
+                + "<<<\n";
+        Script s = MScriptCompiler.preprocess(MScriptCompiler.lex(config, null), env).get(0);
+        s.compile();
+        s.run(Arrays.asList(new Variable[]{}), env, null);
+        verify(fakePlayer).sendMessage("{0, 1, 4}");
+    }
+    
+    @Test(timeout=10000) public void testContinue3() throws ConfigCompileException{
+        String config = "/continue = >>>\n"
+                + " assign(@array, array())"
+                + " for(assign(@i, 0), lt(@i, 5), inc(@i),\n"
+                + "     if(equals(@i, 2), continue(3))\n"
+                + "     array_push(@array, @i)\n"
+                + " )\n"
+                + " msg(@array)\n"
+                + "<<<\n";
+        Script s = MScriptCompiler.preprocess(MScriptCompiler.lex(config, null), env).get(0);
+        s.compile();
+        s.run(Arrays.asList(new Variable[]{}), env, null);
+        verify(fakePlayer).sendMessage("{0, 1}");
+    }
+    
+    @Test public void testBreak1() throws ConfigCompileException{
+        String config = "/break = >>>\n"
+                + " assign(@array, array())"
+                + " for(assign(@i, 0), lt(@i, 2), inc(@i),\n"
+                + "     for(assign(@j, 0), lt(@j, 5), inc(@j),\n"
+                + "         if(equals(@j, 2), break())\n"
+                + "         array_push(@array, concat('j:', @j))\n"
+                + "     )\n"
+                + "     array_push(@array, concat('i:', @i))\n"
+                + " )\n"
+                + " msg(@array)\n"
+                + "<<<\n";
+        Script s = MScriptCompiler.preprocess(MScriptCompiler.lex(config, null), env).get(0);
+        s.compile();
+        s.run(Arrays.asList(new Variable[]{}), env, null);
+        verify(fakePlayer).sendMessage("{j:0, j:1, i:0, j:0, j:1, i:1}");
+    }
+    
+    @Test public void testBreak2() throws ConfigCompileException{
+        String config = "/break = >>>\n"
+                + " assign(@array, array())"
+                + " for(assign(@i, 0), lt(@i, 2), inc(@i),\n"
+                + "     for(assign(@j, 0), lt(@j, 5), inc(@j),\n"
+                + "         if(equals(@j, 2), break(2))\n"
+                + "         array_push(@array, concat('j:', @j))\n"
+                + "     )\n"
+                + "     array_push(@array, concat('i:', @i))\n"
+                + " )\n"
+                + " msg(@array)\n"
+                + "<<<\n";
+        Script s = MScriptCompiler.preprocess(MScriptCompiler.lex(config, null), env).get(0);
+        s.compile();
+        s.run(Arrays.asList(new Variable[]{}), env, null);
+        verify(fakePlayer).sendMessage("{j:0, j:1}");
+    }
+    
+    @Test public void testInclude() throws ConfigCompileException, IOException{
+        String script = 
+                "include('unit_test_inc.ms')";
+        //Create the test file
+        File test = new File("unit_test_inc.ms");
+        FileUtility.write("msg('hello')", test);
+        MScriptCompiler.execute(MScriptCompiler.compile(MScriptCompiler.lex(script, null)), env, null, null);
+        verify(fakePlayer).sendMessage("hello");
+        //delete the test file
+        test.delete();
+    }
+    
+    @Test public void testExportImportIVariable() throws ConfigCompileException{
+        when(fakePlayer.isOp()).thenReturn(true);
+        String script1 = 
+                "assign(@var, 10)"
+                + "export(@var)";
+        SRun(script1, null);
+        SRun("import(@var) msg(@var)", fakePlayer);
+        verify(fakePlayer).sendMessage("10");
+    }
+    
+    @Test public void testExportImportStringValue() throws ConfigCompileException{
+        when(fakePlayer.isOp()).thenReturn(Boolean.TRUE);
+        SRun("export('hi', 20)", fakePlayer);
+        SRun("msg(import('hi'))", fakePlayer);
+        verify(fakePlayer).sendMessage("20");
+    }
+}
diff --git a/src/test/java/com/laytonsmith/core/functions/EchoesTest.java b/src/test/java/com/laytonsmith/core/functions/EchoesTest.java
new file mode 100644
index 0000000..e58d5d8
--- /dev/null
+++ b/src/test/java/com/laytonsmith/core/functions/EchoesTest.java
@@ -0,0 +1,93 @@
+/*
+ * To change this template, choose Tools | Templates
+ * and open the template in the editor.
+ */
+package com.laytonsmith.core.functions;
+
+import com.laytonsmith.abstraction.MCPlayer;
+import com.laytonsmith.abstraction.MCServer;
+import com.laytonsmith.commandhelper.CommandHelperPlugin;
+import com.laytonsmith.core.Env;
+import com.laytonsmith.core.exceptions.CancelCommandException;
+import com.laytonsmith.core.exceptions.ConfigCompileException;
+import com.laytonsmith.testing.C;
+import static com.laytonsmith.testing.StaticTest.*;
+import java.lang.reflect.InvocationTargetException;
+import org.junit.*;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.when;
+
+/**
+ *
+ * @author Layton
+ */
+public class EchoesTest {
+    
+    MCServer fakeServer;
+    MCPlayer fakePlayer;
+    Env env = new Env();
+    
+    public EchoesTest() {
+    }
+
+    @BeforeClass
+    public static void setUpClass() throws Exception {        
+    }
+
+    @AfterClass
+    public static void tearDownClass() throws Exception {
+    }
+    
+    @Before
+    public void setUp() {
+        fakeServer = GetFakeServer();
+        fakePlayer = GetOnlinePlayer(fakeServer);
+        env.SetPlayer(fakePlayer);
+    }
+    
+    @After
+    public void tearDown() {
+    }
+
+    @Test
+    public void testDocs() {
+        TestClassDocs(Echoes.docs(), Echoes.class);
+    }
+    
+    @Test public void testChat() throws CancelCommandException{
+        Echoes.chat a = new Echoes.chat();     
+        a.exec(0, null, env, C.onstruct("Hello World!"));
+        verify(fakePlayer).chat("Hello World!");
+    }
+    
+    @Test public void testBroadcast() throws NoSuchFieldException, InstantiationException, 
+            IllegalAccessException, NoSuchMethodException, IllegalArgumentException, InvocationTargetException, CancelCommandException{
+        Echoes.broadcast a = new Echoes.broadcast();
+        when(fakePlayer.getServer()).thenReturn(fakeServer);
+        CommandHelperPlugin.myServer = fakeServer;
+        a.exec(0, null, env, C.onstruct("Hello World!"));
+        verify(fakeServer).broadcastMessage("Hello World!");        
+    }
+    
+    @Test public void testLongStringMsgd() throws ConfigCompileException{
+        SRun("msg('@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@')", fakePlayer);
+        verify(fakePlayer).sendMessage("@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@");
+    }
+    
+    @Test public void testChatas() throws CancelCommandException, ConfigCompileException{
+        //TODO: Can't get this to work right, though it does work in game
+//        String script = "chatas('wraithguard02', 'Hello World!')";
+//        Player wraithguard02 = GetOnlinePlayer("wraithguard02", fakeServer);
+//        Player op = GetOp("wraithguard", fakeServer);
+//        Run(script, op);
+//        verify(wraithguard02).chat("Hello World!");
+//        Echoes.chatas a = new Echoes.chatas();
+//        Player wraithguard01 = GetOnlinePlayer("wraithguard02", fakeServer);
+//        when(fakePlayer.getServer()).thenReturn(fakeServer);
+//        when(fakeServer.getPlayer("wraithguard01")).thenReturn(wraithguard01);
+//        a.exec(0, null, fakePlayer, C.onstruct("wraithguard02"), C.onstruct("Hello World!"));
+//        verify(wraithguard01).chat("Hello World!");        
+    }
+    
+    
+}
diff --git a/src/test/java/com/laytonsmith/core/functions/ExceptionsTest.java b/src/test/java/com/laytonsmith/core/functions/ExceptionsTest.java
new file mode 100644
index 0000000..af09696
--- /dev/null
+++ b/src/test/java/com/laytonsmith/core/functions/ExceptionsTest.java
@@ -0,0 +1,106 @@
+/*
+ * To change this template, choose Tools | Templates
+ * and open the template in the editor.
+ */
+package com.laytonsmith.core.functions;
+
+import com.laytonsmith.abstraction.MCPlayer;
+import com.laytonsmith.abstraction.MCServer;
+import com.laytonsmith.commandhelper.CommandHelperPlugin;
+import com.laytonsmith.core.Env;
+import com.laytonsmith.core.MScriptCompiler;
+import com.laytonsmith.core.exceptions.ConfigCompileException;
+import com.laytonsmith.core.exceptions.ConfigRuntimeException;
+import com.laytonsmith.testing.StaticTest;
+import com.sk89q.bukkit.migration.PermissionsResolverManager;
+import java.io.File;
+import static org.junit.Assert.fail;
+import org.junit.*;
+import static org.mockito.Mockito.*;
+
+/**
+ *
+ * @author layton
+ */
+public class ExceptionsTest {
+    
+    MCServer fakeServer;
+    MCPlayer fakePlayer;
+    Env env = new Env();
+
+    public ExceptionsTest() {
+    }
+
+    @BeforeClass
+    public static void setUpClass() throws Exception {
+    }
+
+    @AfterClass
+    public static void tearDownClass() throws Exception {
+    }
+
+    @Before
+    public void setUp() {
+        CommandHelperPlugin.perms = mock(PermissionsResolverManager.class);
+        CommandHelperPlugin.myServer = fakeServer;
+        fakePlayer = StaticTest.GetOnlinePlayer();
+        fakeServer = StaticTest.GetFakeServer();
+        env.SetPlayer(fakePlayer);
+    }
+
+    @After
+    public void tearDown() {
+    }
+
+    @Test public void testTryCatch1() throws ConfigCompileException{
+        String script =
+                "try(\n"
+                + "ploc('offlineplayer'),\n"
+                + "@ex,\n"
+                + "msg(@ex[0])\n"
+                + "msg(@ex[1])\n"
+                + "msg(@ex[2])\n"
+                + "msg(@ex[3])\n"
+                + ")";
+        MScriptCompiler.execute(MScriptCompiler.compile(MScriptCompiler.lex(script, null)), env, null, null);
+        verify(fakePlayer).sendMessage("InsufficientPermissionException");
+        verify(fakePlayer).sendMessage("You do not have permission to use the ploc function.");
+        verify(fakePlayer).sendMessage("null");
+        verify(fakePlayer).sendMessage("2");
+    }
+    
+    @Test public void testTryCatch2() throws ConfigCompileException{
+        String script =
+                "try(\n"
+                + "throw(PlayerOfflineException, This is a message),\n"
+                + "@ex,\n"
+                + "msg(@ex[0])\n"
+                + "msg(@ex[1])\n"
+                + "msg(@ex[2])\n"
+                + "msg(@ex[3])\n"               
+                + ")";
+        MScriptCompiler.execute(MScriptCompiler.compile(MScriptCompiler.lex(script, null)), env, null, null);
+        verify(fakePlayer).sendMessage("PlayerOfflineException");
+        verify(fakePlayer).sendMessage("This is a message");
+        verify(fakePlayer).sendMessage("null");
+        verify(fakePlayer).sendMessage("2");
+    }
+    @Test public void testTryCatch3() throws ConfigCompileException{
+        String script =
+                "try(try(\n"
+                + "throw(null, This is a message),\n"
+                + "@ex,\n"
+                + "msg(@ex[0])\n"
+                + "msg(@ex[1])\n"
+                + "msg(@ex[2])\n"
+                + "msg(@ex[3])\n"               
+                + "), @ex, msg('2'))";
+        try{
+            MScriptCompiler.execute(MScriptCompiler.compile(MScriptCompiler.lex(script, new File("file.txt"))), env, null, null);
+            fail("This test was supposed to throw an exception");
+        }catch(ConfigRuntimeException e){
+            //Pass
+        }
+        verify(fakePlayer, never()).sendMessage("2");
+    }
+}
diff --git a/src/test/java/com/laytonsmith/core/functions/MathTest.java b/src/test/java/com/laytonsmith/core/functions/MathTest.java
new file mode 100644
index 0000000..977f9aa
--- /dev/null
+++ b/src/test/java/com/laytonsmith/core/functions/MathTest.java
@@ -0,0 +1,198 @@
+/*
+ * To change this template, choose Tools | Templates
+ * and open the template in the editor.
+ */
+package com.laytonsmith.core.functions;
+
+import com.laytonsmith.abstraction.MCPlayer;
+import com.laytonsmith.abstraction.MCServer;
+import com.laytonsmith.core.Env;
+import com.laytonsmith.core.Static;
+import com.laytonsmith.core.constructs.IVariable;
+import com.laytonsmith.core.exceptions.ConfigCompileException;
+import com.laytonsmith.core.exceptions.ConfigRuntimeException;
+import com.laytonsmith.testing.C;
+import com.laytonsmith.testing.StaticTest;
+import static com.laytonsmith.testing.StaticTest.*;
+import static org.junit.Assert.*;
+import org.junit.*;
+import static org.mockito.Mockito.verify;
+
+/**
+ *
+ * @author Layton
+ */
+public class MathTest {
+    MCServer fakeServer;
+    MCPlayer fakePlayer;
+    IVariableList varList;
+    Env env = new Env();
+    public MathTest() {
+    }
+
+    @BeforeClass
+    public static void setUpClass() throws Exception {
+    }
+
+    @AfterClass
+    public static void tearDownClass() throws Exception {
+    }
+    
+    @Before
+    public void setUp() {
+        fakePlayer = GetOnlinePlayer();
+        fakeServer = GetFakeServer();
+
+        varList = new IVariableList();
+        varList.set(new IVariable("var", C.onstruct(1), 0, null));
+        varList.set(new IVariable("var2", C.onstruct(2.5), 0, null));
+        env.SetVarList(varList);
+        env.SetPlayer(fakePlayer);
+    }
+    
+    @After
+    public void tearDown() {
+    }
+    
+    @Test
+    public void testAbs(){
+        Math.abs a = new Math.abs();
+        assertCEquals(C.onstruct(5), a.exec(0, null, env, C.onstruct(5)));
+        assertCEquals(C.onstruct(3), a.exec(0, null, env, C.onstruct(-3)));
+        assertCEquals(C.onstruct(0), a.exec(0, null, env, C.onstruct(0)));
+    }
+    
+    @Test
+    public void testAdd(){
+        Math.add a = new Math.add();
+        assertCEquals(C.onstruct(7), a.exec(0, null, env, C.onstruct(5), C.onstruct(2)));
+        assertCEquals(C.onstruct(6), a.exec(0, null, env, C.onstruct(3), C.onstruct(3)));
+        assertCEquals(C.onstruct(-4), a.exec(0, null, env, C.onstruct(-3), C.onstruct(-1)));
+        assertCEquals(C.onstruct(1), a.exec(0, null, env, C.onstruct(1), C.onstruct(0)));
+        assertCEquals(C.onstruct(3.1415), a.exec(0, null, env, C.onstruct(3), C.onstruct(0.1415)));
+    }
+    
+    @Test
+    public void testDec() throws ConfigCompileException{
+        Math.dec a = new Math.dec();
+        IVariable v = (IVariable)a.exec(0, null, env, new IVariable("var", C.onstruct(1), 0, null));
+        IVariable v2 = (IVariable)a.exec(0, null, env,new IVariable("var2", C.onstruct(2.5), 0, null));
+        assertCEquals(C.onstruct(0), v.ival());
+        assertCEquals(C.onstruct(1.5), v2.ival());
+        StaticTest.SRun("assign(@var, 0) dec(@var, 2) msg(@var)", fakePlayer);
+        verify(fakePlayer).sendMessage("-2");
+    }
+    
+    @Test
+    public void testDivide(){
+        Math.divide a = new Math.divide();
+        assertCEquals(C.onstruct(2.5), a.exec(0, null, env, C.onstruct(5), C.onstruct(2)));
+        assertCEquals(C.onstruct(1), a.exec(0, null, env, C.onstruct(3), C.onstruct(3)));
+        assertCEquals(C.onstruct(3), a.exec(0, null, env, C.onstruct(-3), C.onstruct(-1)));
+        assertCEquals(C.onstruct(Double.POSITIVE_INFINITY), a.exec(0, null, env, C.onstruct(1), C.onstruct(0)));
+    }
+    
+    @Test
+    public void testInc() throws ConfigCompileException{
+        Math.inc a = new Math.inc();
+        IVariable v = (IVariable)a.exec(0, null, env, new IVariable("var", C.onstruct(1), 0, null));
+        IVariable v2 = (IVariable)a.exec(0, null, env,new IVariable("var2", C.onstruct(2.5), 0, null));
+        assertCEquals(C.onstruct(2), v.ival());
+        assertCEquals(C.onstruct(3.5), v2.ival());
+        StaticTest.SRun("assign(@var, 0) inc(@var, 2) msg(@var)", fakePlayer);
+        verify(fakePlayer).sendMessage("2");
+    }
+    
+    @Test
+    public void testMod(){
+        Math.mod a = new Math.mod();
+        assertCEquals(C.onstruct(1), a.exec(0, null, env, C.onstruct(5), C.onstruct(2)));
+        assertCEquals(C.onstruct(0), a.exec(0, null, env, C.onstruct(3), C.onstruct(3)));
+        assertCEquals(C.onstruct(-1), a.exec(0, null, env, C.onstruct(-3), C.onstruct(-2)));
+    }
+    
+    @Test
+    public void testMultiply(){
+        Math.multiply a = new Math.multiply();
+        assertCEquals(C.onstruct(10), a.exec(0, null, env, C.onstruct(5), C.onstruct(2)));
+        assertCEquals(C.onstruct(9), a.exec(0, null, env, C.onstruct(3), C.onstruct(3)));
+        assertCEquals(C.onstruct(6), a.exec(0, null, env, C.onstruct(-3), C.onstruct(-2)));
+        assertCEquals(C.onstruct(5), a.exec(0, null, env, C.onstruct(10), C.onstruct(0.5)));
+    }
+    
+    @Test
+    public void testPow(){
+        Math.pow a = new Math.pow();
+        assertCEquals(C.onstruct(25), a.exec(0, null, env, C.onstruct(5), C.onstruct(2)));
+        assertCEquals(C.onstruct(27), a.exec(0, null, env, C.onstruct(3), C.onstruct(3)));
+        assertCEquals(C.onstruct(1), a.exec(0, null, env, C.onstruct(-1), C.onstruct(-2)));
+    }
+    
+    @Test
+    public void testRand(){
+        Math.rand a = new Math.rand();
+        for(int i = 0; i < 1000; i++){
+            long j = Static.getInt(a.exec(0, null, env, C.onstruct(10)));
+            if(!(j < 10 && j >= 0)){
+                fail("Expected a number between 0 and 10, but got " + j);
+            }
+            j = Static.getInt(a.exec(0, null, env, C.onstruct(10), C.onstruct(20)));
+            if(!(j < 20 && j >= 10)){
+                fail("Expected a number between 10 and 20, but got " + j);
+            }
+        }
+        try{
+            a.exec(0, null, env, C.onstruct(20), C.onstruct(10));
+            fail("Didn't expect this test to pass");
+        } catch(ConfigRuntimeException e){}
+        try{
+            a.exec(0, null, env, C.onstruct(-1));
+            fail("Didn't expect this test to pass");
+        } catch(ConfigRuntimeException e){}
+        try{
+            a.exec(0, null, env, C.onstruct(87357983597853791L));
+            fail("Didn't expect this test to pass");
+        } catch(ConfigRuntimeException e){}
+    }
+    
+    @Test
+    public void testSubtract(){
+        Math.subtract a = new Math.subtract();
+        assertCEquals(C.onstruct(3), a.exec(0, null, env, C.onstruct(5), C.onstruct(2)));
+        assertCEquals(C.onstruct(0), a.exec(0, null, env, C.onstruct(3), C.onstruct(3)));
+        assertCEquals(C.onstruct(-1), a.exec(0, null, env, C.onstruct(-3), C.onstruct(-2)));
+        assertCEquals(C.onstruct(3), a.exec(0, null, env, C.onstruct(3.1415), C.onstruct(0.1415)));
+    }
+    
+    @Test
+    public void testFloor(){
+        Math.floor a = new Math.floor();
+        assertCEquals(C.onstruct(3), a.exec(0, null, env, C.onstruct(3.8415)));
+        assertCEquals(C.onstruct(-4), a.exec(0, null, env, C.onstruct(-3.1415)));
+    }
+    
+    @Test public void testCeil(){
+        Math.ceil a = new Math.ceil();
+        assertCEquals(C.onstruct(4), a.exec(0, null, env, C.onstruct(3.1415)));
+        assertCEquals(C.onstruct(-3), a.exec(0, null, env, C.onstruct(-3.1415)));
+    }
+    
+    @Test public void testSqrt() throws ConfigCompileException{
+        assertEquals("3", StaticTest.SRun("sqrt(9)", fakePlayer));
+        assertEquals("Test failed", java.lang.Math.sqrt(2), Double.parseDouble(StaticTest.SRun("sqrt(2)", fakePlayer)), .000001);        
+        try{
+            StaticTest.SRun("sqrt(-1)", fakePlayer);
+            fail("Did not expect to pass");
+        } catch(ConfigRuntimeException e){
+            //pass
+        }
+    }
+    
+    @Test public void testMin() throws ConfigCompileException{
+        assertEquals("-2", StaticTest.SRun("min(2, array(5, 6, 4), -2)", fakePlayer));
+    }
+    
+    @Test public void testMax() throws ConfigCompileException{
+        assertEquals("50", StaticTest.SRun("max(6, 7, array(4, 4, 50), 2, 5)", fakePlayer));
+    }
+}
diff --git a/src/test/java/com/laytonsmith/core/functions/MetaTest.java b/src/test/java/com/laytonsmith/core/functions/MetaTest.java
new file mode 100644
index 0000000..b64972e
--- /dev/null
+++ b/src/test/java/com/laytonsmith/core/functions/MetaTest.java
@@ -0,0 +1,83 @@
+/*
+ * To change this template, choose Tools | Templates
+ * and open the template in the editor.
+ */
+package com.laytonsmith.core.functions;
+
+import com.laytonsmith.abstraction.MCPlayer;
+import com.laytonsmith.abstraction.MCServer;
+import com.laytonsmith.commandhelper.CommandHelperPlugin;
+import com.laytonsmith.core.Env;
+import com.laytonsmith.core.MScriptCompiler;
+import com.laytonsmith.core.exceptions.ConfigCompileException;
+import com.laytonsmith.testing.StaticTest;
+import com.sk89q.bukkit.migration.PermissionsResolverManager;
+import org.junit.*;
+import static org.mockito.Mockito.*;
+
+/**
+ *
+ * @author layton
+ */
+public class MetaTest {
+    
+    MCServer fakeServer;
+    MCPlayer fakePlayer;
+    Env env = new Env();
+    
+
+    public MetaTest() {
+    }
+
+    @BeforeClass
+    public static void setUpClass() throws Exception {
+    }
+
+    @AfterClass
+    public static void tearDownClass() throws Exception {
+    }
+
+    @Before
+    public void setUp() {
+        fakePlayer = StaticTest.GetOnlinePlayer();
+        fakeServer = StaticTest.GetFakeServer();
+        CommandHelperPlugin.perms = mock(PermissionsResolverManager.class);
+        CommandHelperPlugin.myServer = fakeServer;
+        env.SetPlayer(fakePlayer);
+    }
+
+    @After
+    public void tearDown() {
+    }
+
+    @Test public void testRunas1() throws ConfigCompileException{
+        String script = 
+                "runas('wraithguard02', '/cmd yay')";
+        MCPlayer fakePlayer2 = StaticTest.GetOnlinePlayer("wraithguard02", fakeServer);
+        when(fakeServer.getPlayer("wraithguard02")).thenReturn(fakePlayer2);
+        when(fakePlayer.isOp()).thenReturn(true);
+        MScriptCompiler.execute(MScriptCompiler.compile(MScriptCompiler.lex(script, null)), env, null, null);
+        //verify(fakePlayer2).performCommand("cmd yay");
+        verify(fakeServer).dispatchCommand(fakePlayer2, "cmd yay");
+    }
+    //:( I can't get this to work right, because AlwaysOpPlayer is different than
+    //fakePlayer, so I can't get my test to activate when the function is called.
+//    @Test public void testRunas2() throws ConfigCompileException{
+//        final AtomicBoolean bool = new AtomicBoolean(false); 
+//        String script = 
+//                "runas(~op, '/cmd yay')";
+//        when(fakeServer.dispatchCommand(fakePlayer, "cmd yay")).thenAnswer(new Answer<Boolean>(){
+//
+//            public Boolean answer(InvocationOnMock invocation) throws Throwable {
+//                System.out.println("HERE");
+//                assertTrue(((Server)invocation.getMock()).getPlayer(fakePlayer.getName()).isOp());
+//                bool.set(true);
+//                return true;
+//            }
+//            
+//        });
+//        MScriptCompiler.execute(MScriptCompiler.compile(MScriptCompiler.lex(script, null)), fakePlayer, null, null);
+//        assertTrue(bool.get());
+//    }
+    
+}
diff --git a/src/test/java/com/laytonsmith/core/functions/PlayerManangementTest.java b/src/test/java/com/laytonsmith/core/functions/PlayerManangementTest.java
new file mode 100644
index 0000000..ae0406f
--- /dev/null
+++ b/src/test/java/com/laytonsmith/core/functions/PlayerManangementTest.java
@@ -0,0 +1,188 @@
+/*
+ * To change this template, choose Tools | Templates
+ * and open the template in the editor.
+ */
+package com.laytonsmith.core.functions;
+
+import com.laytonsmith.abstraction.*;
+import com.laytonsmith.abstraction.blocks.MCBlock;
+import com.laytonsmith.abstraction.bukkit.BukkitMCWorld;
+import com.laytonsmith.commandhelper.CommandHelperPlugin;
+import com.laytonsmith.core.MScriptComplete;
+import com.laytonsmith.core.exceptions.ConfigCompileException;
+import com.laytonsmith.testing.StaticTest;
+import static com.laytonsmith.testing.StaticTest.*;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertEquals;
+import org.junit.*;
+import static org.mockito.Mockito.*;
+//import static org.powermock.api.mockito.PowerMockito.*;
+
+/**
+ *
+ * @author Layton
+ */
+//@RunWith(PowerMockRunner.class)
+//@PrepareForTest( { StaticLayer.class })
+
+public class PlayerManangementTest {
+
+    MCServer fakeServer;
+    MCPlayer fakePlayer;
+    
+    public PlayerManangementTest() {
+    }
+
+    @BeforeClass
+    public static void setUpClass() throws Exception {
+        //mockStatic(StaticLayer.class);
+    }
+
+    @AfterClass
+    public static void tearDownClass() throws Exception {
+    }
+    
+    @Before
+    public void setUp() throws Exception {
+        fakeServer = GetFakeServer();
+        fakePlayer = GetOp("wraithguard01", fakeServer);
+        when(fakePlayer.getServer()).thenReturn(fakeServer);
+        CommandHelperPlugin.myServer = fakeServer;
+        String name = fakePlayer.getName();
+        when(fakeServer.getPlayer(name)).thenReturn(fakePlayer);
+    }
+    
+    @After
+    public void tearDown() {
+    }
+
+    @Test public void testPlayer() throws ConfigCompileException{
+        String script = "player()";
+        assertEquals(fakePlayer.getName(), SRun(script, fakePlayer));
+        assertEquals("null", SRun(script, null));
+    }
+    
+    @Test public void testPlayer2() throws ConfigCompileException{
+        String script = "msg(player())";
+        MCConsoleCommandSender c = GetFakeConsoleCommandSender();
+        Run(script, c);
+        verify(c).sendMessage("~console");
+    }
+    
+    @Test 
+    public void testPlayer3() throws ConfigCompileException{
+        MCCommandSender c = GetFakeConsoleCommandSender();
+        assertEquals("~console", SRun("player()", c));
+    }
+    
+    @Test public void testAllPlayers() throws ConfigCompileException{
+        String script = "all_players()";
+        String done = SRun(script, fakePlayer);
+        //This output is too long to test with msg()        
+        assertEquals("{wraithguard01, wraithguard02, wraithguard03}", done);
+    }
+    
+    @Test public void testPloc() throws ConfigCompileException, Exception{
+        String script = "ploc()";
+        BukkitMCWorld w = GetWorld("world");
+        MCLocation loc = StaticLayer.GetLocation(w, 0, 1, 0);
+        when(fakePlayer.getLocation()).thenReturn(loc);
+        when(fakePlayer.getWorld()).thenReturn(w);
+        final StringBuilder done = new StringBuilder();
+        Run(script, fakePlayer, new MScriptComplete() {
+
+            public void done(String output) {
+                done.append(output);
+            }
+        });
+        assertEquals("{0.0, 0.0, 0.0, world}", done.toString());
+    }
+    
+    /*@Test*/ public void testSetPloc() throws ConfigCompileException, Exception{
+        MCWorld w = GetWorld("world");
+        CommandHelperPlugin.myServer = fakeServer;
+        String name = fakePlayer.getName();
+        when(fakeServer.getPlayer(name)).thenReturn(fakePlayer);
+        when(fakePlayer.getWorld()).thenReturn(w);
+        MCLocation loc = StaticTest.GetFakeLocation(w, 0, 0, 0);
+        when(fakePlayer.getLocation()).thenReturn(loc);
+        
+        Run("set_ploc(1, 1, 1)", fakePlayer);
+        //when(StaticLayer.GetLocation(w, 1, 2, 1)).thenReturn(loc);
+        MCLocation loc1 = StaticTest.GetFakeLocation(w, 1, 2, 1);
+        assertEquals(fakePlayer.getLocation().getX(), loc1.getX(), 0.00000000000001);//verify(fakePlayer).teleport(loc1);
+        
+        Run("set_ploc(array(2, 2, 2))", fakePlayer);
+        verify(fakePlayer).teleport(StaticLayer.GetLocation(w, 2, 3, 2, 0, 0));
+        
+        Run("set_ploc('" + fakePlayer.getName() + "', 3, 3, 3)", fakePlayer);
+        verify(fakePlayer).teleport(StaticLayer.GetLocation(w, 3, 4, 3, 0, 0));
+        
+        Run("set_ploc('" + fakePlayer.getName() + "', array(4, 4, 4))", fakePlayer);
+        verify(fakePlayer).teleport(StaticLayer.GetLocation(w, 4, 5, 4, 0, 0));
+    }
+    
+    @Test public void testPcursor() throws ConfigCompileException, Exception{  
+        MCBlock b = mock(MCBlock.class);
+        CommandHelperPlugin.myServer = fakeServer;
+        when(fakeServer.getPlayer(fakePlayer.getName())).thenReturn(fakePlayer);
+        when(fakePlayer.getTargetBlock(null, 200)).thenReturn(b);
+        MCWorld w = mock(MCWorld.class);
+        when(b.getWorld()).thenReturn(w);
+        Run("pcursor()", fakePlayer);
+        Run("pcursor('" + fakePlayer.getName() + "')", fakePlayer);
+        verify(fakePlayer, times(2)).getTargetBlock(null, 200);
+    }
+    
+    @Test public void testKill() throws ConfigCompileException{        
+        Run("kill()", fakePlayer);
+        Run("kill('" + fakePlayer.getName() + "')", fakePlayer);
+        verify(fakePlayer, times(2)).setHealth(0);
+    }
+    
+    //@Test
+    public void testPgroup() throws ConfigCompileException{
+        Run("", fakePlayer);
+        Run("", fakePlayer);
+    }
+    
+//    //@Test
+//    public void testPinfo(){
+//        
+//    }
+//    
+//    //@Test
+//    public void testPworld(){
+//        
+//    }
+//    
+//    //@Test
+//    public void testKick(){
+//        
+//    }
+//    
+//    //@Test
+//    public void testSetDisplayName(){
+//        
+//    }
+//    
+//    //@Test
+//    public void testResetDisplayName(){
+//        
+//    }
+//    
+//    //@Test
+//    public void testPFacing(){
+//        
+//    }
+//    
+//    //@Test
+//    public void testPinv(){
+//        
+//    }
+//    
+//    //@Test
+//    public void testSetPinv(){
+//        
+//    }
+}
diff --git a/src/test/java/com/laytonsmith/core/functions/RegexTest.java b/src/test/java/com/laytonsmith/core/functions/RegexTest.java
new file mode 100644
index 0000000..36ee4c8
--- /dev/null
+++ b/src/test/java/com/laytonsmith/core/functions/RegexTest.java
@@ -0,0 +1,71 @@
+/*
+ * To change this template, choose Tools | Templates
+ * and open the template in the editor.
+ */
+package com.laytonsmith.core.functions;
+
+import com.laytonsmith.core.exceptions.ConfigCompileException;
+import com.laytonsmith.core.exceptions.ConfigRuntimeException;
+import static com.laytonsmith.testing.StaticTest.SRun;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.fail;
+import org.junit.*;
+
+/**
+ *
+ * @author Layton
+ */
+public class RegexTest {
+    
+    public RegexTest() {
+    }
+
+    @BeforeClass
+    public static void setUpClass() throws Exception {
+    }
+
+    @AfterClass
+    public static void tearDownClass() throws Exception {
+    }
+    
+    @Before
+    public void setUp() {
+    }
+    
+    @After
+    public void tearDown() {
+    }
+
+    @Test public void testRegMatch() throws ConfigCompileException{
+        assertEquals("{word}", SRun("reg_match('word', 'This is a word')", null));
+        assertEquals("{}", SRun("reg_match('word', 'This is an airplane')", null));
+        assertEquals("{word, word}", SRun("reg_match('(word)', 'This is a word')", null));
+        assertEquals("{This is a word, word}", SRun("reg_match('This is a (word)', 'This is a word')", null));
+        assertEquals("{WORD}", SRun("reg_match(array(word, i), 'THIS IS A WORD')", null));
+        try{
+            SRun("reg_match(array(word, l), hi)", null);
+            fail();
+        } catch(ConfigRuntimeException e){
+            //Pass
+        }
+    }
+    
+    @Test public void testRegMatchAll() throws ConfigCompileException{
+        assertEquals("{{This is a word, word}, {This is a word, word}}", SRun("reg_match_all('This is a (word)', 'word, This is a word, This is a word')", null));
+        assertEquals("{}", SRun("reg_match_all('word', 'yay')", null));
+    }
+    
+    @Test public void testRegReplace() throws ConfigCompileException{
+        assertEquals("word", SRun("reg_replace('This is a (word)', '$1', 'This is a word')", null));
+        assertEquals("It's a wordy day!", SRun("reg_replace('sunn', 'word', 'It\\'s a sunny day!')", null));
+    }
+    
+    @Test public void testRegSplit() throws ConfigCompileException{
+        assertEquals("{one, two, three}", SRun("reg_split('\\\\|', 'one|two|three')", null));
+    }
+    
+    @Test public void testRegCount() throws ConfigCompileException{
+        assertEquals("3", SRun("reg_count('/', '///yay')", null));
+        assertEquals("0", SRun("reg_count('poppycock', 'tiddly winks')", null));
+    }
+}
diff --git a/src/test/java/com/laytonsmith/core/functions/StringHandlingTest.java b/src/test/java/com/laytonsmith/core/functions/StringHandlingTest.java
new file mode 100644
index 0000000..05e8285
--- /dev/null
+++ b/src/test/java/com/laytonsmith/core/functions/StringHandlingTest.java
@@ -0,0 +1,108 @@
+/*
+ * To change this template, choose Tools | Templates
+ * and open the template in the editor.
+ */
+package com.laytonsmith.core.functions;
+
+import com.laytonsmith.core.exceptions.ConfigCompileException;
+import com.laytonsmith.testing.C;
+import static com.laytonsmith.testing.StaticTest.SRun;
+import static com.laytonsmith.testing.StaticTest.assertCEquals;
+import static org.junit.Assert.assertEquals;
+import org.junit.*;
+
+/**
+ *
+ * @author Layton
+ */
+public class StringHandlingTest {
+    
+    public StringHandlingTest() {
+    }
+
+    @BeforeClass
+    public static void setUpClass() throws Exception {
+    }
+
+    @AfterClass
+    public static void tearDownClass() throws Exception {
+    }
+    
+    @Before
+    public void setUp() {
+    }
+    
+    @After
+    public void tearDown() {
+    }
+    
+    @Test
+    public void testConcat(){
+        StringHandling.concat a = new StringHandling.concat();
+        assertCEquals(C.onstruct("1234"), a.exec(0, null, null, C.onstruct(1), C.onstruct(2), C.onstruct(3), C.onstruct(4)));
+        assertCEquals(C.onstruct("astring"), a.exec(0, null, null, C.onstruct("a"), C.onstruct("string")));
+    }
+    
+    @Test
+    public void testLength(){
+        StringHandling.length a = new StringHandling.length();
+        assertCEquals(C.onstruct(5), a.exec(0, null, null, C.onstruct("12345")));
+        assertCEquals(C.onstruct(2), a.exec(0, null, null, C.Array(C.onstruct(0), C.onstruct(1))));
+    }
+    
+    @Test
+    public void testParseArgs(){
+        StringHandling.parse_args a = new StringHandling.parse_args();
+        assertCEquals(C.Array(C.onstruct("one"), C.onstruct("two")), a.exec(0, null, null, C.onstruct("one   two")));
+        assertCEquals(C.Array(C.onstruct("one"), C.onstruct("two")), a.exec(0, null, null, C.onstruct("one two")));
+    }
+    
+    @Test
+    public void testRead(){
+        
+    }
+    
+    @Test
+    public void testReplace(){
+        StringHandling.replace a = new StringHandling.replace();
+        assertCEquals(C.onstruct("yay"), a.exec(0, null, null, C.onstruct("yayathing"), C.onstruct("athing"), C.onstruct("")));
+        assertCEquals(C.onstruct("yaymonkey"), a.exec(0, null, null, C.onstruct("yayathing"), C.onstruct("athing"), C.onstruct("monkey")));
+        assertCEquals(C.onstruct("yayathing"), a.exec(0, null, null, C.onstruct("yayathing"), C.onstruct("wut"), C.onstruct("chicken")));
+    }
+    
+    @Test
+    public void testSconcat() throws ConfigCompileException{
+        StringHandling.sconcat a = new StringHandling.sconcat();
+        assertEquals("1 2 3 4", SRun("1 2 3 4", null));
+        assertEquals("a string", SRun("a string", null));
+    }
+    
+    @Test
+    public void testSubstr(){
+        StringHandling.substr a = new StringHandling.substr();
+        assertCEquals(C.onstruct("urge"), a.exec(0, null, null, C.onstruct("hamburger"), C.onstruct(4), C.onstruct(8)));
+        assertCEquals(C.onstruct("mile"), a.exec(0, null, null, C.onstruct("smiles"), C.onstruct(1), C.onstruct(5)));
+        assertCEquals(C.onstruct("ning"), a.exec(0, null, null, C.onstruct("lightning"), C.onstruct(5)));
+    }
+    
+    @Test
+    public void testToUpper(){
+        StringHandling.to_upper a = new StringHandling.to_upper();
+        assertCEquals(C.onstruct("TESTING 123"), a.exec(0, null, null, C.onstruct("testing 123")));
+        assertCEquals(C.onstruct("TESTING 123"), a.exec(0, null, null, C.onstruct("TeStInG 123")));
+    }
+    
+    @Test
+    public void testToLower(){
+        StringHandling.to_lower a = new StringHandling.to_lower();
+        assertCEquals(C.onstruct("testing 123"), a.exec(0, null, null, C.onstruct("TESTING 123")));
+        assertCEquals(C.onstruct("testing 123"), a.exec(0, null, null, C.onstruct("TeStInG 123")));
+    }
+    
+    @Test
+    public void testTrim(){
+        StringHandling.trim a = new StringHandling.trim();
+        assertCEquals(C.onstruct("test 123"), a.exec(0, null, null, C.onstruct("    test 123    ")));
+        assertCEquals(C.onstruct("test   123"), a.exec(0, null, null, C.onstruct("test   123")));
+    }
+}
diff --git a/src/test/java/com/laytonsmith/testing/ArrayTest.java b/src/test/java/com/laytonsmith/testing/ArrayTest.java
new file mode 100644
index 0000000..ad35e98
--- /dev/null
+++ b/src/test/java/com/laytonsmith/testing/ArrayTest.java
@@ -0,0 +1,359 @@
+/*
+ * To change this template, choose Tools | Templates
+ * and open the template in the editor.
+ */
+package com.laytonsmith.testing;
+
+import com.laytonsmith.PureUtilities.SerializedPersistance;
+import com.laytonsmith.abstraction.MCPlayer;
+import com.laytonsmith.commandhelper.CommandHelperPlugin;
+import com.laytonsmith.core.exceptions.ConfigCompileException;
+import com.laytonsmith.core.exceptions.ConfigRuntimeException;
+import static com.laytonsmith.testing.StaticTest.SRun;
+import java.io.File;
+import org.bukkit.plugin.Plugin;
+import static org.junit.Assert.assertEquals;
+import org.junit.Before;
+import org.junit.BeforeClass;
+import org.junit.Test;
+import org.mockito.InOrder;
+import static org.mockito.Mockito.*;
+
+/**
+ *
+ * @author Layton
+ */
+public class ArrayTest {
+    MCPlayer fakePlayer;
+    public ArrayTest() {
+    }
+
+    @BeforeClass
+    public static void setUpClass(){
+        Plugin fakePlugin = mock(Plugin.class);        
+        CommandHelperPlugin.persist = new SerializedPersistance(new File("plugins/CommandHelper/persistance.ser"), fakePlugin);
+    }
+    @Before
+    public void setUp() {
+        fakePlayer = StaticTest.GetOnlinePlayer();
+    }
+    
+    @Test public void testAssociativeCreation() throws ConfigCompileException{
+        assertEquals("{0: 0, 1: 1}", SRun("array(0: 0, 1: 1)", fakePlayer));
+    }
+    
+    @Test public void testAssociativeCreation2() throws ConfigCompileException{
+        SRun("assign(@arr, array(0, 1))"
+                + "msg(@arr)"
+                + "array_set(@arr, 2, 2)"
+                + "msg(@arr)"
+                + "array_set(@arr, 0, 0)"
+                + "msg(@arr)"
+                + "array_set(@arr, 'key', 'value')"
+                + "msg(@arr)"
+                + "array_set(@arr, 10, 'value')"
+                + "msg(@arr)", 
+             fakePlayer);
+        
+        verify(fakePlayer).sendMessage("{0, 1}");
+        verify(fakePlayer, times(2)).sendMessage("{0, 1, 2}");
+        verify(fakePlayer).sendMessage("{0: 0, 1: 1, 2: 2, key: value}");
+        verify(fakePlayer).sendMessage("{0: 0, 1: 1, 2: 2, 10: value, key: value}");
+    }
+    
+    @Test public void testArrayGetWithAssociativeArray() throws ConfigCompileException{
+        assertEquals("test", SRun("g(assign(@arr, array()) array_set(@arr, 'val', 'test')) array_get(@arr, 'val')", fakePlayer));
+    }
+    
+    @Test(expected=ConfigRuntimeException.class)
+    public void testAssociativeSlicing() throws ConfigCompileException{
+        SRun("array(0: 0, 1: 1, 2: 2)[1..-1]", fakePlayer);
+    }
+    
+    @Test public void testAssociativeCopy() throws ConfigCompileException{
+        SRun("assign(@arr, array(0: 0, 1: 1))"
+                + "assign(@arr2, @arr[])"
+                + "array_set(@arr2, 0, 1)"
+                + "msg(@arr)"
+                + "msg(@arr2)", fakePlayer);
+        verify(fakePlayer).sendMessage("{0: 0, 1: 1}");
+        verify(fakePlayer).sendMessage("{0: 1, 1: 1}");
+    }
+    
+    @Test public void testArrayKeyNormalization() throws ConfigCompileException{
+        assertEquals("{0: 0}", SRun("array(false: 0)", fakePlayer));
+        assertEquals("{1: 1}", SRun("array(true: 1)", fakePlayer));
+        assertEquals("{: empty}", SRun("array(null: empty)", fakePlayer));
+        assertEquals("{2.3: 2.3}", SRun("array(2.3: 2.3)", fakePlayer));
+    }
+    
+    @Test public void testArrayKeys() throws ConfigCompileException{
+        assertEquals("{0, 1, potato}", SRun("array_keys(array(potato: 5, 1: 44, 0: 'i can count to'))", fakePlayer));
+    }
+    
+    @Test public void testArrayNormalize() throws ConfigCompileException{
+        assertEquals("{3, 2, 1}", SRun("array_normalize(array(0: 3, 1: 2, 2: 1))", fakePlayer));
+    }
+    
+    @Test public void testArrayPushOnAssociativeArray() throws ConfigCompileException{
+        SRun("assign(@arr, array(0: 0, 1: 1, potato: potato))"
+                + "msg(@arr)"
+                + "array_push(@arr, tomato)"
+                + "msg(@arr)", fakePlayer);
+        verify(fakePlayer).sendMessage("{0: 0, 1: 1, potato: potato}");
+        verify(fakePlayer).sendMessage("{0: 0, 1: 1, 2: tomato, potato: potato}");        
+    }
+    
+    @Test public void testPushingANegativeIndexOnArray() throws ConfigCompileException{
+        SRun("assign(@arr, array(0, 1, 2))"
+                + "array_set(@arr, -1, -1)"
+                + "msg(@arr[-1])", fakePlayer);
+        verify(fakePlayer).sendMessage("-1");
+    }
+    
+    @Test public void testAssociativeArraySerialization() throws ConfigCompileException{        
+        when(fakePlayer.isOp()).thenReturn(true);
+        SRun("assign(@arr, array(0: 0, 1: 1, potato: potato))"
+                + "store_value(potato, @arr)"
+                + "msg(get_value(potato))", fakePlayer);
+        verify(fakePlayer).sendMessage("{0: 0, 1: 1, potato: potato}");
+    }
+    
+    @Test public void testIsAssociative() throws ConfigCompileException{
+        assertEquals("true", SRun("is_associative(array(1: 1))", fakePlayer));
+        assertEquals("false", SRun("is_associative(array(1))", fakePlayer));
+    }
+    
+    @Test public void testFunctionResultAsAssociativeValue() throws ConfigCompileException{
+        assertEquals("{1: thiswasconcated}", SRun("array(1: concat('this', was, concated))", fakePlayer));
+        assertEquals("{1: this was concated}", SRun("array(1: this was concated)", fakePlayer));
+    }
+    
+    @Test public void testDocumentationExample1() throws ConfigCompileException{
+        SRun("assign(@arr, array('string key': 'value', 'string key 2': 'value')) msg(@arr['string key'])", fakePlayer);
+        verify(fakePlayer).sendMessage("value");
+    }
+    
+    @Test public void testDocumentationExample2() throws ConfigCompileException{
+        SRun("assign(@arr, array(0, 1, 2, 3)) "
+                + "msg(is_associative(@arr))"
+                + "array_set(@arr, 4, 4)"
+                + "msg(is_associative(@arr))"
+                + "array_set(@arr, 0, 0)"
+                + "msg(is_associative(@arr))"
+                + "array_push(@arr, 5)"
+                + "msg(is_associative(@arr))"
+                + "msg(@arr)"
+                + "array_set(@arr, 'key', 'value')"
+                + "msg(is_associative(@arr))"
+                , fakePlayer);
+        verify(fakePlayer, times(4)).sendMessage("false");
+        verify(fakePlayer).sendMessage("{0, 1, 2, 3, 4, 5}");
+        verify(fakePlayer).sendMessage("true");
+    }
+    
+    @Test public void testDocumentationExample3() throws ConfigCompileException{
+        SRun("assign(@arr, array(0, 1: 1, 2, 3: 3, a: 'a'))"
+                + "msg(array_keys(@arr))"
+                , fakePlayer);
+        verify(fakePlayer).sendMessage("{0, 1, 2, 3, a}");        
+    }
+    
+    @Test public void testDocumentationExample4() throws ConfigCompileException{
+        SRun("msg(array(0: 0, 2: 2, 1))", fakePlayer);
+        SRun("assign(@arr, array()) array_set(@arr, 0, 0) array_set(@arr, 2, 2) array_push(@arr, 1)", fakePlayer);
+        verify(fakePlayer).sendMessage("{0: 0, 2: 2, 3: 1}");
+    }
+    
+    @Test public void testDocumentationExample5() throws ConfigCompileException{
+        SRun("assign(@arr, array(0, 1: 1, 2, 3: 3, a: 'a'))\n"
+                + "foreach(array_keys(@arr), @key, #array_keys returns {0, 1, 2, 3, a}\n"
+                + "msg(@arr[@key]) #Messages the value\n"
+                + ")", fakePlayer);
+        verify(fakePlayer).sendMessage("0");
+        verify(fakePlayer).sendMessage("1");
+        verify(fakePlayer).sendMessage("2");
+        verify(fakePlayer).sendMessage("3");
+        verify(fakePlayer).sendMessage("a");
+    }
+    
+    @Test public void testDocumentationExample6() throws ConfigCompileException{
+        SRun("assign(@arr, array(-1: -1, 0, 1, 2: 2)) msg(@arr[-1])", fakePlayer);
+        verify(fakePlayer).sendMessage("-1");
+    }
+    
+    @Test public void testDocumentationExample7() throws ConfigCompileException{
+        SRun("assign(@arr, array(-1: -1, 0, 1, 2: 2)) msg(@arr)", fakePlayer);
+        verify(fakePlayer).sendMessage("{-1: -1, 0: 0, 1: 1, 2: 2}");
+    }
+    
+    @Test public void testArraysReference1() throws ConfigCompileException{
+        assertEquals("3", SRun("proc(_test, @array, return(array_size(@array))) _test(array(1, 2, 3))", fakePlayer));
+    }
+    
+    @Test public void testArraysReturned() throws ConfigCompileException{
+        SRun("proc(_test, return(array(1, 2, 3))) foreach(_test(), @i, msg(@i))", fakePlayer);
+        verify(fakePlayer).sendMessage("1");
+        verify(fakePlayer).sendMessage("2");
+        verify(fakePlayer).sendMessage("3");
+    }
+    
+    @Test public void testArrayception1() throws ConfigCompileException{
+        SRun("assign(@t, array("
+                + "     bla: 1, "
+                + "     tro: array('a', 'b')"
+                + " )"
+                + ")"
+                + "foreach(array_keys(@t), @u,"
+                + "     msg(is_array(@t[@u]))"
+                + ")", fakePlayer);
+        verify(fakePlayer).sendMessage("false");
+        verify(fakePlayer).sendMessage("true");
+    }
+    
+    @Test public void testArrayception2() throws ConfigCompileException{
+        when(fakePlayer.isOp()).thenReturn(Boolean.TRUE);
+        SRun("assign(@t, array(bla: 1))"
+                + "array_set(@t, 'tro', array(a, b))"
+                + "foreach(array_keys(@t), @u,"
+                + " msg(is_array(@t[@u]))"
+                + ")"
+                + "store_value('bugtest_bug4', @t)  "
+                + "assign(@t, null)  "
+                + "assign(@t, get_value('bugtest_bug4'))  "
+                + "foreach(array_keys(@t), @u,    "
+                + " msg(is_array(@t[@u]))"
+                + ")", fakePlayer);
+        verify(fakePlayer, times(2)).sendMessage("false");
+        verify(fakePlayer, times(2)).sendMessage("true");
+    }
+    
+    @Test public void testArrayNPE1() throws ConfigCompileException{
+        SRun("assign(@glyphs, array('0': 6, '1': 6,))"
+                + "msg(array_index_exists(@glyphs, '1'))", fakePlayer);
+        verify(fakePlayer).sendMessage("true");
+    }
+    
+    @Test public void testArrayKeys1() throws ConfigCompileException{
+        SRun("assign(@a, array('1 ': 1, ' 1 ': 3)) msg(@a)", fakePlayer);
+        verify(fakePlayer).sendMessage("{ 1 : 3, 1 : 1}");
+    }
+    
+    @Test public void testArrayAssign1() throws ConfigCompileException{
+        SRun("assign(@array, array())\n"
+                + "assign(@array[0], 'value')\n"
+                + "msg(@array[0])", fakePlayer);
+        verify(fakePlayer).sendMessage("value");
+    }
+    
+    @Test public void testArrayAssign2() throws ConfigCompileException{
+        //Essentially, we want to replicate the behavior of java
+        String value = "value";
+        String[] array = new String[1];
+        array[0] = value;
+        value = "failure";
+        
+        SRun("assign(@value, 'value')\n"
+                + "assign(@array, array())\n"
+                + "assign(@array[0], @value)\n"
+                + "assign(@value, 'failure')\n"
+                + "msg(@array[0])", fakePlayer);
+        verify(fakePlayer).sendMessage(array[0]);
+    }
+    
+    @Test public void testArrayAssign3() throws ConfigCompileException{
+        String value = "value";
+        String[][] arrayOut = new String[1][1];
+        String[] arrayIn = new String[1];
+        arrayOut[0] = arrayIn;
+        arrayIn[0] = value;
+        value = "failure";
+        
+        SRun("assign(@value, 'value')\n"
+                + "assign(@arrayOut, array())\n"
+                + "assign(@arrayIn, array())\n"
+                + "assign(@arrayOut[0], @arrayIn)\n"
+                + "assign(@arrayIn[0], @value)\n"
+                + "msg(@arrayOut[0][0])", fakePlayer);
+        
+        verify(fakePlayer).sendMessage(arrayOut[0][0]);
+    }
+    
+    @Test public void testArrayAssign4() throws ConfigCompileException{
+        SRun("assign(@array, array(outer: array(middle: array(inner: failure))))"
+                + "assign(@array['outer']['middle']['inner'], 'value')\n"
+                + "msg(@array['outer']['middle']['inner'])", fakePlayer);
+        verify(fakePlayer).sendMessage("value");
+    }
+    
+    @Test public void testArrayAssign5() throws ConfigCompileException{
+        SRun("assign(@array['outer']['middle']['inner'], 'value')\n"
+                + "msg(@array)\n"
+                + "msg(@array['outer']['middle']['inner'])", fakePlayer);
+        verify(fakePlayer).sendMessage("{outer: {middle: {inner: value}}}");
+        verify(fakePlayer).sendMessage("value");
+    }
+    
+    @Test public void testArrayAssign6() throws ConfigCompileException{
+        SRun("assign(@array, array(1))\n"
+                + "assign(@array[1], 2)\n"
+                + "msg(@array)", fakePlayer);
+        verify(fakePlayer).sendMessage("{1, 2}");
+    }
+    
+    @Test public void testArrayAssign7() throws ConfigCompileException{
+        SRun("assign(@array, array(1: 1))\n"
+                + "assign(@array[0], array(1))\n"
+                + "assign(@array[0][1], 2)\n"
+                + "msg(@array)", fakePlayer);
+        verify(fakePlayer).sendMessage("{0: {1, 2}, 1: 1}");
+    }
+    
+    @Test public void testInnerArrayIsArray() throws ConfigCompileException{
+        SRun("assign(@pdata, array(value: array(1)))\n"
+                + "msg(array_size(@pdata[value]))", fakePlayer);
+        verify(fakePlayer).sendMessage("1");
+    }
+    
+    @Test public void testArrayKeysSortOrder() throws ConfigCompileException{
+        for(int i = 0; i < 5; i++){
+            SRun("assign(@array, array())"
+                    + "array_push(@array, array(1))"
+                    + "array_push(@array, array(2))"
+                    + "array_push(@array, array(3))"
+                    + "foreach(array_keys(@array), @key, msg(@key))", fakePlayer);
+            verify(fakePlayer).sendMessage("0");
+            verify(fakePlayer).sendMessage("1");
+            verify(fakePlayer).sendMessage("2");
+            setUp();
+        }
+    }
+    
+    @Test public void testArrayKeysSortOrderWithPersistance() throws ConfigCompileException{
+        for(int i = 0; i < 5; i++){
+            InOrder inOrder = inOrder(fakePlayer);
+            when(fakePlayer.isOp()).thenReturn(true);
+            SRun("assign(@array, array())"
+                    + "array_push(@array, array(1))"
+                    + "array_push(@array, array(2))"
+                    + "array_push(@array, array(3))"
+                    + "store_value('array', @array)"
+                    + "assign(@array2, get_value('array'))"
+                    + "foreach(array_keys(@array2), @key, msg(@key))", fakePlayer);
+            inOrder.verify(fakePlayer).sendMessage("0");
+            inOrder.verify(fakePlayer).sendMessage("1");
+            inOrder.verify(fakePlayer).sendMessage("2");
+            setUp();
+        }
+    }
+    
+    @Test public void testArrayForeachWithConstructorInitialization() throws ConfigCompileException{
+        SRun("assign(@pdata, array('some': 'thing', 'is': 67890, 'over': 'there'))"
+                + " msg(@pdata['some'])"
+                + " foreach(@pdata, @thing, msg(@thing))", fakePlayer);
+        verify(fakePlayer, times(2)).sendMessage("thing");
+        verify(fakePlayer).sendMessage("67890");
+        verify(fakePlayer).sendMessage("there");
+    }
+
+}
diff --git a/src/test/java/com/laytonsmith/testing/C.java b/src/test/java/com/laytonsmith/testing/C.java
index 357f0dc..2caefc2 100644
--- a/src/test/java/com/laytonsmith/testing/C.java
+++ b/src/test/java/com/laytonsmith/testing/C.java
@@ -4,8 +4,8 @@
  */
 package com.laytonsmith.testing;
 
-import com.laytonsmith.aliasengine.Constructs.*;
-import com.laytonsmith.aliasengine.Static;
+import com.laytonsmith.core.Static;
+import com.laytonsmith.core.constructs.*;
 
 /**
  * This class provides methods for more easily creating different Constructs for testing purposes.
diff --git a/src/test/java/com/laytonsmith/testing/RandomTests.java b/src/test/java/com/laytonsmith/testing/RandomTests.java
index 2e39220..09b0f1e 100644
--- a/src/test/java/com/laytonsmith/testing/RandomTests.java
+++ b/src/test/java/com/laytonsmith/testing/RandomTests.java
@@ -4,23 +4,27 @@
  */
 package com.laytonsmith.testing;
 
-import org.bukkit.Location;
-import org.bukkit.World;
-import com.laytonsmith.aliasengine.Constructs.*;
-import com.laytonsmith.aliasengine.Static;
-import com.laytonsmith.aliasengine.functions.exceptions.ConfigCompileException;
-import com.laytonsmith.aliasengine.functions.exceptions.MarshalException;
+import com.laytonsmith.abstraction.MCLocation;
+import com.laytonsmith.abstraction.MCPlayer;
+import com.laytonsmith.abstraction.MCServer;
+import com.laytonsmith.abstraction.MCWorld;
+import com.laytonsmith.commandhelper.CommandHelperPlugin;
+import com.laytonsmith.core.ObjectGenerator;
+import com.laytonsmith.core.constructs.*;
+import com.laytonsmith.core.exceptions.ConfigCompileException;
+import com.laytonsmith.core.exceptions.MarshalException;
+import com.laytonsmith.core.functions.Function;
+import com.laytonsmith.core.functions.FunctionList;
+import static com.laytonsmith.testing.StaticTest.SRun;
+import com.sk89q.worldedit.expression.Expression;
+import com.sk89q.worldedit.expression.ExpressionException;
 import java.lang.reflect.InvocationTargetException;
 import java.lang.reflect.Method;
-import com.laytonsmith.aliasengine.functions.Function;
-import com.laytonsmith.aliasengine.functions.FunctionList;
-import com.sk89q.commandhelper.CommandHelperPlugin;
 import java.util.logging.Level;
 import java.util.logging.Logger;
-import org.bukkit.Server;
-import org.junit.Test;
 import static org.junit.Assert.*;
-import static com.laytonsmith.testing.StaticTest.*;
+import org.junit.Before;
+import org.junit.Test;
 import static org.mockito.Mockito.*;
 
 /**
@@ -28,6 +32,12 @@ import static org.mockito.Mockito.*;
  * @author Layton
  */
 public class RandomTests {
+    MCPlayer fakePlayer;
+    
+    @Before
+    public void setUp(){
+        fakePlayer = StaticTest.GetOnlinePlayer();
+    }
     /**
      * This function automatically tests all the boilerplate portions of all functions. Note that
      * this can be disabled in the StaticTest class, so that high quality test coverage can be measured.
@@ -69,7 +79,7 @@ public class RandomTests {
     @Test public void testClone() throws CloneNotSupportedException{
         CArray c1 = C.Array(C.Void(), C.Void()).clone();
         CBoolean c2 = C.Boolean(true).clone();
-        CClosure c3 = new CClosure("", null, 0, null).clone();
+        CClosure c3 = new CClosure("", null, null, 0, null).clone();
         CDouble c4 = C.Double(1).clone();
         CFunction c5 = new CFunction("", 0, null).clone();
         CInt c6 = C.Int(1).clone();
@@ -93,7 +103,8 @@ public class RandomTests {
         ca.push(C.Void());
         ca.push(new Command("/Command", 0, null));
         ca.push(new CArray(0, null, new CInt(1, 0, null)));
-        assertEquals("[1, 2.2, \"string\", \"\\\"Quote\\\"\", true, false, null, \"\", \"\\/Command\", [1]]", Construct.json_encode(ca));
+        //[1, 2.2, "string", "\"Quote\"", true, false, null, "", "/Command", [1]]
+        assertEquals("[1,2.2,\"string\",\"\\\"Quote\\\"\",true,false,null,\"\",\"\\/Command\",[1]]", Construct.json_encode(ca, 0, null));
     }
     
     @Test public void testJSONDecodeString() throws MarshalException{
@@ -108,26 +119,26 @@ public class RandomTests {
         ca.push(C.Void());
         ca.push(new Command("/Command", 0, null));
         ca.push(new CArray(0, null, new CInt(1, 0, null)));
-        StaticTest.assertCEquals(ca, Construct.json_decode("[1, 2.2, \"string\", \"\\\"Quote\\\"\", true, false, null, \"\", \"\\/Command\", [1]]"));
+        StaticTest.assertCEquals(ca, Construct.json_decode("[1, 2.2, \"string\", \"\\\"Quote\\\"\", true, false, null, \"\", \"\\/Command\", [1]]", 0, null));
     }
     
     @Test public void testReturnArrayFromProc() throws ConfigCompileException{
         assertEquals("{1, 2, 3}", SRun("proc(_test, @var, assign(@array, array(1, 2)) array_push(@array, @var) return(@array)) _test(3)", null));
     }
     
-    @Test public void testStaticGetLocation(){
-        World fakeWorld = mock(World.class);
-        Server fakeServer = mock(Server.class);
+    /*@Test*/ public void testStaticGetLocation(){
+        MCWorld fakeWorld = mock(MCWorld.class);
+        MCServer fakeServer = mock(MCServer.class);
         when(fakeServer.getWorld("world")).thenReturn(fakeWorld);
         CommandHelperPlugin.myServer = fakeServer;
         CArray ca1 = new CArray(0, null, C.onstruct(1), C.onstruct(2), C.onstruct(3));
-        CArray ca2 = new CArray(0, null, C.onstruct("world"), C.onstruct(1), C.onstruct(2), C.onstruct(3));
+        CArray ca2 = new CArray(0, null, C.onstruct(1), C.onstruct(2), C.onstruct(3), C.onstruct("world"));
         CArray ca3 = new CArray(0, null, C.onstruct(1), C.onstruct(2), C.onstruct(3), C.onstruct(45), C.onstruct(50));
-        CArray ca4 = new CArray(0, null, C.onstruct("world"), C.onstruct(1), C.onstruct(2), C.onstruct(3), C.onstruct(45), C.onstruct(50));
-        Location l1 = Static.GetLocation(ca1, fakeWorld, 0, null);
-        Location l2 = Static.GetLocation(ca2, fakeWorld, 0, null);
-        Location l3 = Static.GetLocation(ca3, fakeWorld, 0, null);
-        Location l4 = Static.GetLocation(ca4, fakeWorld, 0, null);
+        CArray ca4 = new CArray(0, null, C.onstruct(1), C.onstruct(2), C.onstruct(3), C.onstruct("world"), C.onstruct(45), C.onstruct(50));
+        MCLocation l1 = ObjectGenerator.GetGenerator().location(ca1, fakeWorld, 0, null);
+        MCLocation l2 = ObjectGenerator.GetGenerator().location(ca2, fakeWorld, 0, null);
+        MCLocation l3 = ObjectGenerator.GetGenerator().location(ca3, fakeWorld, 0, null);
+        MCLocation l4 = ObjectGenerator.GetGenerator().location(ca4, fakeWorld, 0, null);
         assertEquals(fakeWorld, l1.getWorld());
         assertEquals(fakeWorld, l2.getWorld());
         assertEquals(fakeWorld, l3.getWorld());
@@ -155,4 +166,24 @@ public class RandomTests {
         CommandHelperPlugin.myServer = null;
     }        
     
+    @Test public void expressionTester() throws ExpressionException{
+        //verify basic usage works
+        Expression e = Expression.compile("(x + 2) * y", "x", "y");        
+        assertEquals(16, e.evaluate(2, 4), 0.00001);
+    }
+    
+    @Test public void testProcScope() throws ConfigCompileException{
+        SRun("proc(_b, assign(@a, 2)) assign(@a, 1) _b() msg(@a)", fakePlayer);
+        verify(fakePlayer).sendMessage("1");
+    }
+    
+    @Test public void testDataLookup() throws ConfigCompileException{
+        assertEquals("1", SRun("data_values(stone)", fakePlayer));
+        assertEquals("4", SRun("data_values(cstone)", fakePlayer));
+        assertEquals("6:2", SRun("data_values(birchsapling)", fakePlayer));
+        assertEquals("35:14", SRun("data_values(redwool)", fakePlayer));
+        assertEquals("35:14", SRun("data_values('wool:red')", fakePlayer));
+        assertEquals("35:14", SRun("data_values(REDWOOL)", fakePlayer));
+    }
+    
 }
diff --git a/src/test/java/com/laytonsmith/testing/StaticTest.java b/src/test/java/com/laytonsmith/testing/StaticTest.java
index 3c6ce4c..3c17555 100644
--- a/src/test/java/com/laytonsmith/testing/StaticTest.java
+++ b/src/test/java/com/laytonsmith/testing/StaticTest.java
@@ -4,42 +4,39 @@
  */
 package com.laytonsmith.testing;
 
-import com.laytonsmith.aliasengine.functions.BasicLogic.equals;
-import org.bukkit.command.CommandSender;
-import com.laytonsmith.aliasengine.MScriptCompiler;
-import com.laytonsmith.aliasengine.functions.exceptions.ConfigCompileException;
+import com.laytonsmith.abstraction.*;
+import com.laytonsmith.abstraction.bukkit.BukkitMCLocation;
+import com.laytonsmith.abstraction.bukkit.BukkitMCWorld;
+import com.laytonsmith.commandhelper.CommandHelperPlugin;
+import com.laytonsmith.core.*;
+import com.laytonsmith.core.constructs.CBoolean;
+import com.laytonsmith.core.constructs.Construct;
+import com.laytonsmith.core.constructs.Token;
+import com.laytonsmith.core.exceptions.*;
+import com.laytonsmith.core.functions.BasicLogic.equals;
+import com.laytonsmith.core.functions.Function;
+import com.sk89q.bukkit.migration.PermissionsResolverManager;
 import java.lang.reflect.Field;
-import com.laytonsmith.aliasengine.Constructs.Token;
-import java.util.List;
 import java.util.ArrayList;
-import org.bukkit.entity.Player;
-import com.laytonsmith.aliasengine.functions.exceptions.CancelCommandException;
-import com.laytonsmith.aliasengine.functions.exceptions.ConfigRuntimeException;
-import com.laytonsmith.aliasengine.Constructs.CBoolean;
-import com.laytonsmith.aliasengine.Constructs.Construct;
-import com.laytonsmith.aliasengine.MScriptComplete;
-import com.laytonsmith.aliasengine.Static;
-import com.laytonsmith.aliasengine.Version;
-import com.laytonsmith.aliasengine.functions.Function;
-import com.laytonsmith.aliasengine.functions.exceptions.FunctionReturnException;
-import com.laytonsmith.aliasengine.functions.exceptions.LoopBreakException;
-import com.laytonsmith.aliasengine.functions.exceptions.LoopContinueException;
-import com.sk89q.bukkit.migration.PermissionsResolverManager;
-import com.sk89q.commandhelper.CommandHelperPlugin;
 import java.util.Arrays;
+import java.util.List;
 import java.util.Random;
-import org.bukkit.Bukkit;
-import org.bukkit.Server;
 import org.bukkit.World;
-import org.bukkit.command.ConsoleCommandSender;
+import static org.junit.Assert.fail;
+import org.junit.runner.RunWith;
 import org.mockito.Mockito;
-import static org.junit.Assert.*;
-import static org.mockito.Mockito.*;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.when;
+import org.powermock.core.classloader.annotations.PrepareForTest;
+import org.powermock.modules.junit4.PowerMockRunner;
 
 /**
  * 
  * @author Layton
  */
+@RunWith(PowerMockRunner.class)
+@PrepareForTest( { Static.class })
+
 public class StaticTest {
 
     /**
@@ -49,11 +46,11 @@ public class StaticTest {
      */
     public static void TestBoilerplate(Function f, String name) {
         //For the "quality test code coverage" number, set this to true
-        boolean runQualityTestsOnly = true;
+        boolean runQualityTestsOnly = false;
 
-        Player fakePlayer = Mockito.mock(Player.class);
-        Server fakeServer = Mockito.mock(Server.class);
-        World fakeWorld = Mockito.mock(World.class);
+        MCPlayer fakePlayer = Mockito.mock(MCPlayer.class);
+        MCServer fakeServer = Mockito.mock(MCServer.class);
+        MCWorld fakeWorld = Mockito.mock(MCWorld.class);
         Mockito.when(fakePlayer.getServer()).thenReturn(fakeServer);
         Mockito.when(fakePlayer.getWorld()).thenReturn(fakeWorld);
         System.out.println(name);
@@ -61,7 +58,6 @@ public class StaticTest {
         //are fine
         f.isRestricted();
         f.runAsync();
-        f.varList(null);
         f.preResolveVariables();
         f.thrown();
 
@@ -107,7 +103,9 @@ public class StaticTest {
         //TODO
     }
 
-    public static void TestExec(Function f, CommandSender p) {
+    public static void TestExec(Function f, MCCommandSender p) {
+        Env env = new Env();
+        env.SetCommandSender(p);
         //See if the function throws something other than a ConfigRuntimeException or CancelCommandException if we send it bad arguments,
         //keeping in mind of course, that it isn't supposed to be able to accept the wrong number of arguments. Specifically, we want to try
         //strings, numbers, arrays, and nulls
@@ -154,7 +152,7 @@ public class StaticTest {
                     }
                 }
                 try {
-                    f.exec(0, null, p, con);
+                    f.exec(0, null, env, con);
                 } catch (CancelCommandException e) {
                 } catch (ConfigRuntimeException e) {
                     if (e.getExceptionType() != null) {
@@ -278,24 +276,25 @@ public class StaticTest {
         return tokens;
     }
     
-    public static Player GetOnlinePlayer(){
-        Server s = GetFakeServer();
+    public static MCPlayer GetOnlinePlayer(){
+        MCServer s = GetFakeServer();
         return GetOnlinePlayer("wraithguard01", s);
     }
     
-    public static Player GetOnlinePlayer(Server s){
+    public static MCPlayer GetOnlinePlayer(MCServer s){
         return GetOnlinePlayer("wraithguard01", s);
     }
     
-    public static Player GetOnlinePlayer(String name, Server s){
-        Player p = mock(Player.class);
+    public static MCPlayer GetOnlinePlayer(String name, MCServer s){
+        MCPlayer p = mock(MCPlayer.class);
         when(p.isOnline()).thenReturn(true);
         when(p.getName()).thenReturn(name);        
         when(p.getServer()).thenReturn(s); 
+        when(p.instanceofPlayer()).thenReturn(true);
         if(s != null && s.getOnlinePlayers() != null){
-            List<Player> online = new ArrayList<Player>(Arrays.asList(s.getOnlinePlayers()));
+            List<MCPlayer> online = new ArrayList<MCPlayer>(Arrays.asList(s.getOnlinePlayers()));
             boolean alreadyOnline = false;
-            for(Player o : online){
+            for(MCPlayer o : online){
                 if(o.getName().equals(name)){
                     alreadyOnline = true;
                     break;
@@ -303,31 +302,39 @@ public class StaticTest {
             }
             if(!alreadyOnline){
                 online.add(p);
-                when(s.getOnlinePlayers()).thenReturn(online.toArray(new Player[]{}));
+                when(s.getOnlinePlayers()).thenReturn(online.toArray(new MCPlayer[]{}));
             }            
         }
         return p;
     }
     
-    public static Player GetOp(String name, Server s){
-        Player p = GetOnlinePlayer(name, s);
+    public static MCPlayer GetOp(String name, MCServer s){
+        MCPlayer p = GetOnlinePlayer(name, s);
         when(p.isOp()).thenReturn(true);
         return p;
     }
     
-    public static World GetWorld(String name){
-        World w = mock(World.class);
+    public static BukkitMCWorld GetWorld(String name){
+        BukkitMCWorld w = mock(BukkitMCWorld.class);
         when(w.getName()).thenReturn(name);
         return w;
     }
     
-    public static ConsoleCommandSender GetFakeConsoleCommandSender(){
-        ConsoleCommandSender c = mock(ConsoleCommandSender.class);
-        Server s = GetFakeServer();
+    public static MCConsoleCommandSender GetFakeConsoleCommandSender(){
+        MCConsoleCommandSender c = mock(MCConsoleCommandSender.class);
+        MCServer s = GetFakeServer();
         when(c.getServer()).thenReturn(s);
+        when(c.instanceofMCConsoleCommandSender()).thenReturn(true);
         return c;
     }
     
+    public static MCLocation GetFakeLocation(MCWorld w, int x, int y, int z){
+        MCLocation loc = mock(BukkitMCLocation.class);
+        World bukkitWorld = mock(World.class);
+        when(loc.getWorld()).thenReturn(w);
+        return loc;
+    }
+    
     public static Object GetVariable(Object instance, String var) throws Exception{
         return GetVariable(instance.getClass(), var, instance);
     }
@@ -343,15 +350,17 @@ public class StaticTest {
      * @param player
      * @throws ConfigCompileException 
      */
-    public static void Run(String script, CommandSender player) throws ConfigCompileException{
+    public static void Run(String script, MCCommandSender player) throws ConfigCompileException{
         Run(script, player, null);
     }
     
-    public static void Run(String script, CommandSender player, MScriptComplete done) throws ConfigCompileException{
-        MScriptCompiler.execute(MScriptCompiler.compile(MScriptCompiler.lex(script, null)), player, done, null);
+    public static void Run(String script, MCCommandSender player, MScriptComplete done) throws ConfigCompileException{
+        Env env = new Env();
+        env.SetCommandSender(player);
+        MScriptCompiler.execute(MScriptCompiler.compile(MScriptCompiler.lex(script, null)), env, done, null);
     }
     
-    public static String SRun(String script, CommandSender player) throws ConfigCompileException{
+    public static String SRun(String script, MCCommandSender player) throws ConfigCompileException{
         final StringBuffer b = new StringBuffer();
         Run(script, player, new MScriptComplete() {
 
@@ -365,15 +374,15 @@ public class StaticTest {
     /**
      * Creates an entire fake server environment, adding players and everything.
      */
-    public static Server GetFakeServer(){
-        Server fakeServer = mock(Server.class);
+    public static MCServer GetFakeServer(){
+        MCServer fakeServer = mock(MCServer.class);
         String [] pnames = new String[]{"wraithguard01", "wraithguard02", "wraithguard03"};
-        ArrayList<Player> pps = new ArrayList<Player>();
+        ArrayList<MCPlayer> pps = new ArrayList<MCPlayer>();
         for(String p : pnames){
-            Player pp = GetOnlinePlayer(p, fakeServer);
+            MCPlayer pp = GetOnlinePlayer(p, fakeServer);
             pps.add(pp);
         }
-        when(fakeServer.getOnlinePlayers()).thenReturn(pps.toArray(new Player[]{}));  
+        when(fakeServer.getOnlinePlayers()).thenReturn(pps.toArray(new MCPlayer[]{}));  
         CommandHelperPlugin.myServer = fakeServer;  
         CommandHelperPlugin.perms = mock(PermissionsResolverManager.class);
         return fakeServer;
diff --git a/true b/true
index 6b0ddd4..042aa7c 100644
--- a/true
+++ b/true
@@ -1,5 +1,5 @@
-#Generated by Maven
-#Tue Jul 19 12:56:33 CDT 2011
-version=3.1.2
-groupId=com.sk89q
-artifactId=commandhelper
+#Generated by Maven
+#Tue Jan 24 23:15:58 CST 2012
+version=3.3.0-SNAPSHOT
+groupId=com.sk89q
+artifactId=commandhelper
diff --git a/unit_test_inc.ms b/unit_test_inc.ms
deleted file mode 100644
index a4948d4..0000000
--- a/unit_test_inc.ms
+++ /dev/null
@@ -1 +0,0 @@
-msg('hello')
\ No newline at end of file
